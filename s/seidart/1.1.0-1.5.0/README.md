# Comparing `tmp/seidart-1.1.0-cp311-cp311-win_amd64.whl.zip` & `tmp/seidart-1.5.0-cp311-cp311-manylinux_2_24_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,37 @@
-Zip file size: 941710 bytes, number of entries: 27
--rw-rw-rw-  2.0 fat      127 b- defN 24-May-01 16:14 seidart/__init__.py
--rw-rw-rw-  2.0 fat  1455789 b- defN 24-May-01 16:16 seidart/.libs/libcpmlfdtd.HHM64BD6ITWEAQBB4CKPKFCVIIT6G6AX.gfortran-win_amd64.dll
--rw-rw-rw-  2.0 fat   713500 b- defN 24-May-01 16:16 seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll
--rw-rw-rw-  2.0 fat       17 b- defN 24-May-01 16:14 seidart/fortran/__init__.py
--rw-rw-rw-  2.0 fat    73728 b- defN 24-May-01 16:16 seidart/fortran/cpmlfdtd.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat    35840 b- defN 24-May-01 16:16 seidart/fortran/orientsynth.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat      232 b- defN 24-May-01 16:14 seidart/routines/__init__.py
--rw-rw-rw-  2.0 fat    18025 b- defN 24-May-01 16:14 seidart/routines/arraybuild.py
--rw-rw-rw-  2.0 fat    51433 b- defN 24-May-01 16:14 seidart/routines/definitions.py
--rw-rw-rw-  2.0 fat    35262 b- defN 24-May-01 16:14 seidart/routines/materials.py
--rw-rw-rw-  2.0 fat     3939 b- defN 24-May-01 16:14 seidart/routines/orientation_tensor.py
--rw-rw-rw-  2.0 fat     9671 b- defN 24-May-01 16:14 seidart/routines/prjbuild.py
--rw-rw-rw-  2.0 fat    21596 b- defN 24-May-01 16:14 seidart/routines/prjrun.py
--rw-rw-rw-  2.0 fat     9871 b- defN 24-May-01 16:14 seidart/routines/sourcefunction.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-May-01 16:14 seidart/simulations/__init__.py
--rw-rw-rw-  2.0 fat     8201 b- defN 24-May-01 16:14 seidart/simulations/common_offset.py
--rw-rw-rw-  2.0 fat       46 b- defN 24-May-01 16:14 seidart/visualization/__init__.py
--rw-rw-rw-  2.0 fat     7092 b- defN 24-May-01 16:14 seidart/visualization/im2anim.py
--rw-rw-rw-  2.0 fat    13729 b- defN 24-May-01 16:14 seidart/visualization/imgen.py
--rw-rw-rw-  2.0 fat     1291 b- defN 24-May-01 16:14 seidart/visualization/implot.py
--rw-rw-rw-  2.0 fat     5280 b- defN 24-May-01 16:14 seidart/visualization/slice25d.py
--rw-rw-rw-  2.0 fat     4088 b- defN 24-May-01 16:14 seidart/visualization/vtkbuild.py
--rw-rw-rw-  2.0 fat    35823 b- defN 24-May-01 16:16 seidart-1.1.0.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat    48376 b- defN 24-May-01 16:16 seidart-1.1.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      102 b- defN 24-May-01 16:16 seidart-1.1.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        8 b- defN 24-May-01 16:16 seidart-1.1.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2451 b- defN 24-May-01 16:16 seidart-1.1.0.dist-info/RECORD
-27 files, 2555517 bytes uncompressed, 937706 bytes compressed:  63.3%
+Zip file size: 1053125 bytes, number of entries: 35
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-15 13:44 seidart-1.5.0.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-15 13:44 seidart/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-15 13:44 seidart.libs/
+-rw-r--r--  2.0 unx    35149 b- defN 24-May-15 13:44 seidart-1.5.0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx    47631 b- defN 24-May-15 13:44 seidart-1.5.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx     2519 b- defN 24-May-15 13:44 seidart-1.5.0.dist-info/RECORD
+-rw-r--r--  2.0 unx        8 b- defN 24-May-15 13:44 seidart-1.5.0.dist-info/top_level.txt
+-rw-r--r--  2.0 unx      114 b- defN 24-May-15 13:44 seidart-1.5.0.dist-info/WHEEL
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-15 13:44 seidart/routines/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-15 13:44 seidart/fortran/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-15 13:44 seidart/visualization/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-15 13:44 seidart/simulations/
+-rw-r--r--  2.0 unx      123 b- defN 24-May-15 13:44 seidart/__init__.py
+-rw-r--r--  2.0 unx    50219 b- defN 24-May-15 13:44 seidart/routines/definitions.py
+-rw-r--r--  2.0 unx    21023 b- defN 24-May-15 13:44 seidart/routines/prjrun.py
+-rw-r--r--  2.0 unx    34350 b- defN 24-May-15 13:44 seidart/routines/materials.py
+-rw-r--r--  2.0 unx     9395 b- defN 24-May-15 13:44 seidart/routines/prjbuild.py
+-rw-r--r--  2.0 unx     3827 b- defN 24-May-15 13:44 seidart/routines/orientation_tensor.py
+-rw-r--r--  2.0 unx      224 b- defN 24-May-15 13:44 seidart/routines/__init__.py
+-rw-r--r--  2.0 unx     9587 b- defN 24-May-15 13:44 seidart/routines/sourcefunction.py
+-rw-r--r--  2.0 unx    19672 b- defN 24-May-15 13:44 seidart/routines/arraybuild.py
+-rwxr-xr-x  2.0 unx   199073 b- defN 24-May-15 13:44 seidart/fortran/orientsynth.cpython-311-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx       16 b- defN 24-May-15 13:44 seidart/fortran/__init__.py
+-rwxr-xr-x  2.0 unx  1199721 b- defN 24-May-15 13:44 seidart/fortran/cpmlfdtd.cpython-311-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx     5109 b- defN 24-May-15 13:44 seidart/visualization/slice25d.py
+-rw-r--r--  2.0 unx     6889 b- defN 24-May-15 13:44 seidart/visualization/im2anim.py
+-rw-r--r--  2.0 unx       44 b- defN 24-May-15 13:44 seidart/visualization/__init__.py
+-rw-r--r--  2.0 unx     3959 b- defN 24-May-15 13:44 seidart/visualization/vtkbuild.py
+-rw-r--r--  2.0 unx     1244 b- defN 24-May-15 13:44 seidart/visualization/implot.py
+-rw-r--r--  2.0 unx    13447 b- defN 24-May-15 13:44 seidart/visualization/imgen.py
+-rw-r--r--  2.0 unx     8347 b- defN 24-May-15 13:44 seidart/simulations/common_offset.py
+-rw-r--r--  2.0 unx     8183 b- defN 24-May-15 13:44 seidart/simulations/multioffset.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-15 13:44 seidart/simulations/__init__.py
+-rw-r--r--  2.0 unx   259905 b- defN 24-May-15 13:44 seidart.libs/libquadmath-0605fa11.so.0.0.0
+-rw-r--r--  2.0 unx  1283921 b- defN 24-May-15 13:44 seidart.libs/libgfortran-bbf01bbb.so.3.0.0
+35 files, 3223699 bytes uncompressed, 1048313 bytes compressed:  67.5%
```

## zipnote {}

```diff
@@ -1,82 +1,106 @@
-Filename: seidart/__init__.py
+Filename: seidart-1.5.0.dist-info/
 Comment: 
 
-Filename: seidart/.libs/libcpmlfdtd.HHM64BD6ITWEAQBB4CKPKFCVIIT6G6AX.gfortran-win_amd64.dll
+Filename: seidart/
 Comment: 
 
-Filename: seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll
+Filename: seidart.libs/
 Comment: 
 
-Filename: seidart/fortran/__init__.py
+Filename: seidart-1.5.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: seidart/fortran/cpmlfdtd.cp311-win_amd64.pyd
+Filename: seidart-1.5.0.dist-info/METADATA
 Comment: 
 
-Filename: seidart/fortran/orientsynth.cp311-win_amd64.pyd
+Filename: seidart-1.5.0.dist-info/RECORD
 Comment: 
 
-Filename: seidart/routines/__init__.py
+Filename: seidart-1.5.0.dist-info/top_level.txt
 Comment: 
 
-Filename: seidart/routines/arraybuild.py
+Filename: seidart-1.5.0.dist-info/WHEEL
+Comment: 
+
+Filename: seidart/routines/
+Comment: 
+
+Filename: seidart/fortran/
+Comment: 
+
+Filename: seidart/visualization/
+Comment: 
+
+Filename: seidart/simulations/
+Comment: 
+
+Filename: seidart/__init__.py
 Comment: 
 
 Filename: seidart/routines/definitions.py
 Comment: 
 
-Filename: seidart/routines/materials.py
+Filename: seidart/routines/prjrun.py
 Comment: 
 
-Filename: seidart/routines/orientation_tensor.py
+Filename: seidart/routines/materials.py
 Comment: 
 
 Filename: seidart/routines/prjbuild.py
 Comment: 
 
-Filename: seidart/routines/prjrun.py
+Filename: seidart/routines/orientation_tensor.py
+Comment: 
+
+Filename: seidart/routines/__init__.py
 Comment: 
 
 Filename: seidart/routines/sourcefunction.py
 Comment: 
 
-Filename: seidart/simulations/__init__.py
+Filename: seidart/routines/arraybuild.py
 Comment: 
 
-Filename: seidart/simulations/common_offset.py
+Filename: seidart/fortran/orientsynth.cpython-311-x86_64-linux-gnu.so
 Comment: 
 
-Filename: seidart/visualization/__init__.py
+Filename: seidart/fortran/__init__.py
 Comment: 
 
-Filename: seidart/visualization/im2anim.py
+Filename: seidart/fortran/cpmlfdtd.cpython-311-x86_64-linux-gnu.so
 Comment: 
 
-Filename: seidart/visualization/imgen.py
+Filename: seidart/visualization/slice25d.py
 Comment: 
 
-Filename: seidart/visualization/implot.py
+Filename: seidart/visualization/im2anim.py
 Comment: 
 
-Filename: seidart/visualization/slice25d.py
+Filename: seidart/visualization/__init__.py
 Comment: 
 
 Filename: seidart/visualization/vtkbuild.py
 Comment: 
 
-Filename: seidart-1.1.0.dist-info/LICENSE.txt
+Filename: seidart/visualization/implot.py
 Comment: 
 
-Filename: seidart-1.1.0.dist-info/METADATA
+Filename: seidart/visualization/imgen.py
 Comment: 
 
-Filename: seidart-1.1.0.dist-info/WHEEL
+Filename: seidart/simulations/common_offset.py
+Comment: 
+
+Filename: seidart/simulations/multioffset.py
+Comment: 
+
+Filename: seidart/simulations/__init__.py
 Comment: 
 
-Filename: seidart-1.1.0.dist-info/top_level.txt
+Filename: seidart.libs/libquadmath-0605fa11.so.0.0.0
 Comment: 
 
-Filename: seidart-1.1.0.dist-info/RECORD
+Filename: seidart.libs/libgfortran-bbf01bbb.so.3.0.0
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## seidart/__init__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from . import routines
-from . import fortran 
-from . import visualization
-from . import simulations
+from . import routines
+from . import fortran 
+from . import visualization
+from . import simulations
 # from . import recipes
```

## seidart/fortran/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-from . import *
+from . import *
```

## seidart/routines/__init__.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-# __init__.py
-
-from .prjbuild import prjbuild
-from .prjrun import domain_initialization, runseismic, runelectromag
-from .arraybuild import  *
-from .definitions import *
-from .materials import *
-from .sourcefunction import *
+# __init__.py
+
+from .prjbuild import prjbuild
+from .prjrun import domain_initialization, runseismic, runelectromag
+from .arraybuild import  *
+from .definitions import *
+from .materials import *
+from .sourcefunction import *
```

## seidart/routines/arraybuild.py

```diff
@@ -1,502 +1,562 @@
-import numpy as np
-import pandas as pd
-from glob2 import glob
-import argparse
-import matplotlib.pyplot as plt
-import matplotlib.image as mpimg
-from seidart.routines.definitions import *
-
-# =============================================================================
-class Array:
-    def __init__(
-        self, 
-        channel: str,
-        prjfile: str, 
-        receiver_file: str,
-        receiver_indices: bool = False, 
-        single_precision: bool = True,
-        is_complex: bool = False
-    ):
-        """
-        Initializes the Array object with project settings and receiver details.
-        
-        :param channel: The data channel to be analyzed.
-        :type channel: str
-        :param prjfile: Path to the project file.
-        :type prjfile: str
-        :param receiver_file: Path to the receiver locations file.
-        :type receiver_file: str
-        :param receiver_indices: Flag if receiver file contains indices (True) 
-                                 or Cartesian coordinates (False).
-        :type receiver_indices: bool
-        :param single_precision: Use single precision for numerical data 
-            if True.
-        :type single_precision: bool
-        :param is_complex: Treat the data as complex if True.
-        :type is_complex: bool
-        """
-        self.prjfile = prjfile 
-        self.channel = channel
-        self.receiver_file = receiver_file
-        self.receiver_indices = receiver_indices
-        self.single_precision = single_precision
-        self.is_complex = is_complex
-        self.stream = None
-        self.gain = None
-        self.exaggeration = 0.5
-        self.build()
-    
-    # -------------------------------------------------------------------------
-    def build(self):
-        """
-        Constructs domain and models based on project file and sets up source 
-        and receiver configurations.
-        """
-        self.domain, self.material, self.seismic, self.electromag = loadproject(
-            self.prjfile,
-            Domain(), 
-            Material(),
-            Model(),
-            Model()
-        )
-        if self.channel in ['Vx','Vy','Vz']:
-            self.is_seismic = True
-            self.dt = self.seismic.dt 
-            self.gain = self.seismic.time_steps
-        else:
-            self.is_seismic = False
-            self.dt = self.electromag.dt
-            self.gain = self.electromag.time_steps
-        
-         
-        # __, self.receivers_xyz = self.loadxyz()
-        self.loadxyz()
-        if self.channel == 'Vx' or self.channel == 'Vy' or self.channel == 'Vz':
-            if self.domain.dim == '2.0':
-                self.source = np.array(
-                    [int(self.seismic.x), int(self.seismic.z)]
-                )
-            else:
-                self.source = np.array(
-                    [
-                        int(self.seismic.x), 
-                        int(self.seismic.y), 
-                        int(self.seismic.z)
-                    ]
-                )
-        else:
-            if self.domain.dim == '2.0':
-                self.source = np.array(
-                    [int(self.electromag.x), int(self.electromag.z)]
-                )
-            else:
-                self.source = np.array(
-                    [
-                        int(self.electromag.x), 
-                        int(self.electromag.y), 
-                        int(self.electromag.z)
-                    ]
-                )
-        
-        # Load the time series for all receivers
-        self.getrcx()
-    
-    # -------------------------------------------------------------------------
-    def loadxyz(self):
-        """
-        Loads and sorts receiver locations from a file and adjusts them 
-        according to the domain and CPML layer.  If the source_file flag is 
-        True, the source file is loaded instead of the receiver file and saved
-        to the object under source_xyz.
-
-        :param source_file: Flag to indicate if the file is a source file.
-        :type source_file: bool 
-
-        """
-        xyz = pd.read_csv(self.receiver_file)
-        
-        # We need to make sure the recievers are ordered correctly and the 
-        # absorbing boundary is corrected for
-        # First check to see if the inputs are indices or
-        cpml = int(self.domain.cpml)
-        # Adjust the object fields relative to the cpml. The y-direction will be
-        # adjusted when we are 2.5/3D modeling
-        self.domain.nx = self.domain.nx + 2*cpml
-        self.domain.nz = self.domain.nz + 2*cpml
-        if self.domain.dim == 2.5:
-            self.domain.ny = self.domain.ny + 2*cpml
-        
-        xyz = xyz.to_numpy() 
-        
-        if xyz.shape[1] == 1:
-            xyz = xyz.T
-        
-        # We want to make sure the shape of the self.receiver_xyz array is in 
-        # the correct shape. We won't be able to differentiate if the array is 
-        # in correct shape if it is 3x3
-        if xyz.shape[0] == 3 and np.prod(xyz.shape) > 9:
-            xyz = xyz.T
-        if xyz.shape[0] == 3 and np.prod(xyz.shape) == 6:
-            xyz = xyz.T
-        
-        # If the receiver file contains values that are relative to the 
-        # cartesian space of the domain, we want to change them to the indices
-        # of the 
-        if not self.receiver_indices:
-            xyz = xyz / \
-                np.array(
-                    [
-                        float(self.domain.dx), 
-                        float(self.domain.dy), 
-                        float(self.domain.dz) 
-                    ]
-                )
-            xyz.astype(int)
-        
-        self.receiver_xyz = xyz + cpml
-    
-    # -------------------------------------------------------------------------
-    def getrcx(self):
-        """
-        Loads the time series data for all receivers and handles complex data
-        conditions.
-        """
-        # input rcx as an n-by-2 array integer values for their indices.
-        src_ind = (
-            self.source / \
-            np.array([self.domain.dx, self.domain.dy, self.domain.dz])
-        ).astype(int)
-        if self.domain.dim == 2.5:
-            all_files = glob(
-                self.channel + '*.' + '.'.join(src_ind.astype(str)) + '.dat'
-            )
-        else: 
-            all_files = glob(
-                self.channel + '*.' + '.'.join(src_ind[np.array([0,2])].astype(str)) + '..dat'
-            )
-        
-        all_files.sort()
-        m = len(all_files)
-        if len(self.receiver_xyz.shape) == 1:
-            n = 1
-            timeseries = np.zeros([m]) 
-        else:
-            n = len(self.receiver_xyz[:,0])
-            timeseries = np.zeros([m,n])   
-            
-        timeseries_complex = timeseries.copy()
-        
-        if self.domain.dim == 2.0:
-            self.domain.ny = None
-        
-        if self.domain.dim == 2.5:
-            for i in range(m):
-                npdat = read_dat(
-                    all_files[i], 
-                    self.channel, 
-                    self.domain, 
-                    self.is_complex, 
-                    single = self.single_precision
-                )
-                if n == 1:
-                    timeseries[:,i] = npdat.real[
-                        int(self.receiver_xyz[2]), 
-                        int(self.receiver_xyz[1]), 
-                        int(self.receiver_xyz[0])
-                    ]
-                    timeseries_complex[:,i] = npdat.imag[
-                        int(self.receiver_xyz[2]), 
-                        int(self.receiver_xyz[1]), 
-                        int(self.receiver_xyz[0])
-                    ]
-                else:
-                    for j in range(0, n):
-                        # Don't forget x is columns and z is rows
-                        timeseries[i,j] = npdat.real[
-                            int(self.receiver_xyz[j,2]),
-                            int(self.receiver_xyz[j,1]),
-                            int(self.receiver_xyz[j,0])
-                        ]
-                        timeseries_complex[i,j] = npdat.imag[
-                            int(self.receiver_xyz[j,2]),
-                            int(self.receiver_xyz[j,1]),
-                            int(self.receiver_xyz[j,0])
-                        ]
-        else:
-            for i in range(m):
-                npdat = read_dat(
-                    all_files[i], 
-                    self.channel, 
-                    self.domain, 
-                    self.is_complex,
-                    single = self.single_precision
-                )
-                if n == 1:
-                    timeseries[i] = npdat.real[
-                        int(self.receiver_xyz[2]), int(self.receiver_xyz[0])
-                    ]
-                    timeseries_complex[i] = npdat.imag[
-                        int(self.receiver_xyz[2]), 
-                        int(self.receiver_xyz[0])
-                    ]
-                else:
-                    for j in range(n):
-                        # Don't forget x is columns and z is rows
-                        timeseries[i,j] = npdat.real[
-                            int(self.receiver_xyz[j,2]),
-                            int(self.receiver_xyz[j,0])
-                        ]
-                        timeseries_complex[i,j] = npdat.imag[
-                            int(self.receiver_xyz[j,2]),
-                            int(self.receiver_xyz[j,0])
-                        ]
-        
-        # Store both of the time series in the array object
-        self.timeseries_complex = timeseries_complex
-        self.timeseries = timeseries
-    
-    # -------------------------------------------------------------------------
-    def sectionplot(
-            self, 
-            plot_complex: bool = False
-        ):
-        """
-        Creates a grayscale section plot of the time series data.
-        
-        :param plot_complex: Plot the complex part of the solution if True.
-        :type plot_complex: bool
-        """
-        if plot_complex:
-            # Use complex values 
-            dat = self.timeseries_complex 
-        else:
-            dat = self.timeseries
-        
-        m,n = dat.shape
-        
-        if self.is_seismic:
-            mult = 1e2
-        else:
-            mult = 1e6
-        
-        timelocs = np.arange(0, m, int(m/10) ) # 10 tick marks along y-axis
-        rcxlocs = np.arange(0, np.max([n, 5]), int(np.max([n, 5])/5) ) # 5 tick marks along x-axis
-        
-        if self.is_seismic:
-            timevals = np.round(timelocs*float(self.dt) * mult, 2)
-        else:
-            timevals = np.round(timelocs*float(self.dt) * mult, 2)
-        
-        if self.gain == 0:
-            self.gain = 1
-        
-        if self.gain < m:
-            for j in range(0, n):
-                # Subtract the mean value
-                # dat[:,j] = dat[:,j] - np.mean(dat[:,j])
-                dat[:,j] = agc(dat[:,j], self.gain, "mean")
-        
-        self.fig = plt.figure()#figsize =(n/2,m/2) )
-        self.ax = plt.gca()
-        
-        self.ax.imshow(dat, cmap = 'Greys', aspect = 'auto')
-        self.ax.set_xlabel(r'Receiver #')
-        self.ax.xaxis.tick_top()
-        self.ax.xaxis.set_label_position('top')
-        self.ax.set_xticks(rcxlocs)
-        self.ax.set_xticklabels(rcxlocs)
-        self.ax.set_ylabel(r'Two-way Travel Time (s)')
-        self.ax.set_yticks(timelocs)
-        self.ax.set_yticklabels(timevals)
-        
-        # Other figure handle operations
-        self.ax.set_aspect(aspect = self.exaggeration)
-        
-        if self.is_seismic:
-            self.ax.text(0, m + 0.03*m, 'x $10^{-2}$')
-        else:
-            self.ax.text(0, m + 0.03*m, 'x $10^{-6}$')
-        
-        self.ax.update_datalim( ((0,0),(m, n)))
-        plt.show()
-    
-    # -------------------------------------------------------------------------
-    def save(self):
-        filename = '.'.join( 
-            [
-                self.prjfile.split('.')[:-1][0],
-                self.channel, 
-                '.'.join(self.source.astype(str)), 
-                '.pkl'
-            ]
-        )
-        # Pickle the object and save to file
-        with open(filename, 'wb') as file:
-            pickle.dump(self, filename)
-
-
-# =============================================================================
-# ============================== Main Function ================================
-def main(
-        prjfile: str, 
-        receiver_file: str, 
-        channel: str, 
-        rind: bool, 
-        is_complex: bool, 
-        single_precision: bool, 
-        exaggeration: float, 
-        gain: int,
-        plot_complex: bool = False,
-        plot: bool = False
-    ) -> None:
-    """
-    The main function creating an Array object and triggering plotting or 
-    saving actions based on user inputs.
-    
-    :param prjfile: Path to the project file.
-    :type prjfile: str
-    :param receiver_file: Path to the receiver file.
-    :type receiver_file: str
-    :param channel: Data channel to be analyzed.
-    :type channel: str
-    :param rind: Flag for coordinate indices.
-    :type rind: bool
-    :param is_complex: Flag for complex data handling.
-    :type is_complex: bool
-    :param single_precision: Flag for single precision data.
-    :type single_precision: bool
-    :param exaggeration: Aspect ratio between the x and y axes for plotting.
-    :type exaggeration: float
-    :param gain: Smoothing length for the data.
-    :type gain: int
-    :param plot_complex: Flag to plot complex part of the solution.
-    :type plot_complex: bool
-    :param plot: Flag to enable plotting.
-    :type plot: bool
-    """
-    array = Array(
-        channel,
-        prjfile, 
-        receiver_file,
-        rind, 
-        single_precision = single_precision,
-        is_complex = is_complex
-    )
-    
-    if gain:
-        array.gain = gain
-    if exaggeration:
-        array.exaggeration = exaggeration
-    if save:
-        array.save()
-    if plot:
-        array.section_plot(plot_complex = plot_complex)
-
-
-
-# =============================================================================
-# ========================== Command Line Arguments ===========================
-# =============================================================================
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(
-        description="""This program creates an Array class that can be saved in 
-        pickle format. Receiver locations listed in the the specified receiver 
-        file are extracted to create the time series. The minimum number of 
-        plots is 1 which will return a wiggle plot.""" 
-    )
-    
-    parser.add_argument(
-        '-p', '--prjfile',
-        nargs = 1, type = str, required = True,
-        help = 'The project file path'
-    )
-    
-    parser.add_argument(
-        '-r', '--rcxfile',
-        nargs=1, type=str, required = True,
-        help='the file path for the text file of receiver locations'
-    )
-    
-    parser.add_argument(
-        '-i', '--index',
-        action = 'store_true', required = False,
-        help = """Indicate whether the receiver file contains coordinate indices 
-        or if these are the locations in meters. Default (0 - meters)"""
-    )
-    
-    parser.add_argument(
-        '-c', '--channel',
-        nargs = 1, type = str, required = True,
-        help = """The channel to query. """
-    )
-    
-    parser.add_argument(
-        '-z', '--is_complex', action = 'store_true', required = False,
-        help = """Flag whether the data will be complex valued. If the data is
-        not flagged but is complex, only the real data will be returned. """
-    )
-    
-    parser.add_argument(
-        '-d', 'double_precision', action = 'store_false', required = False,
-        help = '''Flag whether the model outputs are in double precision. 
-        Default is single precision. '''
-    )
-    
-    parser.add_argument(
-        '-g', '--gain',
-        nargs = 1, type = float, required = False, default = [None],
-        help = "The smoothing length"
-    )
-    
-    parser.add_argument(
-        '-e', '--exaggeration',
-        nargs=1, type = float, required = False, default = [None],
-        help = """Set the aspect ratio between the x and y axes for
-        plotting."""
-    )
-    
-    parser.add_argument(
-        '-s', '--save', action = 'store_true', required = False, 
-        help = """Flag to save the array object as a .pkl file."""
-    )
-    
-    parser.add_argument(
-        '-P', '--plot', action = 'store_true', required = False,
-        help = """Flag whether you want to return a plot to the console."""
-    )
-    
-    parser.add_argument(
-        '-C', '--plot_complex', action = 'store_true', required = False,
-        help = """
-        If flagged, plot the complex part of the solution otherwise default to 
-        the real valued solution. 
-        """
-    )
-    
-    # Get the arguments
-    args = parser.parse_args()
-    prjfile = ''.join(args.prjfile)
-    receiver_file = ''.join(args.rcxfile)
-    channel = ''.join(args.channel)
-    rind = args.index
-    is_complex = args.is_complex
-    single_precision = args.double_precision 
-    exaggeration = args.exaggeration[0] 
-    gain = args.gain[0]
-    plot_complex = args.plot_complex
-    plot = args.plot 
-    
-    # ==================== Create the object and assign inputs ====================    
-    main(
-        prjfile, 
-        receiver_file, 
-        channel, 
-        rind, 
-        is_complex, 
-        single_precision, 
-        exaggeration, 
-        gain, 
-        plot_complex = plot_complex,
-        plot = plot
-    )
-        
+import numpy as np
+import pandas as pd
+from glob2 import glob
+import argparse
+import matplotlib.pyplot as plt
+import matplotlib.image as mpimg
+from typing import Tuple
+from seidart.routines.definitions import *
+
+# =============================================================================
+class Array:
+    def __init__(
+        self, 
+        channel: str,
+        prjfile: str, 
+        receiver_file: str,
+        receiver_indices: bool = False, 
+        single_precision: bool = True,
+        is_complex: bool = False
+    ):
+        """
+        Initializes the Array object with project settings and receiver details.
+        
+        :param channel: The data channel to be analyzed.
+        :type channel: str
+        :param prjfile: Path to the project file.
+        :type prjfile: str
+        :param receiver_file: Path to the receiver locations file.
+        :type receiver_file: str
+        :param receiver_indices: Flag if receiver file contains indices (True) 
+                                 or Cartesian coordinates (False).
+        :type receiver_indices: bool
+        :param single_precision: Use single precision for numerical data 
+            if True.
+        :type single_precision: bool
+        :param is_complex: Treat the data as complex if True.
+        :type is_complex: bool
+        """
+        self.prjfile = prjfile 
+        self.channel = channel
+        self.receiver_file = receiver_file
+        self.receiver_indices = receiver_indices
+        self.single_precision = single_precision
+        self.is_complex = is_complex
+        self.stream = None
+        self.gain = None
+        self.exaggeration = 0.5
+        self.build()
+    
+    # -------------------------------------------------------------------------
+    def build(self):
+        """
+        Constructs domain and models based on project file and sets up source 
+        and receiver configurations.
+        """
+        self.domain, self.material, self.seismic, self.electromag = loadproject(
+            self.prjfile,
+            Domain(), 
+            Material(),
+            Model(),
+            Model()
+        )
+        if self.channel in ['Vx','Vy','Vz']:
+            self.is_seismic = True
+            self.dt = self.seismic.dt 
+            self.gain = self.seismic.time_steps
+        else:
+            self.is_seismic = False
+            self.dt = self.electromag.dt
+            self.gain = self.electromag.time_steps
+        
+         
+        # __, self.receivers_xyz = self.loadxyz()
+        self.loadxyz()
+        if self.channel == 'Vx' or self.channel == 'Vy' or self.channel == 'Vz':
+            if self.domain.dim == '2.0':
+                self.source = np.array(
+                    [self.seismic.x, self.seismic.z]
+                )
+            else:
+                self.source = np.array(
+                    [
+                        self.seismic.x, 
+                        self.seismic.y, 
+                        self.seismic.z
+                    ]
+                )
+        else:
+            if self.domain.dim == '2.0':
+                self.source = np.array(
+                    [self.electromag.x, self.electromag.z]
+                )
+            else:
+                self.source = np.array(
+                    [
+                        self.electromag.x, 
+                        self.electromag.y, 
+                        self.electromag.z
+                    ]
+                )
+        
+        # Load the time series for all receivers
+        self.getrcx()
+    
+    # -------------------------------------------------------------------------
+    def loadxyz(self):
+        """
+        Loads and sorts receiver locations from a file and adjusts them 
+        according to the domain and CPML layer.  If the source_file flag is 
+        True, the source file is loaded instead of the receiver file and saved
+        to the object under source_xyz.
+
+        :param source_file: Flag to indicate if the file is a source file.
+        :type source_file: bool 
+
+        """
+        xyz = pd.read_csv(self.receiver_file)
+        
+        # We need to make sure the recievers are ordered correctly and the 
+        # absorbing boundary is corrected for
+        # First check to see if the inputs are indices or
+        cpml = int(self.domain.cpml)
+        # Adjust the object fields relative to the cpml. The y-direction will be
+        # adjusted when we are 2.5/3D modeling
+        self.domain.nx = self.domain.nx + 2*cpml
+        self.domain.nz = self.domain.nz + 2*cpml
+        if self.domain.dim == 2.5:
+            self.domain.ny = self.domain.ny + 2*cpml
+        
+        xyz = xyz.to_numpy() 
+        
+        if xyz.shape[1] == 1:
+            xyz = xyz.T
+        
+        # We want to make sure the shape of the self.receiver_xyz array is in 
+        # the correct shape. We won't be able to differentiate if the array is 
+        # in correct shape if it is 3x3
+        if xyz.shape[0] == 3 and np.prod(xyz.shape) > 9:
+            xyz = xyz.T
+        if xyz.shape[0] == 3 and np.prod(xyz.shape) == 6:
+            xyz = xyz.T
+        
+        # If the receiver file contains values that are relative to the 
+        # cartesian space of the domain, we want to change them to the indices
+        # of the 
+        if not self.receiver_indices:
+            xyz = xyz / \
+                np.array(
+                    [
+                        float(self.domain.dx), 
+                        float(self.domain.dy), 
+                        float(self.domain.dz) 
+                    ]
+                )
+            xyz.astype(int)
+        
+        self.receiver_xyz = xyz + cpml
+    
+    # -------------------------------------------------------------------------
+    def getrcx(self):
+        """
+        Loads the time series data for all receivers and handles complex data
+        conditions.
+        """
+        # input rcx as an n-by-2 array integer values for their indices.
+        src_ind = (
+            self.source / \
+            np.array([self.domain.dx, self.domain.dy, self.domain.dz])
+        ).astype(int)
+        if self.domain.dim == 2.5:
+            all_files = glob(
+                self.channel + '*.' + '.'.join(src_ind.astype(str)) + '.dat'
+            )
+        else: 
+            all_files = glob(
+                self.channel + '*.' + '.'.join(src_ind[np.array([0,2])].astype(str)) + '..dat'
+            )
+        
+        all_files.sort()
+        m = len(all_files)
+        if len(self.receiver_xyz.shape) == 1:
+            n = 1
+            timeseries = np.zeros([m]) 
+        else:
+            n = len(self.receiver_xyz[:,0])
+            timeseries = np.zeros([m,n])   
+            
+        timeseries_complex = timeseries.copy()
+        
+        if self.domain.dim == 2.0:
+            self.domain.ny = None
+        
+        if self.domain.dim == 2.5:
+            for i in range(m):
+                npdat = read_dat(
+                    all_files[i], 
+                    self.channel, 
+                    self.domain, 
+                    self.is_complex, 
+                    single = self.single_precision
+                )
+                if n == 1:
+                    timeseries[:,i] = npdat.real[
+                        int(self.receiver_xyz[2]), 
+                        int(self.receiver_xyz[1]), 
+                        int(self.receiver_xyz[0])
+                    ]
+                    timeseries_complex[:,i] = npdat.imag[
+                        int(self.receiver_xyz[2]), 
+                        int(self.receiver_xyz[1]), 
+                        int(self.receiver_xyz[0])
+                    ]
+                else:
+                    for j in range(0, n):
+                        # Don't forget x is columns and z is rows
+                        timeseries[i,j] = npdat.real[
+                            int(self.receiver_xyz[j,2]),
+                            int(self.receiver_xyz[j,1]),
+                            int(self.receiver_xyz[j,0])
+                        ]
+                        timeseries_complex[i,j] = npdat.imag[
+                            int(self.receiver_xyz[j,2]),
+                            int(self.receiver_xyz[j,1]),
+                            int(self.receiver_xyz[j,0])
+                        ]
+        else:
+            for i in range(m):
+                npdat = read_dat(
+                    all_files[i], 
+                    self.channel, 
+                    self.domain, 
+                    self.is_complex,
+                    single = self.single_precision
+                )
+                if n == 1:
+                    timeseries[i] = npdat.real[
+                        int(self.receiver_xyz[2]), int(self.receiver_xyz[0])
+                    ]
+                    timeseries_complex[i] = npdat.imag[
+                        int(self.receiver_xyz[2]), 
+                        int(self.receiver_xyz[0])
+                    ]
+                else:
+                    for j in range(n):
+                        # Don't forget x is columns and z is rows
+                        timeseries[i,j] = npdat.real[
+                            int(self.receiver_xyz[j,2]),
+                            int(self.receiver_xyz[j,0])
+                        ]
+                        timeseries_complex[i,j] = npdat.imag[
+                            int(self.receiver_xyz[j,2]),
+                            int(self.receiver_xyz[j,0])
+                        ]
+        
+        # Store both of the time series in the array object
+        self.timeseries_complex = timeseries_complex
+        self.timeseries = timeseries
+    
+    # -------------------------------------------------------------------------
+    def sectionplot(
+            self, 
+            plot_complex: bool = False
+        ):
+        """
+        Creates a grayscale section plot of the time series data.
+        
+        :param plot_complex: Plot the complex part of the solution if True.
+        :type plot_complex: bool
+        """
+        if plot_complex:
+            # Use complex values 
+            dat = self.timeseries_complex 
+        else:
+            dat = self.timeseries
+        
+        m,n = dat.shape
+        
+        if self.is_seismic:
+            mult = 1e2
+        else:
+            mult = 1e6
+        
+        timelocs = np.arange(0, m, int(m/10) ) # 10 tick marks along y-axis
+        rcxlocs = np.arange(0, np.max([n, 5]), int(np.max([n, 5])/5) ) # 5 tick marks along x-axis
+        
+        if self.is_seismic:
+            timevals = np.round(timelocs*float(self.dt) * mult, 2)
+        else:
+            timevals = np.round(timelocs*float(self.dt) * mult, 2)
+        
+        if self.gain == 0:
+            self.gain = 1
+        
+        if self.gain < m:
+            for j in range(0, n):
+                # Subtract the mean value
+                # dat[:,j] = dat[:,j] - np.mean(dat[:,j])
+                dat[:,j] = agc(dat[:,j], self.gain, "mean")
+        
+        self.fig = plt.figure()#figsize =(n/2,m/2) )
+        self.ax = plt.gca()
+        
+        self.ax.imshow(dat, cmap = 'Greys', aspect = 'auto')
+        self.ax.set_xlabel(r'Receiver #')
+        self.ax.xaxis.tick_top()
+        self.ax.xaxis.set_label_position('top')
+        self.ax.set_xticks(rcxlocs)
+        self.ax.set_xticklabels(rcxlocs)
+        self.ax.set_ylabel(r'Two-way Travel Time (s)')
+        self.ax.set_yticks(timelocs)
+        self.ax.set_yticklabels(timevals)
+        
+        # Other figure handle operations
+        self.ax.set_aspect(aspect = self.exaggeration)
+        
+        if self.is_seismic:
+            self.ax.text(0, m + 0.03*m, 'x $10^{-2}$')
+        else:
+            self.ax.text(0, m + 0.03*m, 'x $10^{-6}$')
+        
+        self.ax.update_datalim( ((0,0),(m, n)))
+        plt.show()
+    
+    # -------------------------------------------------------------------------
+    def wiggleplot(
+            self, 
+            receiver_number: int, 
+            plot_complex: bool = False, 
+            plot_background: str = 'none',
+            figure_size: Tuple[float, float] = (8, 5),
+            **kwargs
+        ):
+        '''
+        Plot an individual receiver from the list of the receiver files. Use 
+        indices in the Python reference frame with the first component being 0. 
+        
+        :param receiver_number: Specify the indice of the reciever from the 
+            receiver file to plot.  
+        :type receiver_number: int
+        :param plot_complex: Plot the complex part of the solution if True.
+        :type plot_complex: bool
+        :param plot_background: Specify the plot background color. Default is 
+            transparent.
+        :type plot_background: str
+        :param figure_size: Specify the figure dimensions in inches. Default is
+            (8,5) width and height, respectively.
+        :type figure_size: Tuple[float, float]
+        :param **kwargs: Additional plotting parameters as defined in 
+            matplotlib.pyplot.plot. 
+        :type **kwargs: dict
+        '''
+        default_plotspec = {
+            'linewidth': 2,
+            'linestyle': '-',
+            'color': 'k',
+            'alpha': 1
+        }
+        
+        plot_params = {**default_plotspec, **kwargs}
+        
+        if plot_complex:
+            # Use complex values 
+            dat = self.timeseries_complex[:,n]
+        else:
+            dat = self.timeseries[:,n]
+            
+        timevector = np.arange(0, len(dat) ) * self.dt 
+        
+        self.wigglefig = plt.figure(facecolor='none', figsize = figure_size )
+        self.wiggleax = plt.gca()
+        
+        self.wiggleax.plot(timevector, dat, **plot_params)
+        self.wiggleax.set_facecolor(plot_background)
+        ax.set_xlabel('Two-way travel time (s)')
+        if self.is_seismic:
+            self.wiggleax.set_ylabel('Velocity (m/s)')
+        else:
+            self.wiggleax.set_ylabel('Electric Field (V/m)')
+        
+        plt.tight_layout()
+        
+    
+    # -------------------------------------------------------------------------
+    def save(self):
+        filename = '.'.join( 
+            [
+                self.prjfile.split('.')[:-1][0],
+                self.channel, 
+                '.'.join(self.source.astype(str)), 
+                '.pkl'
+            ]
+        )
+        # Pickle the object and save to file
+        with open(filename, 'wb') as file:
+            pickle.dump(self, filename)
+
+
+# =============================================================================
+# ============================== Main Function ================================
+def main(
+        prjfile: str, 
+        receiver_file: str, 
+        channel: str, 
+        rind: bool, 
+        is_complex: bool, 
+        single_precision: bool, 
+        exaggeration: float, 
+        gain: int,
+        plot_complex: bool = False,
+        plot: bool = False
+    ) -> None:
+    """
+    The main function creating an Array object and triggering plotting or 
+    saving actions based on user inputs.
+    
+    :param prjfile: Path to the project file.
+    :type prjfile: str
+    :param receiver_file: Path to the receiver file.
+    :type receiver_file: str
+    :param channel: Data channel to be analyzed.
+    :type channel: str
+    :param rind: Flag for coordinate indices.
+    :type rind: bool
+    :param is_complex: Flag for complex data handling.
+    :type is_complex: bool
+    :param single_precision: Flag for single precision data.
+    :type single_precision: bool
+    :param exaggeration: Aspect ratio between the x and y axes for plotting.
+    :type exaggeration: float
+    :param gain: Smoothing length for the data.
+    :type gain: int
+    :param plot_complex: Flag to plot complex part of the solution.
+    :type plot_complex: bool
+    :param plot: Flag to enable plotting.
+    :type plot: bool
+    """
+    array = Array(
+        channel,
+        prjfile, 
+        receiver_file,
+        rind, 
+        single_precision = single_precision,
+        is_complex = is_complex
+    )
+    
+    if gain:
+        array.gain = gain
+    if exaggeration:
+        array.exaggeration = exaggeration
+    if save:
+        array.save()
+    if plot:
+        array.section_plot(plot_complex = plot_complex)
+
+
+
+# =============================================================================
+# ========================== Command Line Arguments ===========================
+# =============================================================================
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(
+        description="""This program creates an Array class that can be saved in 
+        pickle format. Receiver locations listed in the the specified receiver 
+        file are extracted to create the time series. The minimum number of 
+        plots is 1 which will return a wiggle plot.""" 
+    )
+    
+    parser.add_argument(
+        '-p', '--prjfile',
+        nargs = 1, type = str, required = True,
+        help = 'The project file path'
+    )
+    
+    parser.add_argument(
+        '-r', '--rcxfile',
+        nargs=1, type=str, required = True,
+        help='the file path for the text file of receiver locations'
+    )
+    
+    parser.add_argument(
+        '-i', '--index',
+        action = 'store_true', required = False,
+        help = """Indicate whether the receiver file contains coordinate indices 
+        or if these are the locations in meters. Default (0 - meters)"""
+    )
+    
+    parser.add_argument(
+        '-c', '--channel',
+        nargs = 1, type = str, required = True,
+        help = """The channel to query. """
+    )
+    
+    parser.add_argument(
+        '-z', '--is_complex', action = 'store_true', required = False,
+        help = """Flag whether the data will be complex valued. If the data is
+        not flagged but is complex, only the real data will be returned. """
+    )
+    
+    parser.add_argument(
+        '-d', 'double_precision', action = 'store_false', required = False,
+        help = '''Flag whether the model outputs are in double precision. 
+        Default is single precision. '''
+    )
+    
+    parser.add_argument(
+        '-g', '--gain',
+        nargs = 1, type = float, required = False, default = [None],
+        help = "The smoothing length"
+    )
+    
+    parser.add_argument(
+        '-e', '--exaggeration',
+        nargs=1, type = float, required = False, default = [None],
+        help = """Set the aspect ratio between the x and y axes for
+        plotting."""
+    )
+    
+    parser.add_argument(
+        '-s', '--save', action = 'store_true', required = False, 
+        help = """Flag to save the array object as a .pkl file."""
+    )
+    
+    parser.add_argument(
+        '-P', '--plot', action = 'store_true', required = False,
+        help = """Flag whether you want to return a plot to the console."""
+    )
+    
+    parser.add_argument(
+        '-C', '--plot_complex', action = 'store_true', required = False,
+        help = """
+        If flagged, plot the complex part of the solution otherwise default to 
+        the real valued solution. 
+        """
+    )
+    
+    # Get the arguments
+    args = parser.parse_args()
+    prjfile = ''.join(args.prjfile)
+    receiver_file = ''.join(args.rcxfile)
+    channel = ''.join(args.channel)
+    rind = args.index
+    is_complex = args.is_complex
+    single_precision = args.double_precision 
+    exaggeration = args.exaggeration[0] 
+    gain = args.gain[0]
+    plot_complex = args.plot_complex
+    plot = args.plot 
+    
+    # ==================== Create the object and assign inputs ====================    
+    main(
+        prjfile, 
+        receiver_file, 
+        channel, 
+        rind, 
+        is_complex, 
+        single_precision, 
+        exaggeration, 
+        gain, 
+        plot_complex = plot_complex,
+        plot = plot
+    )
+
```

## seidart/routines/definitions.py

```diff
@@ -1,1320 +1,1321 @@
-import numpy as np
-import pandas as pd
-import seidart.routines.materials as mf
-import matplotlib.pyplot as plt
-import matplotlib.image as mpimg
-import matplotlib.animation as anim
-import os.path
-from typing import Optional
-from subprocess import call
-from scipy.io import FortranFile
-import glob2
-
-
-__all__ = [
-    'read_dat',
-    'image2int',
-    'complex2str',
-    'str2complex',
-    'append_coefficients',
-    'loadproject',
-    'prepme',
-    'coefs2prj',
-    'airsurf',
-    'rcxgen',
-    'coherdt',
-    'coherstf',
-    'stfvec2mat',
-    'movingsrc',
-    'indvar',
-    'agc',
-    'Domain',
-    'Material',
-    'Model',
-    'AnimatedGif'
-    # Add any other public names here
-]
-
-# =============================================================================
-# =========================== Define Class Variables ==========================
-# =============================================================================
-
-# We need to define some class variables
-class Domain:
-    def __init__(self):
-        super().__init__()
-        self.build()
-
-    def build(self):
-        # Initialize variables
-        self.geometry = None
-        self.dim = None
-        self.nx = None
-        self.ny = None
-        self.nz = None
-        self.dx = None
-        self.dy = None
-        self.dz = None
-        self.cpml = None
-        self.write = None
-        self.imfile = None
-        self.exit_status = 1
-
-        # Flag to specify whether the all inputs are fulfilled
-        self.seismic_model = False
-        self.electromag_model = False
-
-    def para_check(self):
-        self.exit_status = 0
-        # make sure there's a geometry. This implies whether nx, and nz exist
-        if self.geometry is None:
-            self.exit_status = 1
-            print('No geometry loaded\n')
-        if not self.dx or self.dx is None:
-            self.exit_status = 1
-            print('No step size in the x-direction')
-        if not self.dz or self.dz is None:
-            self.exit_status = 1
-            print('No step size in the y-direction')
-        if not self.cpml or self.cpml is None:
-            self.exit_status = 1
-            print('No cpml thickness is given')
-
-        # Check 2.5D
-        if self.dim == '2.5' and exit_status == 0:
-            if self.ny is None or self.ny == 'n/a':
-                print('No dimension given for y-direction. Assigning default ny=3.')
-                self.ny = 3
-            if self.dy is None or self.dy == 'n/a':
-                self.dy = np.min( [int(self.dx), int(self.dz)])
-                print('No step size given for y-direction. Assigning min(dx,dz).')
-
-        # Convert variables to required types. Ny and Dy are already converted if given
-        if self.exit_status == 0:
-            self.dim = float(self.dim)
-            self.nx = int(self.nx)
-            self.nz = int(self.nz)
-            self.dx = float(self.dx)
-            self.dz = float(self.dz)
-            self.cpml = int(self.cpml)
-        else:
-            print('\n Domain inputs are not satisfied. I can"t go on anymore. \n')
-            # quit()
-
-# -----------------------------------------------------------------------------
-
-class Material:
-    """
-    A class to manage materials for simulation purposes.
-
-    Attributes
-    ----------
-    material_list : numpy.ndarray
-        An array to store the list of materials.
-    material_flag : bool
-        A flag indicating whether the materials were read in successfully.
-    material : numpy.ndarray or None
-        Stores material information.
-    rgb : numpy.ndarray or None
-        Stores RGB values for materials (not used currently).
-    temp : numpy.ndarray or None
-        Stores temperature values for materials.
-    rho : numpy.ndarray or None
-        Stores density values for materials.
-    porosity : numpy.ndarray or None
-        Stores porosity values for materials.
-    lwc : numpy.ndarray or None
-        Stores liquid water content values for materials.
-    is_anisotropic : numpy.ndarray or None
-        Indicates if the material is anisotropic.
-    angfiles : numpy.ndarray or None
-        Stores ANG file paths for anisotropic materials.
-    functions : Any
-        Stores material processing functions.
-    """
-    # initialize the class
-    def __init__(self) -> None:
-        """
-        Initializes the Material class by building the initial structure.
-        """
-        super().__init__()
-        self.build()
-
-    def build(self) -> None:
-        """
-        Initializes the material attributes with default values.
-        """
-        self.material_list = np.array([]) # initialize
-        self.material_flag = False # Whether the materials were read in
-
-        # We will assign each of the list variables
-        self.material = None
-        self.rgb = None
-        self.temp = None
-        # self.attenuation = None
-        self.rho = None
-        self.porosity = None
-        self.lwc = None
-        self.is_anisotropic = None
-        self.angfiles = None
-
-        # The processing functions
-        self.functions = mf
-
-    def sort_material_list(self) -> None:
-        """
-        Sorts the material list based on the material properties.
-        """
-        self.material = self.material_list[:,1]
-        self.temp = self.material_list[:,2].astype(float)
-        # self.attenuation = self.material_list[:,3].astype(float)
-        self.rho = self.material_list[:,3].astype(float)
-        self.porosity = self.material_list[:,4].astype(float)
-        self.lwc = self.material_list[:,5].astype(float)
-        self.is_anisotropic = self.material_list[:,6] == 'True'
-        self.angfiles = self.material_list[:,7]
-
-    def para_check(self) -> None:
-        """
-        Checks the parameters of the material list for completeness.
-
-        It ensures that necessary fields are provided and checks for the presence of .ANG files for anisotropic materials.
-        """
-        # The fields for the materials in the input are defined as:
-        # 'id, R/G/B, Temp., Dens., Por., WC, Anis, ANG_File'
-        # but the R/G/B column is deleted
-
-        if len(self.material_list) > 0:
-            # Check to make sure the necessary fields are provided
-            check = 0
-
-            for row in self.material_list[:,0:6]:
-                for val in row:
-                    if not val:
-                        check = check + 1
-
-        if check == 0:
-            file_check = 0
-            for ind in range(0, self.material_list.shape[0]):
-                if self.material_list[ind,6] == 'True' and not self.material_list[ind,7] or self.material_list[ind,7] == 'n/a':
-                    file_check = file_check + 1
-        else:
-            print('Material inputs aren"t satisfied.')
-
-        if check == 0:
-            if file_check == 0:
-                self.material_flag = True
-            else:
-                print('No .ANG file specified for anisotropic material')
-
-# -----------------------------------------------------------------------------
-class Model:
-    """
-    A class to manage the simulation model configuration.
-
-    Attributes
-    ----------
-    dt : float or None
-        The time step size.
-    time_steps : int or None
-        The total number of time steps in the simulation.
-    x : float or None
-        The x-coordinate of the source location.
-    y : float or None
-        The y-coordinate of the source location. Optional, defaults to None.
-    z : float or None
-        The z-coordinate of the source location.
-    f0 : float or None
-        The source frequency.
-    theta : float or None
-        The angle of incidence in the xz-plane. Optional, defaults to 0 if unspecified.
-    phi : float or None
-        The angle of incidence in the xy-plane. Optional, defaults to 0 if `y` is specified and `phi` is unspecified.
-    src : Any
-        The source information. Type is unspecified.
-    tensor_coefficients : numpy.ndarray or None
-        The tensor coefficients for the simulation. Optional, but required for tensor-based simulations.
-    compute_coefficients : bool
-        A flag indicating whether to compute coefficients. Defaults to True.
-    attenuation_coefficients : numpy.ndarray or None
-        The attenuation coefficients for the simulation. Optional.
-    fref : float or None
-        The reference frequency for attenuation. Optional.
-    attenuation_fadjust : bool or None
-        Flag to adjust frequency for attenuation. Optional.
-    exit_status : int
-        Status code to indicate the success or failure of parameter checks.
-    """
-    def __init__(self) -> None:
-        """
-        Initializes the Model class by building the initial configuration.
-        """
-        super().__init__()
-        self.build()
-    
-    def build(self) -> None:
-        """
-        Initializes the simulation model attributes with default values.
-        """
-        self.dt = None
-        self.time_steps = None
-        self.x = None
-        self.y = None
-        self.z = None
-        self.f0 = None
-        self.theta = None
-        self.phi = None
-        self.src = None
-        self.tensor_coefficients = None
-        self.compute_coefficients = True
-        self.attenuation_coefficients = None
-        self.fref = None
-        self.attenuation_fadjust = None
-        self.exit_status = 0
-
-    
-    def tensor_check(self) -> None:
-        """
-        Checks if tensor coefficients are specified and valid. Disables coefficient computation if valid.
-        """
-        # If the tensors are there
-        check = 0
-        # if not self.tensor_coefficients:
-        # 	print('ldkjf')
-        for row in self.tensor_coefficients:
-            for val in row:
-                if not val:
-                    check = check + 1
-        
-        if check == 0:
-            self.compute_coefficients = False
-    
-    def para_check(self) -> None:
-        """
-        Performs parameter checks for essential simulation settings and updates the exit status accordingly.
-        """
-        if not self.time_steps:
-            self.exit_status = 1
-            print('Number of time steps aren"t satisfied.')
-        
-        if not self.x or not self.z:
-            self.exit_status = 1
-            print('No source location is specified.')
-        
-        if not self.f0:
-            self.exit_status = 1
-            print('No source frequency is specified.')
-        
-        # in case theta or phi aren't specified we can assign defaults
-        if not self.theta:
-            self.theta = 0
-        
-        # if y is specified but not phi
-        if self.y and not self.phi:
-            self.phi = 0
-
-# -----------------------------------------------------------------------------
-class AnimatedGif:
-    """
-    A class to create an animated GIF from a series of images.
-
-    :param size: The size of the animated GIF in pixels (width, height), 
-        defaults to (640, 480)
-    :type size: Tuple[int, int], optional
-
-    Attributes:
-        fig (matplotlib.figure.Figure): The figure object for the animation.
-        images (List): A list of image frames to be included in the GIF.
-        background (List): Background image data.
-        source_location (List[int, int]): The location of the source point in 
-        the plot.
-        nx (int): Width of the plot.
-        nz (int): Height of the plot.
-        output_format (int): Format of the output file. 0 for GIF, 1 for other 
-        formats.
-    """
-    def __init__(self, size=(640,480) ):
-        """
-        Initialize the AnimatedGif class with a figure size.
-        """
-        self.fig = plt.figure()
-        self.fig.set_size_inches(size[0]/100, size[1]/100)
-        ax = self.fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1)
-        ax.set_xticks([])
-        ax.set_yticks([])
-        self.images = []
-        self.background = []
-        self.source_location = []
-        self.nx = size[0]
-        self.nz = size[1]
-        self.output_format = 0
-
-    def add(self, image, label='', extent=None ):
-        """
-        Adds an image to the animation sequence.
-
-        :param image: The image data to add.
-        :type image: np.ndarray
-        :param label: The label to add to the image, defaults to ''.
-        :type label: str, optional
-        :param extent: The extent of the image, defaults to None.
-        :type extent: Tuple[int, int, int, int], optional
-        """
-        bound = np.max([abs(np.min(image)),abs(np.max(image))])
-        plt_im = plt.imshow(
-            image,cmap='seismic',
-            animated=True,
-            extent=(0, (self.nx), (self.nz), 0),
-            vmin=-bound,vmax=bound
-        )
-        plt_bg = plt.imshow(
-            self.background,
-            alpha = 0.3,
-            extent=extent,
-            animated = True
-        )
-        plt.scatter(
-            self.source_location[0],
-            self.source_location[1],
-            marker = '*',
-            s = 30,
-            linewidths = 1,
-            edgecolor = (0.2, 0.2, 0.2, 1 )
-        )
-        plt_txt = plt.text(
-            extent[0] + 20,
-            extent[2] + 20,
-            label,
-            color='red'
-        ) # Lower left corner
-        self.images.append([plt_im, plt_bg, plt_txt])
-
-    def save(self, filename, frame_rate = 50):
-        """
-        Save the animated GIF.
-
-        :param filename: The name of the output file.
-        :type filename: str
-        :param frame_rate: The frame rate of the animation, defaults to 50.
-        :type frame_rate: int, optional
-        """
-        animation = anim.ArtistAnimation(self.fig,
-                                        self.images,
-                                        interval = frame_rate,
-                                        blit = True
-                                        )
-        if self.output_format == 1:
-            animation.save(filename, dpi = 300)
-        else:
-            animation.save(filename, dpi = 300, writer = 'imagemagick')
-
-# -------------------------- Function Definitions -----------------------------
-def read_dat(
-        fn: str, 
-        channel: str, 
-        domain: Domain, 
-        is_complex: bool, 
-        single: bool =False
-    ) -> np.ndarray:
-    """
-    Read data from an unformatted Fortran binary file and return it as a numpy 
-    array. This function supports reading data in single or double precision, 
-    and can handle complex data.
-
-    :param fn: The filename of the data file to read.
-    :type fn: str
-    :param channel: Specifies the data channel ('Ex', 'Ey', 'Ez', etc.) 
-        to read.
-    :type channel: str
-    :param domain: The domain object that contains dimensions (dim, nx, ny, nz) 
-        of the data.
-    :type domain: Domain
-    :param is_complex: A flag indicating if the data is complex.
-    :type is_complex: bool
-    :param single: A flag indicating if the data should be read in 
-        single precision. Defaults to False (double precision).
-    :type single: bool
-    :return: The data read from the file, reshaped according to the 
-        domain dimensions.
-    :rtype: np.ndarray
-
-    The domain parameter is expected to be an object with attributes 
-        `dim`, `nx`, `ny`, and `nz`.
-    These are used to determine the shape of the returned numpy array.
-    """
-    if single:
-        dtype = np.float32 
-    else:
-        dtype = np.float64 
-    
-    if domain.dim == 2.5:
-        if channel == 'Ex':
-            NX = domain.nz
-            NY = domain.ny
-            NZ = domain.nx-1
-        elif channel == 'Ey':
-            NX = domain.nz
-            NY = domain.ny-1
-            NZ = domain.nx
-        elif channel == 'Ez':
-            NX = domain.nz-1
-            NY = domain.ny
-            NZ = domain.nx
-        else:
-            NX = domain.nz
-            NY = domain.ny
-            NZ = domain.nx
-    else:
-        if channel == 'Ex':
-            NX = domain.nz
-            NZ = domain.nx-1
-        elif channel == 'Ez':
-            NX = domain.nz-1
-            NZ = domain.nx
-        else:
-            NX = domain.nz
-            NZ = domain.nx
-    #
-
-    with FortranFile(fn, 'r') as f:
-        if is_complex:
-            if single:
-                dat = f.read_reals(dtype=np.float32)#.reshape(nx, nz)
-                dat = dat[:(NX*NZ)] + 1j * dat[(NX*NZ):]
-            else:
-                # Read complex data directly as double precision
-                dat = f.read_complex(dtype=np.complex128)#.reshape(nx, nz)
-        else:
-            if single:
-                dat = f.read_reals(dtype = np.float32)
-            else:
-                dat = f.read_reals(dtype = np.float64)
-
-    if domain.dim == 2.5:
-        dat = dat.reshape(NX, NY, NZ)
-    else:
-        dat = dat.reshape(NX, NZ)
-
-    f.close()
-    return(dat)
-
-# =============================================================================
-# ============================== Useful Functions =============================
-# =============================================================================
-
-def image2int(image_filename: str) -> np.ndarray:
-    """
-    Convert an image file into an integer array where each unique RGB color 
-    is mapped to a unique integer.
-
-    This function reads an image from a file, converts RGB colors to a single 
-    integer value by combining the RGB channels, then maps each unique color in
-    the image to a unique integer. This can be useful for image analysis tasks 
-    where colors represent different categories or labels.
-
-    :param image_filename: The path to the image file.
-    :type image_filename: str
-    :return: A 2D array where each element represents a unique integer mapping 
-        of the original RGB colors.
-    :rtype: np.ndarray
-
-    The conversion of RGB to a single value is performed using the formula: 
-    65536*red + 255*green + blue. Note that this function assumes the input 
-    image is in a format readable by matplotlib.image.imread (e.g., PNG, JPG), 
-    and that it has three color channels (RGB).
-    """
-    # read the image
-    img = mpimg.imread(image_filename)
-
-    # Convert RGB to a single value
-    rgb_int = np.array(65536*img[:,:,0] +  255*img[:,:,1] + img[:,:,2])
-
-    # Get the unique values of the image
-    rgb_uni = np.unique(rgb_int)
-
-    # mat_id = np.array( range(0, len(rgb_uni) ) )
-    for ind in range(0, len(rgb_uni) ):
-        rgb_int[ rgb_int == rgb_uni[ind] ] = ind
-
-    return rgb_int.astype(int)
-
-# -----------------------------------------------------------------------------
-# After computing tensor coefficients we want to append them to the given text
-# file. In order to do this, we need to create a new file then move it to the
-# original file
-
-def complex2str(complex_vector: np.ndarray) -> str:
-    """
-    Convert a numpy array of complex numbers into a string representation, 
-    with the first element representing an identifier and the subsequent 
-    elements representing complex numbers.
-
-    This function extracts the real and imaginary parts of each complex number 
-    in the input vector, converts them to strings, and concatenates them with 
-    'j' as the delimiter. The first real number of the input vector is treated 
-    as an identifier (ID) and is converted separately.
-
-    :param complex_vector: A numpy array of complex numbers where the first 
-        element is an ID.
-    :type complex_vector: np.ndarray
-    :return: A string representation of the ID followed by the complex numbers 
-        in the vector.
-    :rtype: str
-
-    The returned string format is 'ID,real1jimag1,real2jimag2,...' where ID is 
-    the integer ID, and realN and imagN are the real and imaginary parts of the
-    Nth complex number, respectively.
-    """
-    reals = complex_vector.real[1:]
-    comps = complex_vector.imag[1:]
-    
-    reals = [format(x, '.2e') for x in reals]
-    comps = [format(x, '.2e') for x in comps]
-    
-    id = complex_vector.real[0].astype(int)
-    m = len(reals)
-    complex_string_vector = np.zeros([m], dtype = object)
-    for ind in range(m):
-        complex_string_vector[ind] = str(reals[ind]) + 'j' + str(comps[ind])
-    
-    return( str(id) + ',' + ','.join(complex_string_vector))
-
-def str2complex(strsplit: list) -> np.ndarray:
-    """
-    Convert a list of strings into a numpy array of complex numbers, where the
-    first string is treated as an identifier (ID) and the subsequent strings 
-    represent complex numbers.
-
-    The function splits each string by 'j' to separate the real and imaginary 
-    parts of each complex number, then constructs a numpy array of complex 
-    numbers from these parts. The first element of the array is the ID.
-
-    :param strsplit: A list of strings, where the first string is an ID and the 
-        remaining strings represent complex numbers in 'realjimag' format.
-    :type strsplit: list
-    :return: A numpy array of complex numbers with the ID as the first element.
-    :rtype: np.ndarray
-
-    Note that the input list should follow the format ['ID', 'real1jimag1', 
-    'real2jimag2', ...], where 'ID' is an integer identifier, and 'realNjimagN' 
-    are the real and imaginary parts of the Nth complex number.
-    """
-    # strsplit = line.split(',')
-    id = int(strsplit[0])
-    m = len(strsplit)
-    complex_vector = np.zeros([m], dtype = complex)
-    complex_vector[0] = id
-    for ind in range(1,m):
-        realvalue, complexvalue = strsplit[ind].split('j')
-        complex_vector[ind] = complex(float(realvalue), float(complexvalue))
-    
-    return(complex_vector)
-        
-def append_coefficients(
-        prjfile: str, tensor: np.ndarray, CP: str = None, dt : float = 1.0 
-    ):
-    """
-    Appends coefficients to a project file based on the provided tensor, 
-    optionally using a line identifier.
-    
-    This function reads a project file, appending new coefficients derived from 
-    a tensor to it. The coefficients are appended based on a line identifier 
-    (`CP`), which specifies the type of modeling (e.g., 'C' for stiffness, 'P' 
-    for permittivity). The function also appends the time step (`dt`) for each 
-    modeling type specified by `CP`.
-    
-    Note: The project file is updated in place, with the original file replaced by 
-    the modified one. The `tensor` can be either a complex or a real numpy array. The function 
-    handles these differently when appending to the file. This function relies on an external command (`mv`) to replace the 
-    original file, which requires that the script has permissions to execute 
-    system commands.
-    
-    :param prjfile: The path to the project file to be modified.
-    :type prjfile: str
-    :param tensor: A numpy array containing the tensor coefficients to append.
-    :type tensor: np.ndarray
-    :param CP: The line identifier indicating the type of modeling ('C' or 'P'), optional.
-    :type CP: str, optional
-    :param dt: The time step to append for the modeling type, defaults to 1.
-    :type dt: float
-    :return: None
-    """
-    newfile = 'newfile.txt'
-    
-    with open(prjfile, 'r') as ogprj, open(newfile, 'a') as temp:
-        # Determine modeling type based on CP
-        mt = 'S' if CP == 'C' else 'E'
-        
-        for line in ogprj.readlines():
-            if line.startswith(CP):
-                line = line.strip().split(',')
-                if np.iscomplexobj(tensor):
-                    temp.write(
-                        CP + ',' + \
-                            complex2str(tensor[int(float(line[1])), :]) + \
-                                '\n'
-                    )
-                else:
-                    temp.write(
-                        CP + ',' + \
-                            ','.join(map(str, tensor[int(float(line[1])), :])) + \
-                                '\n'
-                    )
-            elif line.startswith(mt) and line[2:4] == 'dt':
-                temp.write(mt + ',dt,' + str(dt) + '\n')
-            else:
-                temp.write(line)
-    
-    # Replace the original project file with the new file
-    call('mv ' + newfile + ' ' + prjfile, shell=True)
-
-# =============================================================================
-# ========================= Read/Assign Project File ==========================
-# =============================================================================
-# -----------------------------------------------------------------------------
-def loadproject(
-        project_file: str, 
-        domain: Domain, material: Material, seismic: Model, electromag: Model
-    ) -> tuple[Domain, Material, Model, Model]:
-    """
-    Loads project settings from a project file and assigns values to domain, 
-    material, seismic, and electromagnetic objects.
-
-    This function parses a specified project file, reading configurations and parameters
-    for the domain, materials, seismic modeling, and electromagnetic properties. These
-    parameters are then assigned to the provided objects.
-
-    :param project_file: The path to the project configuration file.
-    :type project_file: str
-    :param domain: An object to hold domain-specific parameters and configurations.
-    :param material: An object to hold material-specific parameters and configurations.
-    :param seismic: An object to hold seismic modeling parameters and configurations.
-    :param electromag: An object to hold electromagnetic modeling parameters and configurations.
-    :return: A tuple containing the updated domain, material, seismic, and electromagnetic objects.
-    :rtype: tuple
-
-    The function assumes the project file contains specific prefixes for different
-    types of configurations (e.g., 'I' for images, 'D' for domain configurations, 'S' for
-    seismic modeling parameters, etc.).
-    """
-    # domain, material, seismic, electromag are the objects that we will assign
-    # values to
-    f = open(project_file)
-
-    # Let the if train begin
-    for line in f:
-        if line[0] == 'I':
-            # There's a trailing new line value
-            im = image2int(line[2:-1])
-            domain.geometry = im.transpose().astype(int)
-            # Get the image file
-            domain.imfile = line[2:-1]
-        
-        # All domain inputs must be input except for ny and dy
-        if line[0] == 'D':
-            temp = line.split(',')
-            
-            if temp[1] == 'dim':
-                domain.dim = float( (temp[2].rsplit())[0])
-            if temp[1] == 'nx':
-                domain.nx = int( (temp[2].rsplit())[0])
-            if temp[1] == 'ny':
-                try:
-                    domain.ny = int( (temp[2].rsplit())[0])
-                except:
-                    pass
-            if temp[1] == 'nz':
-                domain.nz = int( (temp[2].rsplit())[0])
-            if temp[1] == 'dx':
-                domain.dx = float( (temp[2].rsplit())[0])
-            if temp[1] == 'dy':
-                try:
-                    domain.dy = float( (temp[2].rsplit())[0])
-                except:
-                    pass
-            if temp[1] == 'dz':
-                domain.dz = float( (temp[2].rsplit())[0])
-            if temp[1] == 'cpml':
-                domain.cpml = int( (temp[2].rsplit())[0])
-            # if temp[1] == 'write':
-            #     domain.write = temp[2].rsplit()
-            if temp[1] == 'nmats':
-                domain.nmats = int( (temp[2].rsplit())[0])
-            if temp[1] == 'cpml_alpha':
-                domain.cpml_attenuation = float( (temp[2].rsplit())[0])
-        
-        if line[0] == 'S':
-            temp = line.split(',')
-            if temp[1] == 'dt':
-                try :
-                    seismic.dt = float( (temp[2].rsplit())[0])
-                except:
-                    pass
-            if temp[1] == 'time_steps':
-                seismic.time_steps = float( (temp[2].rsplit())[0])
-            if temp[1] == 'x':
-                seismic.x = float( (temp[2].rsplit())[0])
-            if temp[1] == 'y':
-                seismic.y = float( (temp[2].rsplit())[0])
-            if temp[1] == 'z':
-                seismic.z = float( (temp[2].rsplit())[0])
-            if temp[1] == 'f0':
-                seismic.f0 = float( (temp[2].rsplit())[0])
-            if temp[1] == 'theta':
-                seismic.theta = float( (temp[2].rsplit())[0])
-            if temp[1] == 'phi':
-                seismic.phi = float( (temp[2].rsplit())[0])
-
-        if line[0] == 'E':
-            temp = line.split(',')
-            if temp[1] == 'dt':
-                try:
-                    electromag.dt = float( (temp[2].rsplit())[0])
-                except:
-                    pass
-            if temp[1] == 'time_steps':
-                electromag.time_steps = float( (temp[2].rsplit())[0])
-            if temp[1] == 'x':
-                electromag.x = float( (temp[2].rsplit())[0])
-            if temp[1] == 'y':
-                electromag.y = float( (temp[2].rsplit())[0])
-            if temp[1] == 'z':
-                electromag.z = float( (temp[2].rsplit())[0])
-            if temp[1] == 'f0':
-                electromag.f0 = float( (temp[2].rsplit())[0])
-            if temp[1] == 'theta':
-                electromag.theta = float( (temp[2].rsplit())[0])
-            if temp[1] == 'phi':
-                electromag.phi = float( (temp[2].rsplit())[0])
-
-        if line[0] == 'M':
-            line = line[0:-1]
-            temp = line.split(',')
-            if temp[1] == '0':
-                material.material_list = temp[1:]
-                material.rgb = temp[3]
-            else:
-                material.material_list = np.row_stack( (material.material_list, temp[1:]))
-                material.rgb = np.append( material.rgb, temp[3] )
-
-        if line[0] == 'C':
-            temp = line.split(',')
-            # We need to remove the '\n' at the end. Whether the coefficients are
-            # given results in a different string
-            try:
-                temp[-1] = temp[-1].rsplit()[0]
-            except:
-                temp[-1] = ''
-
-            if temp[1] == '0' or temp[1] == '0.0':
-                seismic.tensor_coefficients = temp[1:]
-            else:
-                seismic.tensor_coefficients = np.row_stack((seismic.tensor_coefficients, temp[1:]))
-
-        # Permittivity coefficients
-        if line[0] == 'P':
-            if 'j' in line:
-                is_complex = True 
-            else: 
-                is_complex = False 
-            
-            temp = line.split(',')
-            try:
-                temp[-1] = temp[-1].rsplit()[0] # An index error will be given if coefficients are provided
-            except:
-                temp[-1] = ''
-
-            if temp[1] == '0' or temp[1] == '0.0':
-                if is_complex:
-                    electromag.tensor_coefficients = str2complex(temp[1:])
-                else:
-                    electromag.tensor_coefficients = temp[1:]
-                
-            else:
-                if is_complex:
-                    electromag.tensor_coefficients = np.row_stack( 
-                        (electromag.tensor_coefficients, str2complex(temp[1:]) )
-                    )
-                else:
-                    electromag.tensor_coefficients = np.row_stack( 
-                        (electromag.tensor_coefficients, temp[1:])
-                    )
-                    
-        # Attenuation coefficients
-        if line[0] == 'A':
-            temp = line.split(',')
-            try: 
-                seismic.attenuation_coefficients = np.row_stack(
-                    (
-                        seismic.attenuation_coefficients,
-                        np.array(temp[2:5], dtype = float)
-                    )
-                )
-            except:
-                seismic.attenuation_coefficients = np.array(
-                    temp[2:5], dtype = float
-                )
-                
-            # electromag.fref = float(temp[8])
-            seismic.fref = float(temp[5])
-
-    f.close()
-    return domain, material, seismic, electromag
-
-
-# -----------------------------------------------------------------------------
-# Make sure variables are in the correct type for Fortran
-def prepme(
-        model_object: Model, 
-        domain: Domain, 
-        complex_tensor: bool = True
-    ) -> tuple:
-    """
-    Prepare modeling objects and domain configurations for simulation, ensuring
-    that all parameters are in the correct format for Fortran processing.
-
-    This function adjusts the type of various parameters in the modeling and domain objects,
-    such as converting time steps to integers or ensuring that tensor coefficients are in the
-    correct numerical format (complex or float). Additionally, it arranges source and domain
-    parameters in the correct order based on the dimensionality of the domain.
-
-    :param model_object: The modeling object containing simulation parameters and configurations.
-    :param domain: The domain object containing spatial configurations and parameters.
-    :param complex_tensor: A flag indicating whether the tensor coefficients should be treated as complex numbers.
-    :type complex_tensor: bool
-    :return: A tuple containing the updated modeling object and domain object.
-    :rtype: tuple
-
-    The function specifically adjusts parameters for compatibility with Fortran-based
-    simulation engines, accounting for differences in array indexing and data types.
-    """
-    # Check if there are no errors and the coefficients have been computed
-    model_object.time_steps = int(model_object.time_steps)
-    model_object.f0 = float(model_object.f0)
-    model_object.theta = float(model_object.theta)
-    model_object.x = float(model_object.x)
-    model_object.z = float(model_object.z)
-    if complex_tensor:
-        model_object.tensor_coefficients = model_object.tensor_coefficients.astype(complex)
-    else:
-        model_object.tensor_coefficients = model_object.tensor_coefficients.astype(float)
-    
-    # Put source and domain parameters in correct order
-    if domain.dim == 2.5:
-        # There are additional values we need to assign
-        domain.ny = int(domain.ny)
-        domain.dy = float(domain.dy)
-        model_object.y = float(model_object.y)
-        model_object.phi = float(model_object.phi)
-
-        model_object.src = np.array(
-            [
-                model_object.x/domain.dx,
-                model_object.y/domain.dy,
-                model_object.z/domain.dz
-            ]
-        ).astype(int)
-    else:
-        model_object.src = np.array(
-            [
-                model_object.x/domain.dx,
-                model_object.z/domain.dz
-            ]
-        ).astype(int)
-
-    return(model_object, domain)
-
-# -----------------------------------------------------------------------------
-# Append coefficients
-def coefs2prj(model_object, material, domain, modeltype):
-    pass
-
-
-# -----------------------------------------------------------------------------
-def airsurf(material: Material, domain: Domain, N: int = 2) -> np.ndarray:
-    """
-    Generates a gradient matrix to simulate the air surface in a domain, based 
-    on material properties.
-
-    This function calculates a gradient matrix representing the transition 
-    between air and non-air materials within a domain. It is particularly 
-    useful for creating a surface with variable density or other properties 
-    near the air-material interface.
-
-    :param material: The material object containing material lists and 
-        properties.
-    :type material: Material
-    :param domain: The domain object containing the geometry of the simulation 
-        area.
-    :type domain: Domain
-    :param N: The number of gradational steps in the air surface simulation, 
-        defaults to 2.
-    :type N: int
-    :return: A gradient matrix representing the air surface within the domain.
-    :rtype: np.ndarray
-
-    The function uses the domain's geometry to determine air interfaces and 
-    applies a gradational approach to simulate the air surface effect. The 
-    gradient matrix can be used to adjust physical properties like density near 
-    the surface.
-    """
-    # This can be generalized a little better, but for now...
-    airnum = material.material_list[material.material_list[:,1] == 'air', 0]
-
-    if airnum:
-        airnum = int(airnum[0])
-        gradmatrix = (domain.geometry != airnum).astype(int)
-        # Take the gradient in both directions
-        gradz = np.diff(gradmatrix, axis = 0)
-        gradx = np.diff(gradmatrix, axis = 1)
-
-        # For grady we will append a column of zeros at the beginning so that the value
-        # 1 is located at the interface but on the non-air side
-        gradzpos = np.row_stack([np.zeros([gradz.shape[1] ]),gradz])
-        # For gradx we will append a row of zeros at the beginning
-        gradxpos = np.column_stack([np.zeros([gradx.shape[0] ]),gradx])
-        # -1 also means that there is an air interface. We will need to append to the
-        # end of the array, then we can just flip the sign
-        gradzneg = (np.row_stack( [gradz, np.zeros([gradz.shape[1]]) ] ) )
-        gradxneg = (np.column_stack( [gradx, np.zeros([gradx.shape[0]]) ] ) )
-
-        # At the surface we want to have 15% of density
-        grad = np.zeros( [gradx.shape[0], gradz.shape[1], N] )
-        grad[:,:,0] = gradzpos + gradxpos - gradzneg - gradxneg
-        grad[ grad[:,:,0]>0, 0] = 0.15
-
-        # We will make the change gradational by splitting the difference each step
-        # For instance, 1 - 0.15 = 0.85, so the next percentage will be
-        # 0.85/2 + 0.15 and so on
-        pct = np.zeros([N])
-        pct[0] = 0.15
-
-        for ind in range(1, N):
-            pct[ind] = pct[ind-1] + (1-pct[ind-1])/2
-            gradzpos = np.row_stack( [np.zeros([gradz.shape[1] ]),gradzpos] )[:-1,:]
-            gradxpos = np.column_stack( [np.zeros( [ gradx.shape[0] ] ),gradxpos ])[:,:-1]
-
-            gradzneg = (np.row_stack( [ gradzneg, np.zeros( [gradz.shape[1] ]) ] )[1:,:])
-            gradxneg = (np.column_stack( [ gradxneg, np.zeros( [gradx.shape[0] ]) ] )[:,1:])
-            grad[:,:, ind] = gradzpos + gradxpos - gradzneg - gradxneg
-            grad[ grad[:,:,ind] > 0, ind] = pct[ind]
-
-        gradcomp = np.zeros( [grad.shape[0], grad.shape[1] ])
-        for ind in range(N-1, -1, -1):
-            gradcomp[ grad[:,:,ind] > 0] = pct[ind]
-
-        gradcomp[ gradcomp == 0] = 1
-    else:
-        gradcomp = np.ones([int(domain.nx), int(domain.nz) ])
-
-    return(gradcomp)
-
-# -----------------------------------------------------------------------------
-def rcxgen(
-        rgb: list, 
-        domain: Domain, material: Material, 
-        filename: str = 'receivers.xyz'
-    ):
-    """
-    Creates a receiver list from a specified RGB value found in the model 
-    image, outputting to a CSV file.
-    
-    This function searches the domain's geometry for occurrences of a given RGB 
-    value (specified as a list of integers representing red, green, and blue 
-    components). It then generates a list of receiver coordinates based on the 
-    locations where the RGB value is found. Currently, the function is set up 
-    for 2D receivers only, with Y-coordinates set to zero.
-
-    :param rgb: A list of three integers representing the RGB value to search 
-        for in the domain's geometry.
-    :type rgb: list
-    :param domain: An object representing the domain, including its geometry 
-        and spatial discretization parameters (dz, dx).
-    :param material: An object containing the material list and associated RGB 
-        values.
-    :param filename: The name of the output CSV file containing the receiver 
-        coordinates, defaults to 'receivers.xyz'.
-    :type filename: str
-    :return: A numpy array of receiver coordinates where each row represents 
-        [Z, Y, X] coordinates.
-    :rtype: np.ndarray
-
-    The function converts the RGB list into a string format, looks up the 
-        corresponding integer value from the
-    material list, finds all occurrences in the domain's geometry, and outputs 
-        the coordinates to a specified CSV file.
-    """
-    rgb = '/'.join(np.array(rgb).astype(str))
-    rgbint = int(material.material_list[material.rgb == rgb,0])
-    z,x = np.where(domain.geometry == rgbint)
-    y = np.zeros([len(x)])
-    xyz = np.stack([z*domain.dz,y,x*domain.dx], axis = 1)
-    df = pd.DataFrame(xyz, columns = ['X', 'Y', 'Z'])
-    df.to_csv(filename, index = False)
-    return(xyz)
-
-
-# ============================== Source Functions =============================
-# -----------------------------------------------------------------------------
-def coherdt(
-        alpha: float, 
-        v: float, 
-        n: int, 
-        dx: float, 
-        loc: str = 'left'
-    ) -> np.ndarray:
-    """
-    Calculates a vector of time delays based on the angle of incidence, 
-    velocity, and spatial discretization.
-
-    This function determines the time delay for coherent addition of traces 
-    based on the propagation angle (alpha), velocity (v), and the 
-    discretization in space (dx) along the domain length.
-
-    :param alpha: The angle of incidence in degrees, counter clockwise from the 
-        x-plane. Range: (-90, 90).
-    :type alpha: float
-    :param v: Velocity in meters/second.
-    :type v: float
-    :param n: The number of spatial points in the domain.
-    :type n: int
-    :param dx: The spatial discretization in meters.
-    :type dx: float
-    :param loc: Specifies the reference point's location for time delay 
-        calculation, defaults to 'left'.
-    :type loc: str
-    :return: A numpy array containing the time delays for each spatial point in 
-        the domain.
-    :rtype: np.ndarray
-
-    The function adjusts angles outside the (-90, 90) range and calculates time 
-    delays accordingly.
-    """
-    # Return a vector of time delays along the length of the domain. The angle
-    # alpha, given in degrees between 90 and -90, is counter clockwise from the
-    # x plane. Velocity and dx are in meters/second and meters, respectively.
-    if alpha < 0:
-        self.dz = None
-        self.cpml = None
-        self.write = None
-        self.imfile = None
-        self.exit_status = 1
-
-        # Flag to specify whether the all inputs are fulfilled
-        self.seismic_model = False
-        self.electromag_model = False
-
-    def para_check(self):
-        self.exit_s
-    if alpha > 90.0 or alpha < -90:
-        alpha = 180 - np.sign(alpha) * alpha
-    else:
-        print('Alpha must be on the interval (-90,90)')
-        quit()
-
-    x = np.arange(0, n*dx, dx)
-    dt = x * np.sin( np.deg2rad(alpha) ) / v
-    return(dt)
-
-# -----------------------------------------------------------------------------
-def coherstf(
-        timediff: np.ndarray, 
-        source_function: np.ndarray, 
-        dt: float, 
-        m: int, n: int, cpml: int, 
-        bottom: bool = False
-    ) -> None:
-    """
-    Applies time shifts to a source time function along the domain and saves it 
-    as an m-by-n-by-p matrix.
-
-    :param timediff: A numpy array containing time differences for time 
-        shifting the source function.
-    :type timediff: np.ndarray
-    :param sf: The source time function as a numpy array.
-    :type sf: np.ndarray
-    :param dt: The time interval between successive samples in the source 
-        function.
-    :type dt: float
-    :param m: Number of indices in the y-direction (height of the domain).
-    :type m: int
-    :param n: Number of indices in the x-direction (width of the domain).
-    :type n: int
-    :param cpml: The size of the Convolutional Perfectly Matched Layer (CPML) 
-        padding.
-    :type cpml: int
-    :param bottom: Specifies whether to place the source at the bottom of the 
-        domain. Defaults to False.
-    :type bottom: bool
-    :return: None
-
-    This function time shifts the source time function for each node in the 
-    x-direction, considering CPML adjustments.
-    
-    'topleft' origin is (0,0), 
-    'topright' origin is (x_n, 0)
-    'bottomleft' origin is (0, y_n), 
-    'bottomright' origin is (x_n, y_n)
-    """
-    p = len(source_function)
-    sfmat = np.zeros([m, n, p], order='F') # m indices are in the y-direction
-    cpmlmat = np.zeros([2*cpml + m, 2*cpml + n, p])
-    sfarray = np.zeros([m, p])  # p indices are in the t-direction
-    ndiff = int(np.round(timediff/dt))
-    for ind in range(0, m):
-        sfarray[ind,:] = np.roll(source_function, timediff[i])
-        sfarray[ind,0:timediff[i]] == 0
-    if bottom == True:
-        sfmat[m,:,:] = sfarray[:]
-    else:
-        sfmat[0,:,:] = sfarray[:]
-    cpmlmat[cpml:,cpml:,:] = sfmat[:,:,:]
-    cpmlmat.T.tofile('sourcefunctionmatrix.dat')
-
-# -----------------------------------------------------------------------------
-def stfvec2mat(
-        source_function: np.ndarray, 
-        xind: int, zind: int, 
-        m: int, n: int, 
-        cpml: int, 
-        yind: int = None
-    ) -> None:
-    """
-    Converts a source time function vector to a matrix for 2D or 3D 
-    simulations.
-
-    :param sf: The source time function vector.
-    :type sf: np.ndarray
-    :param xind: The index in the x-direction where the source is located.
-    :type xind: int
-    :param zind: The index in the z-direction where the source is located.
-    :type zind: int
-    :param m: The number of indices in the y-direction (height of the domain).
-    :type m: int
-    :param n: The number of indices in the x-direction (width of the domain).
-    :type n: int
-    :param cpml: The size of the Convolutional Perfectly Matched Layer (CPML) 
-        padding.
-    :type cpml: int
-    :param yind: The index in the y-direction where the source is located, for 
-        3D simulations. Defaults to None for 2D simulations.
-    :type yind: Optional[int]
-    :return: None
-
-    This function arranges the source time function in the spatial domain and applies CPML padding.
-    """
-    # If 2D, y = None. So far we only have 2D. 3D will be implemented later
-    p = len(st)
-    sfmat = np.zeros([m,n,p], order = 'F')
-    sfmat[zind, xind,:] = source_function[:]
-    cpmlmat = np.zeros([2*cpml + m, 2*cpml + n, p], order = 'F')
-    cpmlmat[cpml:,cpml:,:] = sfmat[:,:,:]
-    cpmlmat.T.tofile('sourcefunctionmatrix.dat')
-
-# -----------------------------------------------------------------------------
-def movingsrc(sf: np.ndarray, txlocs: np.ndarray) -> None:
-    """
-    Simulates a moving source given a stationary source time function.
-
-    :param sf: The stationary source time function as a numpy array.
-    :type sf: np.ndarray
-    :param txlocs: A numpy array containing the transmission locations over time.
-    :type txlocs: np.ndarray
-    :return: None
-    
-    This function is intended as a placeholder to simulate a moving source by manipulating the stationary source time function according to the provided transmission locations.
-    """
-    pass  # Implementation yet to be done or specified.
-
-# ----------------------------- Plotting Functions ----------------------------
-def indvar(
-        model_object: Model, domain: Domain
-    ) -> tuple[np.ndarray, Optional[np.ndarray], np.ndarray, np.ndarray]:
-    """
-    Generates spatial and temporal grids based on domain and model object 
-    attributes.
-
-    :param model_object: An object containing model-specific parameters, including 
-        time steps and time interval (dt).
-    :param domain: An object containing domain-specific parameters such as 
-        spatial dimensions (nx, ny, nz) and discretizations (dx, dy, dz).
-    :return: A tuple of numpy arrays representing the grids in x, y (None if ny 
-        is not set), z, and t dimensions.
-    :rtype: tuple
-
-    The function calculates the spatial grid points in the x, z, and optionally 
-    y dimensions, and temporal grid points based on the provided domain and 
-    model parameters. The y-dimension grid is generated only if the domain 
-    parameters include 'ny'.
-    """
-    nx = int(domain.nx[0])
-    nz = int(domain.nz[0])
-    dx = float(domain.dx[0])
-    dz = float(domain.dz[0])
-    dt = float(model_object.dt[0])
-    nt = int(model_object.time_steps[0])
-
-    x = np.linspace(0, dx * (nx - 1), nx)
-    z = np.linspace(0, dz * (nz - 1), nz)
-    t = np.linspace(0, dt * (nt - 1), nt)
-    try:
-        y = np.linspace(
-            0, float(domain.dy[0]) * (int(domain.ny) - 1), int(domain.ny)
-        )
-    except:
-        y = None
-
-    return(x,y,z,t)
-
-# ---------------------------- Processing functions ---------------------------
-def agc(ts, k, agctype):
-    """
-    Applies auto-gain control (AGC) normalization to a time series using a 
-    specified window length and type.
-
-    :param ts: The input time series as a numpy array.
-    :type ts: np.ndarray
-    :param k: The length of the window used for normalization.
-    :type k: int
-    :param agctype: The type of normalization to apply, choices are "std", 
-        "mean", or "median".
-    :type agctype: str
-    :return: The time series after applying AGC normalization.
-    :rtype: np.ndarray
-
-    This function normalizes the input time series using a running window 
-    approach, with the normalization type determined by `agctype`. It supports 
-    standard deviation ("std"), mean ("mean"), or median ("median") based 
-    normalization. The function modifies the series to have a uniform amplitude 
-    characteristic over time.
-    """
-    n = len(ts)
-
-    k2 = int(k/2) # This will floor the number if k is even; (k-1)/2
-    if np.mod(k, 2) == 0: # even numbers need will not have a centered window
-        k = int( k + 1)
-
-    stat = np.ones([n])
-    # Normalize
-    if agctype == "std":
-        for i in range(0, k2):
-            stat[i] = np.std( abs( ts[0:(i+k2)] ) )
-            stat[ (n-k2+i) ] = np.std( abs(ts[ (n-2*k2+i):n] ) )
-        for i in range(k2,n-k2):
-            stat[i] = np.std( abs( ts[ (i-k2):(i+k2) ] ) )
-    elif agctype == "mean":
-        for i in range(0, k2):
-            stat[i] = np.mean( abs( ts[0:(i+k2)] ) )
-            stat[ (n-k2+i) ] = np.mean( abs(ts[ (n-2*k2+i):n] ) )
-        for i in range(k2,n-k2):
-            stat[i] = np.mean( abs( ts[ (i-k2):(i+k2) ] ) )
-    else:
-        for i in range(0, k2):
-            stat[i] = np.std( ts[i:(i+k2)] )
-            stat[ (n-k2+i) ] = np.std( ts[ (n-2*k2+i):n] )
-        for i in range(k2,n-k2):
-            stat[i] = np.std( ts[ (i-k2):(i+k2) ] )
-
-    stat[stat == 0] = 1
-    ts = ts/stat
-    return ts
+import numpy as np
+import pandas as pd
+import seidart.routines.materials as mf
+import matplotlib.pyplot as plt
+import matplotlib.image as mpimg
+import matplotlib.animation as anim
+import os.path
+from typing import Optional
+from subprocess import call
+from scipy.io import FortranFile
+import glob2
+
+
+__all__ = [
+    'read_dat',
+    'image2int',
+    'complex2str',
+    'str2complex',
+    'append_coefficients',
+    'loadproject',
+    'prepme',
+    'coefs2prj',
+    'airsurf',
+    'rcxgen',
+    'coherdt',
+    'coherstf',
+    'stfvec2mat',
+    'movingsrc',
+    'indvar',
+    'agc',
+    'Domain',
+    'Material',
+    'Model',
+    'AnimatedGif'
+    # Add any other public names here
+]
+
+# =============================================================================
+# =========================== Define Class Variables ==========================
+# =============================================================================
+
+# We need to define some class variables
+class Domain:
+    def __init__(self):
+        super().__init__()
+        self.build()
+
+    def build(self):
+        # Initialize variables
+        self.geometry = None
+        self.dim = None
+        self.nx = None
+        self.ny = None
+        self.nz = None
+        self.dx = None
+        self.dy = None
+        self.dz = None
+        self.cpml = None
+        self.cpml_attenuation = 0.0 # Default attenuation in the cpml region. Higher is more attenuation.
+        self.write = None
+        self.imfile = None
+        self.exit_status = 1
+
+        # Flag to specify whether the all inputs are fulfilled
+        self.seismic_model = False
+        self.electromag_model = False
+
+    def para_check(self):
+        self.exit_status = 0
+        # make sure there's a geometry. This implies whether nx, and nz exist
+        if self.geometry is None:
+            self.exit_status = 1
+            print('No geometry loaded\n')
+        if not self.dx or self.dx is None:
+            self.exit_status = 1
+            print('No step size in the x-direction')
+        if not self.dz or self.dz is None:
+            self.exit_status = 1
+            print('No step size in the y-direction')
+        if not self.cpml or self.cpml is None:
+            self.exit_status = 1
+            print('No cpml thickness is given')
+
+        # Check 2.5D
+        if self.dim == '2.5' and exit_status == 0:
+            if self.ny is None or self.ny == 'n/a':
+                print('No dimension given for y-direction. Assigning default ny=3.')
+                self.ny = 3
+            if self.dy is None or self.dy == 'n/a':
+                self.dy = np.min( [int(self.dx), int(self.dz)])
+                print('No step size given for y-direction. Assigning min(dx,dz).')
+
+        # Convert variables to required types. Ny and Dy are already converted if given
+        if self.exit_status == 0:
+            self.dim = float(self.dim)
+            self.nx = int(self.nx)
+            self.nz = int(self.nz)
+            self.dx = float(self.dx)
+            self.dz = float(self.dz)
+            self.cpml = int(self.cpml)
+        else:
+            print('\n Domain inputs are not satisfied. I can"t go on anymore. \n')
+            # quit()
+
+# -----------------------------------------------------------------------------
+
+class Material:
+    """
+    A class to manage materials for simulation purposes.
+
+    Attributes
+    ----------
+    material_list : numpy.ndarray
+        An array to store the list of materials.
+    material_flag : bool
+        A flag indicating whether the materials were read in successfully.
+    material : numpy.ndarray or None
+        Stores material information.
+    rgb : numpy.ndarray or None
+        Stores RGB values for materials (not used currently).
+    temp : numpy.ndarray or None
+        Stores temperature values for materials.
+    rho : numpy.ndarray or None
+        Stores density values for materials.
+    porosity : numpy.ndarray or None
+        Stores porosity values for materials.
+    lwc : numpy.ndarray or None
+        Stores liquid water content values for materials.
+    is_anisotropic : numpy.ndarray or None
+        Indicates if the material is anisotropic.
+    angfiles : numpy.ndarray or None
+        Stores ANG file paths for anisotropic materials.
+    functions : Any
+        Stores material processing functions.
+    """
+    # initialize the class
+    def __init__(self) -> None:
+        """
+        Initializes the Material class by building the initial structure.
+        """
+        super().__init__()
+        self.build()
+
+    def build(self) -> None:
+        """
+        Initializes the material attributes with default values.
+        """
+        self.material_list = np.array([]) # initialize
+        self.material_flag = False # Whether the materials were read in
+
+        # We will assign each of the list variables
+        self.material = None
+        self.rgb = None
+        self.temp = None
+        # self.attenuation = None
+        self.rho = None
+        self.porosity = None
+        self.lwc = None
+        self.is_anisotropic = None
+        self.angfiles = None
+
+        # The processing functions
+        self.functions = mf
+
+    def sort_material_list(self) -> None:
+        """
+        Sorts the material list based on the material properties.
+        """
+        self.material = self.material_list[:,1]
+        self.temp = self.material_list[:,2].astype(float)
+        # self.attenuation = self.material_list[:,3].astype(float)
+        self.rho = self.material_list[:,3].astype(float)
+        self.porosity = self.material_list[:,4].astype(float)
+        self.lwc = self.material_list[:,5].astype(float)
+        self.is_anisotropic = self.material_list[:,6] == 'True'
+        self.angfiles = self.material_list[:,7]
+
+    def para_check(self) -> None:
+        """
+        Checks the parameters of the material list for completeness.
+
+        It ensures that necessary fields are provided and checks for the presence of .ANG files for anisotropic materials.
+        """
+        # The fields for the materials in the input are defined as:
+        # 'id, R/G/B, Temp., Dens., Por., WC, Anis, ANG_File'
+        # but the R/G/B column is deleted
+
+        if len(self.material_list) > 0:
+            # Check to make sure the necessary fields are provided
+            check = 0
+
+            for row in self.material_list[:,0:6]:
+                for val in row:
+                    if not val:
+                        check = check + 1
+
+        if check == 0:
+            file_check = 0
+            for ind in range(0, self.material_list.shape[0]):
+                if self.material_list[ind,6] == 'True' and not self.material_list[ind,7] or self.material_list[ind,7] == 'n/a':
+                    file_check = file_check + 1
+        else:
+            print('Material inputs aren"t satisfied.')
+
+        if check == 0:
+            if file_check == 0:
+                self.material_flag = True
+            else:
+                print('No .ANG file specified for anisotropic material')
+
+# -----------------------------------------------------------------------------
+class Model:
+    """
+    A class to manage the simulation model configuration.
+
+    Attributes
+    ----------
+    dt : float or None
+        The time step size.
+    time_steps : int or None
+        The total number of time steps in the simulation.
+    x : float or None
+        The x-coordinate of the source location.
+    y : float or None
+        The y-coordinate of the source location. Optional, defaults to None.
+    z : float or None
+        The z-coordinate of the source location.
+    f0 : float or None
+        The source frequency.
+    theta : float or None
+        The angle of incidence in the xz-plane. Optional, defaults to 0 if unspecified.
+    phi : float or None
+        The angle of incidence in the xy-plane. Optional, defaults to 0 if `y` is specified and `phi` is unspecified.
+    src : Any
+        The source information. Type is unspecified.
+    tensor_coefficients : numpy.ndarray or None
+        The tensor coefficients for the simulation. Optional, but required for tensor-based simulations.
+    compute_coefficients : bool
+        A flag indicating whether to compute coefficients. Defaults to True.
+    attenuation_coefficients : numpy.ndarray or None
+        The attenuation coefficients for the simulation. Optional.
+    fref : float or None
+        The reference frequency for attenuation. Optional.
+    attenuation_fadjust : bool or None
+        Flag to adjust frequency for attenuation. Optional.
+    exit_status : int
+        Status code to indicate the success or failure of parameter checks.
+    """
+    def __init__(self) -> None:
+        """
+        Initializes the Model class by building the initial configuration.
+        """
+        super().__init__()
+        self.build()
+    
+    def build(self) -> None:
+        """
+        Initializes the simulation model attributes with default values.
+        """
+        self.dt = None
+        self.time_steps = None
+        self.x = None
+        self.y = None
+        self.z = None
+        self.f0 = None
+        self.theta = None
+        self.phi = None
+        self.src = None
+        self.tensor_coefficients = None
+        self.compute_coefficients = True
+        self.attenuation_coefficients = None
+        self.fref = None
+        self.attenuation_fadjust = None
+        self.exit_status = 0
+
+    
+    def tensor_check(self) -> None:
+        """
+        Checks if tensor coefficients are specified and valid. Disables coefficient computation if valid.
+        """
+        # If the tensors are there
+        check = 0
+        # if not self.tensor_coefficients:
+        # 	print('ldkjf')
+        for row in self.tensor_coefficients:
+            for val in row:
+                if not val:
+                    check = check + 1
+        
+        if check == 0:
+            self.compute_coefficients = False
+    
+    def para_check(self) -> None:
+        """
+        Performs parameter checks for essential simulation settings and updates the exit status accordingly.
+        """
+        if not self.time_steps:
+            self.exit_status = 1
+            print('Number of time steps aren"t satisfied.')
+        
+        if not self.x or not self.z:
+            self.exit_status = 1
+            print('No source location is specified.')
+        
+        if not self.f0:
+            self.exit_status = 1
+            print('No source frequency is specified.')
+        
+        # in case theta or phi aren't specified we can assign defaults
+        if not self.theta:
+            self.theta = 0
+        
+        # if y is specified but not phi
+        if self.y and not self.phi:
+            self.phi = 0
+
+# -----------------------------------------------------------------------------
+class AnimatedGif:
+    """
+    A class to create an animated GIF from a series of images.
+
+    :param size: The size of the animated GIF in pixels (width, height), 
+        defaults to (640, 480)
+    :type size: Tuple[int, int], optional
+
+    Attributes:
+        fig (matplotlib.figure.Figure): The figure object for the animation.
+        images (List): A list of image frames to be included in the GIF.
+        background (List): Background image data.
+        source_location (List[int, int]): The location of the source point in 
+        the plot.
+        nx (int): Width of the plot.
+        nz (int): Height of the plot.
+        output_format (int): Format of the output file. 0 for GIF, 1 for other 
+        formats.
+    """
+    def __init__(self, size=(640,480) ):
+        """
+        Initialize the AnimatedGif class with a figure size.
+        """
+        self.fig = plt.figure()
+        self.fig.set_size_inches(size[0]/100, size[1]/100)
+        ax = self.fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1)
+        ax.set_xticks([])
+        ax.set_yticks([])
+        self.images = []
+        self.background = []
+        self.source_location = []
+        self.nx = size[0]
+        self.nz = size[1]
+        self.output_format = 0
+
+    def add(self, image, label='', extent=None ):
+        """
+        Adds an image to the animation sequence.
+
+        :param image: The image data to add.
+        :type image: np.ndarray
+        :param label: The label to add to the image, defaults to ''.
+        :type label: str, optional
+        :param extent: The extent of the image, defaults to None.
+        :type extent: Tuple[int, int, int, int], optional
+        """
+        bound = np.max([abs(np.min(image)),abs(np.max(image))])
+        plt_im = plt.imshow(
+            image,cmap='seismic',
+            animated=True,
+            extent=(0, (self.nx), (self.nz), 0),
+            vmin=-bound,vmax=bound
+        )
+        plt_bg = plt.imshow(
+            self.background,
+            alpha = 0.3,
+            extent=extent,
+            animated = True
+        )
+        plt.scatter(
+            self.source_location[0],
+            self.source_location[1],
+            marker = '*',
+            s = 30,
+            linewidths = 1,
+            edgecolor = (0.2, 0.2, 0.2, 1 )
+        )
+        plt_txt = plt.text(
+            extent[0] + 20,
+            extent[2] + 20,
+            label,
+            color='red'
+        ) # Lower left corner
+        self.images.append([plt_im, plt_bg, plt_txt])
+
+    def save(self, filename, frame_rate = 50):
+        """
+        Save the animated GIF.
+
+        :param filename: The name of the output file.
+        :type filename: str
+        :param frame_rate: The frame rate of the animation, defaults to 50.
+        :type frame_rate: int, optional
+        """
+        animation = anim.ArtistAnimation(self.fig,
+                                        self.images,
+                                        interval = frame_rate,
+                                        blit = True
+                                        )
+        if self.output_format == 1:
+            animation.save(filename, dpi = 300)
+        else:
+            animation.save(filename, dpi = 300, writer = 'imagemagick')
+
+# -------------------------- Function Definitions -----------------------------
+def read_dat(
+        fn: str, 
+        channel: str, 
+        domain: Domain, 
+        is_complex: bool, 
+        single: bool =False
+    ) -> np.ndarray:
+    """
+    Read data from an unformatted Fortran binary file and return it as a numpy 
+    array. This function supports reading data in single or double precision, 
+    and can handle complex data.
+
+    :param fn: The filename of the data file to read.
+    :type fn: str
+    :param channel: Specifies the data channel ('Ex', 'Ey', 'Ez', etc.) 
+        to read.
+    :type channel: str
+    :param domain: The domain object that contains dimensions (dim, nx, ny, nz) 
+        of the data.
+    :type domain: Domain
+    :param is_complex: A flag indicating if the data is complex.
+    :type is_complex: bool
+    :param single: A flag indicating if the data should be read in 
+        single precision. Defaults to False (double precision).
+    :type single: bool
+    :return: The data read from the file, reshaped according to the 
+        domain dimensions.
+    :rtype: np.ndarray
+
+    The domain parameter is expected to be an object with attributes 
+        `dim`, `nx`, `ny`, and `nz`.
+    These are used to determine the shape of the returned numpy array.
+    """
+    if single:
+        dtype = np.float32 
+    else:
+        dtype = np.float64 
+    
+    if domain.dim == 2.5:
+        if channel == 'Ex':
+            NX = domain.nz
+            NY = domain.ny
+            NZ = domain.nx-1
+        elif channel == 'Ey':
+            NX = domain.nz
+            NY = domain.ny-1
+            NZ = domain.nx
+        elif channel == 'Ez':
+            NX = domain.nz-1
+            NY = domain.ny
+            NZ = domain.nx
+        else:
+            NX = domain.nz
+            NY = domain.ny
+            NZ = domain.nx
+    else:
+        if channel == 'Ex':
+            NX = domain.nz
+            NZ = domain.nx-1
+        elif channel == 'Ez':
+            NX = domain.nz-1
+            NZ = domain.nx
+        else:
+            NX = domain.nz
+            NZ = domain.nx
+    #
+
+    with FortranFile(fn, 'r') as f:
+        if is_complex:
+            if single:
+                dat = f.read_reals(dtype=np.float32)#.reshape(nx, nz)
+                dat = dat[:(NX*NZ)] + 1j * dat[(NX*NZ):]
+            else:
+                # Read complex data directly as double precision
+                dat = f.read_complex(dtype=np.complex128)#.reshape(nx, nz)
+        else:
+            if single:
+                dat = f.read_reals(dtype = np.float32)
+            else:
+                dat = f.read_reals(dtype = np.float64)
+
+    if domain.dim == 2.5:
+        dat = dat.reshape(NX, NY, NZ)
+    else:
+        dat = dat.reshape(NX, NZ)
+
+    f.close()
+    return(dat)
+
+# =============================================================================
+# ============================== Useful Functions =============================
+# =============================================================================
+
+def image2int(image_filename: str) -> np.ndarray:
+    """
+    Convert an image file into an integer array where each unique RGB color 
+    is mapped to a unique integer.
+
+    This function reads an image from a file, converts RGB colors to a single 
+    integer value by combining the RGB channels, then maps each unique color in
+    the image to a unique integer. This can be useful for image analysis tasks 
+    where colors represent different categories or labels.
+
+    :param image_filename: The path to the image file.
+    :type image_filename: str
+    :return: A 2D array where each element represents a unique integer mapping 
+        of the original RGB colors.
+    :rtype: np.ndarray
+
+    The conversion of RGB to a single value is performed using the formula: 
+    65536*red + 255*green + blue. Note that this function assumes the input 
+    image is in a format readable by matplotlib.image.imread (e.g., PNG, JPG), 
+    and that it has three color channels (RGB).
+    """
+    # read the image
+    img = mpimg.imread(image_filename)
+
+    # Convert RGB to a single value
+    rgb_int = np.array(65536*img[:,:,0] +  255*img[:,:,1] + img[:,:,2])
+
+    # Get the unique values of the image
+    rgb_uni = np.unique(rgb_int)
+
+    # mat_id = np.array( range(0, len(rgb_uni) ) )
+    for ind in range(0, len(rgb_uni) ):
+        rgb_int[ rgb_int == rgb_uni[ind] ] = ind
+
+    return rgb_int.astype(int)
+
+# -----------------------------------------------------------------------------
+# After computing tensor coefficients we want to append them to the given text
+# file. In order to do this, we need to create a new file then move it to the
+# original file
+
+def complex2str(complex_vector: np.ndarray) -> str:
+    """
+    Convert a numpy array of complex numbers into a string representation, 
+    with the first element representing an identifier and the subsequent 
+    elements representing complex numbers.
+
+    This function extracts the real and imaginary parts of each complex number 
+    in the input vector, converts them to strings, and concatenates them with 
+    'j' as the delimiter. The first real number of the input vector is treated 
+    as an identifier (ID) and is converted separately.
+
+    :param complex_vector: A numpy array of complex numbers where the first 
+        element is an ID.
+    :type complex_vector: np.ndarray
+    :return: A string representation of the ID followed by the complex numbers 
+        in the vector.
+    :rtype: str
+
+    The returned string format is 'ID,real1jimag1,real2jimag2,...' where ID is 
+    the integer ID, and realN and imagN are the real and imaginary parts of the
+    Nth complex number, respectively.
+    """
+    reals = complex_vector.real[1:]
+    comps = complex_vector.imag[1:]
+    
+    reals = [format(x, '.2e') for x in reals]
+    comps = [format(x, '.2e') for x in comps]
+    
+    id = complex_vector.real[0].astype(int)
+    m = len(reals)
+    complex_string_vector = np.zeros([m], dtype = object)
+    for ind in range(m):
+        complex_string_vector[ind] = str(reals[ind]) + 'j' + str(comps[ind])
+    
+    return( str(id) + ',' + ','.join(complex_string_vector))
+
+def str2complex(strsplit: list) -> np.ndarray:
+    """
+    Convert a list of strings into a numpy array of complex numbers, where the
+    first string is treated as an identifier (ID) and the subsequent strings 
+    represent complex numbers.
+
+    The function splits each string by 'j' to separate the real and imaginary 
+    parts of each complex number, then constructs a numpy array of complex 
+    numbers from these parts. The first element of the array is the ID.
+
+    :param strsplit: A list of strings, where the first string is an ID and the 
+        remaining strings represent complex numbers in 'realjimag' format.
+    :type strsplit: list
+    :return: A numpy array of complex numbers with the ID as the first element.
+    :rtype: np.ndarray
+
+    Note that the input list should follow the format ['ID', 'real1jimag1', 
+    'real2jimag2', ...], where 'ID' is an integer identifier, and 'realNjimagN' 
+    are the real and imaginary parts of the Nth complex number.
+    """
+    # strsplit = line.split(',')
+    id = int(strsplit[0])
+    m = len(strsplit)
+    complex_vector = np.zeros([m], dtype = complex)
+    complex_vector[0] = id
+    for ind in range(1,m):
+        realvalue, complexvalue = strsplit[ind].split('j')
+        complex_vector[ind] = complex(float(realvalue), float(complexvalue))
+    
+    return(complex_vector)
+        
+def append_coefficients(
+        prjfile: str, tensor: np.ndarray, CP: str = None, dt : float = 1.0 
+    ):
+    """
+    Appends coefficients to a project file based on the provided tensor, 
+    optionally using a line identifier.
+    
+    This function reads a project file, appending new coefficients derived from 
+    a tensor to it. The coefficients are appended based on a line identifier 
+    (`CP`), which specifies the type of modeling (e.g., 'C' for stiffness, 'P' 
+    for permittivity). The function also appends the time step (`dt`) for each 
+    modeling type specified by `CP`.
+    
+    Note: The project file is updated in place, with the original file replaced by 
+    the modified one. The `tensor` can be either a complex or a real numpy array. The function 
+    handles these differently when appending to the file. This function relies on an external command (`mv`) to replace the 
+    original file, which requires that the script has permissions to execute 
+    system commands.
+    
+    :param prjfile: The path to the project file to be modified.
+    :type prjfile: str
+    :param tensor: A numpy array containing the tensor coefficients to append.
+    :type tensor: np.ndarray
+    :param CP: The line identifier indicating the type of modeling ('C' or 'P'), optional.
+    :type CP: str, optional
+    :param dt: The time step to append for the modeling type, defaults to 1.
+    :type dt: float
+    :return: None
+    """
+    newfile = 'newfile.txt'
+    
+    with open(prjfile, 'r') as ogprj, open(newfile, 'a') as temp:
+        # Determine modeling type based on CP
+        mt = 'S' if CP == 'C' else 'E'
+        
+        for line in ogprj.readlines():
+            if line.startswith(CP):
+                line = line.strip().split(',')
+                if np.iscomplexobj(tensor):
+                    temp.write(
+                        CP + ',' + \
+                            complex2str(tensor[int(float(line[1])), :]) + \
+                                '\n'
+                    )
+                else:
+                    temp.write(
+                        CP + ',' + \
+                            ','.join(map(str, tensor[int(float(line[1])), :])) + \
+                                '\n'
+                    )
+            elif line.startswith(mt) and line[2:4] == 'dt':
+                temp.write(mt + ',dt,' + str(dt) + '\n')
+            else:
+                temp.write(line)
+    
+    # Replace the original project file with the new file
+    call('mv ' + newfile + ' ' + prjfile, shell=True)
+
+# =============================================================================
+# ========================= Read/Assign Project File ==========================
+# =============================================================================
+# -----------------------------------------------------------------------------
+def loadproject(
+        project_file: str, 
+        domain: Domain, material: Material, seismic: Model, electromag: Model
+    ) -> tuple[Domain, Material, Model, Model]:
+    """
+    Loads project settings from a project file and assigns values to domain, 
+    material, seismic, and electromagnetic objects.
+
+    This function parses a specified project file, reading configurations and parameters
+    for the domain, materials, seismic modeling, and electromagnetic properties. These
+    parameters are then assigned to the provided objects.
+
+    :param project_file: The path to the project configuration file.
+    :type project_file: str
+    :param domain: An object to hold domain-specific parameters and configurations.
+    :param material: An object to hold material-specific parameters and configurations.
+    :param seismic: An object to hold seismic modeling parameters and configurations.
+    :param electromag: An object to hold electromagnetic modeling parameters and configurations.
+    :return: A tuple containing the updated domain, material, seismic, and electromagnetic objects.
+    :rtype: tuple
+
+    The function assumes the project file contains specific prefixes for different
+    types of configurations (e.g., 'I' for images, 'D' for domain configurations, 'S' for
+    seismic modeling parameters, etc.).
+    """
+    # domain, material, seismic, electromag are the objects that we will assign
+    # values to
+    f = open(project_file)
+
+    # Let the if train begin
+    for line in f:
+        if line[0] == 'I':
+            # There's a trailing new line value
+            im = image2int(line[2:-1])
+            domain.geometry = im.transpose().astype(int)
+            # Get the image file
+            domain.imfile = line[2:-1]
+        
+        # All domain inputs must be input except for ny and dy
+        if line[0] == 'D':
+            temp = line.split(',')
+            
+            if temp[1] == 'dim':
+                domain.dim = float( (temp[2].rsplit())[0])
+            if temp[1] == 'nx':
+                domain.nx = int( (temp[2].rsplit())[0])
+            if temp[1] == 'ny':
+                try:
+                    domain.ny = int( (temp[2].rsplit())[0])
+                except:
+                    pass
+            if temp[1] == 'nz':
+                domain.nz = int( (temp[2].rsplit())[0])
+            if temp[1] == 'dx':
+                domain.dx = float( (temp[2].rsplit())[0])
+            if temp[1] == 'dy':
+                try:
+                    domain.dy = float( (temp[2].rsplit())[0])
+                except:
+                    pass
+            if temp[1] == 'dz':
+                domain.dz = float( (temp[2].rsplit())[0])
+            if temp[1] == 'cpml':
+                domain.cpml = int( (temp[2].rsplit())[0])
+            # if temp[1] == 'write':
+            #     domain.write = temp[2].rsplit()
+            if temp[1] == 'nmats':
+                domain.nmats = int( (temp[2].rsplit())[0])
+            if temp[1] == 'cpml_alpha':
+                domain.cpml_attenuation = float( (temp[2].rsplit())[0])
+        
+        if line[0] == 'S':
+            temp = line.split(',')
+            if temp[1] == 'dt':
+                try :
+                    seismic.dt = float( (temp[2].rsplit())[0])
+                except:
+                    pass
+            if temp[1] == 'time_steps':
+                seismic.time_steps = float( (temp[2].rsplit())[0])
+            if temp[1] == 'x':
+                seismic.x = float( (temp[2].rsplit())[0])
+            if temp[1] == 'y':
+                seismic.y = float( (temp[2].rsplit())[0])
+            if temp[1] == 'z':
+                seismic.z = float( (temp[2].rsplit())[0])
+            if temp[1] == 'f0':
+                seismic.f0 = float( (temp[2].rsplit())[0])
+            if temp[1] == 'theta':
+                seismic.theta = float( (temp[2].rsplit())[0])
+            if temp[1] == 'phi':
+                seismic.phi = float( (temp[2].rsplit())[0])
+
+        if line[0] == 'E':
+            temp = line.split(',')
+            if temp[1] == 'dt':
+                try:
+                    electromag.dt = float( (temp[2].rsplit())[0])
+                except:
+                    pass
+            if temp[1] == 'time_steps':
+                electromag.time_steps = float( (temp[2].rsplit())[0])
+            if temp[1] == 'x':
+                electromag.x = float( (temp[2].rsplit())[0])
+            if temp[1] == 'y':
+                electromag.y = float( (temp[2].rsplit())[0])
+            if temp[1] == 'z':
+                electromag.z = float( (temp[2].rsplit())[0])
+            if temp[1] == 'f0':
+                electromag.f0 = float( (temp[2].rsplit())[0])
+            if temp[1] == 'theta':
+                electromag.theta = float( (temp[2].rsplit())[0])
+            if temp[1] == 'phi':
+                electromag.phi = float( (temp[2].rsplit())[0])
+
+        if line[0] == 'M':
+            line = line[0:-1]
+            temp = line.split(',')
+            if temp[1] == '0':
+                material.material_list = temp[1:]
+                material.rgb = temp[3]
+            else:
+                material.material_list = np.row_stack( (material.material_list, temp[1:]))
+                material.rgb = np.append( material.rgb, temp[3] )
+
+        if line[0] == 'C':
+            temp = line.split(',')
+            # We need to remove the '\n' at the end. Whether the coefficients are
+            # given results in a different string
+            try:
+                temp[-1] = temp[-1].rsplit()[0]
+            except:
+                temp[-1] = ''
+
+            if temp[1] == '0' or temp[1] == '0.0':
+                seismic.tensor_coefficients = temp[1:]
+            else:
+                seismic.tensor_coefficients = np.row_stack((seismic.tensor_coefficients, temp[1:]))
+
+        # Permittivity coefficients
+        if line[0] == 'P':
+            if 'j' in line:
+                is_complex = True 
+            else: 
+                is_complex = False 
+            
+            temp = line.split(',')
+            try:
+                temp[-1] = temp[-1].rsplit()[0] # An index error will be given if coefficients are provided
+            except:
+                temp[-1] = ''
+
+            if temp[1] == '0' or temp[1] == '0.0':
+                if is_complex:
+                    electromag.tensor_coefficients = str2complex(temp[1:])
+                else:
+                    electromag.tensor_coefficients = temp[1:]
+                
+            else:
+                if is_complex:
+                    electromag.tensor_coefficients = np.row_stack( 
+                        (electromag.tensor_coefficients, str2complex(temp[1:]) )
+                    )
+                else:
+                    electromag.tensor_coefficients = np.row_stack( 
+                        (electromag.tensor_coefficients, temp[1:])
+                    )
+                    
+        # Attenuation coefficients
+        if line[0] == 'A':
+            temp = line.split(',')
+            try: 
+                seismic.attenuation_coefficients = np.row_stack(
+                    (
+                        seismic.attenuation_coefficients,
+                        np.array(temp[2:5], dtype = float)
+                    )
+                )
+            except:
+                seismic.attenuation_coefficients = np.array(
+                    temp[2:5], dtype = float
+                )
+                
+            # electromag.fref = float(temp[8])
+            seismic.fref = float(temp[5])
+
+    f.close()
+    return domain, material, seismic, electromag
+
+
+# -----------------------------------------------------------------------------
+# Make sure variables are in the correct type for Fortran
+def prepme(
+        model_object: Model, 
+        domain: Domain, 
+        complex_tensor: bool = True
+    ) -> tuple:
+    """
+    Prepare modeling objects and domain configurations for simulation, ensuring
+    that all parameters are in the correct format for Fortran processing.
+
+    This function adjusts the type of various parameters in the modeling and domain objects,
+    such as converting time steps to integers or ensuring that tensor coefficients are in the
+    correct numerical format (complex or float). Additionally, it arranges source and domain
+    parameters in the correct order based on the dimensionality of the domain.
+
+    :param model_object: The modeling object containing simulation parameters and configurations.
+    :param domain: The domain object containing spatial configurations and parameters.
+    :param complex_tensor: A flag indicating whether the tensor coefficients should be treated as complex numbers.
+    :type complex_tensor: bool
+    :return: A tuple containing the updated modeling object and domain object.
+    :rtype: tuple
+
+    The function specifically adjusts parameters for compatibility with Fortran-based
+    simulation engines, accounting for differences in array indexing and data types.
+    """
+    # Check if there are no errors and the coefficients have been computed
+    model_object.time_steps = int(model_object.time_steps)
+    model_object.f0 = float(model_object.f0)
+    model_object.theta = float(model_object.theta)
+    model_object.x = float(model_object.x)
+    model_object.z = float(model_object.z)
+    if complex_tensor:
+        model_object.tensor_coefficients = model_object.tensor_coefficients.astype(complex)
+    else:
+        model_object.tensor_coefficients = model_object.tensor_coefficients.astype(float)
+    
+    # Put source and domain parameters in correct order
+    if domain.dim == 2.5:
+        # There are additional values we need to assign
+        domain.ny = int(domain.ny)
+        domain.dy = float(domain.dy)
+        model_object.y = float(model_object.y)
+        model_object.phi = float(model_object.phi)
+
+        model_object.src = np.array(
+            [
+                model_object.x/domain.dx,
+                model_object.y/domain.dy,
+                model_object.z/domain.dz
+            ]
+        ).astype(int)
+    else:
+        model_object.src = np.array(
+            [
+                model_object.x/domain.dx,
+                model_object.z/domain.dz
+            ]
+        ).astype(int)
+
+    return(model_object, domain)
+
+# -----------------------------------------------------------------------------
+# Append coefficients
+def coefs2prj(model_object, material, domain, modeltype):
+    pass
+
+
+# -----------------------------------------------------------------------------
+def airsurf(material: Material, domain: Domain, N: int = 2) -> np.ndarray:
+    """
+    Generates a gradient matrix to simulate the air surface in a domain, based 
+    on material properties.
+
+    This function calculates a gradient matrix representing the transition 
+    between air and non-air materials within a domain. It is particularly 
+    useful for creating a surface with variable density or other properties 
+    near the air-material interface.
+
+    :param material: The material object containing material lists and 
+        properties.
+    :type material: Material
+    :param domain: The domain object containing the geometry of the simulation 
+        area.
+    :type domain: Domain
+    :param N: The number of gradational steps in the air surface simulation, 
+        defaults to 2.
+    :type N: int
+    :return: A gradient matrix representing the air surface within the domain.
+    :rtype: np.ndarray
+
+    The function uses the domain's geometry to determine air interfaces and 
+    applies a gradational approach to simulate the air surface effect. The 
+    gradient matrix can be used to adjust physical properties like density near 
+    the surface.
+    """
+    # This can be generalized a little better, but for now...
+    airnum = material.material_list[material.material_list[:,1] == 'air', 0]
+
+    if airnum:
+        airnum = int(airnum[0])
+        gradmatrix = (domain.geometry != airnum).astype(int)
+        # Take the gradient in both directions
+        gradz = np.diff(gradmatrix, axis = 0)
+        gradx = np.diff(gradmatrix, axis = 1)
+
+        # For grady we will append a column of zeros at the beginning so that the value
+        # 1 is located at the interface but on the non-air side
+        gradzpos = np.row_stack([np.zeros([gradz.shape[1] ]),gradz])
+        # For gradx we will append a row of zeros at the beginning
+        gradxpos = np.column_stack([np.zeros([gradx.shape[0] ]),gradx])
+        # -1 also means that there is an air interface. We will need to append to the
+        # end of the array, then we can just flip the sign
+        gradzneg = (np.row_stack( [gradz, np.zeros([gradz.shape[1]]) ] ) )
+        gradxneg = (np.column_stack( [gradx, np.zeros([gradx.shape[0]]) ] ) )
+
+        # At the surface we want to have 15% of density
+        grad = np.zeros( [gradx.shape[0], gradz.shape[1], N] )
+        grad[:,:,0] = gradzpos + gradxpos - gradzneg - gradxneg
+        grad[ grad[:,:,0]>0, 0] = 0.15
+
+        # We will make the change gradational by splitting the difference each step
+        # For instance, 1 - 0.15 = 0.85, so the next percentage will be
+        # 0.85/2 + 0.15 and so on
+        pct = np.zeros([N])
+        pct[0] = 0.15
+
+        for ind in range(1, N):
+            pct[ind] = pct[ind-1] + (1-pct[ind-1])/2
+            gradzpos = np.row_stack( [np.zeros([gradz.shape[1] ]),gradzpos] )[:-1,:]
+            gradxpos = np.column_stack( [np.zeros( [ gradx.shape[0] ] ),gradxpos ])[:,:-1]
+
+            gradzneg = (np.row_stack( [ gradzneg, np.zeros( [gradz.shape[1] ]) ] )[1:,:])
+            gradxneg = (np.column_stack( [ gradxneg, np.zeros( [gradx.shape[0] ]) ] )[:,1:])
+            grad[:,:, ind] = gradzpos + gradxpos - gradzneg - gradxneg
+            grad[ grad[:,:,ind] > 0, ind] = pct[ind]
+
+        gradcomp = np.zeros( [grad.shape[0], grad.shape[1] ])
+        for ind in range(N-1, -1, -1):
+            gradcomp[ grad[:,:,ind] > 0] = pct[ind]
+
+        gradcomp[ gradcomp == 0] = 1
+    else:
+        gradcomp = np.ones([int(domain.nx), int(domain.nz) ])
+
+    return(gradcomp)
+
+# -----------------------------------------------------------------------------
+def rcxgen(
+        rgb: list, 
+        domain: Domain, material: Material, 
+        filename: str = 'receivers.xyz'
+    ):
+    """
+    Creates a receiver list from a specified RGB value found in the model 
+    image, outputting to a CSV file.
+    
+    This function searches the domain's geometry for occurrences of a given RGB 
+    value (specified as a list of integers representing red, green, and blue 
+    components). It then generates a list of receiver coordinates based on the 
+    locations where the RGB value is found. Currently, the function is set up 
+    for 2D receivers only, with Y-coordinates set to zero.
+
+    :param rgb: A list of three integers representing the RGB value to search 
+        for in the domain's geometry.
+    :type rgb: list
+    :param domain: An object representing the domain, including its geometry 
+        and spatial discretization parameters (dz, dx).
+    :param material: An object containing the material list and associated RGB 
+        values.
+    :param filename: The name of the output CSV file containing the receiver 
+        coordinates, defaults to 'receivers.xyz'.
+    :type filename: str
+    :return: A numpy array of receiver coordinates where each row represents 
+        [Z, Y, X] coordinates.
+    :rtype: np.ndarray
+
+    The function converts the RGB list into a string format, looks up the 
+        corresponding integer value from the
+    material list, finds all occurrences in the domain's geometry, and outputs 
+        the coordinates to a specified CSV file.
+    """
+    rgb = '/'.join(np.array(rgb).astype(str))
+    rgbint = int(material.material_list[material.rgb == rgb,0])
+    z,x = np.where(domain.geometry == rgbint)
+    y = np.zeros([len(x)])
+    xyz = np.stack([z*domain.dz,y,x*domain.dx], axis = 1)
+    df = pd.DataFrame(xyz, columns = ['X', 'Y', 'Z'])
+    df.to_csv(filename, index = False)
+    return(xyz)
+
+
+# ============================== Source Functions =============================
+# -----------------------------------------------------------------------------
+def coherdt(
+        alpha: float, 
+        v: float, 
+        n: int, 
+        dx: float, 
+        loc: str = 'left'
+    ) -> np.ndarray:
+    """
+    Calculates a vector of time delays based on the angle of incidence, 
+    velocity, and spatial discretization.
+
+    This function determines the time delay for coherent addition of traces 
+    based on the propagation angle (alpha), velocity (v), and the 
+    discretization in space (dx) along the domain length.
+
+    :param alpha: The angle of incidence in degrees, counter clockwise from the 
+        x-plane. Range: (-90, 90).
+    :type alpha: float
+    :param v: Velocity in meters/second.
+    :type v: float
+    :param n: The number of spatial points in the domain.
+    :type n: int
+    :param dx: The spatial discretization in meters.
+    :type dx: float
+    :param loc: Specifies the reference point's location for time delay 
+        calculation, defaults to 'left'.
+    :type loc: str
+    :return: A numpy array containing the time delays for each spatial point in 
+        the domain.
+    :rtype: np.ndarray
+
+    The function adjusts angles outside the (-90, 90) range and calculates time 
+    delays accordingly.
+    """
+    # Return a vector of time delays along the length of the domain. The angle
+    # alpha, given in degrees between 90 and -90, is counter clockwise from the
+    # x plane. Velocity and dx are in meters/second and meters, respectively.
+    if alpha < 0:
+        self.dz = None
+        self.cpml = None
+        self.write = None
+        self.imfile = None
+        self.exit_status = 1
+
+        # Flag to specify whether the all inputs are fulfilled
+        self.seismic_model = False
+        self.electromag_model = False
+
+    def para_check(self):
+        self.exit_s
+    if alpha > 90.0 or alpha < -90:
+        alpha = 180 - np.sign(alpha) * alpha
+    else:
+        print('Alpha must be on the interval (-90,90)')
+        quit()
+
+    x = np.arange(0, n*dx, dx)
+    dt = x * np.sin( np.deg2rad(alpha) ) / v
+    return(dt)
+
+# -----------------------------------------------------------------------------
+def coherstf(
+        timediff: np.ndarray, 
+        source_function: np.ndarray, 
+        dt: float, 
+        m: int, n: int, cpml: int, 
+        bottom: bool = False
+    ) -> None:
+    """
+    Applies time shifts to a source time function along the domain and saves it 
+    as an m-by-n-by-p matrix.
+
+    :param timediff: A numpy array containing time differences for time 
+        shifting the source function.
+    :type timediff: np.ndarray
+    :param sf: The source time function as a numpy array.
+    :type sf: np.ndarray
+    :param dt: The time interval between successive samples in the source 
+        function.
+    :type dt: float
+    :param m: Number of indices in the y-direction (height of the domain).
+    :type m: int
+    :param n: Number of indices in the x-direction (width of the domain).
+    :type n: int
+    :param cpml: The size of the Convolutional Perfectly Matched Layer (CPML) 
+        padding.
+    :type cpml: int
+    :param bottom: Specifies whether to place the source at the bottom of the 
+        domain. Defaults to False.
+    :type bottom: bool
+    :return: None
+
+    This function time shifts the source time function for each node in the 
+    x-direction, considering CPML adjustments.
+    
+    'topleft' origin is (0,0), 
+    'topright' origin is (x_n, 0)
+    'bottomleft' origin is (0, y_n), 
+    'bottomright' origin is (x_n, y_n)
+    """
+    p = len(source_function)
+    sfmat = np.zeros([m, n, p], order='F') # m indices are in the y-direction
+    cpmlmat = np.zeros([2*cpml + m, 2*cpml + n, p])
+    sfarray = np.zeros([m, p])  # p indices are in the t-direction
+    ndiff = int(np.round(timediff/dt))
+    for ind in range(0, m):
+        sfarray[ind,:] = np.roll(source_function, timediff[i])
+        sfarray[ind,0:timediff[i]] == 0
+    if bottom == True:
+        sfmat[m,:,:] = sfarray[:]
+    else:
+        sfmat[0,:,:] = sfarray[:]
+    cpmlmat[cpml:,cpml:,:] = sfmat[:,:,:]
+    cpmlmat.T.tofile('sourcefunctionmatrix.dat')
+
+# -----------------------------------------------------------------------------
+def stfvec2mat(
+        source_function: np.ndarray, 
+        xind: int, zind: int, 
+        m: int, n: int, 
+        cpml: int, 
+        yind: int = None
+    ) -> None:
+    """
+    Converts a source time function vector to a matrix for 2D or 3D 
+    simulations.
+
+    :param sf: The source time function vector.
+    :type sf: np.ndarray
+    :param xind: The index in the x-direction where the source is located.
+    :type xind: int
+    :param zind: The index in the z-direction where the source is located.
+    :type zind: int
+    :param m: The number of indices in the y-direction (height of the domain).
+    :type m: int
+    :param n: The number of indices in the x-direction (width of the domain).
+    :type n: int
+    :param cpml: The size of the Convolutional Perfectly Matched Layer (CPML) 
+        padding.
+    :type cpml: int
+    :param yind: The index in the y-direction where the source is located, for 
+        3D simulations. Defaults to None for 2D simulations.
+    :type yind: Optional[int]
+    :return: None
+
+    This function arranges the source time function in the spatial domain and applies CPML padding.
+    """
+    # If 2D, y = None. So far we only have 2D. 3D will be implemented later
+    p = len(st)
+    sfmat = np.zeros([m,n,p], order = 'F')
+    sfmat[zind, xind,:] = source_function[:]
+    cpmlmat = np.zeros([2*cpml + m, 2*cpml + n, p], order = 'F')
+    cpmlmat[cpml:,cpml:,:] = sfmat[:,:,:]
+    cpmlmat.T.tofile('sourcefunctionmatrix.dat')
+
+# -----------------------------------------------------------------------------
+def movingsrc(sf: np.ndarray, txlocs: np.ndarray) -> None:
+    """
+    Simulates a moving source given a stationary source time function.
+
+    :param sf: The stationary source time function as a numpy array.
+    :type sf: np.ndarray
+    :param txlocs: A numpy array containing the transmission locations over time.
+    :type txlocs: np.ndarray
+    :return: None
+    
+    This function is intended as a placeholder to simulate a moving source by manipulating the stationary source time function according to the provided transmission locations.
+    """
+    pass  # Implementation yet to be done or specified.
+
+# ----------------------------- Plotting Functions ----------------------------
+def indvar(
+        model_object: Model, domain: Domain
+    ) -> tuple[np.ndarray, Optional[np.ndarray], np.ndarray, np.ndarray]:
+    """
+    Generates spatial and temporal grids based on domain and model object 
+    attributes.
+
+    :param model_object: An object containing model-specific parameters, including 
+        time steps and time interval (dt).
+    :param domain: An object containing domain-specific parameters such as 
+        spatial dimensions (nx, ny, nz) and discretizations (dx, dy, dz).
+    :return: A tuple of numpy arrays representing the grids in x, y (None if ny 
+        is not set), z, and t dimensions.
+    :rtype: tuple
+
+    The function calculates the spatial grid points in the x, z, and optionally 
+    y dimensions, and temporal grid points based on the provided domain and 
+    model parameters. The y-dimension grid is generated only if the domain 
+    parameters include 'ny'.
+    """
+    nx = int(domain.nx[0])
+    nz = int(domain.nz[0])
+    dx = float(domain.dx[0])
+    dz = float(domain.dz[0])
+    dt = float(model_object.dt[0])
+    nt = int(model_object.time_steps[0])
+
+    x = np.linspace(0, dx * (nx - 1), nx)
+    z = np.linspace(0, dz * (nz - 1), nz)
+    t = np.linspace(0, dt * (nt - 1), nt)
+    try:
+        y = np.linspace(
+            0, float(domain.dy[0]) * (int(domain.ny) - 1), int(domain.ny)
+        )
+    except:
+        y = None
+
+    return(x,y,z,t)
+
+# ---------------------------- Processing functions ---------------------------
+def agc(ts, k, agctype):
+    """
+    Applies auto-gain control (AGC) normalization to a time series using a 
+    specified window length and type.
+
+    :param ts: The input time series as a numpy array.
+    :type ts: np.ndarray
+    :param k: The length of the window used for normalization.
+    :type k: int
+    :param agctype: The type of normalization to apply, choices are "std", 
+        "mean", or "median".
+    :type agctype: str
+    :return: The time series after applying AGC normalization.
+    :rtype: np.ndarray
+
+    This function normalizes the input time series using a running window 
+    approach, with the normalization type determined by `agctype`. It supports 
+    standard deviation ("std"), mean ("mean"), or median ("median") based 
+    normalization. The function modifies the series to have a uniform amplitude 
+    characteristic over time.
+    """
+    n = len(ts)
+
+    k2 = int(k/2) # This will floor the number if k is even; (k-1)/2
+    if np.mod(k, 2) == 0: # even numbers need will not have a centered window
+        k = int( k + 1)
+
+    stat = np.ones([n])
+    # Normalize
+    if agctype == "std":
+        for i in range(0, k2):
+            stat[i] = np.std( abs( ts[0:(i+k2)] ) )
+            stat[ (n-k2+i) ] = np.std( abs(ts[ (n-2*k2+i):n] ) )
+        for i in range(k2,n-k2):
+            stat[i] = np.std( abs( ts[ (i-k2):(i+k2) ] ) )
+    elif agctype == "mean":
+        for i in range(0, k2):
+            stat[i] = np.mean( abs( ts[0:(i+k2)] ) )
+            stat[ (n-k2+i) ] = np.mean( abs(ts[ (n-2*k2+i):n] ) )
+        for i in range(k2,n-k2):
+            stat[i] = np.mean( abs( ts[ (i-k2):(i+k2) ] ) )
+    else:
+        for i in range(0, k2):
+            stat[i] = np.std( ts[i:(i+k2)] )
+            stat[ (n-k2+i) ] = np.std( ts[ (n-2*k2+i):n] )
+        for i in range(k2,n-k2):
+            stat[i] = np.std( ts[ (i-k2):(i+k2) ] )
+
+    stat[stat == 0] = 1
+    ts = ts/stat
+    return ts
```

## seidart/routines/materials.py

 * *Ordering differences only*

```diff
@@ -1,913 +1,913 @@
-import numpy as np
-import pandas as pd
-from typing import Union, Tuple
-from scipy.interpolate import interp1d
-
-__all__ = [
-    'pressure_array',
-    'anisotropic_boolean',
-    'get_seismic',
-    'get_perm',
-    'rho_water_correction',
-    'isotropic_stiffness_tensor',
-    'isotropic_permittivity_tensor',
-    'porewater_correction',
-    'ice_stiffness',
-    'ice_permittivity',
-    'snow_permittivity',
-    'snow_conductivity',
-    'read_ang',
-    'rotator_zxz',
-    'bond',
-    'fujita_complex_permittivity'
-]
-
-# Global constants
-eps0 = 8.85418782e-12 # used for em only
-mu0 = 4.0*np.pi*1.0e-7 # used for em only
-
-"""
-Seismic values can be found in: 
-      Acoustics of Porous Media (1992), Bourbie, Coussy, and Zinszner
-      
-Permittivity values can be found in:
-        Electrical Properties of Rocks and Minerals
-    The following values are provided by:
-        Seismic Velocities - https://pangea.stanford.edu/courses/gp262/Notes/8.SeismicVelocity.pdf
-        Permeabilitues - http://www.geo.umass.edu/faculty/wclement/dielec.html
-        Conductivities - Duba et al. (1977), Duba et al. (1978), Watanabe (1970), 
-                    Mohammadi and Mohammadi (2016),
-                    https://www.nrcs.usda.gov/INTERNET/FSE_DOCUMENTS/NRCS142P2_053280.PDF,
-                    https://en.wikipedia.org/wiki/Electrical_resistivity_and_conductivity
-    Values are: 
-        Vp_min, Vp_max, Vs_min, Vs_max, Rel_Perm_min, Rel_Perm_max, Conductivity_min, Conductivity_max
-    
-    Permittivity is given as the relative permittivity and for most cases we 
-    will assume that relative permeability is unity; however, if we include
-    materials that are high in magnetite, hematite, etc. then we will need to
-    accomodate for better permeability estimates.
-    
-    We are given a range of velocities of different materials found empirically. 
-    For isotropic materials we can determine the Lame constants from the equations:
-        Vp = sqrt( lambda + 2 mu  / rho ),
-        Vs = sqrt( mu / rho ),
-        c11 = c22 = c33 = lambda + 2 mu,
-        c12 = c13 = c23 = lambda,
-        c44 = c55 = c66 = mu
-        
-    Created by Steven Bernsen
-"""
-
-# =============================================================================
-#                       Define material dictionaries
-# =============================================================================
-
-isotropic_materials = {
-    "air":np.array([343, 343, 0.0, 0.0, 1.0, 1.0, 1.0e-16, 1.0e-15]),
-    "ice1h":np.array([3400, 3800, 1700, 1900, 3.1, 3.22, 1.0e-7, 1.0e-6]),
-    "snow":np.array([100, 2000, 50, 500, 1.0, 70, 1.0e-9, 1.0e-4]),
-    "soil":np.array([300, 700, 100, 300, 3.9, 29.4, 1.0e-2, 1.0e-1]), # Permittivity estimates are best constructed with the snow_permittivity() function
-    "water":np.array([1450, 1500, 0, 0, 80.36, 80.36, 5.5e-6, 5.0e-2]), # This can change drastically depending on the ions in solution
-    "oil":np.array([1200, 1250, 0, 0, 2.07, 2.14, 5.7e-8, 2.1e-7]),
-    "dry_sand":np.array([400, 1200, 100, 500, 2.9, 4.7, 1.0e-3, 1.0e-3]), # perm porositiy dependence
-    "wet_sand":np.array([1500, 2000, 400, 600, 2.9, 105, 2.5e-4, 1.2e-3]), 
-    "granite":np.array([4500, 6000, 2500, 3300, 4.8, 18.9, 4.0e-5, 2.5e-4]),
-    "gneiss":np.array([4400, 5200, 2700, 3200, 8.5, 8.5, 2.5e-4, 2.5e-3]),
-    "basalt":np.array([5000, 6000, 2800, 3400, 12, 12, 1.0e-6, 1.0e-4]),
-    "limestone":np.array([3500, 6000, 2000, 3300, 7.8, 8.5, 2.5e-4, 1.0e-3]),
-    "anhydrite":np.array([4000, 5500, 2200, 3100, 5, 11.5, 1.0e-6, 1.0e-5]), # permittivity value from Gypsum
-    "coal":np.array([2200, 2700, 1000, 1400, 5.6, 6.3, 1.0e-8, 1.0e-3]), # This has a water dependency
-    "salt":np.array([4500, 5500, 2500, 3100, 5.6, 5.6, 1.0e-7, 1.0e2]) # This is dependent on ions and water content
-}
-# =============================================================================
-#                                  Functions
-# =============================================================================
-
-# -----------------------------------------------------------------------------
-def pressure_array(
-        im: Union[list, np.ndarray], 
-        temp: Union[list, np.ndarray], 
-        rho: Union[list, np.ndarray], 
-        dz: Union[list, np.ndarray], 
-        porosity: Union[list, np.ndarray] = [0], 
-        lwc: Union[list, np.ndarray] = [0]
-    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
-    """
-    Computes the hydrostatic pressure, temperature, and density at each grid 
-    point based on material ID, accounting for porosity and water content.
-
-    :param im: An m-by-n array of integer values representing material IDs.
-    :param temp: Temperatures at each grid point.
-    :param rho: Densities at each grid point.
-    :param dz: Vertical spacing between grid points.
-    :param porosity: Porosities at each grid point, default is a list of zeros.
-    :param lwc: Liquid water contents at each grid point, default is a list 
-        of zeros.
-    :type im: Union[list, np.ndarray]
-    :type temp: Union[list, np.ndarray]
-    :type rho: Union[list, np.ndarray]
-    :type dz: Union[list, np.ndarray]
-    :type porosity: Union[list, np.ndarray], optional
-    :type lwc: Union[list, np.ndarray], optional
-    :return: A tuple containing arrays for temperature, density, and hydrostatic 
-        pressure at each grid point.
-    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray]
-    """
-
-
-    # First match the size of 
-    k = np.unique(im)
-
-    m, n = im.shape
-    # allocate the pressure, temperature and density
-    pressure = np.zeros([m, n])
-    density = np.zeros([m, n])
-
-    if not temp.shape == im.shape:
-        temperature = np.zeros([m, n])
-    for j in range(0,n):
-        for i in range(0, m):
-            temperature[i,j] = temp[ im[i,j] ]
-            density[i,j],_,_ = porewater_correction(temperature[i,j], rho[ im[i,j] ], 
-                porosity[ im[i,j]], lwc[ im[i,j]])
-            pressure[i,j] = np.mean(density[0:i,j]) * 9.80665 * i * dz
-    
-    return(temperature, density, pressure)
-
-# -----------------------------------------------------------------------------
-def anisotropic_boolean(
-        im: Union[np.ndarray, list], 
-        matbool: Union[np.ndarray, list], 
-        angvect: Union[np.ndarray, list]
-    ) -> Tuple[np.ndarray, np.ndarray]:
-    """
-    Determines if materials identified in an image are anisotropic and provides
-    corresponding angular file names if applicable.
-
-    :param im: An array representing material IDs in an image.
-    :param matbool: Array indicating whether a material is anisotropic.
-    :param angvect: Array of angular file names for anisotropic materials.
-    :type im: Union[np.ndarray, list]
-    :type matbool: Union[np.ndarray, list]
-    :type angvect: Union[np.ndarray, list]
-    :return: A tuple of two arrays; the first indicates anisotropy (boolean), 
-        the second contains angular file names.
-    :rtype: Tuple[np.ndarray, np.ndarray]
-    """
-
-    m,n = im.shape
-    anisotropic = np.zeros([m,n], dtype = bool)
-    afile = np.zeros([m,n], dtype = str)
-
-    for i in range(0, m):
-        for j in range(0,n):
-
-            # The booolean in anisotropic could be true, True, TRUE     
-            anisotropic[i,j] = (
-                matbool[ im[i,j] ] == 'true' or \
-                matbool[ im[i,j] ] == 'TRUE' or \
-                matbool[ im[i,j] ] == 'True'
-            )
-            
-            if anisotropic[i,j]:
-                afile[i,j] = angvect[ im[i,j] ]
-
-    return(anisotropic, afile)
-
-# -----------------------------------------------------------------------------
-def get_seismic(
-        material_name: Union[list, np.ndarray] = [None], 
-        temp: Union[list, np.ndarray] = [None], 
-        rho: Union[list, np.ndarray] = [None], 
-        porosity: Union[list, np.ndarray] = [0], 
-        lwc: Union[list, np.ndarray] = [0], 
-        anisotropic: Union[list, np.ndarray] = [False], 
-        angfile: Union[list, np.ndarray] = [None]
-    ) -> np.ndarray:
-    """
-    Calculates seismic stiffness coefficients based on material properties,
-    accounting for anisotropic conditions where applicable.
-
-    :param material_name: Names of materials.
-    :param temp: Temperatures associated with each material.
-    :param rho: Densities of materials.
-    :param porosity: Porosities of materials.
-    :param lwc: Liquid water contents of materials.
-    :param anisotropic: Indicates if materials are anisotropic.
-    :param angfile: Angular files associated with anisotropic materials.
-    :type material_name: Union[list, np.ndarray], optional
-    :type temp: Union[list, np.ndarray], optional
-    :type rho: Union[list, np.ndarray], optional
-    :type porosity: Union[list, np.ndarray], optional
-    :type lwc: Union[list, np.ndarray], optional
-    :type anisotropic: Union[list, np.ndarray], optional
-    :type angfile: Union[list, np.ndarray], optional
-    :return: A tensor containing seismic stiffness coefficients.
-    :rtype: np.ndarray
-    """
-
-    m = len(temp)
-    tensor = np.zeros([m, 23])
-
-    # Adjust the stiffness tensor according to the pressure and temperature 
-    # conditions for ice
-    for ind in range(0, m):
-        density,_,_ = porewater_correction(
-            temp[ind], 
-            rho[ind], 
-            porosity[ind], 
-            lwc[ind] 
-        )
-
-        if anisotropic[ind] and material_name[ind] == 'ice1h':
-            euler = read_ang(angfile[ind])
-            p = len(euler[:,0])
-
-            cvoigt = np.zeros([6,6])
-            creuss = np.zeros([6,6])
-            C = np.zeros([6,6])
-            
-            # Assume a constant pressure of 0.1 MPa (Why? because this is 
-            # approximately 1 ATM)
-            C = ice_stiffness(temp[ind], 0.1)
-            S = np.linalg.inv(C)
-
-            for k in range(0, p):
-                R = rotator_zxz(euler[k,:] )
-                M = bond(R)
-                N = np.linalg.inv(M)
-                cvoigt = cvoigt + ( np.matmul( M, np.matmul(C, M.T) ) )
-                creuss = creuss + ( np.matmul( N, np.matmul(S, N.T) ) )
-
-            cvoigt = cvoigt/p
-            creuss = creuss/p 
-            creuss = np.linalg.inv(creuss) 
-
-            # Calculate the hill average 
-            C = (cvoigt + creuss)/2
-        elif not anisotropic[ind] and material_name[ind] == 'ice1h':
-            C = ice_stiffness(temp[ind], 0.1)
-        else:
-            material_limits = isotropic_materials[ material_name[ind] ]
-            C = isotropic_stiffness_tensor(0.1, density, material_limits )
-
-        tensor[ind, :] = (
-            ind, 
-            C[0,0], C[0,1], C[0,2], C[0,3], C[0,4], C[0,5],
-            C[1,1], C[1,2], C[1,3], C[1,4], C[1,5],
-            C[2,2], C[2,3], C[2,4], C[2,5],
-            C[3,3], C[3,4], C[3,5],
-            C[4,4], C[4,5],
-            C[5,5], 
-            density
-        )
-
-    return(tensor)
-
-# -----------------------------------------------------------------------------
-def get_perm(
-        material,
-        modelclass
-    ) -> np.ndarray:
-    """
-    Computes the permittivity and conductivity tensors for materials based on attributes
-    contained within material and model class instances.
-
-    :param material: An instance of a class containing attributes for materials, including
-                     temperature, density, porosity, water content, and anisotropic properties.
-    :type material: Material
-    :param modelclass: An instance of a class containing modeling parameters, such as the
-                       frequency of interest for electromagnetic modeling.
-    :type modelclass: Model
-    :return: A tensor array containing permittivity and conductivity values for each material.
-    :rtype: np.ndarray
-    """
-
-    #!!!!! Use the material class as an input since it will have all of the values that you need instead of inputting all of them 
-    material.temp
-    
-    m = len(material.temp)
-    # We will always compute the complex tensor. 
-    tensor = np.zeros([m, 13], dtype = complex)
-    
-    # Adjust the stiffness tensor according to the pressure and temperature 
-    # conditions for ice
-    for ind in range(0, m):
-        
-        if material.material[ind] == 'ice1h':
-            permittivity = ice_permittivity(
-                material.temp[ind],
-                material.rho[ind],
-                center_frequency = modelclass.f0
-            )
-            conductivity = snow_conductivity(
-                permittivity = permittivity, frequency = modelclass.f0
-            )
-            
-        elif material.material[ind] == 'snow':
-            permittivity = snow_permittivity(
-                temperature = material.temp[ind],
-                lwc = material.lwc[ind], 
-                porosity = material.porosity[ind]
-            )
-            conductivity = snow_conductivity(
-                permittivity = permittivity, frequency = modelclass.f0
-            )
-        else:
-            permittivity = np.round(
-                isotropic_permittivity_tensor(
-                    material.temp[ind], 
-                    material.porosity[ind], 
-                    material.lwc[ind], 
-                    material.material[ind])[0], 
-                    3
-                )
-            conductivity = isotropic_permittivity_tensor(
-                material.temp[ind], 
-                material.porosity[ind], 
-                material.lwc[ind], material.material[ind]
-            )[1]
-        
-        if material.is_anisotropic[ind]:
-            euler = read_ang(angfile[ind])
-            p = len(euler[:,0])
-            
-            pvoigt = np.zeros([3,3])
-            preuss = np.zeros([3,3])
-            permittivity = np.zeros([3,3])
-            
-            # Assume a constant pressure of 0.1 MPa
-            
-            S = np.linalg.inv(permittivity)
-            
-            for k in range(0, p):
-                R = rotator_zxz(euler[k,:] )
-            
-                Ri = np.linalg.inv(R)
-                #!!!!! We need to do the same for conductivity.  
-                pvoigt = pvoigt + ( np.matmul( R, np.matmul(permittivity, R.T) ) )
-                preuss = preuss + ( np.matmul( Ri, np.matmul(S, Ri.T) ) )
-            
-            pvoigt = pvoigt/p
-            preuss = preuss/p 
-            preuss = np.linalg.inv(preuss) 
-            
-            # Calculate the hill average 
-            permittivity = (pvoigt + preuss)/2
-            
-        tensor[ind, :] = np.array(
-            [
-                ind,
-                permittivity[0,0], permittivity[0,1], permittivity[0,2],
-                permittivity[1,1], permittivity[1,2],
-                permittivity[2,2],
-                conductivity[0,0], conductivity[0,1], conductivity[0,2],
-                conductivity[1,1], conductivity[1,2],
-                conductivity[2,2]
-            ] 
-        )
-    
-    return(tensor)
-
-# -----------------------------------------------------------------------------
-def rho_water_correction(temperature: float = 0.0) -> float:
-    """
-    Corrects the density of water based on temperature using the empirical 
-    formula derived from the Kell equation.
-
-    :param temperature: The temperature at which to compute the water density 
-        correction.
-    :type temperature: float
-    :return: The corrected water density.
-    :rtype: float
-    """
-    rho_water = (
-        999.83952 + \
-            16.945176 * temperature - \
-                7.9870401e-3 * temperature**2 - \
-                    46.170461e-6 * temperature**3 + \
-                        105.56302e-9 * temperature**4 - \
-                            280.54253e-12 * temperature**5
-        )/(1 + 16.897850e-3 * temperature)
-    return(rho_water)
-
-# -----------------------------------------------------------------------------
-def isotropic_stiffness_tensor(
-        pressure: float, 
-        density: float, 
-        material_limits: np.ndarray
-        ) -> np.ndarray:
-    """
-    Computes the isotropic stiffness tensor for a given material based on 
-    pressure, density, and predefined material properties.
-
-    :param pressure: The hydrostatic pressure to which the material is 
-        subjected.
-    :param density: The density of the material.
-    :param material_limits: An array containing the material's velocity limits 
-        and other relevant properties.
-    :type pressure: float
-    :type density: float
-    :type material_limits: np.ndarray
-    :return: The isotropic stiffness tensor for the material.
-    :rtype: np.ndarray
-    """
-
-    Vp = material_limits[0:2]
-    Vs = material_limits[2:4]
-    cp = 2*(Vp[1] - Vp[0])/np.pi 
-    cs = 2*(Vs[1] - Vs[0])/np.pi
-    
-    # Correct for pressure
-    pvelocity = cp*np.arctan(pressure ) + Vp[0]
-    svelocity = cs*np.arctan(pressure) + Vs[0]
-    
-    # Compute the lame parameters
-    mu = density*(svelocity**2)
-    lam = density*(pvelocity**2) - 2*mu
-
-    # Assign the matrix
-    C = np.zeros([6,6])
-    C[0:3,0:3] = lam
-    np.fill_diagonal(C, C.diagonal() + mu)
-    C[0,0] = lam + 2*mu
-    C[1,1]= C[1,1] + mu
-    C[2,2] = C[2,2] + mu
-
-    return(C)
-
-# -----------------------------------------------------------------------------
-def isotropic_permittivity_tensor(
-        temperature: float, 
-        porosity: float, 
-        water_content: float, 
-        material_name: str
-    ) -> Tuple[np.ndarray, np.ndarray]:
-    """
-    Computes the isotropic permittivity tensor for a material based on 
-    temperature, porosity, water content, and the material's inherent properties.
-
-    :param temperature: The temperature of the material.
-    :param porosity: The porosity of the material.
-    :param water_content: The water content in the material.
-    :param material_name: The name of the material.
-    :type temperature: float
-    :type porosity: float
-    :type water_content: float
-    :type material_name: str
-    :return: A tuple containing the permittivity and conductivity tensors.
-    :rtype: Tuple[np.ndarray, np.ndarray]
-    """
-
-    material_limits = isotropic_materials[ material_name ]
-    perm0 = material_limits[4]
-    perm1 = material_limits[5]
-
-    cond0 = material_limits[6]
-    cond1 = material_limits[7]
-
-    # Calculate the slope         
-    if material_name == 'ice1h':
-        # We'll assume that the maximum porosity of ice (a.k.a. fresh pow pow)
-        # is 85%. The porosity is given as percent [0,100]
-        perm0 = 3.1884 + 9.1e-4 * temperature
-        perm_coef = (perm1 - perm0)/85
-        cond_coef = (cond1 - cond0)/85
-        permittivity = np.eye(3,3) * (perm_coef*(porosity) + perm0)
-        conductivity = np.eye(3,3) * (cond_coef*(porosity) + cond0)
-            
-    elif material_name == 'soil' or material_name == 'dry sand':
-        # The limit of these two materials is around 55%
-        perm_coef = (perm1 - perm0)/55
-        cond_coef = (cond1 - cond0)/55
-        permittivity = np.eye(3,3) * (perm_coef*(porosity) + perm0)
-        conductivity = np.eye(3,3) * (cond_coef*(porosity) + cond0)
-    
-    elif material_name == 'salt':
-        # Permittivity will change a little bit but let's neglect it for now
-        permittivity = np.eye(3,3) * perm0
-        # Let's use a simple linear trend for a maximum of 20%? water content
-        cond_coef = (cond1 - cond0)/20
-        conductivity = np.eye(3,3) * (cond_coef*(water_content) +  cond0 )
-    
-    elif material_name == 'water' or material_name == 'oil':
-        # Water and oil do not have a porosity.
-        permittivity = np.eye(3,3) * material_limits[4]
-        conductivity = np.eye(3,3) * material_limits[6]
-    else:
-        # For other materials we'll assume the limit is around 3%
-        perm_coef = (perm1 - perm0)/3
-        cond_coef = (cond1 - cond0)/3
-        permittivity = np.eye(3,3) * (perm_coef*(porosity) + perm0)
-        conductivity = np.eye(3,3) * (cond_coef*(porosity) + cond0)
-    
-    return(permittivity, conductivity)
-
-# -----------------------------------------------------------------------------
-def porewater_correction(
-        temperature: float, 
-        density: float, 
-        porosity: float, 
-        liquid_water_content: float
-    ) -> Tuple[float, float, float]:
-    """
-    Applies corrections to the bulk density of a material based on its porosity 
-    and water content, considering temperature adjustments to the densities of 
-    air and water.
-
-    :param temperature: The temperature of the material.
-    :param density: The initial density of the material.
-    :param porosity: The porosity percentage of the material.
-    :param liquid_water_content: The percentage of the pore space filled with 
-        water.
-    :type temperature: float
-    :type density: float
-    :type porosity: float
-    :type liquid_water_content: float
-    :return: A tuple containing the corrected density, the density contribution 
-        from air, and the density contribution from water.
-    :rtype: Tuple[float, float, float]
-    """
-
-    rho_air = 0.02897/(8.2057338e-5 * (273 + temperature) )
-    # Kell Equation; This doesn't incorporate pressure. That would be a nice
-    # addition so that we can mimic super cooled water at depth. 
-    rho_water = rho_water_correction(temperature)
-    
-    # rho_water = -4.6074e-7*temperature**4 + \
-    #   1.0326e-4*temperature**3 - 1.0833e-2*temperature**2 + \
-    #       9.4207e-2*temperature**1 + 999.998
-
-    # There are certain limits such as phase changes so let's put practical 
-    # limits on this
-    rho_water = np.max( (rho_water, 950) ) # We can't quite accomodate supercooled water density
-    rho_water = np.min( (rho_water, rho_water_correction() )) # beyond the freezing and vaporization temperatures, things get wonky
-    
-    # the water content is the percent of pores that contain water
-    grams_air = (1-liquid_water_content/100)*rho_air
-    grams_water = (liquid_water_content/100)*rho_water
-    rho_wc = grams_air + grams_water
-        
-    density = (1-porosity/100)*density + (porosity/100)*rho_wc
-
-    return(density, grams_air, grams_water)
-
-# -----------------------------------------------------------------------------
-def ice_stiffness(
-        temperature: float = None, 
-        pressure: float = 0.0
-    ) -> np.ndarray:
-    """
-    Computes the stiffness tensor for ice under specified temperature and 
-    pressure conditions based on empirical relationships.
-
-    :param temperature: The temperature at which to compute the stiffness tensor.
-    :param pressure: The pressure at which to compute the stiffness tensor.
-    :type temperature: float, optional
-    :type pressure: float
-    :return: The stiffness tensor for ice.
-    :rtype: np.ndarray
-    """
-
-    # Allocate space for the stiffness tensor
-    C = np.zeros([6,6])
-    
-    C[0,0] = 136.813 - 0.28940*temperature - 0.00178270*(temperature**2) \
-      + 4.6648*pressure - 0.13501*(pressure**2) 
-    C[0,1] = 69.4200 - 0.14673*temperature - 0.00090362*(temperature**2) \
-      + 5.0743*pressure + .085917*(pressure**2)
-    C[0,2] = 56.3410 - 0.11916*temperature - 0.00073120*(temperature**2) \
-      + 6.4189*pressure - .52490*(pressure**2)
-    C[2,2] = 147.607 - 0.31129*temperature - 0.0018948*(temperature**2) \
-      + 4.7546*pressure - .11307*(pressure**2)
-    C[3,3] = 29.7260 - 0.062874*temperature - 0.00038956*(temperature**2) \
-      + 0.5662*pressure + .036917*(pressure**2)
-    
-    # Fill in the symmetry
-    C[1,1] = C[0,0]
-    C[1,0] = C[0,1]
-    C[2,0] = C[0,2]
-    C[1,2] = C[0,2]
-    C[2,1] = C[1,2]
-    C[4,4] = C[3,3]
-    C[5,5] = (C[0,0] - C[0,1] )/2
-    
-    stiffness = C*1e8
-
-    return(stiffness)
-
-# -----------------------------------------------------------------------------
-def ice_permittivity(
-        temperature: float, 
-        density: float, 
-        center_frequency: float = None,
-        method: str = "fujita"
-    ) -> np.ndarray:
-    """
-    Computes the complex permittivity of ice given its temperature, density, and
-    the frequency of interest. Supports different methods of calculation.
-
-    :param temperature: Temperature of the ice in degrees Celsius.
-    :param density: Density of the ice in kg/m^3.
-    :param center_frequency: Frequency at which to compute permittivity, in Hz.
-    :param method: The method used for calculating permittivity. Supports 
-        "kovacs" and "fujita".
-    :type temperature: float
-    :type density: float
-    :type center_frequency: float, optional
-    :type method: str
-    :return: The complex permittivity tensor for ice.
-    :rtype: np.ndarray
-    """
-    #Allocate
-    P = np.zeros([3,3], dtype = complex)
-
-    # The following is for 2-10 GHz. The details can be found in 
-    if method == "kovacs":
-        perm = (1 + 0.845 * density)**2
-    else: # Fujita et al. (2000)
-        perm = 3.1884 + 9.1e-4 * temperature
-        dP = 0.0256 + 3.57e-5 * (6.0e-6) * temperature
-        complex_perm = fujita_complex_permittivity(
-            temperature, center_frequency
-        )
-        perm = complex(perm, complex_perm)
-    
-    permittivity = np.eye(3,3) * perm 
-    if method == 'fujita':
-        permittivity[2,2] = perm + dP 
-
-    return(permittivity)
-
-# -----------------------------------------------------------------------------
-def snow_permittivity(
-        density: float = 917., 
-        temperature: float = 0., 
-        lwc: float = 0., 
-        porosity: float = 50.,
-        method: str = "shivola-tiuri"
-    ) -> np.ndarray:
-    """
-    Calculates the complex permittivity of snow based on its density, temperature, liquid water content (LWC), 
-    porosity, and the chosen calculation method.
-
-    :param density: Density of the snow in kg/m^3.
-    :param temperature: Temperature of the snow in degrees Celsius.
-    :param lwc: Liquid water content of the snow in percentage.
-    :param porosity: Porosity of the snow in percentage.
-    :param method: The method to be used for calculating permittivity. Defaults to "shivola-tiuri".
-    :type density: float
-    :type temperature: float
-    :type lwc: float
-    :type porosity: float
-    :type method: str
-    :return: The complex permittivity tensor for snow.
-    :rtype: np.ndarray
-    """
-
-    # Temperature equations
-    # jones (2005), liebe et al. (1991)
-    # Density equations 
-    # shivola and tiuri (1986), wise
-    
-    rho_d,grams_air,grams_water = porewater_correction(
-        temperature, density, porosity, lwc
-    )
-    
-    # LWC is in kg/m3 but we need it in g/cm3
-    lwc = grams_water / 1000
-    rho_d = rho_d / 1000
-    # Put temperature in terms of kelvin
-    T = temperature + 273.15
-
-    if method == "shivola-tiuri":
-        perm = 8.8*lwc + 70.4*(lwc**2) + 1 + 1.17*rho_d + 0.7*(rho_d**2)
-    elif method == "wise":
-        perm = 1 + 1.202*rho_d + 0.983*(rho_d**2) + 21.3*lwc
-    elif method == "jones":
-        perm = 78.51 * (
-            1 - 4.579 * 1e-3 * (T - 298) + \
-                1.19 * 1e-5 * (T - 298)**2 - \
-                    2.8*1e-8 * (T - 298)**3
-        )
-    else: # Liebe et al.
-        perm = 77.66 - 103.3 * (1 - (300/(T)) )
-    
-    # Compute the complex part
-    complex_permittivity = 0.8*lwc + 0.72*(lwc**2)
-    permittivity = np.eye(3,3) * complex(perm, complex_permittivity)
-
-    return(permittivity)
-
-# -----------------------------------------------------------------------------
-def water_permittivity(temperature):
-    pass
-
-# -----------------------------------------------------------------------------
-def snow_conductivity(
-        lwc: float = None, 
-        permittivity: np.ndarray = None, 
-        frequency: float = None
-    ) -> np.ndarray:
-    """
-    Computes the electrical conductivity of snow given its liquid water content 
-    (LWC), permittivity, and frequency of interest.
-
-    :param lwc: Liquid water content of the snow, optionally used if 
-        permittivity is not provided.
-    :param permittivity: The complex permittivity of snow, if available.
-    :param frequency: Frequency at which conductivity is to be calculated, 
-        in Hz.
-    :type lwc: float, optional
-    :type permittivity: np.ndarray, optional
-    :type frequency: float, optional
-    :return: The conductivity tensor for snow.
-    :rtype: np.ndarray
-    """
-
-    if np.iscomplexobj(permittivity):
-        sigma = permittivity.imag * frequency * eps0
-    else:
-        # granlund et al. (2010)
-        _,_,grams_water = porewater_correction(
-            temperature, density, porosity, lwc
-        )
-        
-        # LWC is in kg/m3 but we need it in g/cm3
-        lwc = grams_water / 1000
-        # granlund provides an equation for micro-S/m so we multiply by 1e-4 to
-        # put it in terms of S/m
-        sigma = (20 + 3e3 * lwc) * 1e-4 
-    
-    conductivity = np.eye(3,3) * sigma 
-    return(conductivity)
-
-# -----------------------------------------------------------------------------
-def read_ang(filepath: str, delimiter = " ") -> np.ndarray:
-    """
-    Reads Euler angles from a .ang file, typically associated with 
-    EBSD (Electron Backscatter Diffraction) data.
-
-    :param filepath: The path to the .ang file.
-    :type filepath: str
-    :param delimiter: The delimiter for the input file
-    :type delimiter: str
-    :return: An array of Euler angles extracted from the file.
-    :rtype: np.ndarray
-
-    Note:
-        The .ang file is expected to contain columns for Euler angles in 
-        radians, following Bunge's notation (z-x-z rotation), among other data 
-        related to EBSD measurements.
-    """
-
-    
-    # Load the file in as a data frame
-    # if delimiter = ",":
-    #     euler = pd.read_csv(filepath).to_numpy()
-    # else:
-    #     euler = np.genfromtxt(filepath, delimiter = delimiter)
-    euler = pd.read_table(filepath, delimiter = delimiter).to_numpy()
-    
-    # take only the euler angles...for now
-    if euler.shape[0] > 3 :
-        euler = euler[:,0:3]
-
-    # Unfortunately, the space delimiters are inconsistent :(
-    # We know there are 10 columns and the rows shouldn't contain all NA's
-    m, n = np.shape(euler)
-
-    # reshape to M-by-1 vector
-    euler = euler.reshape(m*n,1)
-
-    # remvoe 'nan'
-    euler = euler[~np.isnan(euler)]
-
-    # reshape back to array
-    euler = euler.reshape(m, int( len(euler)/m ) )
-
-    # save ferris
-    return(euler)
-
-# -----------------------------------------------------------------------------
-def rotator_zxz(eul: np.ndarray) -> np.ndarray:
-    """
-    Generates a rotation matrix from Euler angles using the z-x-z rotation 
-    convention.
-
-    :param eul: An array containing the three Euler angles.
-    :type eul: np.ndarray
-    :return: The 3x3 rotation matrix derived from the Euler angles.
-    :rtype: np.ndarray
-    """
-
-    # From the 3 euler angles for the zxz rotation, compute the rotation matrix
-    R = np.zeros([3,3])
-    D = np.zeros([3,3])
-    C = np.zeros([3,3])
-    B = np.zeros([3,3])
-
-    D[0,:] = [ np.cos( eul[0] ), -np.sin( eul[0] ), 0.0 ]
-    D[1,:] = [ np.sin( eul[0] ), np.cos( eul[0] ), 0.0 ]
-    D[2,:] = [ 0.0, 0.0, 1.0 ]
-
-    C[0,:] = [ 1.0, 0.0, 0.0 ]
-    C[1,:] = [ 0.0, np.cos( eul[1] ), -np.sin( eul[1] ) ]
-    C[2,:] = [ 0.0, np.sin( eul[1] ), np.cos( eul[1] ) ]
-
-    B[0,:] = [ np.cos( eul[2] ), -np.sin( eul[2] ), 0.0 ] 
-    B[1,:] = [ np.sin( eul[2] ), np.cos( eul[2] ), 0.0 ]
-    B[2,:] = [ 0.0, 0.0, 1.0 ]
-
-    R = np.matmul(D, C)
-    R = np.matmul(R, B)
-
-    return(R)
-
-# -----------------------------------------------------------------------------
-def bond(R: np.ndarray) -> np.ndarray:
-    """
-    Calculates the 6x6 Bond transformation matrix from a 3x3 rotation matrix, 
-    useful for transforming stiffness or compliance matrices in crystallography 
-    and materials science.
-
-    :param R: The 3x3 rotation matrix.
-    :type R: np.ndarray
-    :return: The 6x6 Bond transformation matrix.
-    :rtype: np.ndarray
-    """
-
-    # From the euler rotation matrix, compute the 6-by-6 bond matrix
-    M = np.zeros([6,6])
-    M[0,:] = [ 
-        R[0,0]**2, R[0,1]**2, R[0,2]**2, 
-        2*R[0,1]*R[0,2], 2*R[0,2]*R[0,0], 2*R[0,0]*R[0,1] 
-    ]
-    M[1,:] = [ 
-        R[1,0]**2, R[1,1]**2, R[1,2]**2, 
-        2*R[1,1]*R[1,2], 2*R[1,2]*R[1,0], 2*R[1,0] * R[1,1] 
-    ]
-    M[2,:] = [ 
-        R[2,0]**2, R[2,1]**2, R[2,2]**2, 
-        2*R[2,1]*R[2,2], 2*R[2,2]*R[2,0], 2*R[2,0] * R[2,1] 
-    ]
-    M[3,:] = [ 
-        R[1,0]* R[2,0], R[1,1] * R[2,1], 
-        R[1,2] * R[2,2], R[1,1] * R[2,2] + R[1,2]*R[2,1], 
-        R[1,0]*R[2,2] + R[1,2]*R[2,0], R[1,1]*R[2,0] + R[1,0]*R[2,1] 
-    ]
-    M[4,:] = [ 
-        R[2,0]* R[0,0], R[2,1] * R[0,1], 
-        R[2,2] * R[0,2], R[0,1] * R[2,2] + R[0,2]*R[2,1], 
-        R[0,2]*R[2,0] + R[0,0]*R[2,2], R[0,0]*R[2,1] + R[0,1]*R[2,0] 
-    ]
-    M[5,:] = [ 
-        R[0,0]* R[1,0], R[0,1] * R[1,1], 
-        R[0,2] * R[1,2], R[0,1] * R[1,2] + R[0,2]*R[1,1], 
-        R[0,2]*R[1,0] + R[0,0]*R[1,2], R[0,0]*R[1,1] + R[0,1]*R[1,0] 
-    ]
-
-    return(M)
-    
-# -----------------------------------------------------------------------------
-# -----------------------------------------------------------------------------
-# The following is for the complex permittivity calculations that were defined
-# by Fujita et al. 
-T = np.array(
-    [190, 200, 220, 240, 248, 253, 258, 263, 265]
-)
-A = np.array(
-    [0.005, 0.010, 0.031, .268, .635, 1.059, 1.728, 2.769, 3.326]
-)*10.e-4
-B = np.array(
-    [1.537, 1.747, 2.469, 3.495, 4.006, 4.380, 4.696, 5.277, 5.646]
-)*10.e-5
-C = np.array(
-    [1.175, 1.168, 1.129, 1.088, 1.073, 1.062, 1.056, 1.038, 1.024]
-)
-# Interpolation functions for A, B, and C
-A_interp = interp1d(T, A, kind='cubic', fill_value='extrapolate')
-B_interp = interp1d(T, B, kind='cubic', fill_value='extrapolate')
-C_interp = interp1d(T, C, kind='cubic', fill_value='extrapolate')
-
-def fujita_complex_permittivity(temperature: float, frequency: float) -> float:
-    """
-    Calculates the complex permittivity of ice using Fujita's method, based on 
-    the provided temperature and frequency.
-
-    :param temperature: The temperature of ice in degrees Celsius.
-    :param frequency: The frequency at which to calculate permittivity, in Hz.
-    :type temperature: float
-    :type frequency: float
-    :return: The complex permittivity value.
-    :rtype: float
-    """
-    # frequency = 1 is equivalent to 1 GHz or 1e9 Hz. The input is in Hz.
-    temperature = temperature + 273 # Convert to Kelvins
-    frequency = frequency / 1e9
-    A_val = A_interp(temperature)
-    B_val = B_interp(temperature)
-    C_val = C_interp(temperature)
-    epsilon_val = A_val/frequency + B_val*(frequency**C_val)
-    return epsilon_val
+import numpy as np
+import pandas as pd
+from typing import Union, Tuple
+from scipy.interpolate import interp1d
+
+__all__ = [
+    'pressure_array',
+    'anisotropic_boolean',
+    'get_seismic',
+    'get_perm',
+    'rho_water_correction',
+    'isotropic_stiffness_tensor',
+    'isotropic_permittivity_tensor',
+    'porewater_correction',
+    'ice_stiffness',
+    'ice_permittivity',
+    'snow_permittivity',
+    'snow_conductivity',
+    'read_ang',
+    'rotator_zxz',
+    'bond',
+    'fujita_complex_permittivity'
+]
+
+# Global constants
+eps0 = 8.85418782e-12 # used for em only
+mu0 = 4.0*np.pi*1.0e-7 # used for em only
+
+"""
+Seismic values can be found in: 
+      Acoustics of Porous Media (1992), Bourbie, Coussy, and Zinszner
+      
+Permittivity values can be found in:
+        Electrical Properties of Rocks and Minerals
+    The following values are provided by:
+        Seismic Velocities - https://pangea.stanford.edu/courses/gp262/Notes/8.SeismicVelocity.pdf
+        Permeabilitues - http://www.geo.umass.edu/faculty/wclement/dielec.html
+        Conductivities - Duba et al. (1977), Duba et al. (1978), Watanabe (1970), 
+                    Mohammadi and Mohammadi (2016),
+                    https://www.nrcs.usda.gov/INTERNET/FSE_DOCUMENTS/NRCS142P2_053280.PDF,
+                    https://en.wikipedia.org/wiki/Electrical_resistivity_and_conductivity
+    Values are: 
+        Vp_min, Vp_max, Vs_min, Vs_max, Rel_Perm_min, Rel_Perm_max, Conductivity_min, Conductivity_max
+    
+    Permittivity is given as the relative permittivity and for most cases we 
+    will assume that relative permeability is unity; however, if we include
+    materials that are high in magnetite, hematite, etc. then we will need to
+    accomodate for better permeability estimates.
+    
+    We are given a range of velocities of different materials found empirically. 
+    For isotropic materials we can determine the Lame constants from the equations:
+        Vp = sqrt( lambda + 2 mu  / rho ),
+        Vs = sqrt( mu / rho ),
+        c11 = c22 = c33 = lambda + 2 mu,
+        c12 = c13 = c23 = lambda,
+        c44 = c55 = c66 = mu
+        
+    Created by Steven Bernsen
+"""
+
+# =============================================================================
+#                       Define material dictionaries
+# =============================================================================
+
+isotropic_materials = {
+    "air":np.array([343, 343, 0.0, 0.0, 1.0, 1.0, 1.0e-16, 1.0e-15]),
+    "ice1h":np.array([3400, 3800, 1700, 1900, 3.1, 3.22, 1.0e-7, 1.0e-6]),
+    "snow":np.array([100, 2000, 50, 500, 1.0, 70, 1.0e-9, 1.0e-4]),
+    "soil":np.array([300, 700, 100, 300, 3.9, 29.4, 1.0e-2, 1.0e-1]), # Permittivity estimates are best constructed with the snow_permittivity() function
+    "water":np.array([1450, 1500, 0, 0, 80.36, 80.36, 5.5e-6, 5.0e-2]), # This can change drastically depending on the ions in solution
+    "oil":np.array([1200, 1250, 0, 0, 2.07, 2.14, 5.7e-8, 2.1e-7]),
+    "dry_sand":np.array([400, 1200, 100, 500, 2.9, 4.7, 1.0e-3, 1.0e-3]), # perm porositiy dependence
+    "wet_sand":np.array([1500, 2000, 400, 600, 2.9, 105, 2.5e-4, 1.2e-3]), 
+    "granite":np.array([4500, 6000, 2500, 3300, 4.8, 18.9, 4.0e-5, 2.5e-4]),
+    "gneiss":np.array([4400, 5200, 2700, 3200, 8.5, 8.5, 2.5e-4, 2.5e-3]),
+    "basalt":np.array([5000, 6000, 2800, 3400, 12, 12, 1.0e-6, 1.0e-4]),
+    "limestone":np.array([3500, 6000, 2000, 3300, 7.8, 8.5, 2.5e-4, 1.0e-3]),
+    "anhydrite":np.array([4000, 5500, 2200, 3100, 5, 11.5, 1.0e-6, 1.0e-5]), # permittivity value from Gypsum
+    "coal":np.array([2200, 2700, 1000, 1400, 5.6, 6.3, 1.0e-8, 1.0e-3]), # This has a water dependency
+    "salt":np.array([4500, 5500, 2500, 3100, 5.6, 5.6, 1.0e-7, 1.0e2]) # This is dependent on ions and water content
+}
+# =============================================================================
+#                                  Functions
+# =============================================================================
+
+# -----------------------------------------------------------------------------
+def pressure_array(
+        im: Union[list, np.ndarray], 
+        temp: Union[list, np.ndarray], 
+        rho: Union[list, np.ndarray], 
+        dz: Union[list, np.ndarray], 
+        porosity: Union[list, np.ndarray] = [0], 
+        lwc: Union[list, np.ndarray] = [0]
+    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
+    """
+    Computes the hydrostatic pressure, temperature, and density at each grid 
+    point based on material ID, accounting for porosity and water content.
+
+    :param im: An m-by-n array of integer values representing material IDs.
+    :param temp: Temperatures at each grid point.
+    :param rho: Densities at each grid point.
+    :param dz: Vertical spacing between grid points.
+    :param porosity: Porosities at each grid point, default is a list of zeros.
+    :param lwc: Liquid water contents at each grid point, default is a list 
+        of zeros.
+    :type im: Union[list, np.ndarray]
+    :type temp: Union[list, np.ndarray]
+    :type rho: Union[list, np.ndarray]
+    :type dz: Union[list, np.ndarray]
+    :type porosity: Union[list, np.ndarray], optional
+    :type lwc: Union[list, np.ndarray], optional
+    :return: A tuple containing arrays for temperature, density, and hydrostatic 
+        pressure at each grid point.
+    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray]
+    """
+
+
+    # First match the size of 
+    k = np.unique(im)
+
+    m, n = im.shape
+    # allocate the pressure, temperature and density
+    pressure = np.zeros([m, n])
+    density = np.zeros([m, n])
+
+    if not temp.shape == im.shape:
+        temperature = np.zeros([m, n])
+    for j in range(0,n):
+        for i in range(0, m):
+            temperature[i,j] = temp[ im[i,j] ]
+            density[i,j],_,_ = porewater_correction(temperature[i,j], rho[ im[i,j] ], 
+                porosity[ im[i,j]], lwc[ im[i,j]])
+            pressure[i,j] = np.mean(density[0:i,j]) * 9.80665 * i * dz
+    
+    return(temperature, density, pressure)
+
+# -----------------------------------------------------------------------------
+def anisotropic_boolean(
+        im: Union[np.ndarray, list], 
+        matbool: Union[np.ndarray, list], 
+        angvect: Union[np.ndarray, list]
+    ) -> Tuple[np.ndarray, np.ndarray]:
+    """
+    Determines if materials identified in an image are anisotropic and provides
+    corresponding angular file names if applicable.
+
+    :param im: An array representing material IDs in an image.
+    :param matbool: Array indicating whether a material is anisotropic.
+    :param angvect: Array of angular file names for anisotropic materials.
+    :type im: Union[np.ndarray, list]
+    :type matbool: Union[np.ndarray, list]
+    :type angvect: Union[np.ndarray, list]
+    :return: A tuple of two arrays; the first indicates anisotropy (boolean), 
+        the second contains angular file names.
+    :rtype: Tuple[np.ndarray, np.ndarray]
+    """
+
+    m,n = im.shape
+    anisotropic = np.zeros([m,n], dtype = bool)
+    afile = np.zeros([m,n], dtype = str)
+
+    for i in range(0, m):
+        for j in range(0,n):
+
+            # The booolean in anisotropic could be true, True, TRUE     
+            anisotropic[i,j] = (
+                matbool[ im[i,j] ] == 'true' or \
+                matbool[ im[i,j] ] == 'TRUE' or \
+                matbool[ im[i,j] ] == 'True'
+            )
+            
+            if anisotropic[i,j]:
+                afile[i,j] = angvect[ im[i,j] ]
+
+    return(anisotropic, afile)
+
+# -----------------------------------------------------------------------------
+def get_seismic(
+        material_name: Union[list, np.ndarray] = [None], 
+        temp: Union[list, np.ndarray] = [None], 
+        rho: Union[list, np.ndarray] = [None], 
+        porosity: Union[list, np.ndarray] = [0], 
+        lwc: Union[list, np.ndarray] = [0], 
+        anisotropic: Union[list, np.ndarray] = [False], 
+        angfile: Union[list, np.ndarray] = [None]
+    ) -> np.ndarray:
+    """
+    Calculates seismic stiffness coefficients based on material properties,
+    accounting for anisotropic conditions where applicable.
+
+    :param material_name: Names of materials.
+    :param temp: Temperatures associated with each material.
+    :param rho: Densities of materials.
+    :param porosity: Porosities of materials.
+    :param lwc: Liquid water contents of materials.
+    :param anisotropic: Indicates if materials are anisotropic.
+    :param angfile: Angular files associated with anisotropic materials.
+    :type material_name: Union[list, np.ndarray], optional
+    :type temp: Union[list, np.ndarray], optional
+    :type rho: Union[list, np.ndarray], optional
+    :type porosity: Union[list, np.ndarray], optional
+    :type lwc: Union[list, np.ndarray], optional
+    :type anisotropic: Union[list, np.ndarray], optional
+    :type angfile: Union[list, np.ndarray], optional
+    :return: A tensor containing seismic stiffness coefficients.
+    :rtype: np.ndarray
+    """
+
+    m = len(temp)
+    tensor = np.zeros([m, 23])
+
+    # Adjust the stiffness tensor according to the pressure and temperature 
+    # conditions for ice
+    for ind in range(0, m):
+        density,_,_ = porewater_correction(
+            temp[ind], 
+            rho[ind], 
+            porosity[ind], 
+            lwc[ind] 
+        )
+
+        if anisotropic[ind] and material_name[ind] == 'ice1h':
+            euler = read_ang(angfile[ind])
+            p = len(euler[:,0])
+
+            cvoigt = np.zeros([6,6])
+            creuss = np.zeros([6,6])
+            C = np.zeros([6,6])
+            
+            # Assume a constant pressure of 0.1 MPa (Why? because this is 
+            # approximately 1 ATM)
+            C = ice_stiffness(temp[ind], 0.1)
+            S = np.linalg.inv(C)
+
+            for k in range(0, p):
+                R = rotator_zxz(euler[k,:] )
+                M = bond(R)
+                N = np.linalg.inv(M)
+                cvoigt = cvoigt + ( np.matmul( M, np.matmul(C, M.T) ) )
+                creuss = creuss + ( np.matmul( N, np.matmul(S, N.T) ) )
+
+            cvoigt = cvoigt/p
+            creuss = creuss/p 
+            creuss = np.linalg.inv(creuss) 
+
+            # Calculate the hill average 
+            C = (cvoigt + creuss)/2
+        elif not anisotropic[ind] and material_name[ind] == 'ice1h':
+            C = ice_stiffness(temp[ind], 0.1)
+        else:
+            material_limits = isotropic_materials[ material_name[ind] ]
+            C = isotropic_stiffness_tensor(0.1, density, material_limits )
+
+        tensor[ind, :] = (
+            ind, 
+            C[0,0], C[0,1], C[0,2], C[0,3], C[0,4], C[0,5],
+            C[1,1], C[1,2], C[1,3], C[1,4], C[1,5],
+            C[2,2], C[2,3], C[2,4], C[2,5],
+            C[3,3], C[3,4], C[3,5],
+            C[4,4], C[4,5],
+            C[5,5], 
+            density
+        )
+
+    return(tensor)
+
+# -----------------------------------------------------------------------------
+def get_perm(
+        material,
+        modelclass
+    ) -> np.ndarray:
+    """
+    Computes the permittivity and conductivity tensors for materials based on attributes
+    contained within material and model class instances.
+
+    :param material: An instance of a class containing attributes for materials, including
+                     temperature, density, porosity, water content, and anisotropic properties.
+    :type material: Material
+    :param modelclass: An instance of a class containing modeling parameters, such as the
+                       frequency of interest for electromagnetic modeling.
+    :type modelclass: Model
+    :return: A tensor array containing permittivity and conductivity values for each material.
+    :rtype: np.ndarray
+    """
+
+    #!!!!! Use the material class as an input since it will have all of the values that you need instead of inputting all of them 
+    material.temp
+    
+    m = len(material.temp)
+    # We will always compute the complex tensor. 
+    tensor = np.zeros([m, 13], dtype = complex)
+    
+    # Adjust the stiffness tensor according to the pressure and temperature 
+    # conditions for ice
+    for ind in range(0, m):
+        
+        if material.material[ind] == 'ice1h':
+            permittivity = ice_permittivity(
+                material.temp[ind],
+                material.rho[ind],
+                center_frequency = modelclass.f0
+            )
+            conductivity = snow_conductivity(
+                permittivity = permittivity, frequency = modelclass.f0
+            )
+            
+        elif material.material[ind] == 'snow':
+            permittivity = snow_permittivity(
+                temperature = material.temp[ind],
+                lwc = material.lwc[ind], 
+                porosity = material.porosity[ind]
+            )
+            conductivity = snow_conductivity(
+                permittivity = permittivity, frequency = modelclass.f0
+            )
+        else:
+            permittivity = np.round(
+                isotropic_permittivity_tensor(
+                    material.temp[ind], 
+                    material.porosity[ind], 
+                    material.lwc[ind], 
+                    material.material[ind])[0], 
+                    3
+                )
+            conductivity = isotropic_permittivity_tensor(
+                material.temp[ind], 
+                material.porosity[ind], 
+                material.lwc[ind], material.material[ind]
+            )[1]
+        
+        if material.is_anisotropic[ind]:
+            euler = read_ang(angfile[ind])
+            p = len(euler[:,0])
+            
+            pvoigt = np.zeros([3,3])
+            preuss = np.zeros([3,3])
+            permittivity = np.zeros([3,3])
+            
+            # Assume a constant pressure of 0.1 MPa
+            
+            S = np.linalg.inv(permittivity)
+            
+            for k in range(0, p):
+                R = rotator_zxz(euler[k,:] )
+            
+                Ri = np.linalg.inv(R)
+                #!!!!! We need to do the same for conductivity.  
+                pvoigt = pvoigt + ( np.matmul( R, np.matmul(permittivity, R.T) ) )
+                preuss = preuss + ( np.matmul( Ri, np.matmul(S, Ri.T) ) )
+            
+            pvoigt = pvoigt/p
+            preuss = preuss/p 
+            preuss = np.linalg.inv(preuss) 
+            
+            # Calculate the hill average 
+            permittivity = (pvoigt + preuss)/2
+            
+        tensor[ind, :] = np.array(
+            [
+                ind,
+                permittivity[0,0], permittivity[0,1], permittivity[0,2],
+                permittivity[1,1], permittivity[1,2],
+                permittivity[2,2],
+                conductivity[0,0], conductivity[0,1], conductivity[0,2],
+                conductivity[1,1], conductivity[1,2],
+                conductivity[2,2]
+            ] 
+        )
+    
+    return(tensor)
+
+# -----------------------------------------------------------------------------
+def rho_water_correction(temperature: float = 0.0) -> float:
+    """
+    Corrects the density of water based on temperature using the empirical 
+    formula derived from the Kell equation.
+
+    :param temperature: The temperature at which to compute the water density 
+        correction.
+    :type temperature: float
+    :return: The corrected water density.
+    :rtype: float
+    """
+    rho_water = (
+        999.83952 + \
+            16.945176 * temperature - \
+                7.9870401e-3 * temperature**2 - \
+                    46.170461e-6 * temperature**3 + \
+                        105.56302e-9 * temperature**4 - \
+                            280.54253e-12 * temperature**5
+        )/(1 + 16.897850e-3 * temperature)
+    return(rho_water)
+
+# -----------------------------------------------------------------------------
+def isotropic_stiffness_tensor(
+        pressure: float, 
+        density: float, 
+        material_limits: np.ndarray
+        ) -> np.ndarray:
+    """
+    Computes the isotropic stiffness tensor for a given material based on 
+    pressure, density, and predefined material properties.
+
+    :param pressure: The hydrostatic pressure to which the material is 
+        subjected.
+    :param density: The density of the material.
+    :param material_limits: An array containing the material's velocity limits 
+        and other relevant properties.
+    :type pressure: float
+    :type density: float
+    :type material_limits: np.ndarray
+    :return: The isotropic stiffness tensor for the material.
+    :rtype: np.ndarray
+    """
+
+    Vp = material_limits[0:2]
+    Vs = material_limits[2:4]
+    cp = 2*(Vp[1] - Vp[0])/np.pi 
+    cs = 2*(Vs[1] - Vs[0])/np.pi
+    
+    # Correct for pressure
+    pvelocity = cp*np.arctan(pressure ) + Vp[0]
+    svelocity = cs*np.arctan(pressure) + Vs[0]
+    
+    # Compute the lame parameters
+    mu = density*(svelocity**2)
+    lam = density*(pvelocity**2) - 2*mu
+
+    # Assign the matrix
+    C = np.zeros([6,6])
+    C[0:3,0:3] = lam
+    np.fill_diagonal(C, C.diagonal() + mu)
+    C[0,0] = lam + 2*mu
+    C[1,1]= C[1,1] + mu
+    C[2,2] = C[2,2] + mu
+
+    return(C)
+
+# -----------------------------------------------------------------------------
+def isotropic_permittivity_tensor(
+        temperature: float, 
+        porosity: float, 
+        water_content: float, 
+        material_name: str
+    ) -> Tuple[np.ndarray, np.ndarray]:
+    """
+    Computes the isotropic permittivity tensor for a material based on 
+    temperature, porosity, water content, and the material's inherent properties.
+
+    :param temperature: The temperature of the material.
+    :param porosity: The porosity of the material.
+    :param water_content: The water content in the material.
+    :param material_name: The name of the material.
+    :type temperature: float
+    :type porosity: float
+    :type water_content: float
+    :type material_name: str
+    :return: A tuple containing the permittivity and conductivity tensors.
+    :rtype: Tuple[np.ndarray, np.ndarray]
+    """
+
+    material_limits = isotropic_materials[ material_name ]
+    perm0 = material_limits[4]
+    perm1 = material_limits[5]
+
+    cond0 = material_limits[6]
+    cond1 = material_limits[7]
+
+    # Calculate the slope         
+    if material_name == 'ice1h':
+        # We'll assume that the maximum porosity of ice (a.k.a. fresh pow pow)
+        # is 85%. The porosity is given as percent [0,100]
+        perm0 = 3.1884 + 9.1e-4 * temperature
+        perm_coef = (perm1 - perm0)/85
+        cond_coef = (cond1 - cond0)/85
+        permittivity = np.eye(3,3) * (perm_coef*(porosity) + perm0)
+        conductivity = np.eye(3,3) * (cond_coef*(porosity) + cond0)
+            
+    elif material_name == 'soil' or material_name == 'dry sand':
+        # The limit of these two materials is around 55%
+        perm_coef = (perm1 - perm0)/55
+        cond_coef = (cond1 - cond0)/55
+        permittivity = np.eye(3,3) * (perm_coef*(porosity) + perm0)
+        conductivity = np.eye(3,3) * (cond_coef*(porosity) + cond0)
+    
+    elif material_name == 'salt':
+        # Permittivity will change a little bit but let's neglect it for now
+        permittivity = np.eye(3,3) * perm0
+        # Let's use a simple linear trend for a maximum of 20%? water content
+        cond_coef = (cond1 - cond0)/20
+        conductivity = np.eye(3,3) * (cond_coef*(water_content) +  cond0 )
+    
+    elif material_name == 'water' or material_name == 'oil':
+        # Water and oil do not have a porosity.
+        permittivity = np.eye(3,3) * material_limits[4]
+        conductivity = np.eye(3,3) * material_limits[6]
+    else:
+        # For other materials we'll assume the limit is around 3%
+        perm_coef = (perm1 - perm0)/3
+        cond_coef = (cond1 - cond0)/3
+        permittivity = np.eye(3,3) * (perm_coef*(porosity) + perm0)
+        conductivity = np.eye(3,3) * (cond_coef*(porosity) + cond0)
+    
+    return(permittivity, conductivity)
+
+# -----------------------------------------------------------------------------
+def porewater_correction(
+        temperature: float, 
+        density: float, 
+        porosity: float, 
+        liquid_water_content: float
+    ) -> Tuple[float, float, float]:
+    """
+    Applies corrections to the bulk density of a material based on its porosity 
+    and water content, considering temperature adjustments to the densities of 
+    air and water.
+
+    :param temperature: The temperature of the material.
+    :param density: The initial density of the material.
+    :param porosity: The porosity percentage of the material.
+    :param liquid_water_content: The percentage of the pore space filled with 
+        water.
+    :type temperature: float
+    :type density: float
+    :type porosity: float
+    :type liquid_water_content: float
+    :return: A tuple containing the corrected density, the density contribution 
+        from air, and the density contribution from water.
+    :rtype: Tuple[float, float, float]
+    """
+
+    rho_air = 0.02897/(8.2057338e-5 * (273 + temperature) )
+    # Kell Equation; This doesn't incorporate pressure. That would be a nice
+    # addition so that we can mimic super cooled water at depth. 
+    rho_water = rho_water_correction(temperature)
+    
+    # rho_water = -4.6074e-7*temperature**4 + \
+    #   1.0326e-4*temperature**3 - 1.0833e-2*temperature**2 + \
+    #       9.4207e-2*temperature**1 + 999.998
+
+    # There are certain limits such as phase changes so let's put practical 
+    # limits on this
+    rho_water = np.max( (rho_water, 950) ) # We can't quite accomodate supercooled water density
+    rho_water = np.min( (rho_water, rho_water_correction() )) # beyond the freezing and vaporization temperatures, things get wonky
+    
+    # the water content is the percent of pores that contain water
+    grams_air = (1-liquid_water_content/100)*rho_air
+    grams_water = (liquid_water_content/100)*rho_water
+    rho_wc = grams_air + grams_water
+        
+    density = (1-porosity/100)*density + (porosity/100)*rho_wc
+
+    return(density, grams_air, grams_water)
+
+# -----------------------------------------------------------------------------
+def ice_stiffness(
+        temperature: float = None, 
+        pressure: float = 0.0
+    ) -> np.ndarray:
+    """
+    Computes the stiffness tensor for ice under specified temperature and 
+    pressure conditions based on empirical relationships.
+
+    :param temperature: The temperature at which to compute the stiffness tensor.
+    :param pressure: The pressure at which to compute the stiffness tensor.
+    :type temperature: float, optional
+    :type pressure: float
+    :return: The stiffness tensor for ice.
+    :rtype: np.ndarray
+    """
+
+    # Allocate space for the stiffness tensor
+    C = np.zeros([6,6])
+    
+    C[0,0] = 136.813 - 0.28940*temperature - 0.00178270*(temperature**2) \
+      + 4.6648*pressure - 0.13501*(pressure**2) 
+    C[0,1] = 69.4200 - 0.14673*temperature - 0.00090362*(temperature**2) \
+      + 5.0743*pressure + .085917*(pressure**2)
+    C[0,2] = 56.3410 - 0.11916*temperature - 0.00073120*(temperature**2) \
+      + 6.4189*pressure - .52490*(pressure**2)
+    C[2,2] = 147.607 - 0.31129*temperature - 0.0018948*(temperature**2) \
+      + 4.7546*pressure - .11307*(pressure**2)
+    C[3,3] = 29.7260 - 0.062874*temperature - 0.00038956*(temperature**2) \
+      + 0.5662*pressure + .036917*(pressure**2)
+    
+    # Fill in the symmetry
+    C[1,1] = C[0,0]
+    C[1,0] = C[0,1]
+    C[2,0] = C[0,2]
+    C[1,2] = C[0,2]
+    C[2,1] = C[1,2]
+    C[4,4] = C[3,3]
+    C[5,5] = (C[0,0] - C[0,1] )/2
+    
+    stiffness = C*1e8
+
+    return(stiffness)
+
+# -----------------------------------------------------------------------------
+def ice_permittivity(
+        temperature: float, 
+        density: float, 
+        center_frequency: float = None,
+        method: str = "fujita"
+    ) -> np.ndarray:
+    """
+    Computes the complex permittivity of ice given its temperature, density, and
+    the frequency of interest. Supports different methods of calculation.
+
+    :param temperature: Temperature of the ice in degrees Celsius.
+    :param density: Density of the ice in kg/m^3.
+    :param center_frequency: Frequency at which to compute permittivity, in Hz.
+    :param method: The method used for calculating permittivity. Supports 
+        "kovacs" and "fujita".
+    :type temperature: float
+    :type density: float
+    :type center_frequency: float, optional
+    :type method: str
+    :return: The complex permittivity tensor for ice.
+    :rtype: np.ndarray
+    """
+    #Allocate
+    P = np.zeros([3,3], dtype = complex)
+
+    # The following is for 2-10 GHz. The details can be found in 
+    if method == "kovacs":
+        perm = (1 + 0.845 * density)**2
+    else: # Fujita et al. (2000)
+        perm = 3.1884 + 9.1e-4 * temperature
+        dP = 0.0256 + 3.57e-5 * (6.0e-6) * temperature
+        complex_perm = fujita_complex_permittivity(
+            temperature, center_frequency
+        )
+        perm = complex(perm, complex_perm)
+    
+    permittivity = np.eye(3,3) * perm 
+    if method == 'fujita':
+        permittivity[2,2] = perm + dP 
+
+    return(permittivity)
+
+# -----------------------------------------------------------------------------
+def snow_permittivity(
+        density: float = 917., 
+        temperature: float = 0., 
+        lwc: float = 0., 
+        porosity: float = 50.,
+        method: str = "shivola-tiuri"
+    ) -> np.ndarray:
+    """
+    Calculates the complex permittivity of snow based on its density, temperature, liquid water content (LWC), 
+    porosity, and the chosen calculation method.
+
+    :param density: Density of the snow in kg/m^3.
+    :param temperature: Temperature of the snow in degrees Celsius.
+    :param lwc: Liquid water content of the snow in percentage.
+    :param porosity: Porosity of the snow in percentage.
+    :param method: The method to be used for calculating permittivity. Defaults to "shivola-tiuri".
+    :type density: float
+    :type temperature: float
+    :type lwc: float
+    :type porosity: float
+    :type method: str
+    :return: The complex permittivity tensor for snow.
+    :rtype: np.ndarray
+    """
+
+    # Temperature equations
+    # jones (2005), liebe et al. (1991)
+    # Density equations 
+    # shivola and tiuri (1986), wise
+    
+    rho_d,grams_air,grams_water = porewater_correction(
+        temperature, density, porosity, lwc
+    )
+    
+    # LWC is in kg/m3 but we need it in g/cm3
+    lwc = grams_water / 1000
+    rho_d = rho_d / 1000
+    # Put temperature in terms of kelvin
+    T = temperature + 273.15
+
+    if method == "shivola-tiuri":
+        perm = 8.8*lwc + 70.4*(lwc**2) + 1 + 1.17*rho_d + 0.7*(rho_d**2)
+    elif method == "wise":
+        perm = 1 + 1.202*rho_d + 0.983*(rho_d**2) + 21.3*lwc
+    elif method == "jones":
+        perm = 78.51 * (
+            1 - 4.579 * 1e-3 * (T - 298) + \
+                1.19 * 1e-5 * (T - 298)**2 - \
+                    2.8*1e-8 * (T - 298)**3
+        )
+    else: # Liebe et al.
+        perm = 77.66 - 103.3 * (1 - (300/(T)) )
+    
+    # Compute the complex part
+    complex_permittivity = 0.8*lwc + 0.72*(lwc**2)
+    permittivity = np.eye(3,3) * complex(perm, complex_permittivity)
+
+    return(permittivity)
+
+# -----------------------------------------------------------------------------
+def water_permittivity(temperature):
+    pass
+
+# -----------------------------------------------------------------------------
+def snow_conductivity(
+        lwc: float = None, 
+        permittivity: np.ndarray = None, 
+        frequency: float = None
+    ) -> np.ndarray:
+    """
+    Computes the electrical conductivity of snow given its liquid water content 
+    (LWC), permittivity, and frequency of interest.
+
+    :param lwc: Liquid water content of the snow, optionally used if 
+        permittivity is not provided.
+    :param permittivity: The complex permittivity of snow, if available.
+    :param frequency: Frequency at which conductivity is to be calculated, 
+        in Hz.
+    :type lwc: float, optional
+    :type permittivity: np.ndarray, optional
+    :type frequency: float, optional
+    :return: The conductivity tensor for snow.
+    :rtype: np.ndarray
+    """
+
+    if np.iscomplexobj(permittivity):
+        sigma = permittivity.imag * frequency * eps0
+    else:
+        # granlund et al. (2010)
+        _,_,grams_water = porewater_correction(
+            temperature, density, porosity, lwc
+        )
+        
+        # LWC is in kg/m3 but we need it in g/cm3
+        lwc = grams_water / 1000
+        # granlund provides an equation for micro-S/m so we multiply by 1e-4 to
+        # put it in terms of S/m
+        sigma = (20 + 3e3 * lwc) * 1e-4 
+    
+    conductivity = np.eye(3,3) * sigma 
+    return(conductivity)
+
+# -----------------------------------------------------------------------------
+def read_ang(filepath: str, delimiter = " ") -> np.ndarray:
+    """
+    Reads Euler angles from a .ang file, typically associated with 
+    EBSD (Electron Backscatter Diffraction) data.
+
+    :param filepath: The path to the .ang file.
+    :type filepath: str
+    :param delimiter: The delimiter for the input file
+    :type delimiter: str
+    :return: An array of Euler angles extracted from the file.
+    :rtype: np.ndarray
+
+    Note:
+        The .ang file is expected to contain columns for Euler angles in 
+        radians, following Bunge's notation (z-x-z rotation), among other data 
+        related to EBSD measurements.
+    """
+
+    
+    # Load the file in as a data frame
+    # if delimiter = ",":
+    #     euler = pd.read_csv(filepath).to_numpy()
+    # else:
+    #     euler = np.genfromtxt(filepath, delimiter = delimiter)
+    euler = pd.read_table(filepath, delimiter = delimiter).to_numpy()
+    
+    # take only the euler angles...for now
+    if euler.shape[0] > 3 :
+        euler = euler[:,0:3]
+
+    # Unfortunately, the space delimiters are inconsistent :(
+    # We know there are 10 columns and the rows shouldn't contain all NA's
+    m, n = np.shape(euler)
+
+    # reshape to M-by-1 vector
+    euler = euler.reshape(m*n,1)
+
+    # remvoe 'nan'
+    euler = euler[~np.isnan(euler)]
+
+    # reshape back to array
+    euler = euler.reshape(m, int( len(euler)/m ) )
+
+    # save ferris
+    return(euler)
+
+# -----------------------------------------------------------------------------
+def rotator_zxz(eul: np.ndarray) -> np.ndarray:
+    """
+    Generates a rotation matrix from Euler angles using the z-x-z rotation 
+    convention.
+
+    :param eul: An array containing the three Euler angles.
+    :type eul: np.ndarray
+    :return: The 3x3 rotation matrix derived from the Euler angles.
+    :rtype: np.ndarray
+    """
+
+    # From the 3 euler angles for the zxz rotation, compute the rotation matrix
+    R = np.zeros([3,3])
+    D = np.zeros([3,3])
+    C = np.zeros([3,3])
+    B = np.zeros([3,3])
+
+    D[0,:] = [ np.cos( eul[0] ), -np.sin( eul[0] ), 0.0 ]
+    D[1,:] = [ np.sin( eul[0] ), np.cos( eul[0] ), 0.0 ]
+    D[2,:] = [ 0.0, 0.0, 1.0 ]
+
+    C[0,:] = [ 1.0, 0.0, 0.0 ]
+    C[1,:] = [ 0.0, np.cos( eul[1] ), -np.sin( eul[1] ) ]
+    C[2,:] = [ 0.0, np.sin( eul[1] ), np.cos( eul[1] ) ]
+
+    B[0,:] = [ np.cos( eul[2] ), -np.sin( eul[2] ), 0.0 ] 
+    B[1,:] = [ np.sin( eul[2] ), np.cos( eul[2] ), 0.0 ]
+    B[2,:] = [ 0.0, 0.0, 1.0 ]
+
+    R = np.matmul(D, C)
+    R = np.matmul(R, B)
+
+    return(R)
+
+# -----------------------------------------------------------------------------
+def bond(R: np.ndarray) -> np.ndarray:
+    """
+    Calculates the 6x6 Bond transformation matrix from a 3x3 rotation matrix, 
+    useful for transforming stiffness or compliance matrices in crystallography 
+    and materials science.
+
+    :param R: The 3x3 rotation matrix.
+    :type R: np.ndarray
+    :return: The 6x6 Bond transformation matrix.
+    :rtype: np.ndarray
+    """
+
+    # From the euler rotation matrix, compute the 6-by-6 bond matrix
+    M = np.zeros([6,6])
+    M[0,:] = [ 
+        R[0,0]**2, R[0,1]**2, R[0,2]**2, 
+        2*R[0,1]*R[0,2], 2*R[0,2]*R[0,0], 2*R[0,0]*R[0,1] 
+    ]
+    M[1,:] = [ 
+        R[1,0]**2, R[1,1]**2, R[1,2]**2, 
+        2*R[1,1]*R[1,2], 2*R[1,2]*R[1,0], 2*R[1,0] * R[1,1] 
+    ]
+    M[2,:] = [ 
+        R[2,0]**2, R[2,1]**2, R[2,2]**2, 
+        2*R[2,1]*R[2,2], 2*R[2,2]*R[2,0], 2*R[2,0] * R[2,1] 
+    ]
+    M[3,:] = [ 
+        R[1,0]* R[2,0], R[1,1] * R[2,1], 
+        R[1,2] * R[2,2], R[1,1] * R[2,2] + R[1,2]*R[2,1], 
+        R[1,0]*R[2,2] + R[1,2]*R[2,0], R[1,1]*R[2,0] + R[1,0]*R[2,1] 
+    ]
+    M[4,:] = [ 
+        R[2,0]* R[0,0], R[2,1] * R[0,1], 
+        R[2,2] * R[0,2], R[0,1] * R[2,2] + R[0,2]*R[2,1], 
+        R[0,2]*R[2,0] + R[0,0]*R[2,2], R[0,0]*R[2,1] + R[0,1]*R[2,0] 
+    ]
+    M[5,:] = [ 
+        R[0,0]* R[1,0], R[0,1] * R[1,1], 
+        R[0,2] * R[1,2], R[0,1] * R[1,2] + R[0,2]*R[1,1], 
+        R[0,2]*R[1,0] + R[0,0]*R[1,2], R[0,0]*R[1,1] + R[0,1]*R[1,0] 
+    ]
+
+    return(M)
+    
+# -----------------------------------------------------------------------------
+# -----------------------------------------------------------------------------
+# The following is for the complex permittivity calculations that were defined
+# by Fujita et al. 
+T = np.array(
+    [190, 200, 220, 240, 248, 253, 258, 263, 265]
+)
+A = np.array(
+    [0.005, 0.010, 0.031, .268, .635, 1.059, 1.728, 2.769, 3.326]
+)*10.e-4
+B = np.array(
+    [1.537, 1.747, 2.469, 3.495, 4.006, 4.380, 4.696, 5.277, 5.646]
+)*10.e-5
+C = np.array(
+    [1.175, 1.168, 1.129, 1.088, 1.073, 1.062, 1.056, 1.038, 1.024]
+)
+# Interpolation functions for A, B, and C
+A_interp = interp1d(T, A, kind='cubic', fill_value='extrapolate')
+B_interp = interp1d(T, B, kind='cubic', fill_value='extrapolate')
+C_interp = interp1d(T, C, kind='cubic', fill_value='extrapolate')
+
+def fujita_complex_permittivity(temperature: float, frequency: float) -> float:
+    """
+    Calculates the complex permittivity of ice using Fujita's method, based on 
+    the provided temperature and frequency.
+
+    :param temperature: The temperature of ice in degrees Celsius.
+    :param frequency: The frequency at which to calculate permittivity, in Hz.
+    :type temperature: float
+    :type frequency: float
+    :return: The complex permittivity value.
+    :rtype: float
+    """
+    # frequency = 1 is equivalent to 1 GHz or 1e9 Hz. The input is in Hz.
+    temperature = temperature + 273 # Convert to Kelvins
+    frequency = frequency / 1e9
+    A_val = A_interp(temperature)
+    B_val = B_interp(temperature)
+    C_val = C_interp(temperature)
+    epsilon_val = A_val/frequency + B_val*(frequency**C_val)
+    return epsilon_val
```

## seidart/routines/orientation_tensor.py

 * *Ordering differences only*

```diff
@@ -1,113 +1,113 @@
-#!/usr/bin/env python3
-
-# Wrapper to generate the euler angles for the plunge and trend 
-# then plot the results
-
-import numpy as np
-import argparse
-import matplotlib.pyplot as plt
-import mplstereonet
-
-import seidart.fortran.orientsynth as ot
-
-
-
-# -----------------------------------------------------------------------------
-def	main(
-		output_file: str, 
-		npts: int, 
-		plunge: float, trend: float, 
-		angle_min: float, angle_max: float, 
-		view_bool: bool
-	) -> None:
-	"""
-	This function wraps the FORTRAN module orientsynth which synthesizes a 
-	material fabric then saves outputs to a space delimited text file containing 
-	the euler angles for z-x-z (bunge notation) that is correctly formatted for 
-	input into the seidart program.
-	
-	:param output_file: Specify the output file that will be created to save the
-		euler angles
-	:type output_file: str
-	:param npts: The number of crystal orientations within the substrate
-	:type npts: int 
-	:param plunge: the average plunge of the fabric in degrees
-	:type plunge: float 
-	:param trend: the average trend of the fabric in degrees
-	:type trend: float 
-	:param view_plot: Specify if a stereonet needs to be created.
-	:type view_plot: bool
-	"""
-	euler_list= np.array([])
-	orten = np.array([])
-
-	euler_list, orten = ot.orientsynth(trend, plunge, amin, amax, npts)
-
-	# Save the euler angles
-	np.savetxt(output_file, euler_list, delimiter = " ")
-
-	if view_plot:
-		fig = plt.figure( figsize = (7, 5) )
-		ax = fig.add_subplot(111,projection='stereonet')
-		ax.pole(euler_list[:,0]*180/np.pi, euler_list[:,1]*180/np.pi, 'g^', markersize=6)
-		ax.grid()
-
-		# plt.rc('text', usetex=True)
-		plt.figtext(0.01, 0.95, 'trend = ' + str(trend)   )
-		plt.figtext(0.01, 0.9, 'plunge = ' + str(plunge) )
-		plt.figtext(0.01, 0.85, 'angle min/max = ' + str(amin) + '/' + str(amax) )
-		plt.figtext(0.01, 0.8, 'N = ' + str(npts) )
-
-		# plt.figtext(0.01, 0.7, r'\underline{Tensor Coefficients}')
-		plt.figtext(0.01, 0.7, 'Tensor Coefficients')
-		plt.figtext(0.01, 0.65, '$a_{11} = $' + str( round( orten[0,0], 5) ) )
-		plt.figtext(0.01, 0.6, '$a_{22} = $' + str( round( orten[1,1], 5) ) )
-		plt.figtext(0.01, 0.55, '$a_{33} = $' + str( round( orten[2,2], 5) ) )
-
-		plt.figtext(0.01, 0.5, '$a_{12} = $' +str( round( orten[0,1],5 ) ) )
-		plt.figtext(0.01, 0.45, '$a_{13} = $' +str( round( orten[0,2], 5) ) )
-		plt.figtext(0.01, 0.4, '$a_{23} = $' +str( round( orten[1,2], 5) ) )
-
-		plt.show()
-
-
-
-
-# -------------------------- Command Line Arguments ---------------------------
-if __name__ == "__main__":
-	parser = argparse.ArgumentParser(description=""" """ )
-
-	parser.add_argument( '-o', '--outputfile', nargs=1, type=str,
-							help='Specify the file to save the outputs', 
-							default=None)
-
-	parser.add_argument( '-n', '--npts', nargs = 1, type = int, required = False,
-		help = """ Total number of grains in synthetic sample.""", default = [100])
-
-	parser.add_argument( '-P', '--plunge', nargs = 1, type = float, 
-		required = True, help = """ Plunge angle in degrees.""")
-
-	parser.add_argument( '-t', '--trend', nargs =1, type = float, required = True,
-		help = """ Trend angle in degrees.""")
-
-	parser.add_argument( '-a', '--anglemin', nargs = 1, type = float, 
-		required = True, help = """ Minimum angle deviation.""")
-
-	parser.add_argument( '-A', '--anglemax', nargs = 1, type = float, 
-		required = True, help = """Maximum angle deviation. """)
-
-	parser.add_argument('-v', '--view_plot', action='store_true', 
-		help = """Flag if you would like a plot to be shown""")
-	
-	# Get the arguments
-	args = parser.parse_args()
-	output_file = ''.join(args.outputfile)
-	npts = args.npts[0]
-	plunge=args.plunge[0]
-	trend=args.trend[0]
-	angle_min=args.anglemin[0]
-	angle_max=args.anglemax[0]
-	view_plot = args.view_plot
-	
-	main(output_file, npts, plunge, trend, angle_min, angle_max, view_plot)
+#!/usr/bin/env python3
+
+# Wrapper to generate the euler angles for the plunge and trend 
+# then plot the results
+
+import numpy as np
+import argparse
+import matplotlib.pyplot as plt
+import mplstereonet
+
+import seidart.fortran.orientsynth as ot
+
+
+
+# -----------------------------------------------------------------------------
+def	main(
+		output_file: str, 
+		npts: int, 
+		plunge: float, trend: float, 
+		angle_min: float, angle_max: float, 
+		view_bool: bool
+	) -> None:
+	"""
+	This function wraps the FORTRAN module orientsynth which synthesizes a 
+	material fabric then saves outputs to a space delimited text file containing 
+	the euler angles for z-x-z (bunge notation) that is correctly formatted for 
+	input into the seidart program.
+	
+	:param output_file: Specify the output file that will be created to save the
+		euler angles
+	:type output_file: str
+	:param npts: The number of crystal orientations within the substrate
+	:type npts: int 
+	:param plunge: the average plunge of the fabric in degrees
+	:type plunge: float 
+	:param trend: the average trend of the fabric in degrees
+	:type trend: float 
+	:param view_plot: Specify if a stereonet needs to be created.
+	:type view_plot: bool
+	"""
+	euler_list= np.array([])
+	orten = np.array([])
+
+	euler_list, orten = ot.orientsynth(trend, plunge, amin, amax, npts)
+
+	# Save the euler angles
+	np.savetxt(output_file, euler_list, delimiter = " ")
+
+	if view_plot:
+		fig = plt.figure( figsize = (7, 5) )
+		ax = fig.add_subplot(111,projection='stereonet')
+		ax.pole(euler_list[:,0]*180/np.pi, euler_list[:,1]*180/np.pi, 'g^', markersize=6)
+		ax.grid()
+
+		# plt.rc('text', usetex=True)
+		plt.figtext(0.01, 0.95, 'trend = ' + str(trend)   )
+		plt.figtext(0.01, 0.9, 'plunge = ' + str(plunge) )
+		plt.figtext(0.01, 0.85, 'angle min/max = ' + str(amin) + '/' + str(amax) )
+		plt.figtext(0.01, 0.8, 'N = ' + str(npts) )
+
+		# plt.figtext(0.01, 0.7, r'\underline{Tensor Coefficients}')
+		plt.figtext(0.01, 0.7, 'Tensor Coefficients')
+		plt.figtext(0.01, 0.65, '$a_{11} = $' + str( round( orten[0,0], 5) ) )
+		plt.figtext(0.01, 0.6, '$a_{22} = $' + str( round( orten[1,1], 5) ) )
+		plt.figtext(0.01, 0.55, '$a_{33} = $' + str( round( orten[2,2], 5) ) )
+
+		plt.figtext(0.01, 0.5, '$a_{12} = $' +str( round( orten[0,1],5 ) ) )
+		plt.figtext(0.01, 0.45, '$a_{13} = $' +str( round( orten[0,2], 5) ) )
+		plt.figtext(0.01, 0.4, '$a_{23} = $' +str( round( orten[1,2], 5) ) )
+
+		plt.show()
+
+
+
+
+# -------------------------- Command Line Arguments ---------------------------
+if __name__ == "__main__":
+	parser = argparse.ArgumentParser(description=""" """ )
+
+	parser.add_argument( '-o', '--outputfile', nargs=1, type=str,
+							help='Specify the file to save the outputs', 
+							default=None)
+
+	parser.add_argument( '-n', '--npts', nargs = 1, type = int, required = False,
+		help = """ Total number of grains in synthetic sample.""", default = [100])
+
+	parser.add_argument( '-P', '--plunge', nargs = 1, type = float, 
+		required = True, help = """ Plunge angle in degrees.""")
+
+	parser.add_argument( '-t', '--trend', nargs =1, type = float, required = True,
+		help = """ Trend angle in degrees.""")
+
+	parser.add_argument( '-a', '--anglemin', nargs = 1, type = float, 
+		required = True, help = """ Minimum angle deviation.""")
+
+	parser.add_argument( '-A', '--anglemax', nargs = 1, type = float, 
+		required = True, help = """Maximum angle deviation. """)
+
+	parser.add_argument('-v', '--view_plot', action='store_true', 
+		help = """Flag if you would like a plot to be shown""")
+	
+	# Get the arguments
+	args = parser.parse_args()
+	output_file = ''.join(args.outputfile)
+	npts = args.npts[0]
+	plunge=args.plunge[0]
+	trend=args.trend[0]
+	angle_min=args.anglemin[0]
+	angle_max=args.anglemax[0]
+	view_plot = args.view_plot
+	
+	main(output_file, npts, plunge, trend, angle_min, angle_max, view_plot)
```

## seidart/routines/prjbuild.py

 * *Ordering differences only*

```diff
@@ -1,276 +1,276 @@
-#!/usr/bin/env python3
-#
-# This script will read an image and build the template project file template
-# to be used in the seisarT program
-#
-# -----------------------------------------------------------------------------
-
-import argparse
-import numpy as np
-import matplotlib.image as mpimg
-from typing import Tuple
-
-__all__ = ['prjbuild']
-
-# ------------------------ Some Necessary Definitions -------------------------
-
-def image2int(imfilename: str) -> Tuple[np.ndarray, np.ndarray]:
-	"""
-	Converts an image file to a 2D array of integer values representing unique
-	RGB combinations and returns the unique RGB values.
-
-	:param imfilename: The path to the image file.
-	:type imfilename: str
-	:return: A tuple containing the 2D array of integer values and the array of unique RGB values.
-	:rtype: Tuple[np.ndarray, np.ndarray]
-	"""
-	# read the image
-	img = mpimg.imread(imfilename)
-	# Convert RGB to a single value
-	rgb_int = np.array(65536*img[:,:,0] +  255*img[:,:,1] + img[:,:,2])
-	# Get the unique values of the image
-	rgb_uni = np.unique(rgb_int)
-	# We want the unique rgb values too
-	rgb = np.zeros( [len(rgb_uni), 3] )
-	# reshape the image. We know it's three channels
-	img_vect = np.zeros( [np.prod(rgb_int.shape), 3] )
-	img_vect[:,0] = np.reshape(img[:, :, 0], np.prod(np.shape(img[:, :, 0]) ) )
-	img_vect[:,1] =	np.reshape(img[:, :, 1], np.prod(np.shape(img[:, :, 1]) ) )
-	img_vect[:,2] =	np.reshape(img[:, :, 2], np.prod(np.shape(img[:, :, 2]) ) )
-
-	for ind in range(0, len(rgb_uni) ):
-		rgb_ind = np.reshape(rgb_int == rgb_uni[ind], [np.prod(rgb_int.shape)])
-		rgb[ind,:] = (img_vect[rgb_ind,:])[0,:]
-		rgb_int[ rgb_int == rgb_uni[ind] ] = ind
-
-	if np.max(rgb) <= 1.0:
-		rgb = rgb * 255
-		rgb = rgb.astype(int)
-
-	return( rgb_int.astype(int), rgb)
-
-def prjbuild(image_file: str, prjfile: str) -> None:
-	"""
-	Generates a project file (.prj) based on an input image file. This file
-	contains domain parameters, material parameters, attenuation parameters,
-	seismic parameters, and electromagnetic parameters derived from the image.
-
-	:param image_file: The path to the input image file.
-	:param prjfile: The path where the project file is to be saved.
-	:type image_file: str
-	:type prjfile: str
-	"""
-	# ----- Read the image file
-	im, rgb = image2int(image_file)
-	im = im.transpose()
-	mat_id = np.unique(im)
-	# Start writing the project file. To allow for headers we will start all
-	# pertinant information after
-	with open(prjfile, 'w') as prj:
-		prj.write(header_comment)
-		prj.write(new_line)
-		prj.write('I,'+image_file+new_line)
-		prj.write(new_line)
-		
-	# -------------------------------------------------------------------------
-	# ------ Write domain parameters
-	dim = 'D,dim,2'
-	nx = 'D,nx,' + str(np.shape(im)[0])
-	ny = 'D,ny,n/a'
-	nz = 'D,nz,' + str(np.shape(im)[1])
-	dx = 'D,dx,'
-	dy = 'D,dy,n/a'
-	dz = 'D,dz,'
-	cpml = 'D,cpml,20'
-	nmat = 'D,nmats,' + str(len( np.unique(im) ))
-	tfile = 'D,tfile,'
-	with open(prjfile, 'a') as prj:
-		prj.write(dim+new_line)
-		prj.write(nx+new_line)
-		prj.write(ny+new_line)
-		prj.write(nz+new_line)
-		prj.write(dx+new_line)
-		prj.write(dy+new_line)
-		prj.write(dz+new_line)
-		prj.write(cpml+new_line)
-		prj.write(nmat+new_line)
-		prj.write(tfile + new_line)
-		prj.write(new_line)
-	
-	# -------------------------------------------------------------------------
-	# ----- Write material parameters
-	header = ("# number, id, R/G/B, Temperature, Density, Porosity, "
-					"Water_Content, Anisotropic, ANG_File")
-	
-	with open(prjfile, 'a') as prj:
-		i = 0
-		prj.write(header + new_line )
-		for x in mat_id:
-			ln = ('M,' + str(x) + ',,' + str(rgb[x,0])  + '/' +
-				str(rgb[x,1]) + '/' + str(rgb[x,2]) +
-				',,,,,,,')
-			prj.write( ln + new_line)
-		prj.write(new_line)
-	
-	# -------------------------------------------------------------------------
-	# ----- Write the attenuation parameters
-	header = ("# number, Alpha1, Alpha2, Alpha3, fref")
-	with open(prjfile, 'a') as prj:
-		i = 0
-		prj.write(header + new_line)
-		for x in mat_id:
-			ln = ('A,' + str(x) + ',,,,')
-			prj.write(ln + new_line)
-		prj.write(new_line)
-	
-	# -------------------------------------------------------------------------
-	# ----- Write seismic parameters
-	dt = 'dt,'
-	steps = 'time_steps,'
-	x = 'x,'
-	y = 'y,'
-	z = 'z,'
-	f0 = 'f0,'
-	theta = 'theta,0'
-	phi = 'phi,0'
-	source_file='source_file,'
-	#
-	comm = '# The source parameters for the seismic model'
-	header = '# id, C11, C12, C13, C22, C23, C33, C44, C55, C66, rho'
-	#
-	with open(prjfile, 'a') as prj:
-		i = 0
-		prj.write(comm + new_line)
-		prj.write('S,' + dt + new_line)
-		prj.write('S,' + steps + new_line)
-		prj.write('S,' + x + new_line)
-		prj.write('S,' + y + new_line)
-		prj.write('S,' + z + new_line)
-		prj.write('S,' + f0 + new_line)
-		prj.write('S,' + theta + new_line)
-		prj.write('S,' + phi + new_line)
-		prj.write(new_line)
-
-		prj.write(header + new_line )
-		for ind in mat_id:
-			prj.write( 'C,' + str(ind) + ',,,,,,,,,,' + new_line)
-
-		prj.write(new_line)
-	
-	# -------------------------------------------------------------------------
-	# ----- Write EM Parameters 
-	comm = '# The source parameters for the electromagnetic model'
-	header = '# id, e11, e22, e33, s11, s22, s33'
-	#
-	with open(prjfile, 'a') as prj:
-		i = 0
-		prj.write(comm + new_line)
-		prj.write('E,' + dt + new_line)
-		prj.write('E,' + steps + new_line)
-		prj.write('E,' + x + new_line)
-		prj.write('E,' + y + new_line)
-		prj.write('E,' + z + new_line)
-		prj.write('E,' + f0 + new_line)
-		prj.write('E,' + theta + new_line)
-		prj.write('E,' + phi + new_line)
-
-		prj.write(new_line)
-
-		prj.write(header + new_line )
-		for ind in mat_id:
-			prj.write( 'P,' + str(ind) + ',,,,,,,,,,' + new_line)
-
-		prj.write(new_line)
-
-# -------------------------------- String Variables -------------------------------
-new_line = '\n'
-header_comment = """
-# This is a project file template for the SeidarT software. In order to run the
-# model for seismic, electromagnetic or both, the required inputs must be
-#
-# Domain Input Values:
-#	dim 		- STR; either '2' or '2.5'; default is '2'
-#	nx,ny,nz 	- INT; the dimensions of the image. If dim = 2.5, and ny is
-#			  empty then default ny=1
-#	dx,dy,dz	- REAL; the spatial step size for each dimension in meters. If
-#			  dim = 2.5 and dy is empty then default dy=min(dx,dz)
-#
-# Material Input Values:
-#	id 		- INT; the identifier given to each unique rgb value as it
-#			  is read into the computer. It's recommended to use this
-#			  script to make sure it's sorted correctly.
-#	R/G/B 		- STR; the 0-255 values for each color code.
-#	Temperature 	- REAL; temperature in Celsius.
-#	Attenuation 	- REAL; (placeholder) will be attenuation length soon.
-#	Density 	- REAL; density in kg/m^3
-#	Porosity 	- REAL; percent porosity
-#	Water_Content 	- REAL; percent of pores that contain water
-#	Anisotropic 	- BOOL; whether the material is anisotropic (True) or
-#			  isotropic (False).
-#	ANG_File 	- STR; if Anisotrpic is True then the full path to the
-#			  .ang file is supplied. The .ang file is a delimited text
-#			  file that contains the 3-by-n array of euler rotation
-#			  angles in radians.
-#
-#		or alternatively...
-#	C11-C66 	- REAL; the stiffness coefficients with the appropriate id
-#	E11-E33,S11-S33	- REAL; the permittivity and conductivity coefficients and
-#			  'id' value corresponding to the coefficients along the diagonal
-#			  of their respective tensors.
-#
-#
-# Source Input Values:
-#	dt 		- REAL; dx/(2*maxvelcity)
-#	steps 		- INT; the total number of time steps
-#	x,y,z 		- REAL; locations in meters, +x is to the right, +z is down, +y is into the screen
-#	f0 		- REAL; center frequency for the guassian pulse function if
-#			  'source_file' isn't supplied
-#	theta 		- REAL; source orientation in the x-z plane,
-#	phi 		- REAL; source orientation in the x-y plane for 2.5/3D only,
-#	source_file	- STR; the pointer to the text file that contains the source
-#			  timeseries as a steps-by-1 vector.
-#
-# 	**phi and theta are the rotation angles for spherical coordinates so
-#		x = r sin(theta)cos(phi)
-#		y = r sin(theta)sin(phi)
-#		z = r cos(theta)
-#
-#	Theta is the angle from the z-axis (+ down relative to image), phi is the
-#	angle from x-axis in the x-y plane (+ counterclockwise when viewed from above)
-#
-# Written by Steven Bernsen
-# University of Maine
-# -----------------------------------------------------------------------------
-
-"""
-def main(image_file, prjfile):
-	prjbuild(image_file, prjfile)
-
-# -------------------------- Command Line Arguments ---------------------------
-if __name__ == "__main__":
-	parser = argparse.ArgumentParser(description="""The SeidarT software requires a
-		.PNG image that is used to construct the model domain for seismic and
-		electromagnetic wave propagation. Given the image file, a project file
-		will be constructed which contains all the necessary parameters to be
-		read in to the finite differences time domain modeling schemes.""" )
-	
-	parser.add_argument(
-		'-i','--imagefile', 
-		nargs=1, type=str, required = True,
-		help='the full file path for the image', default=None
-	)
-
-	parser.add_argument(
-		'-p', '--prjfile',
-		nargs=1, type=str, required = False, default = 'jordan_downs.prj',
-		help = """name of output file path with extension .prj and excluding
-		the full path directory"""
-	)
-
-	# Get the arguments
-	args = parser.parse_args()
-	image_file = ''.join(args.imagefile)
-	prjfile = ''.join(args.prjfile)
-	main(image_file, prjfile)
-
-
+#!/usr/bin/env python3
+#
+# This script will read an image and build the template project file template
+# to be used in the seisarT program
+#
+# -----------------------------------------------------------------------------
+
+import argparse
+import numpy as np
+import matplotlib.image as mpimg
+from typing import Tuple
+
+__all__ = ['prjbuild']
+
+# ------------------------ Some Necessary Definitions -------------------------
+
+def image2int(imfilename: str) -> Tuple[np.ndarray, np.ndarray]:
+	"""
+	Converts an image file to a 2D array of integer values representing unique
+	RGB combinations and returns the unique RGB values.
+
+	:param imfilename: The path to the image file.
+	:type imfilename: str
+	:return: A tuple containing the 2D array of integer values and the array of unique RGB values.
+	:rtype: Tuple[np.ndarray, np.ndarray]
+	"""
+	# read the image
+	img = mpimg.imread(imfilename)
+	# Convert RGB to a single value
+	rgb_int = np.array(65536*img[:,:,0] +  255*img[:,:,1] + img[:,:,2])
+	# Get the unique values of the image
+	rgb_uni = np.unique(rgb_int)
+	# We want the unique rgb values too
+	rgb = np.zeros( [len(rgb_uni), 3] )
+	# reshape the image. We know it's three channels
+	img_vect = np.zeros( [np.prod(rgb_int.shape), 3] )
+	img_vect[:,0] = np.reshape(img[:, :, 0], np.prod(np.shape(img[:, :, 0]) ) )
+	img_vect[:,1] =	np.reshape(img[:, :, 1], np.prod(np.shape(img[:, :, 1]) ) )
+	img_vect[:,2] =	np.reshape(img[:, :, 2], np.prod(np.shape(img[:, :, 2]) ) )
+
+	for ind in range(0, len(rgb_uni) ):
+		rgb_ind = np.reshape(rgb_int == rgb_uni[ind], [np.prod(rgb_int.shape)])
+		rgb[ind,:] = (img_vect[rgb_ind,:])[0,:]
+		rgb_int[ rgb_int == rgb_uni[ind] ] = ind
+
+	if np.max(rgb) <= 1.0:
+		rgb = rgb * 255
+		rgb = rgb.astype(int)
+
+	return( rgb_int.astype(int), rgb)
+
+def prjbuild(image_file: str, prjfile: str) -> None:
+	"""
+	Generates a project file (.prj) based on an input image file. This file
+	contains domain parameters, material parameters, attenuation parameters,
+	seismic parameters, and electromagnetic parameters derived from the image.
+
+	:param image_file: The path to the input image file.
+	:param prjfile: The path where the project file is to be saved.
+	:type image_file: str
+	:type prjfile: str
+	"""
+	# ----- Read the image file
+	im, rgb = image2int(image_file)
+	im = im.transpose()
+	mat_id = np.unique(im)
+	# Start writing the project file. To allow for headers we will start all
+	# pertinant information after
+	with open(prjfile, 'w') as prj:
+		prj.write(header_comment)
+		prj.write(new_line)
+		prj.write('I,'+image_file+new_line)
+		prj.write(new_line)
+		
+	# -------------------------------------------------------------------------
+	# ------ Write domain parameters
+	dim = 'D,dim,2'
+	nx = 'D,nx,' + str(np.shape(im)[0])
+	ny = 'D,ny,n/a'
+	nz = 'D,nz,' + str(np.shape(im)[1])
+	dx = 'D,dx,'
+	dy = 'D,dy,n/a'
+	dz = 'D,dz,'
+	cpml = 'D,cpml,20'
+	nmat = 'D,nmats,' + str(len( np.unique(im) ))
+	tfile = 'D,tfile,'
+	with open(prjfile, 'a') as prj:
+		prj.write(dim+new_line)
+		prj.write(nx+new_line)
+		prj.write(ny+new_line)
+		prj.write(nz+new_line)
+		prj.write(dx+new_line)
+		prj.write(dy+new_line)
+		prj.write(dz+new_line)
+		prj.write(cpml+new_line)
+		prj.write(nmat+new_line)
+		prj.write(tfile + new_line)
+		prj.write(new_line)
+	
+	# -------------------------------------------------------------------------
+	# ----- Write material parameters
+	header = ("# number, id, R/G/B, Temperature, Density, Porosity, "
+					"Water_Content, Anisotropic, ANG_File")
+	
+	with open(prjfile, 'a') as prj:
+		i = 0
+		prj.write(header + new_line )
+		for x in mat_id:
+			ln = ('M,' + str(x) + ',,' + str(rgb[x,0])  + '/' +
+				str(rgb[x,1]) + '/' + str(rgb[x,2]) +
+				',,,,,,,')
+			prj.write( ln + new_line)
+		prj.write(new_line)
+	
+	# -------------------------------------------------------------------------
+	# ----- Write the attenuation parameters
+	header = ("# number, Alpha1, Alpha2, Alpha3, fref")
+	with open(prjfile, 'a') as prj:
+		i = 0
+		prj.write(header + new_line)
+		for x in mat_id:
+			ln = ('A,' + str(x) + ',,,,')
+			prj.write(ln + new_line)
+		prj.write(new_line)
+	
+	# -------------------------------------------------------------------------
+	# ----- Write seismic parameters
+	dt = 'dt,'
+	steps = 'time_steps,'
+	x = 'x,'
+	y = 'y,'
+	z = 'z,'
+	f0 = 'f0,'
+	theta = 'theta,0'
+	phi = 'phi,0'
+	source_file='source_file,'
+	#
+	comm = '# The source parameters for the seismic model'
+	header = '# id, C11, C12, C13, C22, C23, C33, C44, C55, C66, rho'
+	#
+	with open(prjfile, 'a') as prj:
+		i = 0
+		prj.write(comm + new_line)
+		prj.write('S,' + dt + new_line)
+		prj.write('S,' + steps + new_line)
+		prj.write('S,' + x + new_line)
+		prj.write('S,' + y + new_line)
+		prj.write('S,' + z + new_line)
+		prj.write('S,' + f0 + new_line)
+		prj.write('S,' + theta + new_line)
+		prj.write('S,' + phi + new_line)
+		prj.write(new_line)
+
+		prj.write(header + new_line )
+		for ind in mat_id:
+			prj.write( 'C,' + str(ind) + ',,,,,,,,,,' + new_line)
+
+		prj.write(new_line)
+	
+	# -------------------------------------------------------------------------
+	# ----- Write EM Parameters 
+	comm = '# The source parameters for the electromagnetic model'
+	header = '# id, e11, e22, e33, s11, s22, s33'
+	#
+	with open(prjfile, 'a') as prj:
+		i = 0
+		prj.write(comm + new_line)
+		prj.write('E,' + dt + new_line)
+		prj.write('E,' + steps + new_line)
+		prj.write('E,' + x + new_line)
+		prj.write('E,' + y + new_line)
+		prj.write('E,' + z + new_line)
+		prj.write('E,' + f0 + new_line)
+		prj.write('E,' + theta + new_line)
+		prj.write('E,' + phi + new_line)
+
+		prj.write(new_line)
+
+		prj.write(header + new_line )
+		for ind in mat_id:
+			prj.write( 'P,' + str(ind) + ',,,,,,,,,,' + new_line)
+
+		prj.write(new_line)
+
+# -------------------------------- String Variables -------------------------------
+new_line = '\n'
+header_comment = """
+# This is a project file template for the SeidarT software. In order to run the
+# model for seismic, electromagnetic or both, the required inputs must be
+#
+# Domain Input Values:
+#	dim 		- STR; either '2' or '2.5'; default is '2'
+#	nx,ny,nz 	- INT; the dimensions of the image. If dim = 2.5, and ny is
+#			  empty then default ny=1
+#	dx,dy,dz	- REAL; the spatial step size for each dimension in meters. If
+#			  dim = 2.5 and dy is empty then default dy=min(dx,dz)
+#
+# Material Input Values:
+#	id 		- INT; the identifier given to each unique rgb value as it
+#			  is read into the computer. It's recommended to use this
+#			  script to make sure it's sorted correctly.
+#	R/G/B 		- STR; the 0-255 values for each color code.
+#	Temperature 	- REAL; temperature in Celsius.
+#	Attenuation 	- REAL; (placeholder) will be attenuation length soon.
+#	Density 	- REAL; density in kg/m^3
+#	Porosity 	- REAL; percent porosity
+#	Water_Content 	- REAL; percent of pores that contain water
+#	Anisotropic 	- BOOL; whether the material is anisotropic (True) or
+#			  isotropic (False).
+#	ANG_File 	- STR; if Anisotrpic is True then the full path to the
+#			  .ang file is supplied. The .ang file is a delimited text
+#			  file that contains the 3-by-n array of euler rotation
+#			  angles in radians.
+#
+#		or alternatively...
+#	C11-C66 	- REAL; the stiffness coefficients with the appropriate id
+#	E11-E33,S11-S33	- REAL; the permittivity and conductivity coefficients and
+#			  'id' value corresponding to the coefficients along the diagonal
+#			  of their respective tensors.
+#
+#
+# Source Input Values:
+#	dt 		- REAL; dx/(2*maxvelcity)
+#	steps 		- INT; the total number of time steps
+#	x,y,z 		- REAL; locations in meters, +x is to the right, +z is down, +y is into the screen
+#	f0 		- REAL; center frequency for the guassian pulse function if
+#			  'source_file' isn't supplied
+#	theta 		- REAL; source orientation in the x-z plane,
+#	phi 		- REAL; source orientation in the x-y plane for 2.5/3D only,
+#	source_file	- STR; the pointer to the text file that contains the source
+#			  timeseries as a steps-by-1 vector.
+#
+# 	**phi and theta are the rotation angles for spherical coordinates so
+#		x = r sin(theta)cos(phi)
+#		y = r sin(theta)sin(phi)
+#		z = r cos(theta)
+#
+#	Theta is the angle from the z-axis (+ down relative to image), phi is the
+#	angle from x-axis in the x-y plane (+ counterclockwise when viewed from above)
+#
+# Written by Steven Bernsen
+# University of Maine
+# -----------------------------------------------------------------------------
+
+"""
+def main(image_file, prjfile):
+	prjbuild(image_file, prjfile)
+
+# -------------------------- Command Line Arguments ---------------------------
+if __name__ == "__main__":
+	parser = argparse.ArgumentParser(description="""The SeidarT software requires a
+		.PNG image that is used to construct the model domain for seismic and
+		electromagnetic wave propagation. Given the image file, a project file
+		will be constructed which contains all the necessary parameters to be
+		read in to the finite differences time domain modeling schemes.""" )
+	
+	parser.add_argument(
+		'-i','--imagefile', 
+		nargs=1, type=str, required = True,
+		help='the full file path for the image', default=None
+	)
+
+	parser.add_argument(
+		'-p', '--prjfile',
+		nargs=1, type=str, required = False, default = 'jordan_downs.prj',
+		help = """name of output file path with extension .prj and excluding
+		the full path directory"""
+	)
+
+	# Get the arguments
+	args = parser.parse_args()
+	image_file = ''.join(args.imagefile)
+	prjfile = ''.join(args.prjfile)
+	main(image_file, prjfile)
+
+
```

## seidart/routines/prjrun.py

```diff
@@ -1,584 +1,583 @@
-import argparse
-import os.path
-import os
-import numpy as np
-import matplotlib.image as mpimg
-from subprocess import call
-from typing import Tuple
-# import seidart.routines.materials as mf
-from seidart.routines.definitions import *
-
-# Modeling modules
-from seidart.fortran.cpmlfdtd import cpmlfdtd
-
-# Global Constants
-clight = 2.99792458e8  # Speed of light in vacuum (m/s)
-NP = 2  # Numerical parameter for CPML
-NPA = 2  # Additional numerical parameter for CPML
-k_max = 1.1e1  # Max value for CPML parameter
-eps0 = 8.85418782e-12  # Permittivity of free space
-mu0 = 4.0 * np.pi * 1.0e-7  # Permeability of free space
-Rcoef = 0.0010  # Reflection coefficient, used for seismic only
-
-# ============================ Create the objects =============================
-# Let's initiate the domain and check to make sure everything is good to go
-def domain_initialization(
-        prjfile: str
-    ) -> Tuple[Domain, Material, Model, Model]:
-    """
-    Initializes the simulation domain and materials, and prepares seismic and 
-    electromagnetic models based on a project file.
-
-    This function reads simulation parameters from a specified project file and 
-    uses them to initialize the domain, material properties, and two models 
-    (seismic and electromagnetic). It performs checks to ensure all necessary 
-    parameters are specified and modifies the material list by removing RGB 
-    values. 
-
-    :param prjfile: The path to the project file containing initialization 
-        parameters for the domain, materials, and models.
-    :type prjfile: str
-    :return: A tuple containing initialized Domain, Material, and two Model 
-        instances (seismic and electromagnetic).
-    :rtype: Tuple[Domain, Material, Model, Model]
-
-    Each Model instance is checked to ensure required parameters are provided, 
-    and the material list is pruned to exclude RGB values before final checks 
-    are performed.
-    """
-
-    domain, material, seismic, electromag = loadproject(
-        prjfile,
-        Domain(), 
-        Material(),
-        Model(),
-        Model()
-    )
-
-    # Model initialization and checks
-    domain.para_check()
-    seismic.para_check()
-    electromag.para_check()
-    seismic.tensor_check()
-    electromag.tensor_check()
-
-    # Modify material list and perform final checks
-    material.material_list = np.delete(material.material_list, 2, axis=1)
-    material.para_check()
-
-    return(domain, material, seismic, electromag)
-
-# -----------------------------------------------------------------------------
-def status_check(
-        modelclass: Model, 
-        material: Material, 
-        domain: Domain, 
-        prjfile: str, 
-        seismic: bool = True, 
-        append_to_prjfile: bool = True
-    ) -> None:
-    """
-    Checks the status of the modeling classes and appends coefficients to the
-    project file if necessary.
-
-    :param modelclass: The model class to check.
-    :param material: The material class instance.
-    :param domain: The domain class instance.
-    :param prjfile: Path to the project file.
-    :param seismic: Flag indicating if the model is seismic. Defaults to True.
-    :param append_to_prjfile: Flag to append coefficients to the project file. 
-                              Defaults to True.
-    :type modelclass: Union[Model, None]
-    :type material: Material
-    :type domain: Domain
-    :type prjfile: str
-    :type seismic: bool
-    :type append_to_prjfile: bool
-    """
-    if modelclass.exit_status == 0 and \
-        material.material_flag and \
-            append_to_prjfile:
-        # The coefficients aren't provided but the materials are so we can 
-        # compute them
-        # Assign the materials to their respective corners
-        material.sort_material_list()
-        
-        if seismic:
-            print('Computing the stiffness coefficients.')
-            tensor = material.functions.get_seismic(
-                temp = material.temp, 
-                rho = material.rho,
-                porosity = material.porosity,
-                lwc = material.lwc, 
-                anisotropic = material.is_anisotropic,
-                angfile = material.angfiles, 
-                material_name = material.material
-            )
-            modelclass.tensor_coefficients = tensor
-        else:
-            print('Computing the permittivity and conductivity coefficients.')
-            
-            tensor = material.functions.get_perm(
-                material, modelclass
-            )
-            modelclass.tensor_coefficients = tensor
-        
-        # Before we append the coefficients to the text file let's round to the second decimal
-        tensor = np.round(tensor, 2)
-        if seismic:
-            ind = np.where(tensor.max() == tensor)
-            max_rho = tensor[ ind[0][0], -1]
-        
-        # We're going to find the lines marked 'C' or 'P' and input the values there
-
-        if seismic:
-            modelclass.dt = np.min([domain.dx, domain.dz]) / np.sqrt(3.0 * tensor.max()/max_rho )
-            append_coefficients(prjfile, tensor, CP = 'C', dt = modelclass.dt)
-        else:
-            modelclass.dt = np.min([domain.dx, domain.dz]) / \
-                (2.0 * clight/ \
-                    np.sqrt(np.min(
-                        [
-                            tensor[:,1].astype(float).min(), 
-                            tensor[:,4].astype(float).min()
-                        ]
-                    )) 
-                )
-            append_coefficients(prjfile, tensor, CP = 'P', dt = modelclass.dt)
-        
-        # The time step needs to satisfy the Courant number and also have a nyquist
-        # that will resolve the source frequency
-        src_nyquist = 1/(2*modelclass.f0)
-        if src_nyquist < modelclass.dt:
-            print(
-                '''Nyquist is not small enough for the source frequency. Change
-                the source frequency or decrease the spatial step size'''
-            )
-
-        print("Finished. Appending to project file.\n")
-
-# -----------------------------------------------------------------------------
-def cpmlcompute(
-        modelclass: Model, 
-        domain: Domain, 
-        direction: str, 
-        half: bool = False, 
-        seismic: bool = True
-    ) -> None:
-    """
-    Computes CPML parameters for a given direction and updates model/domain.
-
-    :param modelclass: The model class instance to update.
-    :param domain: The domain class instance to update.
-    :param direction: Direction to compute CPML ('x', 'y', or 'z').
-    :param half: Flag to compute half CPML parameters. Defaults to False.
-    :param seismic: Flag indicating if the model is seismic. Defaults to True.
-    :type modelclass: Model
-    :type domain: Domain
-    :type direction: str
-    :type half: bool
-    :type seismic: bool
-    """
-
-    # For 2D models, we don't need to compute the cpml in the y-direction
-    if domain.dim == 2 and direction == 'y':
-        return 
-    
-    nx = domain.nx + 2*domain.cpml
-    nz = domain.nz + 2*domain.cpml
-    if domain.dim == 2.5:
-        ny = domain.ny + 2*domain.cpml
-        deltamin = np.min([domain.dx, domain.dy, domain.dz]) 
-    else:
-        deltamin = np.min([domain.dx, domain.dz]) 
-
-    # Allocate space
-    if direction == 'x':
-        N = int(nx)
-        dx = float(domain.dx)
-    elif direction == 'y':
-        N = int(ny)
-        dx = float(domain.dy) 
-    else:
-        N = int(nz)
-        dx = float(domain.dz)
-    
-    # -----------------------------------------------------------------------------
-    # Compute the distance along the absorbing boundary relative to the end of the 
-    # original model space. 
-    dist = dx * np.arange(0, domain.cpml)
-    if half:
-        dist = dist + dx/2 
-
-    dist = dx*domain.cpml - dist
-    dist = dist/(dx*domain.cpml)
-
-    quasi_cp_max = 0.7* deltamin / (2.0 * modelclass.dt)
-    alpha_max = np.pi*modelclass.f0
-    if seismic:
-        sig_max = - np.log(Rcoef) * (NP+1) * quasi_cp_max / (2.0 * domain.cpml )
-    else:
-        sig_max = 0.7 * (NP+1) / (dx * np.sqrt(mu0/eps0) )
-
-    kappa = np.ones([N])
-    alpha = np.zeros([N])
-    sigma = np.zeros([N])
-    acoeff = np.zeros([N])
-    bcoeff = np.zeros([N])
-
-    # Compute in the x, and z directions
-    for ind in range(0, domain.cpml):
-        # From 0
-        sigma[ind] = sig_max*dist[ind]**NP
-        kappa[ind] = 1.0 + (k_max - 1.0) * dist[ind]**NP
-        alpha[ind] = alpha_max * (1 - dist[ind])**NPA
-        sigma[-(ind+1)] = sig_max*dist[ind]**NP
-        kappa[-(ind+1)] = 1 + (k_max - 1) * dist[ind]**NP
-        alpha[-(ind+1)] = alpha_max * (1 - dist[ind])**NPA
-        bcoeff[-(ind+1)] = np.exp(- (sigma[-(ind+1)] / kappa[-(ind+1)] + alpha[-(ind+1)]) * modelclass.dt)
-        bcoeff[ind] = np.exp( - (sigma[ind] / kappa[ind] + alpha[ind]) * modelclass.dt)
-
-    # Compute the a-coefficients 
-    alpha[np.where(alpha < 0.0)] = 0.0
-    indices = np.where(np.abs(sigma) > 1.0e-6)
-    acoeff[indices] = sigma[indices] * (bcoeff[indices] - 1) / \
-            (kappa[indices] * sigma[indices] + kappa[indices] * alpha[indices] )
-
-    # Save the results to a fortran binary
-    if half:
-        sigma.tofile('sigma' + direction + '_half_cpml.dat')
-        kappa.tofile('kappa' + direction + '_half_cpml.dat')
-        alpha.tofile('alpha' + direction + '_half_cpml.dat')
-        acoeff.tofile('acoef' + direction + '_half_cpml.dat')
-        bcoeff.tofile('bcoef' + direction + '_half_cpml.dat')
-    else:
-        sigma.tofile('sigma' + direction + '_cpml.dat')
-        kappa.tofile('kappa' + direction + '_cpml.dat')
-        alpha.tofile('alpha' + direction + '_cpml.dat')
-        acoeff.tofile('acoef' + direction + '_cpml.dat')
-        bcoeff.tofile('bcoef' + direction + '_cpml.dat')
-
-# ================================== SEISMIC ==================================
-def runseismic(
-        modelclass: Model, 
-        material: Material, 
-        domain: Domain, 
-        single_precision: bool = True
-    ) -> None:
-    """
-    Runs the seismic model using the initialized modelclass, material, and domain.
-
-    :param modelclass: The seismic model class instance.
-    :param material: The material class instance.
-    :param domain: The domain class instance.
-    :param single_precision: Flag for single precision data processing.
-    :type modelclass: Model
-    :type material: Material
-    :type domain: Domain
-    :type single_precision: bool
-    """
-
-    modelclass, domain = prepme(modelclass, domain, complex_tensor = False)
-    direction = ['x', 'y', 'z']
-    # Compute CPML
-    print(direction)
-    print('computing cpml')
-    for d in direction:
-        cpmlcompute(modelclass, domain, d, seismic = True)
-        cpmlcompute(modelclass, domain, d, half = True, seismic = True)
-    
-    # We need to set a density gradient at air interfaces because high
-    # density gradients lead to numerical instability
-    rhograd = airsurf(material, domain, 2)
-    # Write the coefficient images to a fortran file
-    
-    # Create the stiffness .dat files
-    cpmlfdtd.stiffness_write(
-        domain.geometry + 1,
-        modelclass.tensor_coefficients,
-        domain.cpml,
-        rhograd,
-        domain.nx,
-        domain.nz
-    )
-    attenuation_coefficients = modelclass.attenuation_coefficients * \
-        modelclass.dt / (np.ones([domain.nmats, 3]) * \
-            material.material_list[:,3].astype(float) ).T
-    # Create the attenuation .dat files
-    cpmlfdtd.attenuation_write(
-        domain.geometry + 1,
-        attenuation_coefficients,
-        domain.cpml,
-        # domain.nx, 
-        # domain.nz,
-        domain.cpml_attenuation,
-        True
-    )
-    
-    if domain.dim == 2.5:
-        print('Running 2.5D model')
-        # Run the FDTD
-        cpmlfdtd.seismic25(
-            domain.nx + 2*domain.cpml, 
-            domain.ny + 2*domain.cpml, 
-            domain.nz + 2*domain.cpml,
-            domain.dx, domain.dy, domain.dz,
-            domain.cpml,
-            modelclass.src,
-            modelclass.time_steps,
-            single_precision
-        )
-    else:
-            print('Running 2D model')
-            cpmlfdtd.seismic2c(
-                domain.nx + 2*domain.cpml, 
-                domain.nz + 2*domain.cpml,
-                domain.dx, domain.dz,
-                domain.cpml,
-                modelclass.src,
-                modelclass.time_steps,
-                single_precision
-            )     
-
-# =============================================================================
-def runelectromag(
-        modelclass: Model, 
-        material: Material, 
-        domain: Domain, 
-        use_complex_equations: bool = False,
-        single_precision: bool = True
-    ) -> None:
-    """
-    Runs the electromagnetic model with options for complex equations and precision.
-
-    :param modelclass: The electromagnetic model class instance.
-    :param material: The material class instance.
-    :param domain: The domain class instance.
-    :param use_complex_equations: Flag to use complex equations in modeling.
-    :param single_precision: Flag for single precision data processing.
-    :type modelclass: Model
-    :type material: Material
-    :type domain: Domain
-    :type use_complex_equations: bool
-    :type single_precision: bool
-    """
-
-    modelclass, domain = prepme(
-        modelclass, domain, complex_tensor = use_complex_equations
-    )
-    direction = ['x', 'y', 'z']
-    # Compute CPML
-    print(direction)
-    print('computing cpml')
-    for d in direction:
-        cpmlcompute(modelclass, domain, d, seismic = False)
-        cpmlcompute(modelclass, domain, d, half = True, seismic = False)
-    
-    if use_complex_equations:
-        cpmlfdtd.permittivity_write_c(
-            domain.geometry+1,
-            modelclass.tensor_coefficients,
-            domain.cpml,
-            domain.nx, 
-            domain.nz
-        )
-        if domain.dim == 2.5:
-            print('Running complex 3D model.')
-            cpmlfdtd.electromag25c(
-                domain.nx + 2*domain.cpml, 
-                domain.ny + 2*domain.cpml, 
-                domain.nz + 2*domain.cpml,
-                domain.dx, domain.dy, domain.dz,
-                domain.cpml,
-                modelclass.src,
-                modelclass.time_steps,
-                single_precision
-            )
-        else:
-            print('Running complex 2D model')
-            cpmlfdtd.electromag2c(
-                domain.nx + 2*domain.cpml,
-                domain.nz + 2*domain.cpml,
-                domain.dx, domain.dz,
-                domain.cpml,
-                modelclass.src,
-                modelclass.time_steps,
-                single_precision
-            )
-    else:  
-        cpmlfdtd.permittivity_write(
-                domain.geometry+1,
-                modelclass.tensor_coefficients.real,
-                domain.cpml,
-                domain.nx, 
-                domain.nz
-            )
-        if domain.dim == 2.5:
-            print('Running 2.5D model')
-            cpmlfdtd.electromag25(
-                domain.nx + 2*domain.cpml, 
-                domain.ny + 2*domain.cpml, 
-                domain.nz + 2*domain.cpml,
-                domain.dx, domain.dy, domain.dz,
-                domain.cpml,
-                modelclass.src,
-                modelclass.time_steps,
-                single_precision
-            )
-        else:
-            print('Running 2D model')
-            cpmlfdtd.electromag2(
-                domain.nx + 2*domain.cpml,
-                domain.nz + 2*domain.cpml,
-                domain.dx, domain.dz,
-                domain.cpml,
-                modelclass.src,
-                modelclass.time_steps,
-                single_precision
-            )
-        
-def main(
-        prjfile: str, 
-        model_type: str, 
-        append_to_prjfile: bool, 
-        pwd: str, 
-        double_precision: bool, 
-        use_complex_equations: bool
-    ) -> None:
-    """
-    Main function orchestrating domain initialization, status checking, and 
-    model execution based on provided command line arguments.
-
-    Initializes the simulation domain and material properties from a project file,
-    checks the status of seismic and electromagnetic models, and runs the specified
-    model(s) with configured settings. The function allows for re-computation and 
-    appending of material coefficients to the project file and supports both
-    seismic and electromagnetic model types with options for precision and complex
-    equations.
-
-    :param prjfile: The path to the project file containing simulation settings.
-    :param model_type: Specifies the type of model to run ('s' for seismic, 'e' 
-                       for electromagnetic).
-    :param append_to_prjfile: Flag indicating whether to append computed coefficients 
-                              to the project file.
-    :param pwd: The working directory where the project file is located.
-    :param double_precision: Flag indicating whether to use double precision for 
-                             simulation outputs.
-    :param use_complex_equations: Flag indicating whether to use complex equations 
-                                  for electromagnetic simulations.
-    :type prjfile: str
-    :type model_type: str
-    :type append_to_prjfile: bool
-    :type pwd: str
-    :type double_precision: bool
-    :type use_complex_equations: bool
-    """
-    domain, material, seismic, electromag = domain_initialization(prjfile)
-    status_check(
-        seismic, 
-        material,
-        domain,
-        prjfile, 
-        seismic=True, 
-        append_to_prjfile = append_to_prjfile
-    )
-    status_check(
-        electromag, 
-        material, 
-        domain,
-        prjfile, 
-        seismic=False, 
-        append_to_prjfile = append_to_prjfile,
-        use_complex_equations = use_complex_equations
-    )
-    
-    
-    if model_type == 's':
-        runseismic(
-            seismic, material, domain, 
-            double_precision
-        )
-    if model_type == 'e':
-        runelectromag(
-            electromag, material, domain, 
-            use_complex_equations = use_complex_equations, 
-            double_precision = double_precision
-        )
-
-# -------------------------- Command Line Arguments ---------------------------
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(
-        description="""
-        This script will read the parameters given from a project file and run 
-        the specified models. The SeidarT software requires a .PNG image that is used to construct the model domain for seismic and
-        electromagnetic wave propagation. Given the image file, a project file
-        will be constructed which contains all the necessary parameters to be
-        read in to the finite differences time domain modeling schemes."""
-    )
-
-    parser.add_argument(
-        '-p', '--prjfile', nargs=1, type=str, required = True,
-        help='the full file path for the project file', default=None
-    )
-
-    parser.add_argument(
-        '-m', '--model', nargs = 1, type = str, required = False,
-        help = """Specify whether to run the seismic (s), or electromagnetic (e), 
-        or none (default = n)""",
-        default = 'n'
-    )
-
-    parser.add_argument(
-        '-a', '--append',
-        action='store_true', required = False,
-        help = """Append/recompute the coefficients to the permittivity and
-        stiffness matrices; DEFAULT is True"""
-    )
-    
-    parser.add_argument(
-        '-d', '--double_precision', 
-        action='store_false', required = False,
-        help = """Specify double precision output of the simulation. If 
-        complex, the outputs are real valued of each of the components of the 
-        complex value. The default is True."""
-    )
-    
-    parser.add_argument(
-        '-c', '--use_complex_equations', action = 'store_true', required = False,
-        help = """Flag whether to use the complex permittivity in the model
-        simulation. The complex permittivity will be computed for ice and snow
-        in all situations, but unless specified here, the complex permittivity 
-        will only be used to compute the conductivity."""
-    )
-    
-    parser.add_argument(
-        '-o', '--output_directory_path', required = False, 
-        nargs = 1, type = str, 
-        help = '''Specify the output directory folder path to write the Fortran
-        outputs to. '''
-    )
-    # parser.add_argument(
-    #     '-A', '--attenuation', action='store_true', required = False,
-    #     help = """Specify whether to include attenuation in the model. The 
-    #     default is False."""
-    # )
-
-    # Get the arguments
-    args = parser.parse_args()
-    prjfile = ''.join(args.prjfile)
-    model_type = ''.join(args.model)
-    append_to_prjfile = args.append
-    pwd = os.path.dirname(prjfile)
-    double_precision = args.double_precision
-    use_complex_equations = args.use_complex_equations
-     
-    # attenuation = args.attenuation
-    #
-    main(
-        prjfile, 
-        model_type, 
-        append_to_prjfile, 
-        pwd, 
-        double_precision, 
-        use_complex_equations
+import argparse
+import os.path
+import os
+import numpy as np
+import matplotlib.image as mpimg
+from subprocess import call
+from typing import Tuple
+# import seidart.routines.materials as mf
+from seidart.routines.definitions import *
+
+# Modeling modules
+from seidart.fortran.cpmlfdtd import cpmlfdtd
+
+# Global Constants
+clight = 2.99792458e8  # Speed of light in vacuum (m/s)
+NP = 2  # Numerical parameter for CPML
+NPA = 2  # Additional numerical parameter for CPML
+k_max = 1.1e1  # Max value for CPML parameter
+eps0 = 8.85418782e-12  # Permittivity of free space
+mu0 = 4.0 * np.pi * 1.0e-7  # Permeability of free space
+Rcoef = 0.0010  # Reflection coefficient, used for seismic only
+
+# ============================ Create the objects =============================
+# Let's initiate the domain and check to make sure everything is good to go
+def domain_initialization(
+        prjfile: str
+    ) -> Tuple[Domain, Material, Model, Model]:
+    """
+    Initializes the simulation domain and materials, and prepares seismic and 
+    electromagnetic models based on a project file.
+
+    This function reads simulation parameters from a specified project file and 
+    uses them to initialize the domain, material properties, and two models 
+    (seismic and electromagnetic). It performs checks to ensure all necessary 
+    parameters are specified and modifies the material list by removing RGB 
+    values. 
+
+    :param prjfile: The path to the project file containing initialization 
+        parameters for the domain, materials, and models.
+    :type prjfile: str
+    :return: A tuple containing initialized Domain, Material, and two Model 
+        instances (seismic and electromagnetic).
+    :rtype: Tuple[Domain, Material, Model, Model]
+
+    Each Model instance is checked to ensure required parameters are provided, 
+    and the material list is pruned to exclude RGB values before final checks 
+    are performed.
+    """
+
+    domain, material, seismic, electromag = loadproject(
+        prjfile,
+        Domain(), 
+        Material(),
+        Model(),
+        Model()
+    )
+
+    # Model initialization and checks
+    domain.para_check()
+    seismic.para_check()
+    electromag.para_check()
+    seismic.tensor_check()
+    electromag.tensor_check()
+
+    # Modify material list and perform final checks
+    material.material_list = np.delete(material.material_list, 2, axis=1)
+    material.para_check()
+
+    return(domain, material, seismic, electromag)
+
+# -----------------------------------------------------------------------------
+def status_check(
+        modelclass: Model, 
+        material: Material, 
+        domain: Domain, 
+        prjfile: str, 
+        seismic: bool = True, 
+        append_to_prjfile: bool = True
+    ) -> None:
+    """
+    Checks the status of the modeling classes and appends coefficients to the
+    project file if necessary.
+
+    :param modelclass: The model class to check.
+    :param material: The material class instance.
+    :param domain: The domain class instance.
+    :param prjfile: Path to the project file.
+    :param seismic: Flag indicating if the model is seismic. Defaults to True.
+    :param append_to_prjfile: Flag to append coefficients to the project file. 
+                              Defaults to True.
+    :type modelclass: Union[Model, None]
+    :type material: Material
+    :type domain: Domain
+    :type prjfile: str
+    :type seismic: bool
+    :type append_to_prjfile: bool
+    """
+    if modelclass.exit_status == 0 and \
+        material.material_flag and \
+            append_to_prjfile:
+        # The coefficients aren't provided but the materials are so we can 
+        # compute them
+        # Assign the materials to their respective corners
+        material.sort_material_list()
+        
+        if seismic:
+            print('Computing the stiffness coefficients.')
+            tensor = material.functions.get_seismic(
+                temp = material.temp, 
+                rho = material.rho,
+                porosity = material.porosity,
+                lwc = material.lwc, 
+                anisotropic = material.is_anisotropic,
+                angfile = material.angfiles, 
+                material_name = material.material
+            )
+            modelclass.tensor_coefficients = tensor
+        else:
+            print('Computing the permittivity and conductivity coefficients.')
+            
+            tensor = material.functions.get_perm(
+                material, modelclass
+            )
+            modelclass.tensor_coefficients = tensor
+        
+        # Before we append the coefficients to the text file let's round to the second decimal
+        tensor = np.round(tensor, 2)
+        if seismic:
+            ind = np.where(tensor.max() == tensor)
+            max_rho = tensor[ ind[0][0], -1]
+        
+        # We're going to find the lines marked 'C' or 'P' and input the values there
+
+        if seismic:
+            modelclass.dt = np.min([domain.dx, domain.dz]) / np.sqrt(3.0 * tensor.max()/max_rho )
+            append_coefficients(prjfile, tensor, CP = 'C', dt = modelclass.dt)
+        else:
+            modelclass.dt = np.min([domain.dx, domain.dz]) / \
+                (2.0 * clight/ \
+                    np.sqrt(np.min(
+                        [
+                            tensor[:,1].astype(float).min(), 
+                            tensor[:,4].astype(float).min()
+                        ]
+                    )) 
+                )
+            append_coefficients(prjfile, tensor, CP = 'P', dt = modelclass.dt)
+        
+        # The time step needs to satisfy the Courant number and also have a nyquist
+        # that will resolve the source frequency
+        src_nyquist = 1/(2*modelclass.f0)
+        if src_nyquist < modelclass.dt:
+            print(
+                '''Nyquist is not small enough for the source frequency. Change
+                the source frequency or decrease the spatial step size'''
+            )
+
+        print("Finished. Appending to project file.\n")
+
+# -----------------------------------------------------------------------------
+def cpmlcompute(
+        modelclass: Model, 
+        domain: Domain, 
+        direction: str, 
+        half: bool = False, 
+        seismic: bool = True
+    ) -> None:
+    """
+    Computes CPML parameters for a given direction and updates model/domain.
+
+    :param modelclass: The model class instance to update.
+    :param domain: The domain class instance to update.
+    :param direction: Direction to compute CPML ('x', 'y', or 'z').
+    :param half: Flag to compute half CPML parameters. Defaults to False.
+    :param seismic: Flag indicating if the model is seismic. Defaults to True.
+    :type modelclass: Model
+    :type domain: Domain
+    :type direction: str
+    :type half: bool
+    :type seismic: bool
+    """
+
+    # For 2D models, we don't need to compute the cpml in the y-direction
+    if domain.dim == 2 and direction == 'y':
+        return 
+    
+    nx = domain.nx + 2*domain.cpml
+    nz = domain.nz + 2*domain.cpml
+    if domain.dim == 2.5:
+        ny = domain.ny + 2*domain.cpml
+        deltamin = np.min([domain.dx, domain.dy, domain.dz]) 
+    else:
+        deltamin = np.min([domain.dx, domain.dz]) 
+
+    # Allocate space
+    if direction == 'x':
+        N = int(nx)
+        dx = float(domain.dx)
+    elif direction == 'y':
+        N = int(ny)
+        dx = float(domain.dy) 
+    else:
+        N = int(nz)
+        dx = float(domain.dz)
+    
+    # -----------------------------------------------------------------------------
+    # Compute the distance along the absorbing boundary relative to the end of the 
+    # original model space. 
+    dist = dx * np.arange(0, domain.cpml)
+    if half:
+        dist = dist + dx/2 
+
+    dist = dx*domain.cpml - dist
+    dist = dist/(dx*domain.cpml)
+
+    quasi_cp_max = 0.7* deltamin / (2.0 * modelclass.dt)
+    alpha_max = np.pi*modelclass.f0
+    if seismic:
+        sig_max = - np.log(Rcoef) * (NP+1) * quasi_cp_max / (2.0 * domain.cpml )
+    else:
+        sig_max = 0.7 * (NP+1) / (dx * np.sqrt(mu0/eps0) )
+
+    kappa = np.ones([N])
+    alpha = np.zeros([N])
+    sigma = np.zeros([N])
+    acoeff = np.zeros([N])
+    bcoeff = np.zeros([N])
+
+    # Compute in the x, and z directions
+    for ind in range(0, domain.cpml):
+        # From 0
+        sigma[ind] = sig_max*dist[ind]**NP
+        kappa[ind] = 1.0 + (k_max - 1.0) * dist[ind]**NP
+        alpha[ind] = alpha_max * (1 - dist[ind])**NPA
+        sigma[-(ind+1)] = sig_max*dist[ind]**NP
+        kappa[-(ind+1)] = 1 + (k_max - 1) * dist[ind]**NP
+        alpha[-(ind+1)] = alpha_max * (1 - dist[ind])**NPA
+        bcoeff[-(ind+1)] = np.exp(- (sigma[-(ind+1)] / kappa[-(ind+1)] + alpha[-(ind+1)]) * modelclass.dt)
+        bcoeff[ind] = np.exp( - (sigma[ind] / kappa[ind] + alpha[ind]) * modelclass.dt)
+
+    # Compute the a-coefficients 
+    alpha[np.where(alpha < 0.0)] = 0.0
+    indices = np.where(np.abs(sigma) > 1.0e-6)
+    acoeff[indices] = sigma[indices] * (bcoeff[indices] - 1) / \
+            (kappa[indices] * sigma[indices] + kappa[indices] * alpha[indices] )
+
+    # Save the results to a fortran binary
+    if half:
+        sigma.tofile('sigma' + direction + '_half_cpml.dat')
+        kappa.tofile('kappa' + direction + '_half_cpml.dat')
+        alpha.tofile('alpha' + direction + '_half_cpml.dat')
+        acoeff.tofile('acoef' + direction + '_half_cpml.dat')
+        bcoeff.tofile('bcoef' + direction + '_half_cpml.dat')
+    else:
+        sigma.tofile('sigma' + direction + '_cpml.dat')
+        kappa.tofile('kappa' + direction + '_cpml.dat')
+        alpha.tofile('alpha' + direction + '_cpml.dat')
+        acoeff.tofile('acoef' + direction + '_cpml.dat')
+        bcoeff.tofile('bcoef' + direction + '_cpml.dat')
+
+# ================================== SEISMIC ==================================
+def runseismic(
+        modelclass: Model, 
+        material: Material, 
+        domain: Domain, 
+        single_precision: bool = True
+    ) -> None:
+    """
+    Runs the seismic model using the initialized modelclass, material, and domain.
+
+    :param modelclass: The seismic model class instance.
+    :param material: The material class instance.
+    :param domain: The domain class instance.
+    :param single_precision: Flag for single precision data processing.
+    :type modelclass: Model
+    :type material: Material
+    :type domain: Domain
+    :type single_precision: bool
+    """
+
+    modelclass, domain = prepme(modelclass, domain, complex_tensor = False)
+    direction = ['x', 'y', 'z']
+    # Compute CPML
+    print(direction)
+    print('computing cpml')
+    for d in direction:
+        cpmlcompute(modelclass, domain, d, seismic = True)
+        cpmlcompute(modelclass, domain, d, half = True, seismic = True)
+    
+    # We need to set a density gradient at air interfaces because high
+    # density gradients lead to numerical instability
+    rhograd = airsurf(material, domain, 2)
+    # Write the coefficient images to a fortran file
+    
+    # Create the stiffness .dat files
+    cpmlfdtd.stiffness_write(
+        domain.geometry + 1,
+        modelclass.tensor_coefficients,
+        domain.cpml,
+        rhograd,
+        domain.nx,
+        domain.nz
+    )
+    # attenuation_coefficients = modelclass.attenuation_coefficients * \
+    #     modelclass.dt / (np.ones([domain.nmats, 3]) * \
+    #         modelclass.attenuation_coefficients.astype(float) ).T
+    # Create the attenuation .dat files
+    cpmlfdtd.attenuation_write(
+        domain.geometry + 1,
+        modelclass.attenuation_coefficients,
+        domain.cpml,
+        # domain.nx, 
+        # domain.nz,
+        domain.cpml_attenuation
+    )
+    
+    if domain.dim == 2.5:
+        print('Running 2.5D model')
+        # Run the FDTD
+        cpmlfdtd.seismic25(
+            domain.nx + 2*domain.cpml, 
+            domain.ny + 2*domain.cpml, 
+            domain.nz + 2*domain.cpml,
+            domain.dx, domain.dy, domain.dz,
+            domain.cpml,
+            modelclass.src,
+            modelclass.time_steps,
+            single_precision
+        )
+    else:
+            print('Running 2D model')
+            cpmlfdtd.seismic2(
+                domain.nx + 2*domain.cpml, 
+                domain.nz + 2*domain.cpml,
+                domain.dx, domain.dz,
+                domain.cpml,
+                modelclass.src,
+                modelclass.time_steps,
+                single_precision
+            )     
+
+# =============================================================================
+def runelectromag(
+        modelclass: Model, 
+        material: Material, 
+        domain: Domain, 
+        use_complex_equations: bool = False,
+        single_precision: bool = True
+    ) -> None:
+    """
+    Runs the electromagnetic model with options for complex equations and precision.
+
+    :param modelclass: The electromagnetic model class instance.
+    :param material: The material class instance.
+    :param domain: The domain class instance.
+    :param use_complex_equations: Flag to use complex equations in modeling.
+    :param single_precision: Flag for single precision data processing.
+    :type modelclass: Model
+    :type material: Material
+    :type domain: Domain
+    :type use_complex_equations: bool
+    :type single_precision: bool
+    """
+
+    modelclass, domain = prepme(
+        modelclass, domain, complex_tensor = use_complex_equations
+    )
+    direction = ['x', 'y', 'z']
+    # Compute CPML
+    print(direction)
+    print('computing cpml')
+    for d in direction:
+        cpmlcompute(modelclass, domain, d, seismic = False)
+        cpmlcompute(modelclass, domain, d, half = True, seismic = False)
+    
+    if use_complex_equations:
+        cpmlfdtd.permittivity_write_c(
+            domain.geometry+1,
+            modelclass.tensor_coefficients,
+            domain.cpml,
+            domain.nx, 
+            domain.nz
+        )
+        if domain.dim == 2.5:
+            print('Running complex 3D model.')
+            cpmlfdtd.electromag25c(
+                domain.nx + 2*domain.cpml, 
+                domain.ny + 2*domain.cpml, 
+                domain.nz + 2*domain.cpml,
+                domain.dx, domain.dy, domain.dz,
+                domain.cpml,
+                modelclass.src,
+                modelclass.time_steps,
+                single_precision
+            )
+        else:
+            print('Running complex 2D model')
+            cpmlfdtd.electromag2c(
+                domain.nx + 2*domain.cpml,
+                domain.nz + 2*domain.cpml,
+                domain.dx, domain.dz,
+                domain.cpml,
+                modelclass.src,
+                modelclass.time_steps,
+                single_precision
+            )
+    else:  
+        cpmlfdtd.permittivity_write(
+                domain.geometry+1,
+                modelclass.tensor_coefficients.real,
+                domain.cpml,
+                domain.nx, 
+                domain.nz
+            )
+        if domain.dim == 2.5:
+            print('Running 2.5D model')
+            cpmlfdtd.electromag25(
+                domain.nx + 2*domain.cpml, 
+                domain.ny + 2*domain.cpml, 
+                domain.nz + 2*domain.cpml,
+                domain.dx, domain.dy, domain.dz,
+                domain.cpml,
+                modelclass.src,
+                modelclass.time_steps,
+                single_precision
+            )
+        else:
+            print('Running 2D model')
+            cpmlfdtd.electromag2(
+                domain.nx + 2*domain.cpml,
+                domain.nz + 2*domain.cpml,
+                domain.dx, domain.dz,
+                domain.cpml,
+                modelclass.src,
+                modelclass.time_steps,
+                single_precision
+            )
+        
+def main(
+        prjfile: str, 
+        model_type: str, 
+        append_to_prjfile: bool, 
+        pwd: str, 
+        double_precision: bool, 
+        use_complex_equations: bool
+    ) -> None:
+    """
+    Main function orchestrating domain initialization, status checking, and 
+    model execution based on provided command line arguments.
+
+    Initializes the simulation domain and material properties from a project file,
+    checks the status of seismic and electromagnetic models, and runs the specified
+    model(s) with configured settings. The function allows for re-computation and 
+    appending of material coefficients to the project file and supports both
+    seismic and electromagnetic model types with options for precision and complex
+    equations.
+
+    :param prjfile: The path to the project file containing simulation settings.
+    :param model_type: Specifies the type of model to run ('s' for seismic, 'e' 
+                       for electromagnetic).
+    :param append_to_prjfile: Flag indicating whether to append computed coefficients 
+                              to the project file.
+    :param pwd: The working directory where the project file is located.
+    :param double_precision: Flag indicating whether to use double precision for 
+                             simulation outputs.
+    :param use_complex_equations: Flag indicating whether to use complex equations 
+                                  for electromagnetic simulations.
+    :type prjfile: str
+    :type model_type: str
+    :type append_to_prjfile: bool
+    :type pwd: str
+    :type double_precision: bool
+    :type use_complex_equations: bool
+    """
+    domain, material, seismic, electromag = domain_initialization(prjfile)
+    status_check(
+        seismic, 
+        material,
+        domain,
+        prjfile, 
+        seismic=True, 
+        append_to_prjfile = append_to_prjfile
+    )
+    status_check(
+        electromag, 
+        material, 
+        domain,
+        prjfile, 
+        seismic=False, 
+        append_to_prjfile = append_to_prjfile,
+        use_complex_equations = use_complex_equations
+    )
+    
+    
+    if model_type == 's':
+        runseismic(
+            seismic, material, domain, 
+            double_precision
+        )
+    if model_type == 'e':
+        runelectromag(
+            electromag, material, domain, 
+            use_complex_equations = use_complex_equations, 
+            double_precision = double_precision
+        )
+
+# -------------------------- Command Line Arguments ---------------------------
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(
+        description="""
+        This script will read the parameters given from a project file and run 
+        the specified models. The SeidarT software requires a .PNG image that is used to construct the model domain for seismic and
+        electromagnetic wave propagation. Given the image file, a project file
+        will be constructed which contains all the necessary parameters to be
+        read in to the finite differences time domain modeling schemes."""
+    )
+
+    parser.add_argument(
+        '-p', '--prjfile', nargs=1, type=str, required = True,
+        help='the full file path for the project file', default=None
+    )
+
+    parser.add_argument(
+        '-m', '--model', nargs = 1, type = str, required = False,
+        help = """Specify whether to run the seismic (s), or electromagnetic (e), 
+        or none (default = n)""",
+        default = 'n'
+    )
+
+    parser.add_argument(
+        '-a', '--append',
+        action='store_true', required = False,
+        help = """Append/recompute the coefficients to the permittivity and
+        stiffness matrices; DEFAULT is True"""
+    )
+    
+    parser.add_argument(
+        '-d', '--double_precision', 
+        action='store_false', required = False,
+        help = """Specify double precision output of the simulation. If 
+        complex, the outputs are real valued of each of the components of the 
+        complex value. The default is True."""
+    )
+    
+    parser.add_argument(
+        '-c', '--use_complex_equations', action = 'store_true', required = False,
+        help = """Flag whether to use the complex permittivity in the model
+        simulation. The complex permittivity will be computed for ice and snow
+        in all situations, but unless specified here, the complex permittivity 
+        will only be used to compute the conductivity."""
+    )
+    
+    parser.add_argument(
+        '-o', '--output_directory_path', required = False, 
+        nargs = 1, type = str, 
+        help = '''Specify the output directory folder path to write the Fortran
+        outputs to. '''
+    )
+    # parser.add_argument(
+    #     '-A', '--attenuation', action='store_true', required = False,
+    #     help = """Specify whether to include attenuation in the model. The 
+    #     default is False."""
+    # )
+
+    # Get the arguments
+    args = parser.parse_args()
+    prjfile = ''.join(args.prjfile)
+    model_type = ''.join(args.model)
+    append_to_prjfile = args.append
+    pwd = os.path.dirname(prjfile)
+    double_precision = args.double_precision
+    use_complex_equations = args.use_complex_equations
+     
+    # attenuation = args.attenuation
+    #
+    main(
+        prjfile, 
+        model_type, 
+        append_to_prjfile, 
+        pwd, 
+        double_precision, 
+        use_complex_equations
     )
```

## seidart/routines/sourcefunction.py

 * *Ordering differences only*

```diff
@@ -1,284 +1,284 @@
-
-import argparse
-import numpy as np 
-from seidart.routines.definitions import *
-from scipy import signal
-import matplotlib.pyplot as plt 
-from scipy.io import FortranFile 
-import scipy.signal
-from typing import Tuple 
-
-# ================================ Definitions ================================
-def wavelet(timevec: np.ndarray, f: float, stype: str) -> np.ndarray:
-    """
-    Generates a wavelet based on the specified type and parameters.
-    
-    :param timevec: The time vector for the wavelet.
-    :param f: The center frequency of the wavelet.
-    :param stype: The type of wavelet to generate. Options include 'gaus0', 
-                    'gaus1', 'gaus2', 'chirp', and 'chirplet'.
-    :type timevec: np.ndarray
-    :type f: float
-    :type stype: str
-    :return: The generated wavelet.
-    :rtype: np.ndarray
-    """
-    
-    # Create the wavelet given the parameters
-    a = np.pi**2 * f**2
-    to = 1/f
-    if stype == 'gaus0':
-        x = np.exp(-a*(timevec - to)**2)
-    if stype == "gaus1":
-        x = - 2.0 * a * (timevec - to) * np.exp(-a * ((timevec - to)**2))    
-    if stype == "gaus2":
-        x = 2.0 * a * np.exp(-a * (timevec - to)**2) * (2.0 * a * (timevec - to)**2 - 1)
-    if stype == "chirp":
-        f
-        x = signal.chirp(timevec, 10*f, to, f, phi = -90)    
-    if stype == "chirplet":
-        x = signal.chirp(timevec, f, to, 20*f, phi = -90)
-        g = np.exp(-(a/4)*(timevec - to)**2)
-        x = x * g        
-    x = x/x.max()
-    return(x)
-
-def multimodesrc(timevec: np.ndarray, f: float, stype: str) -> np.ndarray:
-    """
-    Creates a multi-mode source by linearly combining wavelets at different 
-    frequencies.
-    
-    :param timevec: The time vector for the source.
-    :param f: The center frequency around which the modes are generated.
-    :param stype: The type of wavelet to use for each mode.
-    :type timevec: np.ndarray
-    :type f: float
-    :type stype: str
-    :return: The combined multi-mode source.
-    :rtype: np.ndarray
-    """
-    # Create a double octave sweep centered at f0 from the addition of multiple
-    # sources. 
-    # The change will be linear in 1/8 octave steps
-    fmin = f0/4 
-    fmax = f0
-    df = (f0 - f0/2)/8
-    f = np.arange(fmin, fmax, df)
-    stf = np.zeros([len(timevec)])
-    for freq in f:
-        stf = stf + wavelet(timevec, freq, stype)
-    return(stf)
-
-def plotsource(t: np.ndarray, x: np.ndarray) -> Tuple[plt.Figure, np.ndarray]:
-    """
-    Plots the source function and its power spectrum.
-    
-    :param t: The time vector corresponding to the source function.
-    :param x: The source function.
-    :type t: np.ndarray
-    :type x: np.ndarray
-    :return: A tuple containing the matplotlib figure and axes array.
-    :rtype: Tuple[plt.Figure, np.ndarray]
-    """
-    fs = 1/np.mean(np.diff(t) )
-    f, pxx = signal.welch(x, fs = fs)
-    db = 10*np.log10(pxx)
-    fig, ax = plt.subplots(2)
-    ax[0].plot(t, x, '-b')
-    ax[0].set( xlabel = 'Time (s)', ylabel= 'Amplitude')
-    ax[1].plot(f, db, '-b')
-    ax[1].set(xlabel = 'Frequency (Hz)', ylabel = 'Power (dB)')
-    ax[1].set_xlim([f.min(), np.min([20*f0, f.max()])] )
-    return(fig,ax)
-
-def writesrc(fn: str, srcarray: np.ndarray) -> None:
-    """
-    Writes a source array to a Fortran-formatted binary file.
-    
-    :param fn: The filename for the output file.
-    :param srcarray: The source array to write.
-    :type fn: str
-    :type srcarray: np.ndarray
-    """
-    f = FortranFile(fn, 'w')
-    f.write_record(srcarray)
-    f.close()
-
-def sourcefunction(
-        modelclass: Model, 
-        factor: float, 
-        source_type: str, 
-        model_type: str, 
-        multimodal: bool = False
-    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
-    """
-    Generates a source function based on the provided model class and parameters.
-    
-    :param modelclass: The model class containing time steps, frequency, and 
-        orientation.
-    :param factor: Amplitude scaling factor for the source.
-    :param source_type: The type of source to generate.
-    :param model_type: Specifies whether the source is for a seismic ('s') or 
-        electromagnetic ('e') model.
-    :param multimodal: Whether to generate a multimodal source. Defaults to False.
-    :type modelclass: Model
-    :type factor: float
-    :type source_type: str
-    :type model_type: str
-    :type multimodal: bool
-    :return: A tuple containing the time vector and the x, y, z components of 
-        the force, along with the source function.
-    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]
-    """
-    # Create the source 
-    N = int(modelclass.time_steps)
-    timevec = np.linspace(1, N, num = N ) * \
-        float(modelclass.dt)
-    f0 = float(modelclass.f0)
-    
-    # Create the source function
-    if multimodal:
-        srcfn = factor * multimodesrc(timevec, f0, source_type)
-    else:
-        srcfn = factor * wavelet(timevec, f0, source_type)
-    # rotate 
-    theta = np.pi * modelclass.theta * 180
-    phi = np.pi * modelclass.phi * 180
-    forcex = np.sin( theta ) * np.cos( phi ) * srcfn
-    forcey = np.sin( theta ) * np.sin( phi ) * srcfn
-    forcez = np.cos( theta ) * srcfn
-    if model_type == 's' or model_type == 'seismic':
-        writesrc("seismicsourcex.dat", forcex)
-        writesrc("seismicsourcey.dat", forcey)
-        writesrc("seismicsourcez.dat", forcez)
-    if model_type == 'e' or model_type == 'electromag':
-        writesrc("electromagneticsourcex.dat", forcex)
-        writesrc("electromagneticsourcey.dat", forcey)
-        writesrc("electromagneticsourcez.dat", forcez)
-    return(timevec, forcex, forcey, forcez, srcfn)
-
-def main(
-        prjfile: str, 
-        source_type: str, 
-        factor: float, 
-        model_type: str,
-        multimodal: bool, 
-        make_plot: bool
-    ) -> None:
-    """
-    Main function to generate and optionally plot a source function based on 
-    input parameters.
-    
-    :param prjfile: Path to the project file.
-    :param source_type: Type of the source function to generate.
-    :param factor: Amplitude scaling factor for the source.
-    :param model_type: Specifies the model type ('s' for seismic, 'e' for 
-        electromagnetic).
-    :param multimodal: Indicates if a multimodal source should be generated. 
-        Defaults to False.
-    :param make_plot: Whether to plot the generated source function. Defaults 
-        to False.
-    :type prjfile: str
-    :type source_type: str
-    :type factor: float
-    :type model_type: str
-    :type multimodal: bool
-    :type make_plot: bool
-    """
-    # Load the project file 
-    # Let's initiate the domain
-    domain, material, seismic, electromag = loadproject(
-        prjfile, 
-        Domain(), 
-        Material(), 
-        Model(), 
-        Model()
-    )
-    if model_type == 's' or model_type == 'seismic':
-        timevec, fx, fy, fz, srcfn = sourcefunction(
-            seismic, 
-            factor, 
-            source_type, 
-            model_type, 
-            multimodal = multimodal
-        )
-    if model_type == 'e' or model_type == 'electromagnetic':
-        timevec, fx, fy, fz, srcfn = sourcefunction(
-            electromag, 
-            factor, 
-            source_type, 
-            model_type, 
-            multimodal = multimodal
-        )
-    if make_plot:
-        plotsource(timevec, srcfn)
-        plt.show()
-
-# --------------------------- Command Line Arguments --------------------------
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(
-        description = """We support building a few different source time 
-        functions and writing them to a text file. From a specified project 
-        file we can create the time series for a source function and save it 
-        in a Fortran formatted .dat file. The default is an impulse function 
-        with center frequency f0, but we can also generate other wavelets and 
-        chirplets.
-        """
-    )
-    
-    parser.add_argument(
-        '-p', '--projectfile', nargs = 1, type = str, required = True,
-        help = """The path to the project file"""
-    )
-    
-    parser.add_argument(
-        '-S', '--sourcetype', nargs = 1, type = str, required = False, 
-        default = "gaus0",
-        help = """Specify the source type. Available wavelets are: 
-        gaus0, gaus1, gaus2 (gaussian n-th derivative), chirp, chirplet, 
-        multimodal. (Default = gaus0)"""
-    )
-    
-    parser.add_argument(
-        '-m', '--modeltype', nargs = 1, type = str, required = False, 
-        default = 's',
-        help = """Specify whether to construct the source for an em or seismic
-        model. s-seismic, e-electromagnetic, b-both"""
-    )
-    
-    parser.add_argument(
-        '-a', '--amplitude', nargs = 1, type = float, required = False,
-        default = 1.0,
-        help = """Input the scalar factor for source amplification. 
-        (Default = 1.0)"""
-    )
-    
-    parser.add_argument(
-        '-M', '--multimodal', action='store_true',
-        help = """Multimodal source is computed across 2 octaves at 1/8 steps 
-        and centered at f0 """
-    )
-    
-    parser.add_argument(
-        '-P', '--plot', action='store_true',
-        help = """Plot the source and spectrum"""
-    )
-    
-    args = parser.parse_args()
-    prjfile = ''.join(args.projectfile)
-    source_type = ''.join(args.sourcetype)
-    factor = args.amplitude[0]
-    model_type = ''.join(args.modeltype)
-    multimodal = args.multimodal 
-    make_plot = args.plot
-    #
-    
-    main(prjfile, source_type, factor, model_type, multimodal, make_plot)
-    
-
-
-
-
-
-
-
+
+import argparse
+import numpy as np 
+from seidart.routines.definitions import *
+from scipy import signal
+import matplotlib.pyplot as plt 
+from scipy.io import FortranFile 
+import scipy.signal
+from typing import Tuple 
+
+# ================================ Definitions ================================
+def wavelet(timevec: np.ndarray, f: float, stype: str) -> np.ndarray:
+    """
+    Generates a wavelet based on the specified type and parameters.
+    
+    :param timevec: The time vector for the wavelet.
+    :param f: The center frequency of the wavelet.
+    :param stype: The type of wavelet to generate. Options include 'gaus0', 
+                    'gaus1', 'gaus2', 'chirp', and 'chirplet'.
+    :type timevec: np.ndarray
+    :type f: float
+    :type stype: str
+    :return: The generated wavelet.
+    :rtype: np.ndarray
+    """
+    
+    # Create the wavelet given the parameters
+    a = np.pi**2 * f**2
+    to = 1/f
+    if stype == 'gaus0':
+        x = np.exp(-a*(timevec - to)**2)
+    if stype == "gaus1":
+        x = - 2.0 * a * (timevec - to) * np.exp(-a * ((timevec - to)**2))    
+    if stype == "gaus2":
+        x = 2.0 * a * np.exp(-a * (timevec - to)**2) * (2.0 * a * (timevec - to)**2 - 1)
+    if stype == "chirp":
+        f
+        x = signal.chirp(timevec, 10*f, to, f, phi = -90)    
+    if stype == "chirplet":
+        x = signal.chirp(timevec, f, to, 20*f, phi = -90)
+        g = np.exp(-(a/4)*(timevec - to)**2)
+        x = x * g        
+    x = x/x.max()
+    return(x)
+
+def multimodesrc(timevec: np.ndarray, f: float, stype: str) -> np.ndarray:
+    """
+    Creates a multi-mode source by linearly combining wavelets at different 
+    frequencies.
+    
+    :param timevec: The time vector for the source.
+    :param f: The center frequency around which the modes are generated.
+    :param stype: The type of wavelet to use for each mode.
+    :type timevec: np.ndarray
+    :type f: float
+    :type stype: str
+    :return: The combined multi-mode source.
+    :rtype: np.ndarray
+    """
+    # Create a double octave sweep centered at f0 from the addition of multiple
+    # sources. 
+    # The change will be linear in 1/8 octave steps
+    fmin = f0/4 
+    fmax = f0
+    df = (f0 - f0/2)/8
+    f = np.arange(fmin, fmax, df)
+    stf = np.zeros([len(timevec)])
+    for freq in f:
+        stf = stf + wavelet(timevec, freq, stype)
+    return(stf)
+
+def plotsource(t: np.ndarray, x: np.ndarray) -> Tuple[plt.Figure, np.ndarray]:
+    """
+    Plots the source function and its power spectrum.
+    
+    :param t: The time vector corresponding to the source function.
+    :param x: The source function.
+    :type t: np.ndarray
+    :type x: np.ndarray
+    :return: A tuple containing the matplotlib figure and axes array.
+    :rtype: Tuple[plt.Figure, np.ndarray]
+    """
+    fs = 1/np.mean(np.diff(t) )
+    f, pxx = signal.welch(x, fs = fs)
+    db = 10*np.log10(pxx)
+    fig, ax = plt.subplots(2)
+    ax[0].plot(t, x, '-b')
+    ax[0].set( xlabel = 'Time (s)', ylabel= 'Amplitude')
+    ax[1].plot(f, db, '-b')
+    ax[1].set(xlabel = 'Frequency (Hz)', ylabel = 'Power (dB)')
+    ax[1].set_xlim([f.min(), np.min([20*f0, f.max()])] )
+    return(fig,ax)
+
+def writesrc(fn: str, srcarray: np.ndarray) -> None:
+    """
+    Writes a source array to a Fortran-formatted binary file.
+    
+    :param fn: The filename for the output file.
+    :param srcarray: The source array to write.
+    :type fn: str
+    :type srcarray: np.ndarray
+    """
+    f = FortranFile(fn, 'w')
+    f.write_record(srcarray)
+    f.close()
+
+def sourcefunction(
+        modelclass: Model, 
+        factor: float, 
+        source_type: str, 
+        model_type: str, 
+        multimodal: bool = False
+    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
+    """
+    Generates a source function based on the provided model class and parameters.
+    
+    :param modelclass: The model class containing time steps, frequency, and 
+        orientation.
+    :param factor: Amplitude scaling factor for the source.
+    :param source_type: The type of source to generate.
+    :param model_type: Specifies whether the source is for a seismic ('s') or 
+        electromagnetic ('e') model.
+    :param multimodal: Whether to generate a multimodal source. Defaults to False.
+    :type modelclass: Model
+    :type factor: float
+    :type source_type: str
+    :type model_type: str
+    :type multimodal: bool
+    :return: A tuple containing the time vector and the x, y, z components of 
+        the force, along with the source function.
+    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]
+    """
+    # Create the source 
+    N = int(modelclass.time_steps)
+    timevec = np.linspace(1, N, num = N ) * \
+        float(modelclass.dt)
+    f0 = float(modelclass.f0)
+    
+    # Create the source function
+    if multimodal:
+        srcfn = factor * multimodesrc(timevec, f0, source_type)
+    else:
+        srcfn = factor * wavelet(timevec, f0, source_type)
+    # rotate 
+    theta = np.pi * modelclass.theta * 180
+    phi = np.pi * modelclass.phi * 180
+    forcex = np.sin( theta ) * np.cos( phi ) * srcfn
+    forcey = np.sin( theta ) * np.sin( phi ) * srcfn
+    forcez = np.cos( theta ) * srcfn
+    if model_type == 's' or model_type == 'seismic':
+        writesrc("seismicsourcex.dat", forcex)
+        writesrc("seismicsourcey.dat", forcey)
+        writesrc("seismicsourcez.dat", forcez)
+    if model_type == 'e' or model_type == 'electromag':
+        writesrc("electromagneticsourcex.dat", forcex)
+        writesrc("electromagneticsourcey.dat", forcey)
+        writesrc("electromagneticsourcez.dat", forcez)
+    return(timevec, forcex, forcey, forcez, srcfn)
+
+def main(
+        prjfile: str, 
+        source_type: str, 
+        factor: float, 
+        model_type: str,
+        multimodal: bool, 
+        make_plot: bool
+    ) -> None:
+    """
+    Main function to generate and optionally plot a source function based on 
+    input parameters.
+    
+    :param prjfile: Path to the project file.
+    :param source_type: Type of the source function to generate.
+    :param factor: Amplitude scaling factor for the source.
+    :param model_type: Specifies the model type ('s' for seismic, 'e' for 
+        electromagnetic).
+    :param multimodal: Indicates if a multimodal source should be generated. 
+        Defaults to False.
+    :param make_plot: Whether to plot the generated source function. Defaults 
+        to False.
+    :type prjfile: str
+    :type source_type: str
+    :type factor: float
+    :type model_type: str
+    :type multimodal: bool
+    :type make_plot: bool
+    """
+    # Load the project file 
+    # Let's initiate the domain
+    domain, material, seismic, electromag = loadproject(
+        prjfile, 
+        Domain(), 
+        Material(), 
+        Model(), 
+        Model()
+    )
+    if model_type == 's' or model_type == 'seismic':
+        timevec, fx, fy, fz, srcfn = sourcefunction(
+            seismic, 
+            factor, 
+            source_type, 
+            model_type, 
+            multimodal = multimodal
+        )
+    if model_type == 'e' or model_type == 'electromagnetic':
+        timevec, fx, fy, fz, srcfn = sourcefunction(
+            electromag, 
+            factor, 
+            source_type, 
+            model_type, 
+            multimodal = multimodal
+        )
+    if make_plot:
+        plotsource(timevec, srcfn)
+        plt.show()
+
+# --------------------------- Command Line Arguments --------------------------
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(
+        description = """We support building a few different source time 
+        functions and writing them to a text file. From a specified project 
+        file we can create the time series for a source function and save it 
+        in a Fortran formatted .dat file. The default is an impulse function 
+        with center frequency f0, but we can also generate other wavelets and 
+        chirplets.
+        """
+    )
+    
+    parser.add_argument(
+        '-p', '--projectfile', nargs = 1, type = str, required = True,
+        help = """The path to the project file"""
+    )
+    
+    parser.add_argument(
+        '-S', '--sourcetype', nargs = 1, type = str, required = False, 
+        default = "gaus0",
+        help = """Specify the source type. Available wavelets are: 
+        gaus0, gaus1, gaus2 (gaussian n-th derivative), chirp, chirplet, 
+        multimodal. (Default = gaus0)"""
+    )
+    
+    parser.add_argument(
+        '-m', '--modeltype', nargs = 1, type = str, required = False, 
+        default = 's',
+        help = """Specify whether to construct the source for an em or seismic
+        model. s-seismic, e-electromagnetic, b-both"""
+    )
+    
+    parser.add_argument(
+        '-a', '--amplitude', nargs = 1, type = float, required = False,
+        default = 1.0,
+        help = """Input the scalar factor for source amplification. 
+        (Default = 1.0)"""
+    )
+    
+    parser.add_argument(
+        '-M', '--multimodal', action='store_true',
+        help = """Multimodal source is computed across 2 octaves at 1/8 steps 
+        and centered at f0 """
+    )
+    
+    parser.add_argument(
+        '-P', '--plot', action='store_true',
+        help = """Plot the source and spectrum"""
+    )
+    
+    args = parser.parse_args()
+    prjfile = ''.join(args.projectfile)
+    source_type = ''.join(args.sourcetype)
+    factor = args.amplitude[0]
+    model_type = ''.join(args.modeltype)
+    multimodal = args.multimodal 
+    make_plot = args.plot
+    #
+    
+    main(prjfile, source_type, factor, model_type, multimodal, make_plot)
+    
+
+
+
+
+
+
+
```

## seidart/simulations/common_offset.py

```diff
@@ -1,206 +1,214 @@
-import numpy as np
-import pandas as pd
-from seidart.routines.definitions import *
-from seidart.routines import prjrun, sourcefunction
-from seidart.routines.definitions import Domain, Material, Model
-from seidart.routines.arraybuild import Array
-from glob2 import glob 
-import os
-
-# =============================================================================
-class CommonOffset(Array):
-    """
-    Utilize the Array class to build a common offset image from a .prj file and 
-    a source location file. If offsets are not provided then a receiver file 
-    must be provided that coincides with the source file.
-
-    The 
-    """
-    def __init__(
-            self, source_file: str, 
-            channel: str,
-            prjfile: str, 
-            receiver_file: str,
-            receiver_indices: bool = False, 
-            single_precision: bool = True,
-            is_complex: bool = False
-        ): #*args, **kwargs) -> None:
-        """
-        Initialize the CommonOffset object. A receiver file must be provided 
-        that coincides with the source file.
-
-        :param source_file: The source file that contains the source locations
-        :type source_file: str
-        :param args: Additional positional arguments inherited from the Array 
-            class.
-        :type args: tuple
-        :param kwargs: Additional keyword arguments inherited from the Array 
-            class.
-        :type kwargs: dict
-
-        """
-        # super().__init__(source_file, *args, **kwargs) 
-        self.source_file = source_file
-        self.prjfile = prjfile
-        self.channel = channel
-        self.receiver_file = receiver_file
-        self.receiver_indices = receiver_indices
-        self.single_precision = single_precision    
-        self.is_complex = is_complex
-        self.gain = 100
-        self.exaggeration = 0.5
-        self.build()
-
-    def build(self) -> None:
-        """
-        Constructs domain and models based on project file and sets up source 
-        and receiver configurations.
-        """
-        self.domain, self.material, self.seismic, self.electromag = loadproject(
-            self.prjfile,
-            Domain(), 
-            Material(),
-            Model(),
-            Model()
-        )
-        if self.channel in ['Vx','Vy','Vz']:
-            self.is_seismic = True
-            self.dt = self.seismic.dt 
-        else:
-            self.is_seismic = False
-            self.dt = self.electromag.dt
-        
-         
-        # Load the source and receiver locations
-        self.source_receiver_xyz()
-
-        # Copy the receiver_xyz to the variable receiver_xyz_all because we 
-        # will modify the receiver_xyz variable
-        self.receiver_xyz_all = self.receiver_xyz.copy()
-        self.receiver_xyz = np.empty((0,3))
-
-    def source_receiver_xyz(self):
-        """
-        Loads and sorts receiver and source locations from a file and adjusts them 
-        according to the domain and CPML layer. 
-        """
-        
-        self.source_xyz = pd.read_csv(self.source_file)
-        self.receiver_xyz = pd.read_csv(self.receiver_file)
-        
-        # We need to make sure the receivers are ordered correctly and the 
-        # absorbing boundary is corrected for
-        # First check to see if the inputs are indices or
-        cpml = int(self.domain.cpml)
-        
-        
-        self.source_xyz = self.source_xyz.to_numpy() 
-        self.receiver_xyz = self.receiver_xyz.to_numpy()
-        if self.receiver_xyz.shape[1] == 1:
-            self.receiver_xyz = self.receiver_xyz.T
-        
-        # We want to make sure the shape of the self.receiver_xyz array is in 
-        # the correct shape. We won't be able to differentiate if the array is 
-        # in correct shape if it is 3x3
-        if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) > 9:
-            self.receiver_xyz = self.receiver_xyz.T
-        if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) == 6:
-            self.receiver_xyz = self.receiver_xyz.T
-        
-        # If the receiver file contains values that are relative to the 
-        # cartesian space of the domain, we want to change them to the indices
-        # of the 
-        if not self.receiver_indices:
-            self.receiver_xyz = self.receiver_xyz / \
-                np.array(
-                    [
-                        float(self.domain.dx), 
-                        float(self.domain.dy), 
-                        float(self.domain.dz) 
-                    ]
-                )
-            self.receiver_xyz.astype(int)
-        
-        self.source_xyz = self.source_xyz
-        self.receiver_xyz = self.receiver_xyz + cpml
-    
-    def co_run(self, seismic: bool = True) -> None:
-        """
-        Run the electromagnetic or seismic model and extract the receiver 
-        time series
-
-        :param seismic: If True, run the seismic model. If False, run the 
-            electromagnetic model.
-        :type seismic: bool
-
-        """
-        self.timevec, self.fx, self.fy, self.fz, self.srcfn = sourcefunction(
-            self.electromag, 1e7, 'gaus1', 'e'
-        )
-        n = len(self.source_xyz)
-        self.co_image = np.zeros([len(self.timevec), n])
-        self.co_image_complex = self.co_image.copy()
-
-        # Loop through the source locations
-        for i in range(n):
-            self.receiver_xyz = self.receiver_xyz_all[i,:]
-            self.source = self.source_xyz[i,:]
-
-            print(f'Running shot gather for source location {self.source}')
-            # Run the seismic or electromagnetic model
-            if seismic:
-                self.seismic.x = self.source[0]
-                self.seismic.y = self.source[1]
-                self.seismic.z = self.source[2]
-                prjrun.runseismic(self.seismic, self.material, self.domain)
-            else:
-                self.electromag.x = self.source[0]
-                self.electromag.y = self.source[1]
-                self.electromag.z = self.source[2]
-                prjrun.runelectromag(
-                    self.electromag, 
-                    self.material, 
-                    self.domain, 
-                    use_complex_equations = self.is_complex
-                )
-            
-            # Extract the receiver time series
-            self.domain.nx = self.domain.nx + 2 * int(self.domain.cpml)
-            self.domain.nz = self.domain.nz + 2 * int(self.domain.cpml)
-            if self.domain.dim == 2.5:
-                self.domain.ny = self.domain.ny + 2 * int(self.domain.cpml)
-            
-            self.getrcx() 
-            # Put a bandaid on the domain values 
-            self.domain.nx = self.domain.nx - 2 * int(self.domain.cpml)
-            self.domain.nz = self.domain.nz - 2 * int(self.domain.cpml)
-            if self.domain.dim == 2.5:
-                self.domain.ny = self.domain.ny - 2 * int(self.domain.cpml)
-            
-            # Remove all of the files 
-            for file in glob('E*.0*.dat'):
-                try:
-                    os.remove(file) 
-                except OSError as e:
-                    print(f"Error removing file: {e.strerror}")
-                    
-
-            self.co_image[:,i] = self.timeseries
-            # If the desired model is complex, extract the complex time series
-            if self.is_complex:
-                self.co_image_complex[:,i] = self.timeseries_complex
-            
-            # Overwrite the self.timeseries and self.timeseries_complex
-            # variables wth the self.co_image variable
-            self.timeseries = self.co_image
-            self.timeseries_complex = self.co_image_complex
-
-    # def receiver_timeseries(self):
-    #     if self.domain.dim == 2.5:
-    #         all_files = glob(
-    #             self.channel + '*.' + '.'.join(src_ind.astype(str)) + '.dat'
-    #         )
-    #     else: 
-    #         all_files = glob(
-    #             self.channel + '*.' + '.'.join(src_ind[np.array([0,2])].astype(str)) + '..dat'
-    #         )
+import numpy as np
+import pandas as pd
+from seidart.routines.definitions import *
+from seidart.routines import prjrun, sourcefunction
+from seidart.routines.definitions import Domain, Material, Model
+from seidart.routines.arraybuild import Array
+from glob2 import glob 
+import os
+
+# =============================================================================
+class CommonOffset(Array):
+    """
+    Utilize the Array class to build a common offset image from a .prj file and 
+    a source location file. If offsets are not provided then a receiver file 
+    must be provided that coincides with the source file.
+
+    The 
+    """
+    def __init__(
+            self, source_file: str, 
+            channel: str,
+            prjfile: str, 
+            receiver_file: str,
+            receiver_indices: bool = False, 
+            single_precision: bool = True,
+            is_complex: bool = False
+        ): #*args, **kwargs) -> None:
+        """
+        Initialize the CommonOffset object. A receiver file must be provided 
+        that coincides with the source file.
+
+        :param source_file: The source file that contains the source locations
+        :type source_file: str
+        :param channel: The field direction to plot in either V[x,y,z] or E[x,y,z].  
+        :type channel: str
+        :param prjfile: The associated project file. 
+        :type prjfile: str
+        :param receiver_file: The receiver file that contains the receivers locations.
+        :type receiver_file: str
+        :param receiver_indices: If the receiver and source file are provided as indices then this needs to be flagged as True. Default to is in cartesian coordinates.
+        :type receiver_indices: bool
+        :param single_precision: 
+        :type single_precision: bool
+
+        """
+        # super().__init__(source_file, *args, **kwargs) 
+        self.source_file = source_file
+        self.prjfile = prjfile
+        self.channel = channel
+        self.receiver_file = receiver_file
+        self.receiver_indices = receiver_indices
+        self.single_precision = single_precision    
+        self.is_complex = is_complex
+        self.gain = 100
+        self.exaggeration = 0.5
+        self.build()
+
+    def build(self) -> None:
+        """
+        Constructs domain and models based on project file and sets up source 
+        and receiver configurations.
+        """
+        self.domain, self.material, self.seismic, self.electromag = loadproject(
+            self.prjfile,
+            Domain(), 
+            Material(),
+            Model(),
+            Model()
+        )
+        if self.channel in ['Vx','Vy','Vz']:
+            self.is_seismic = True
+            self.dt = self.seismic.dt 
+        else:
+            self.is_seismic = False
+            self.dt = self.electromag.dt
+        
+         
+        # Load the source and receiver locations
+        self.source_receiver_xyz()
+
+        # Copy the receiver_xyz to the variable receiver_xyz_all because we 
+        # will modify the receiver_xyz variable
+        self.receiver_xyz_all = self.receiver_xyz.copy()
+        self.receiver_xyz = np.empty((0,3))
+
+    def source_receiver_xyz(self):
+        """
+        Loads and sorts receiver and source locations from a file and adjusts them 
+        according to the domain and CPML layer. 
+        """
+        
+        self.source_xyz = pd.read_csv(self.source_file)
+        self.receiver_xyz = pd.read_csv(self.receiver_file)
+        
+        # We need to make sure the receivers are ordered correctly and the 
+        # absorbing boundary is corrected for
+        # First check to see if the inputs are indices or
+        cpml = int(self.domain.cpml)
+        
+        
+        self.source_xyz = self.source_xyz.to_numpy() 
+        self.receiver_xyz = self.receiver_xyz.to_numpy()
+        if self.receiver_xyz.shape[1] == 1:
+            self.receiver_xyz = self.receiver_xyz.T
+        
+        # We want to make sure the shape of the self.receiver_xyz array is in 
+        # the correct shape. We won't be able to differentiate if the array is 
+        # in correct shape if it is 3x3
+        if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) > 9:
+            self.receiver_xyz = self.receiver_xyz.T
+        if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) == 6:
+            self.receiver_xyz = self.receiver_xyz.T
+        
+        # If the receiver file contains values that are relative to the 
+        # cartesian space of the domain, we want to change them to the indices
+        # of the 
+        if not self.receiver_indices:
+            self.receiver_xyz = self.receiver_xyz / \
+                np.array(
+                    [
+                        float(self.domain.dx), 
+                        float(self.domain.dy), 
+                        float(self.domain.dz) 
+                    ]
+                )
+            self.receiver_xyz.astype(int)
+        
+        self.source_xyz = self.source_xyz
+        self.receiver_xyz = self.receiver_xyz + cpml
+    
+    def co_run(self, seismic: bool = True) -> None:
+        """
+        Run the electromagnetic or seismic model and extract the receiver 
+        time series
+
+        :param seismic: If True, run the seismic model. If False, run the 
+            electromagnetic model.
+        :type seismic: bool
+
+        """
+        self.timevec, self.fx, self.fy, self.fz, self.srcfn = sourcefunction(
+            self.electromag, 1e7, 'gaus1', 'e'
+        )
+        n = len(self.source_xyz)
+        self.co_image = np.zeros([len(self.timevec), n])
+        self.co_image_complex = self.co_image.copy()
+
+        # Loop through the source locations
+        for i in range(n):
+            self.receiver_xyz = self.receiver_xyz_all[i,:]
+            self.source = self.source_xyz[i,:]
+
+            print(f'Running shot gather for source location {self.source}')
+            # Run the seismic or electromagnetic model
+            if seismic:
+                self.seismic.x = self.source[0]
+                self.seismic.y = self.source[1]
+                self.seismic.z = self.source[2]
+                prjrun.runseismic(self.seismic, self.material, self.domain)
+            else:
+                self.electromag.x = self.source[0]
+                self.electromag.y = self.source[1]
+                self.electromag.z = self.source[2]
+                prjrun.runelectromag(
+                    self.electromag, 
+                    self.material, 
+                    self.domain, 
+                    use_complex_equations = self.is_complex
+                )
+            
+            # Extract the receiver time series
+            self.domain.nx = self.domain.nx + 2 * int(self.domain.cpml)
+            self.domain.nz = self.domain.nz + 2 * int(self.domain.cpml)
+            if self.domain.dim == 2.5:
+                self.domain.ny = self.domain.ny + 2 * int(self.domain.cpml)
+            
+            self.getrcx() 
+            # Put a bandaid on the domain values 
+            self.domain.nx = self.domain.nx - 2 * int(self.domain.cpml)
+            self.domain.nz = self.domain.nz - 2 * int(self.domain.cpml)
+            if self.domain.dim == 2.5:
+                self.domain.ny = self.domain.ny - 2 * int(self.domain.cpml)
+            
+            # Remove all of the files 
+            for file in glob('E*.0*.dat'):
+                try:
+                    os.remove(file) 
+                except OSError as e:
+                    print(f"Error removing file: {e.strerror}")
+                    
+
+            self.co_image[:,i] = self.timeseries
+            # If the desired model is complex, extract the complex time series
+            if self.is_complex:
+                self.co_image_complex[:,i] = self.timeseries_complex
+            
+            # Overwrite the self.timeseries and self.timeseries_complex
+            # variables wth the self.co_image variable
+            self.timeseries = self.co_image
+            self.timeseries_complex = self.co_image_complex
+
+    
+    # def receiver_timeseries(self):
+    #     if self.domain.dim == 2.5:
+    #         all_files = glob(
+    #             self.channel + '*.' + '.'.join(src_ind.astype(str)) + '.dat'
+    #         )
+    #     else: 
+    #         all_files = glob(
+    #             self.channel + '*.' + '.'.join(src_ind[np.array([0,2])].astype(str)) + '..dat'
+    #         )
+
+
+c
```

## seidart/visualization/__init__.py

 * *Ordering differences only*

```diff
@@ -1,2 +1,2 @@
-from . import imgen 
-from . import im2anim 
+from . import imgen 
+from . import im2anim
```

## seidart/visualization/im2anim.py

 * *Ordering differences only*

```diff
@@ -1,204 +1,204 @@
-#!/usr/bin/env python3
-
-# From the set of image outputs, we can build a gif. The images will be in csv
-# or fortran unformatted binary
-
-
-import numpy as np
-from glob2 import glob
-import argparse
-import matplotlib.pyplot as plt
-import matplotlib.image as mpimg
-from scipy.io import FortranFile
-from seidart.visualization.imgen import *
-import os
-import subprocess
-
-# =============================================================================
-def build_animation(
-        prjfile, 
-        channel, 
-        delay, 
-        numsteps, 
-        alpha, 
-        is_complex: bool = False,
-        is_single_precision: bool = True,
-        plottype: str = 'magnitude'
-    ):
-    '''
-    This function builds a gif from the set of images output of the FDTD modeling. 
-    The images can be in csv or unformatted Fortran binary, however, the program 
-    runs faster to use the latter. 
-    
-    :param prjfile: The full file path for the project file.
-    :type prjfile: str
-    :param channel: The channel to be used. Available channels are Ex, Ez, Vx, and Vz 
-                    for the electric field and seismic velocities, respectively.
-    :type channel: str
-    :param delay: The amount of delay between two frames in the GIF animation.
-    :type delay: int
-    :param numsteps: The time step interval between the images to be used. 
-                     For example, n=20 means that every 20th image will be used.
-    :type numsteps: int
-    :param alpha: Change the transparency of the model plotted in the background. 
-                  0 is fully transparent, 1 is fully opaque.
-    :type alpha: float
-    :param is_complex: Flag indicating whether the data will be complex valued. 
-                       If not flagged but the data is complex, only the real part is used.
-    :type is_complex: bool, optional
-    :param is_single_precision: Flag indicating whether the data is in single precision.
-    :type is_single_precision: bool, optional
-    :param plottype: The type of plot to generate. Valid inputs are 'magnitude', 
-                     'phase' (complex only), and 'energy_density' (complex only) for EM; 
-                     'magnitude' and 'quiver' for seismic.
-    :type plottype: str, optional
-    :return: None
-
-        EM
-        --    
-            'magnitude', 
-            'phase' (complex only), 
-            'energy_density (complex only)'
-        Seismic
-        -------
-            'magnitude',
-            'quiver'
-    
-    Returns
-    -------
-    None
-    '''
-    # Check if the .dat files are still around
-    files = glob(channel + '*.dat')
-    files.sort()
-
-    # We'll start counting with the first frame
-    n=numsteps
-
-    for fn in files:
-        if n == numsteps:
-            mag = FDTDImage(
-                prjfile, fn, 
-                is_complex = is_complex, 
-                is_single_precision = is_single_precision,
-                plottype = plottype
-            )
-            mag.magnitudeplot(alpha = alpha)
-            mag.addlabels()
-            mag.plotfile = 'magnitude.' + fn[:-3] + '.png'
-            plt.savefig(mag.plotfile)
-            plt.close()
-            n = 1
-        else:
-            n = n + 1
-
-
-    print('Creating the GIF')
-    # Use imagemagick via shell command to create the gif
-    shellcommand = 'convert -delay ' + \
-        str(delay) + ' -loop 0 magnitude.' + channel + '*.png ' + \
-            channel + '.gif'
-    subprocess.call(shellcommand, shell = True)
-
-    # Remove the png files 
-    for filepath in glob('magnitude.' + channel + '*.png'):
-        os.remove(filepath)
-        
-
-# -------------------------- Command Line Arguments ---------------------------
-if __name__=="__main__":
-    parser = argparse.ArgumentParser(description="""This program builds a gif from
-        the set of image output of the FDTD modeling. The images can be in csv or
-        unformatted Fortran binary, however, the program runs faster to use the
-        latter. """ )
-
-    parser.add_argument(
-        '-p','--prjfile', 
-        nargs=1, type=str, required = True,
-        help='the full file path for the project file'
-    )
-
-
-    parser.add_argument(
-        '-n', '--num_steps', 
-        nargs = 1, type = int, required = True, 
-        help = """The time step interval between the images that
-        are going to be used. Every time step is written to file which means that
-        we can take any equally spaced images to create the gif with an
-        appropriate resolution, time to compute, and file size. For example,
-        n=20 means that every 20 images will be used thus significantly reducing
-        how long it takes to compile the gif."""
-    )
-
-    parser.add_argument(
-        '-c', '--channel', 
-        nargs = 1, type = str, required = True,
-        help = """Specify whether a particular channel is going to be used. The
-        available channels are Ex, Ez, Vx, and Vz for the electric field and
-        seismic velocities, respectively."""
-    )
-
-    parser.add_argument(
-        '-d', '--delay', 
-        nargs = 1, type = int, required = False, default = [1], 
-        help = """The amount of delay between two frames"""
-    )
-
-    parser.add_argument(
-        '-a', '--alpha',
-        nargs = 1, type = float, required = False, default = [0.3],
-        help = """(OPTIONAL FLOAT [0,1]) Change the transparency of the model 
-        plotted in the background; default = 0.3. Zeros is full transparency, 1 is 
-        CIA transparency."""
-    )
-    
-    parser.add_argument(
-        '-z', '--is_complex', action = 'store_true', required = False,
-        help = """Flag whether the data will be complex valued. If the data is
-        not flagged but is complex, only the real data will be returned. """
-    )
-    
-    parser.add_argument(
-        '-D', '--is_double_precision', action = 'store_false', required = False,
-        help = """Flag whether the data is in double precision."""
-    )
-    
-    parser.add_argument(
-        '-P', '--plot_type', required = False, default = ['magnitude'], 
-        nargs = 1, type = str, 
-        help = """
-        Plot types are different for EM and seismic. Valid inputs are: 
-        
-        EM
-        --    
-            'magnitude', 
-            'phase' (complex only), 
-            'energy_density (complex only)'
-        Seismic
-        -------
-            'magnitude',
-            'quiver'
-        """
-    )
-
-    # Get the arguments
-    args = parser.parse_args()
-    prjfile = ''.join(args.prjfile)
-    channel = ''.join(args.channel)
-    delay = str(args.delay[0])
-    num_steps = args.num_steps[0]
-    alpha = min([1, args.alpha[0]] )
-    is_complex = args.is_complex
-    is_single_precision = args.is_single_precision
-    plot_type = args.plot_type[0]
-    
-    build_animation(
-        prjfile, 
-        channel, 
-        delay, 
-        numsteps, 
-        alpha, 
-        is_complex,
-        is_single_precision,
-        plot_type
+#!/usr/bin/env python3
+
+# From the set of image outputs, we can build a gif. The images will be in csv
+# or fortran unformatted binary
+
+
+import numpy as np
+from glob2 import glob
+import argparse
+import matplotlib.pyplot as plt
+import matplotlib.image as mpimg
+from scipy.io import FortranFile
+from seidart.visualization.imgen import *
+import os
+import subprocess
+
+# =============================================================================
+def build_animation(
+        prjfile, 
+        channel, 
+        delay, 
+        numsteps, 
+        alpha, 
+        is_complex: bool = False,
+        is_single_precision: bool = True,
+        plottype: str = 'magnitude'
+    ):
+    '''
+    This function builds a gif from the set of images output of the FDTD modeling. 
+    The images can be in csv or unformatted Fortran binary, however, the program 
+    runs faster to use the latter. 
+    
+    :param prjfile: The full file path for the project file.
+    :type prjfile: str
+    :param channel: The channel to be used. Available channels are Ex, Ez, Vx, and Vz 
+                    for the electric field and seismic velocities, respectively.
+    :type channel: str
+    :param delay: The amount of delay between two frames in the GIF animation.
+    :type delay: int
+    :param numsteps: The time step interval between the images to be used. 
+                     For example, n=20 means that every 20th image will be used.
+    :type numsteps: int
+    :param alpha: Change the transparency of the model plotted in the background. 
+                  0 is fully transparent, 1 is fully opaque.
+    :type alpha: float
+    :param is_complex: Flag indicating whether the data will be complex valued. 
+                       If not flagged but the data is complex, only the real part is used.
+    :type is_complex: bool, optional
+    :param is_single_precision: Flag indicating whether the data is in single precision.
+    :type is_single_precision: bool, optional
+    :param plottype: The type of plot to generate. Valid inputs are 'magnitude', 
+                     'phase' (complex only), and 'energy_density' (complex only) for EM; 
+                     'magnitude' and 'quiver' for seismic.
+    :type plottype: str, optional
+    :return: None
+
+        EM
+        --    
+            'magnitude', 
+            'phase' (complex only), 
+            'energy_density (complex only)'
+        Seismic
+        -------
+            'magnitude',
+            'quiver'
+    
+    Returns
+    -------
+    None
+    '''
+    # Check if the .dat files are still around
+    files = glob(channel + '*.dat')
+    files.sort()
+
+    # We'll start counting with the first frame
+    n=numsteps
+
+    for fn in files:
+        if n == numsteps:
+            mag = FDTDImage(
+                prjfile, fn, 
+                is_complex = is_complex, 
+                is_single_precision = is_single_precision,
+                plottype = plottype
+            )
+            mag.magnitudeplot(alpha = alpha)
+            mag.addlabels()
+            mag.plotfile = 'magnitude.' + fn[:-3] + '.png'
+            plt.savefig(mag.plotfile)
+            plt.close()
+            n = 1
+        else:
+            n = n + 1
+
+
+    print('Creating the GIF')
+    # Use imagemagick via shell command to create the gif
+    shellcommand = 'convert -delay ' + \
+        str(delay) + ' -loop 0 magnitude.' + channel + '*.png ' + \
+            channel + '.gif'
+    subprocess.call(shellcommand, shell = True)
+
+    # Remove the png files 
+    for filepath in glob('magnitude.' + channel + '*.png'):
+        os.remove(filepath)
+        
+
+# -------------------------- Command Line Arguments ---------------------------
+if __name__=="__main__":
+    parser = argparse.ArgumentParser(description="""This program builds a gif from
+        the set of image output of the FDTD modeling. The images can be in csv or
+        unformatted Fortran binary, however, the program runs faster to use the
+        latter. """ )
+
+    parser.add_argument(
+        '-p','--prjfile', 
+        nargs=1, type=str, required = True,
+        help='the full file path for the project file'
+    )
+
+
+    parser.add_argument(
+        '-n', '--num_steps', 
+        nargs = 1, type = int, required = True, 
+        help = """The time step interval between the images that
+        are going to be used. Every time step is written to file which means that
+        we can take any equally spaced images to create the gif with an
+        appropriate resolution, time to compute, and file size. For example,
+        n=20 means that every 20 images will be used thus significantly reducing
+        how long it takes to compile the gif."""
+    )
+
+    parser.add_argument(
+        '-c', '--channel', 
+        nargs = 1, type = str, required = True,
+        help = """Specify whether a particular channel is going to be used. The
+        available channels are Ex, Ez, Vx, and Vz for the electric field and
+        seismic velocities, respectively."""
+    )
+
+    parser.add_argument(
+        '-d', '--delay', 
+        nargs = 1, type = int, required = False, default = [1], 
+        help = """The amount of delay between two frames"""
+    )
+
+    parser.add_argument(
+        '-a', '--alpha',
+        nargs = 1, type = float, required = False, default = [0.3],
+        help = """(OPTIONAL FLOAT [0,1]) Change the transparency of the model 
+        plotted in the background; default = 0.3. Zeros is full transparency, 1 is 
+        CIA transparency."""
+    )
+    
+    parser.add_argument(
+        '-z', '--is_complex', action = 'store_true', required = False,
+        help = """Flag whether the data will be complex valued. If the data is
+        not flagged but is complex, only the real data will be returned. """
+    )
+    
+    parser.add_argument(
+        '-D', '--is_double_precision', action = 'store_false', required = False,
+        help = """Flag whether the data is in double precision."""
+    )
+    
+    parser.add_argument(
+        '-P', '--plot_type', required = False, default = ['magnitude'], 
+        nargs = 1, type = str, 
+        help = """
+        Plot types are different for EM and seismic. Valid inputs are: 
+        
+        EM
+        --    
+            'magnitude', 
+            'phase' (complex only), 
+            'energy_density (complex only)'
+        Seismic
+        -------
+            'magnitude',
+            'quiver'
+        """
+    )
+
+    # Get the arguments
+    args = parser.parse_args()
+    prjfile = ''.join(args.prjfile)
+    channel = ''.join(args.channel)
+    delay = str(args.delay[0])
+    num_steps = args.num_steps[0]
+    alpha = min([1, args.alpha[0]] )
+    is_complex = args.is_complex
+    is_single_precision = args.is_single_precision
+    plot_type = args.plot_type[0]
+    
+    build_animation(
+        prjfile, 
+        channel, 
+        delay, 
+        numsteps, 
+        alpha, 
+        is_complex,
+        is_single_precision,
+        plot_type
     )
```

## seidart/visualization/imgen.py

```diff
@@ -1,405 +1,408 @@
-#!/usr/bin/env python3
-
-"""
-Functions for plotting a 2D vector/quiver plot over the model image
-"""
-
-import numpy as np 
-import matplotlib.pyplot as plt
-import matplotlib as mpl
-
-import argparse
-from seidart.routines.definitions import *
-import matplotlib.image as mpimg
-
-from glob2 import glob 
-
-# ============================ Create the objects =============================
-class FDTDImage:
-    """
-    A class to represent an FDTD image for visualization.
-
-    This class provides methods to build and manipulate images generated from FDTD modeling.
-
-    :param prjfile: The full file path for the project file.
-    :type prjfile: str
-    :param inputfile: The name of the input file containing simulation data.
-    :type inputfile: str
-    :param is_complex: Indicates if the data is complex valued.
-    :type is_complex: bool
-    :param is_single_precision: Indicates if the data is in single precision format.
-    :type is_single_precision: bool, optional
-    :param plottype: The type of plot to generate ('magnitude', 'quiver', 'phase', 'energy_density').
-    :type plottype: str, optional
-    """
-    def __init__(
-            self, 
-            prjfile, inputfile,
-            is_complex: bool, 
-            is_single_precision: bool = True,
-            plottype: str = 'magnitude'
-        ):
-        self.prjfile = prjfile
-        self.x = None
-        self.z = None
-        self.inputfile = inputfile
-        self.srcx = None
-        self.srcz = None
-        self.channel = None
-        # Plot values
-        self.extent = None
-        self.background = None
-        self.ax = None 
-        self.fig = None
-        self.dx = None 
-        self.dz = None
-        self.nx = None 
-        self.nz = None
-        # Flags
-        self.is_complex = is_complex
-        self.is_single_precision = is_single_precision
-        
-        # Check the inputs that need to be checked
-        if plottype not in [
-            'magnitude', 'quiver', 'phase', 'energy_density'
-        ]:
-            raise ValueError(
-                "plottype must be one of \
-                    'magnitude', 'quiver', 'phase', 'energy_density'"
-            )
-        
-        self.plottype = plottype
-        self.build()
-        self.getprjvals()
-         
-    def build(self):
-        """
-        Builds the domain, material, seismic, and electromagnetic models from the project file.
-        """
-        self.domain, self.material, self.seismic, self.electromag = loadproject(
-            self.prjfile,
-            Domain(), 
-            Material(),
-            Model(),
-            Model()
-        )
-        
-        if self.is_complex:
-            self.imag_part = None
-        
-        # Define the channel given the input file name
-        self.channel = self.inputfile[0:2]
-        if self.plottype == 'quiver':
-            if 'E' in self.channel:
-                self.xfile = 'Ex' + self.inputfile[2:]
-                self.zfile = 'Ez' + self.inputfile[2:]
-            else:
-                self.xfile = 'Vx' + self.inputfile[2:]
-                self.zfile = 'Vz' + self.inputfile[2:]
-            
-        self.plotfile = self.plottype + '.' + self.inputfile[2:-3] + '.png'
-    
-    def getprjvals(self):
-        """
-        Retrieves project values and initializes domain parameters.
-        """
-        # Let's initiate the domain
-        
-        self.domain.cpml = int(self.domain.cpml)
-        self.domain.nx = int(self.domain.nx) + 2*self.domain.cpml
-        self.domain.nz = int(self.domain.nz) + 2*self.domain.cpml
-        self.dx = float(self.domain.dx)
-        self.dz = float(self.domain.dz)
-        # The EM code uses a slightly different mesh
-        if self.channel == 'Ex':
-            self.nx = self.domain.nx - 1
-            self.nz = self.domain.nz
-        if self.channel == 'Ez':
-            self.nz = self.domain.nz - 1
-            self.nx = self.domain.nx
-        
-        self.extent = (
-            -self.domain.cpml, 
-            (self.nx-self.domain.cpml), 
-            (self.nz-self.domain.cpml), 
-            -self.domain.cpml
-        )
-
-        if self.channel == 'Ex' or self.channel == 'Ez':
-            self.srcx = float(self.electromag.x)/self.dx + self.domain.cpml + 1
-            self.srcz = float(self.electromag.z)/self.dz + self.domain.cpml + 1
-        else:    
-            self.srcx = float(self.seismic.x)/self.dx + cpml + 1
-            self.srcz = float(self.seismic.z)/self.dz + cpml + 1
-        
-        # Define tick locations for plotting
-        self.xticklocs = np.array(
-            [
-                0, 
-                (self.nx-2*self.domain.cpml)/4, 
-                int((self.nx-2*self.domain.cpml)/2), 
-                3*(self.nx-2*self.domain.cpml)/4, 
-                self.nx - 2*self.domain.cpml
-            ]
-        )
-        self.yticklocs = np.array(
-            [
-                0, 
-                (self.nz-2*self.domain.cpml)/4, 
-                int((self.nz-2*self.domain.cpml)/2), 
-                3*(self.nz-2*self.domain.cpml)/4, 
-                self.nz - 2*self.domain.cpml
-            ]
-        )
-        # Load the model image and assign variables
-        self.background = mpimg.imread(self.domain.imfile)
-        
-    # -------------------------------------------------------------------------
-    def quiverplot(self, papercolumnwidth: float = 7.2) -> None:
-        """
-        Generates a quiver plot for seismic outputs.
-
-        :param papercolumnwidth: The width of the paper column for the plot.
-        :type papercolumnwidth: float, optional
-        """
-        # buildmesh
-        # Get axes values
-        x = (np.arange(-self.domain.cpml, self.nx-self.domain.cpml))
-        z = (np.arange(-self.domain.cpml, self.nz-self.domain.cpml))
-        # Append the cpml values 
-        x, z = np.meshgrid(x,z)
-
-        u = read_dat(
-            self.xfile, 
-            self.channel[0] + 'x', 
-            self.domain, 
-            is_complex = False, 
-            single = self.is_single_precision
-        )
-        v = read_dat(
-            self.zfile, 
-            self.channel[0] + 'z', 
-            self.domain, 
-            is_complex = False, 
-            single = self.is_single_precision
-        )        
-        # Set the figure size to be for a full two column width
-        
-        # Create the figure and axes objects
-        self.fig = plt.figure(
-            figsize = [
-                papercolumnwidth, 
-                self.nz*papercolumnwidth/self.nx
-            ]
-        )
-        self.ax = plt.gca()
-        
-        # add the model 
-        self.ax.imshow(
-            self.background,
-            alpha = 0.7, 
-            extent=[
-                0, self.nx-2*self.domain.cpml, 
-                self.nz-2*self.domain.cpml, 0
-            ]
-        )
-        
-        # add quiver
-        q = self.ax.quiver(
-            x, z, u, v, 
-            headwidth = 0.5, 
-            headlength = 1,
-            headaxislength = 1, 
-            scale = 16, 
-            minlength = 0.1
-        )
-    
-    # -------------------------------------------------------------------------
-    def magnitudeplot(
-            self, alpha: float = 0.3, papercolumnwidth: float = 7.2
-        ) -> None:
-        """
-        Plots the real data as a magnitude plot.
-
-        :param alpha: Transparency of the model plotted in the background.
-        :type alpha: float, optional
-        :param papercolumnwidth: The width of the paper column for the plot.
-        :type papercolumnwidth: float, optional
-        """
-        dat = read_dat(
-            self.inputfile, 
-            self.channel, 
-            self.domain, 
-            is_complex = self.is_complex, 
-            single = self.is_single_precision
-        )
-        if self.plottype == 'energy_density':
-            # Convert the complex electric field to the 
-            dat = dat.conj() * dat 
-            dat = dat.real
-        elif self.plottype == 'phase':
-            dat = np.angle(dat)
-        else:
-            dat = dat.real
-        
-        self.fig = plt.figure(
-            figsize = [
-                papercolumnwidth, 
-                self.nz*papercolumnwidth/self.nx
-            ]
-        )
-        self.ax = plt.gca()
-        self.ax.imshow(
-            dat, 
-            cmap = 'seismic',
-            extent = self.extent,
-            norm = mpl.colors.CenteredNorm()
-        )
-        self.ax.imshow(
-            self.background,
-            alpha = alpha,
-            extent = [
-                0, self.nx-2*self.domain.cpml, 
-                self.nz-2*self.domain.cpml, 0
-            ]
-        )
-        
-    # -------------------------------------------------------------------------
-    def sliceplot(
-            self, 
-            dat: np.ndarray, 
-            axscale: tuple, 
-            sliceaxes: str, 
-            alpha: float = 0.3, 
-            papercolumnwidth: float = 7.2
-        ) -> None:
-        """
-        Generates a slice plot from the given data.
-
-        :param dat: The data array to plot.
-        :type dat: np.ndarray
-        :param axscale: The scale for the axes.
-        :type axscale: tuple
-        :param sliceaxes: The axes to slice ('xy', 'xz', 'yz').
-        :type sliceaxes: str
-        :param alpha: Transparency of the model plotted in the background.
-        :type alpha: float, optional
-        :param papercolumnwidth: The width of the paper column for the plot.
-        :type papercolumnwidth: float, optional
-        """
-        # sliceaxes is a string that specifies 'xy', 'xz', or 'yz'
-        # All of the slices need to be scaled equally and normalized
-        # axscale = (nz, ny, nx)/max(nz, ny, nx)
-        if sliceaxes == 'xy': # dat dims will be y then x
-            figuredims = [
-                axscale[1]*papercolumnwidth, axscale[2]*papercolumnwidth
-            ]
-            exaggeration = axscale[2]/axscale[1]
-        elif sliceaxes == 'xz': # Dims will be z then x
-            figuredims = [
-                axscale[0]*papercolumnwidth, axscale[2]*papercolumnwidth
-            ]
-            exaggeration = axscale[2]/axscale[0]
-        else:
-            figuredims = [
-                axscale[0]*papercolumnwidth, axscale[1]*papercolumnwidth
-            ]
-            exaggeration = axscale[1]/axscale[0]
-        
-        self.fig = plt.figure(
-            figsize = figuredims
-        )
-        self.ax = plt.gca()
-        self.ax.imshow(
-            dat,
-            cmap = 'seismic', 
-            extent = self.extent,
-            norm = mpl.colors.CenteredNorm()
-        )
-        self.ax.set_aspect(exaggeration)
-        self.ax.imshow(
-            self.background,
-            alpha = alpha,
-            extent = [
-                0, self.nx-2*self.domain.cpml, 
-                self.nz-2*self.domain.cpml, 0
-            ]
-        )
-    
-    # -------------------------------------------------------------------------
-    def imvector(self) -> None:
-        """
-        Generates a vector image from the project values and saves it.
-        """
-        self.getprjvals()
-        self.quiverplot()
-        self.addlabels()
-        plt.savefig(self.plotfile)
-        plt.close()
-    
-    # This is setup for seismic
-    def vectoranim(self, files: list = glob('Vx*.dat')) -> None:
-        """
-        Creates an animation of vector images from a list of files.
-
-        :param files: A list of file names to create the animation from.
-        :type files: list, optional
-        """
-        # Project file needs to already be assigned in the object
-        if self.prjfile:
-            files.sort()
-
-            print('Creating PNG snapshots')
-            # We want to do the first file; initial condition
-            n=num_steps
-            for fn in files:
-                if n == num_steps:
-                    self.inputfile = fn
-                    self.imvector()
-                    n = 1
-                else:
-                    n = n + 1
-            # Create the gif using Imagemagick
-            print('Creating the GIF')
-            call('convert -delay 20 -loop 0 vector.*.png vector.gif', shell = True)
-        else:
-            print('No project file has been assigned')
-    
-    # -------------------------------------------------------------------------
-    
-    # -------------------------------------------------------------------------
-    
-    # -------------------------------------------------------------------------
-    def addlabels(self) -> None:
-        """
-        Adds labels to the plot and updates the axis and figure objects.
-        """
-        # Set axes labels
-        xticklabels = (self.xticklocs)*self.dx
-        yticklabels = (self.yticklocs)*self.dz
-        self.ax.set_xlabel(r'X (m)')
-        self.ax.xaxis.tick_top()
-        self.ax.xaxis.set_label_position('top')
-        self.ax.set_xticks(self.xticklocs)
-        self.ax.set_xticklabels(xticklabels)
-        self.ax.set_ylabel(r'Z (m)')
-        self.ax.set_yticks(self.yticklocs)
-        self.ax.set_yticklabels(yticklabels)
-        
-    def addsource(self) -> None:
-        """
-        Adds the source location to the plot.
-        """
-        # Source location
-        self.ax.scatter(
-            self.srcx, 
-            self.srcz,
-            marker = '*', 
-            s = 30, 
-            linewidths = 1,
-            edgecolor = (0.2, 0.2, 0.2, 1 ) 
-        )
-
-    def addrcx(self):
-        pass 
-    
+#!/usr/bin/env python3
+
+"""
+Functions for plotting a 2D vector/quiver plot over the model image
+"""
+
+import numpy as np 
+import matplotlib.pyplot as plt
+import matplotlib as mpl
+
+import argparse
+from seidart.routines.definitions import *
+import matplotlib.image as mpimg
+
+from glob2 import glob 
+
+# ============================ Create the objects =============================
+class FDTDImage:
+    """
+    A class to represent an FDTD image for visualization.
+
+    This class provides methods to build and manipulate images generated from FDTD modeling.
+
+    :param prjfile: The full file path for the project file.
+    :type prjfile: str
+    :param inputfile: The name of the input file containing simulation data.
+    :type inputfile: str
+    :param is_complex: Indicates if the data is complex valued.
+    :type is_complex: bool
+    :param is_single_precision: Indicates if the data is in single precision format.
+    :type is_single_precision: bool, optional
+    :param plottype: The type of plot to generate ('magnitude', 'quiver', 'phase', 'energy_density').
+    :type plottype: str, optional
+    """
+    def __init__(
+            self, 
+            prjfile, inputfile,
+            is_complex: bool = False, 
+            is_single_precision: bool = True,
+            plottype: str = 'magnitude'
+        ):
+        self.prjfile = prjfile
+        self.x = None
+        self.z = None
+        self.inputfile = inputfile
+        self.srcx = None
+        self.srcz = None
+        self.channel = None
+        # Plot values
+        self.extent = None
+        self.background = None
+        self.ax = None 
+        self.fig = None
+        self.dx = None 
+        self.dz = None
+        self.nx = None 
+        self.nz = None
+        # Flags
+        self.is_complex = is_complex
+        self.is_single_precision = is_single_precision
+        
+        # Check the inputs that need to be checked
+        if plottype not in [
+            'magnitude', 'quiver', 'phase', 'energy_density'
+        ]:
+            raise ValueError(
+                "plottype must be one of \
+                    'magnitude', 'quiver', 'phase', 'energy_density'"
+            )
+        
+        self.plottype = plottype
+        self.build()
+        self.getprjvals()
+         
+    def build(self):
+        """
+        Builds the domain, material, seismic, and electromagnetic models from the project file.
+        """
+        self.domain, self.material, self.seismic, self.electromag = loadproject(
+            self.prjfile,
+            Domain(), 
+            Material(),
+            Model(),
+            Model()
+        )
+        
+        if self.is_complex:
+            self.imag_part = None
+        
+        # Define the channel given the input file name
+        self.channel = self.inputfile[0:2]
+        if self.plottype == 'quiver':
+            if 'E' in self.channel:
+                self.xfile = 'Ex' + self.inputfile[2:]
+                self.zfile = 'Ez' + self.inputfile[2:]
+            else:
+                self.xfile = 'Vx' + self.inputfile[2:]
+                self.zfile = 'Vz' + self.inputfile[2:]
+            
+        self.plotfile = self.plottype + '.' + self.inputfile[2:-3] + '.png'
+    
+    def getprjvals(self):
+        """
+        Retrieves project values and initializes domain parameters.
+        """
+        # Let's initiate the domain
+        
+        self.domain.cpml = int(self.domain.cpml)
+        self.domain.nx = int(self.domain.nx) + 2*self.domain.cpml
+        self.domain.nz = int(self.domain.nz) + 2*self.domain.cpml
+        self.dx = float(self.domain.dx)
+        self.dz = float(self.domain.dz)
+        # The EM code uses a slightly different mesh
+        if self.channel == 'Ex':
+            self.nx = self.domain.nx - 1
+            self.nz = self.domain.nz
+        elif self.channel == 'Ez':
+            self.nz = self.domain.nz - 1
+            self.nx = self.domain.nx
+        else:
+            self.nz = self.domain.nz 
+            self.nx = self.domain.nx
+        
+        self.extent = (
+            -self.domain.cpml, 
+            (self.nx-self.domain.cpml), 
+            (self.nz-self.domain.cpml), 
+            -self.domain.cpml
+        )
+
+        if self.channel == 'Ex' or self.channel == 'Ez':
+            self.srcx = float(self.electromag.x)/self.dx + self.domain.cpml + 1
+            self.srcz = float(self.electromag.z)/self.dz + self.domain.cpml + 1
+        else:    
+            self.srcx = float(self.seismic.x)/self.dx + self.domain.cpml + 1
+            self.srcz = float(self.seismic.z)/self.dz + self.domain.cpml + 1
+        
+        # Define tick locations for plotting
+        self.xticklocs = np.array(
+            [
+                0, 
+                (self.nx-2*self.domain.cpml)/4, 
+                int((self.nx-2*self.domain.cpml)/2), 
+                3*(self.nx-2*self.domain.cpml)/4, 
+                self.nx - 2*self.domain.cpml
+            ]
+        )
+        self.yticklocs = np.array(
+            [
+                0, 
+                (self.nz-2*self.domain.cpml)/4, 
+                int((self.nz-2*self.domain.cpml)/2), 
+                3*(self.nz-2*self.domain.cpml)/4, 
+                self.nz - 2*self.domain.cpml
+            ]
+        )
+        # Load the model image and assign variables
+        self.background = mpimg.imread(self.domain.imfile)
+        
+    # -------------------------------------------------------------------------
+    def quiverplot(self, papercolumnwidth: float = 7.2) -> None:
+        """
+        Generates a quiver plot for seismic outputs.
+
+        :param papercolumnwidth: The width of the paper column for the plot.
+        :type papercolumnwidth: float, optional
+        """
+        # buildmesh
+        # Get axes values
+        x = (np.arange(-self.domain.cpml, self.nx-self.domain.cpml))
+        z = (np.arange(-self.domain.cpml, self.nz-self.domain.cpml))
+        # Append the cpml values 
+        x, z = np.meshgrid(x,z)
+
+        u = read_dat(
+            self.xfile, 
+            self.channel[0] + 'x', 
+            self.domain, 
+            is_complex = False, 
+            single = self.is_single_precision
+        )
+        v = read_dat(
+            self.zfile, 
+            self.channel[0] + 'z', 
+            self.domain, 
+            is_complex = False, 
+            single = self.is_single_precision
+        )        
+        # Set the figure size to be for a full two column width
+        
+        # Create the figure and axes objects
+        self.fig = plt.figure(
+            figsize = [
+                papercolumnwidth, 
+                self.nz*papercolumnwidth/self.nx
+            ]
+        )
+        self.ax = plt.gca()
+        
+        # add the model 
+        self.ax.imshow(
+            self.background,
+            alpha = 0.7, 
+            extent=[
+                0, self.nx-2*self.domain.cpml, 
+                self.nz-2*self.domain.cpml, 0
+            ]
+        )
+        
+        # add quiver
+        q = self.ax.quiver(
+            x, z, u, v, 
+            headwidth = 0.5, 
+            headlength = 1,
+            headaxislength = 1, 
+            scale = 16, 
+            minlength = 0.1
+        )
+    
+    # -------------------------------------------------------------------------
+    def magnitudeplot(
+            self, alpha: float = 0.3, papercolumnwidth: float = 7.2
+        ) -> None:
+        """
+        Plots the real data as a magnitude plot.
+
+        :param alpha: Transparency of the model plotted in the background.
+        :type alpha: float, optional
+        :param papercolumnwidth: The width of the paper column for the plot.
+        :type papercolumnwidth: float, optional
+        """
+        dat = read_dat(
+            self.inputfile, 
+            self.channel, 
+            self.domain, 
+            is_complex = self.is_complex, 
+            single = self.is_single_precision
+        )
+        if self.plottype == 'energy_density':
+            # Convert the complex electric field to the 
+            dat = dat.conj() * dat 
+            dat = dat.real
+        elif self.plottype == 'phase':
+            dat = np.angle(dat)
+        else:
+            dat = dat.real
+        
+        self.fig = plt.figure(
+            figsize = [
+                papercolumnwidth, 
+                self.nz*papercolumnwidth/self.nx
+            ]
+        )
+        self.ax = plt.gca()
+        self.ax.imshow(
+            dat, 
+            cmap = 'seismic',
+            extent = self.extent,
+            norm = mpl.colors.CenteredNorm()
+        )
+        self.ax.imshow(
+            self.background,
+            alpha = alpha,
+            extent = [
+                0, self.nx-2*self.domain.cpml, 
+                self.nz-2*self.domain.cpml, 0
+            ]
+        )
+        
+    # -------------------------------------------------------------------------
+    def sliceplot(
+            self, 
+            dat: np.ndarray, 
+            axscale: tuple, 
+            sliceaxes: str, 
+            alpha: float = 0.3, 
+            papercolumnwidth: float = 7.2
+        ) -> None:
+        """
+        Generates a slice plot from the given data.
+
+        :param dat: The data array to plot.
+        :type dat: np.ndarray
+        :param axscale: The scale for the axes.
+        :type axscale: tuple
+        :param sliceaxes: The axes to slice ('xy', 'xz', 'yz').
+        :type sliceaxes: str
+        :param alpha: Transparency of the model plotted in the background.
+        :type alpha: float, optional
+        :param papercolumnwidth: The width of the paper column for the plot.
+        :type papercolumnwidth: float, optional
+        """
+        # sliceaxes is a string that specifies 'xy', 'xz', or 'yz'
+        # All of the slices need to be scaled equally and normalized
+        # axscale = (nz, ny, nx)/max(nz, ny, nx)
+        if sliceaxes == 'xy': # dat dims will be y then x
+            figuredims = [
+                axscale[1]*papercolumnwidth, axscale[2]*papercolumnwidth
+            ]
+            exaggeration = axscale[2]/axscale[1]
+        elif sliceaxes == 'xz': # Dims will be z then x
+            figuredims = [
+                axscale[0]*papercolumnwidth, axscale[2]*papercolumnwidth
+            ]
+            exaggeration = axscale[2]/axscale[0]
+        else:
+            figuredims = [
+                axscale[0]*papercolumnwidth, axscale[1]*papercolumnwidth
+            ]
+            exaggeration = axscale[1]/axscale[0]
+        
+        self.fig = plt.figure(
+            figsize = figuredims
+        )
+        self.ax = plt.gca()
+        self.ax.imshow(
+            dat,
+            cmap = 'seismic', 
+            extent = self.extent,
+            norm = mpl.colors.CenteredNorm()
+        )
+        self.ax.set_aspect(exaggeration)
+        self.ax.imshow(
+            self.background,
+            alpha = alpha,
+            extent = [
+                0, self.nx-2*self.domain.cpml, 
+                self.nz-2*self.domain.cpml, 0
+            ]
+        )
+    
+    # -------------------------------------------------------------------------
+    def imvector(self) -> None:
+        """
+        Generates a vector image from the project values and saves it.
+        """
+        self.getprjvals()
+        self.quiverplot()
+        self.addlabels()
+        plt.savefig(self.plotfile)
+        plt.close()
+    
+    # This is setup for seismic
+    def vectoranim(self, files: list = glob('Vx*.dat')) -> None:
+        """
+        Creates an animation of vector images from a list of files.
+
+        :param files: A list of file names to create the animation from.
+        :type files: list, optional
+        """
+        # Project file needs to already be assigned in the object
+        if self.prjfile:
+            files.sort()
+
+            print('Creating PNG snapshots')
+            # We want to do the first file; initial condition
+            n=num_steps
+            for fn in files:
+                if n == num_steps:
+                    self.inputfile = fn
+                    self.imvector()
+                    n = 1
+                else:
+                    n = n + 1
+            # Create the gif using Imagemagick
+            print('Creating the GIF')
+            call('convert -delay 20 -loop 0 vector.*.png vector.gif', shell = True)
+        else:
+            print('No project file has been assigned')
+    
+    # -------------------------------------------------------------------------
+    
+    # -------------------------------------------------------------------------
+    
+    # -------------------------------------------------------------------------
+    def addlabels(self) -> None:
+        """
+        Adds labels to the plot and updates the axis and figure objects.
+        """
+        # Set axes labels
+        xticklabels = (self.xticklocs)*self.dx
+        yticklabels = (self.yticklocs)*self.dz
+        self.ax.set_xlabel(r'X (m)')
+        self.ax.xaxis.tick_top()
+        self.ax.xaxis.set_label_position('top')
+        self.ax.set_xticks(self.xticklocs)
+        self.ax.set_xticklabels(xticklabels)
+        self.ax.set_ylabel(r'Z (m)')
+        self.ax.set_yticks(self.yticklocs)
+        self.ax.set_yticklabels(yticklabels)
+        
+    def addsource(self) -> None:
+        """
+        Adds the source location to the plot.
+        """
+        # Source location
+        self.ax.scatter(
+            self.srcx, 
+            self.srcz,
+            marker = '*', 
+            s = 30, 
+            linewidths = 1,
+            edgecolor = (0.2, 0.2, 0.2, 1 ) 
+        )
+
+    def addrcx(self):
+        pass 
+
```

## seidart/visualization/implot.py

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-#!/usr/bin/env python3
-
-"""
-Plot a snapshot of the wavefield with axes
-"""
-
-import numpy as np 
-import matplotlib.pyplot as plt
-import argparse
-from seidart.routines.definitions import *
-import matplotlib.image as mpimg
-from seidart.visualization.imgen import *
-
-
-# =============================================================================
-parser = argparse.ArgumentParser(
-    description="""Plot a snapshop of the vector wavefield in 2D"""
-)
-
-parser.add_argument(
-    '-p', '--prjfile',
-    nargs = 1, type = str, required = True,
-    help = 'The full file path to the project file'
-)
-
-parser.add_argument(
-    '-v', '--velocity',
-    nargs = 1, type = str, required = True,
-    help = """The .dat file that corresponds to the velocity in either the 
-    x-direction or z-direction (e.g. Vx000400.dat). The corresponding 
-    orthogonal velocity file will be loaded as well."""
-) 
-
-args = parser.parse_args()
-prjfile = ''.join(args.prjfile)
-velocityfile = ''.join(args.velocity)
-
-
-# ============================ Create the objects =============================
-
-mag = FDTDImage(prjfile, velocityfile)
-mag.getprjvals()
-mag.magnitudeplot()
-mag.addlabels()
-mag.plotfile = velocityfile[:-3] + 'plot.png'
-plt.savefig(mag.plotfile)
-plt.close()
+#!/usr/bin/env python3
+
+"""
+Plot a snapshot of the wavefield with axes
+"""
+
+import numpy as np 
+import matplotlib.pyplot as plt
+import argparse
+from seidart.routines.definitions import *
+import matplotlib.image as mpimg
+from seidart.visualization.imgen import *
+
+
+# =============================================================================
+parser = argparse.ArgumentParser(
+    description="""Plot a snapshop of the vector wavefield in 2D"""
+)
+
+parser.add_argument(
+    '-p', '--prjfile',
+    nargs = 1, type = str, required = True,
+    help = 'The full file path to the project file'
+)
+
+parser.add_argument(
+    '-v', '--velocity',
+    nargs = 1, type = str, required = True,
+    help = """The .dat file that corresponds to the velocity in either the 
+    x-direction or z-direction (e.g. Vx000400.dat). The corresponding 
+    orthogonal velocity file will be loaded as well."""
+) 
+
+args = parser.parse_args()
+prjfile = ''.join(args.prjfile)
+velocityfile = ''.join(args.velocity)
+
+
+# ============================ Create the objects =============================
+
+mag = FDTDImage(prjfile, velocityfile)
+mag.getprjvals()
+mag.magnitudeplot()
+mag.addlabels()
+mag.plotfile = velocityfile[:-3] + 'plot.png'
+plt.savefig(mag.plotfile)
+plt.close()
```

## seidart/visualization/slice25d.py

 * *Ordering differences only*

```diff
@@ -1,172 +1,172 @@
-#!/usr/bin/env python3
-
-"""
-Create a gif for a given plane of a 2.5D model
-"""
-
-import numpy as np 
-from seidart.visualization.imgen import *
-from seidart.routines.definitions import *
-import argparse
-
-
-# !!!!! This could use some better organization of the definition
-
-# !!!!! This needs to be moved over to FDTDImage in the imgen.py file
-
-# ==================== Create the object and assign inputs ====================
-def slice(prjfile, channel, indslice, num_steps, plane, alpha, delay):
-    """
-    
-    """
-    # We don't need the material values
-    domain, material, seismic, electromag = loadproject(
-        prjfile,
-        Domain(),
-        Material(),
-        Model(),
-        Model()
-    )
-    # First check to see if the inputs are indices or
-    domain.dim = domain.dim
-    # Adjust the object fields relative to the cpml
-    domain.nx = int(domain.nx) + 2*int(domain.cpml)
-    domain.ny = int(domain.ny) + 2*int(domain.cpml)
-    domain.nz = int(domain.nz) + 2*int(domain.cpml)
-
-    # Get the list of files to load
-    all_files = glob.glob(channel + '*.dat')
-    all_files.sort()
-
-    m = len(all_files)
-
-    if channel == 'Ex':
-        NX = domain.nz
-        NY = domain.ny
-        NZ = domain.nx-1
-    elif channel == 'Ey':
-        NX = domain.nz
-        NY = domain.ny-1
-        NZ = domain.nx
-    elif channel == 'Ez':
-        NX = domain.nz-1
-        NY = domain.ny
-        NZ = domain.nx
-    else:
-        NX = domain.nz
-        NY = domain.ny 
-        NZ = domain.nx
-
-    # Pre allocate depending on what dimension we are slicing
-    if plane == 'xy':
-        imageseries = np.zeros([NY, NZ, m])
-    elif plane == 'xz':
-        imageseries = np.zeros([NX, NZ, m])
-    else:
-        imageseries = np.zeros([NX, NY, m])
-
-
-    # We'll start counting with the first frame
-    n=num_steps
-    axscale = np.array([domain.nz, domain.ny, domain.nx])
-    axscale = axscale/axscale.max() 
-
-    for ind, fn in enumerate(all_files, start = 0):
-        if n == num_steps:
-            mag = FDTDImage(prjfile, fn)
-            mag.getprjvals()
-            npdat = read_dat(fn,channel,domain, single=True)
-            if plane == 'xy':
-                npdat = npdat[int(indslice),:,:]
-            elif plane == 'xz':
-                npdat = npdat[:,int(indslice),:]
-            else:
-                npdat = npdat[:,:,int(indslice)]
-            mag.nx = npdat.shape[1]
-            mag.nz = npdat.shape[0]
-            mag.sliceplot(npdat, axscale, plane, alpha = alpha)
-            mag.addlabels()
-            mag.plotfile = 'magnitude.' + fn[:-3] + '.png'
-            plt.savefig(mag.plotfile)
-            plt.close()
-            n = 1
-        else:
-            n = n + 1
-
-
-    print('Creating the GIF')
-    # Use imagemagick via shell command to create the gif
-    shellcommand = 'convert -delay ' + \
-        delay + ' -loop 0 magnitude.' + channel + '*.png ' + \
-            channel + '.gif'
-    call(shellcommand, shell = True)
-
-    # Remove the png files 
-    for filepath in glob.glob('magnitude.' + channel + '*.png'):
-        os.remove(filepath)
-            
-
-# -------------------------- Command Line Arguments ---------------------------
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(
-        description="""This program creates a csv file of time series for each 
-        receiver location listed in the the specified receiver file.""" 
-    )
-
-    parser.add_argument(
-        '-p', '--prjfile',
-        nargs = 1, type = str, required = True,
-        help = 'The project file path'
-    )
-
-    parser.add_argument(
-        '-i', '--index',
-        nargs=1, type=int, required = True,
-        help='The index along the plane that we are slicing.'
-    )
-
-    parser.add_argument(
-        '-c', '--channel',
-        nargs = 1, type = str, required = True,
-        help = """The channel to query. """
-    )
-
-    parser.add_argument(
-        '-P', '--plane',
-        nargs = 1, type = str, default = ['xz'], required = False,
-        help = """Specify what plane to slice (default = 'xy'). The slice is the 
-        along the 3rd plane. """
-    )
-
-    parser.add_argument(
-        '-n', '--num_steps', 
-        nargs = 1, type = int, required = True,
-        help = """Specify the number of time steps between frames"""
-
-    )
-
-    parser.add_argument(
-        '-d', '--delay', 
-        nargs = 1, type = int, required = False, default = [1], 
-        help = """The amount of delay between two frames"""
-    )
-
-    parser.add_argument(
-        '-a', '--alpha',
-        nargs = 1, type = float, required = False, default = [0.3],
-        help = """(OPTIONAL FLOAT [0,1]) Change the transparency of the model 
-        plotted in the background; default = 0.3. Zeros is full transparency, 1 is 
-        CIA transparency."""
-    )
-
-    # Get the arguments
-    args = parser.parse_args()
-    prjfile = ''.join(args.prjfile)
-    channel = ''.join(args.channel)
-    indslice = args.index[0]
-    num_steps = args.num_steps[0]
-    plane = ''.join(args.plane)
-    alpha = args.alpha[0]
-    delay = str(args.delay[0])
-
+#!/usr/bin/env python3
+
+"""
+Create a gif for a given plane of a 2.5D model
+"""
+
+import numpy as np 
+from seidart.visualization.imgen import *
+from seidart.routines.definitions import *
+import argparse
+
+
+# !!!!! This could use some better organization of the definition
+
+# !!!!! This needs to be moved over to FDTDImage in the imgen.py file
+
+# ==================== Create the object and assign inputs ====================
+def slice(prjfile, channel, indslice, num_steps, plane, alpha, delay):
+    """
+    
+    """
+    # We don't need the material values
+    domain, material, seismic, electromag = loadproject(
+        prjfile,
+        Domain(),
+        Material(),
+        Model(),
+        Model()
+    )
+    # First check to see if the inputs are indices or
+    domain.dim = domain.dim
+    # Adjust the object fields relative to the cpml
+    domain.nx = int(domain.nx) + 2*int(domain.cpml)
+    domain.ny = int(domain.ny) + 2*int(domain.cpml)
+    domain.nz = int(domain.nz) + 2*int(domain.cpml)
+
+    # Get the list of files to load
+    all_files = glob.glob(channel + '*.dat')
+    all_files.sort()
+
+    m = len(all_files)
+
+    if channel == 'Ex':
+        NX = domain.nz
+        NY = domain.ny
+        NZ = domain.nx-1
+    elif channel == 'Ey':
+        NX = domain.nz
+        NY = domain.ny-1
+        NZ = domain.nx
+    elif channel == 'Ez':
+        NX = domain.nz-1
+        NY = domain.ny
+        NZ = domain.nx
+    else:
+        NX = domain.nz
+        NY = domain.ny 
+        NZ = domain.nx
+
+    # Pre allocate depending on what dimension we are slicing
+    if plane == 'xy':
+        imageseries = np.zeros([NY, NZ, m])
+    elif plane == 'xz':
+        imageseries = np.zeros([NX, NZ, m])
+    else:
+        imageseries = np.zeros([NX, NY, m])
+
+
+    # We'll start counting with the first frame
+    n=num_steps
+    axscale = np.array([domain.nz, domain.ny, domain.nx])
+    axscale = axscale/axscale.max() 
+
+    for ind, fn in enumerate(all_files, start = 0):
+        if n == num_steps:
+            mag = FDTDImage(prjfile, fn)
+            mag.getprjvals()
+            npdat = read_dat(fn,channel,domain, single=True)
+            if plane == 'xy':
+                npdat = npdat[int(indslice),:,:]
+            elif plane == 'xz':
+                npdat = npdat[:,int(indslice),:]
+            else:
+                npdat = npdat[:,:,int(indslice)]
+            mag.nx = npdat.shape[1]
+            mag.nz = npdat.shape[0]
+            mag.sliceplot(npdat, axscale, plane, alpha = alpha)
+            mag.addlabels()
+            mag.plotfile = 'magnitude.' + fn[:-3] + '.png'
+            plt.savefig(mag.plotfile)
+            plt.close()
+            n = 1
+        else:
+            n = n + 1
+
+
+    print('Creating the GIF')
+    # Use imagemagick via shell command to create the gif
+    shellcommand = 'convert -delay ' + \
+        delay + ' -loop 0 magnitude.' + channel + '*.png ' + \
+            channel + '.gif'
+    call(shellcommand, shell = True)
+
+    # Remove the png files 
+    for filepath in glob.glob('magnitude.' + channel + '*.png'):
+        os.remove(filepath)
+            
+
+# -------------------------- Command Line Arguments ---------------------------
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(
+        description="""This program creates a csv file of time series for each 
+        receiver location listed in the the specified receiver file.""" 
+    )
+
+    parser.add_argument(
+        '-p', '--prjfile',
+        nargs = 1, type = str, required = True,
+        help = 'The project file path'
+    )
+
+    parser.add_argument(
+        '-i', '--index',
+        nargs=1, type=int, required = True,
+        help='The index along the plane that we are slicing.'
+    )
+
+    parser.add_argument(
+        '-c', '--channel',
+        nargs = 1, type = str, required = True,
+        help = """The channel to query. """
+    )
+
+    parser.add_argument(
+        '-P', '--plane',
+        nargs = 1, type = str, default = ['xz'], required = False,
+        help = """Specify what plane to slice (default = 'xy'). The slice is the 
+        along the 3rd plane. """
+    )
+
+    parser.add_argument(
+        '-n', '--num_steps', 
+        nargs = 1, type = int, required = True,
+        help = """Specify the number of time steps between frames"""
+
+    )
+
+    parser.add_argument(
+        '-d', '--delay', 
+        nargs = 1, type = int, required = False, default = [1], 
+        help = """The amount of delay between two frames"""
+    )
+
+    parser.add_argument(
+        '-a', '--alpha',
+        nargs = 1, type = float, required = False, default = [0.3],
+        help = """(OPTIONAL FLOAT [0,1]) Change the transparency of the model 
+        plotted in the background; default = 0.3. Zeros is full transparency, 1 is 
+        CIA transparency."""
+    )
+
+    # Get the arguments
+    args = parser.parse_args()
+    prjfile = ''.join(args.prjfile)
+    channel = ''.join(args.channel)
+    indslice = args.index[0]
+    num_steps = args.num_steps[0]
+    plane = ''.join(args.plane)
+    alpha = args.alpha[0]
+    delay = str(args.delay[0])
+
     slice(prjfile, channel, indslice, num_steps, plane, alpha, delay)
```

## seidart/visualization/vtkbuild.py

 * *Ordering differences only*

```diff
@@ -1,129 +1,129 @@
-#!/usr/bin/env python3
-
-#
-
-import numpy as np
-import glob
-import argparse
-from scipy.io import FortranFile
-from seidart.routines.definitions import *
-from pyevtk.hl import imageToVTK
-
-# -------------------------- Command Line Arguments ---------------------------
-parser = argparse.ArgumentParser(description="""This program builds .VTI
-    (Visualization Toolkit Image) files from the 3d array outputs of the FDTD
-    modeling. These files can be displayed using Paraview.""" )
-
-parser.add_argument(
-    '-p', '--prjfile',
-    nargs=1, type=str, required = True,
-    help='the full file path for the project file'
-)
-
-parser.add_argument(
-    '-c', '--channel',
-    nargs = 1, type = str, required = True,
-	help = """Specify whether a particular channel is going to be used. The
-	available channels are Ex, Ez, Vx, and Vz for the electric field and
-	seismic velocities, respectively."""
-)
-
-parser.add_argument(
-    '-n', '--num_steps',
-    nargs = 1, type = int, required = True,
-    help = """The time step interval between the images that
-	are going to be used. Every time step is written to file which means that
-	we can take any equally spaced images to create the gif with an
-	appropriate resolution, time to compute, and file size. For example,
-	n=20 means that every 20 images will be used thus significantly reducing
-	how long it takes to compile."""
-)
-
-#-- Get the arguments
-args = parser.parse_args()
-project_file = ''.join(args.prjfile)
-channel = ''.join(args.channel)
-num_steps = args.num_steps[0]
-
-# ------------------------------ Run the program ------------------------------
-
-domain, material, seismic, electromag = loadproject(
-    project_file,
-    Domain(),
-    Material(),
-    Model(),
-    Model()
-)
-
-# Define some plotting inputs
-domain.cpml = int(domain.cpml)
-domain.nx = int(domain.nx) + 2*domain.cpml
-domain.ny = int(domain.ny) + 2*domain.cpml
-domain.nz = int(domain.nz) + 2*domain.cpml
-ncells = domain.nx*domain.ny*domain.nz
-
-# Create the coordinate system
-# domain.dx = float(domain.dx[0])
-# domain.dy = float(domain.dy[0])
-# domain.dz = float(domain.dz[0])
-
-X = np.linspace(1, domain.nx, num = domain.nx)*domain.dx
-Y = np.linspace(1, domain.nx, num = domain.ny)*domain.dy
-Z = np.linspace(domain.nz, 1, num = domain.nz)*domain.dz
-x = np.zeros([domain.nx, domain.ny, domain.nz])
-y = np.zeros([domain.nx, domain.ny, domain.nz])
-z = np.zeros([domain.nx, domain.ny, domain.nz])
-
-for i in range(0, domain.nx):
-    for j in range(0, domain.ny):
-        for k in range(0, domain.nz):
-            x[i,j,k] = X[i]
-            y[i,j,k] = Y[j]
-            z[i,j,k] = Z[k]
-
-# Add the source location to plot
-if channel == 'Ex' or channel == 'Ey' or channel == 'Ez':
-    electromag.x = float(electromag.x)
-    electromag.y = float(electromag.y)
-    electromag.z = float(electromag.z)
-    ex = electromag.x/domain.dx + domain.cpml+1
-    ey = electromag.y/domain.dy + domain.cpml+1
-    ez = electromag.z/domain.dz + domain.cpml+1
-    source_location = np.array([ex, ey, ez])
-    dt = float(electromag.dt)
-else:
-    seismic.x = float(seismic.x)
-    seismic.y = float(seismic.y)
-    seismic.z = float(seismic.z)
-    sx = seismic.x/domain.dx + domain.cpml+1
-    sy = seismic.y/domain.dy + domain.cpml+1
-    sz = seismic.z/domain.dz + domain.cpml+1
-    source_location = np.array([sx, sy, sz])
-    dt = float(seismic.dt)
-
-# Proceed accordingly to the channel flag
-
-# Check if the .dat files are still around
-files = glob.glob(channel + '*.dat')
-ind = 0
-files.sort()
-
-# We'll start counting with the first frame
-n=num_steps
-for fn in files:
-    if n == num_steps:
-        dat = read_dat(fn,channel,domain, single=True)
-        
-        # Zero out any values below our given threshold
-        duration = dt*ind
-
-		# Reset the countern = 1
-        ind = ind + 1
-        n = 1
-
-        vtkfilename = "./image" + channel + "." + str(ind)
-        imageToVTK(vtkfilename, cellData = {"Displacement" : dat} )
-
-    else:
-        ind = ind + 1
-        n = n + 1
+#!/usr/bin/env python3
+
+#
+
+import numpy as np
+import glob
+import argparse
+from scipy.io import FortranFile
+from seidart.routines.definitions import *
+from pyevtk.hl import imageToVTK
+
+# -------------------------- Command Line Arguments ---------------------------
+parser = argparse.ArgumentParser(description="""This program builds .VTI
+    (Visualization Toolkit Image) files from the 3d array outputs of the FDTD
+    modeling. These files can be displayed using Paraview.""" )
+
+parser.add_argument(
+    '-p', '--prjfile',
+    nargs=1, type=str, required = True,
+    help='the full file path for the project file'
+)
+
+parser.add_argument(
+    '-c', '--channel',
+    nargs = 1, type = str, required = True,
+	help = """Specify whether a particular channel is going to be used. The
+	available channels are Ex, Ez, Vx, and Vz for the electric field and
+	seismic velocities, respectively."""
+)
+
+parser.add_argument(
+    '-n', '--num_steps',
+    nargs = 1, type = int, required = True,
+    help = """The time step interval between the images that
+	are going to be used. Every time step is written to file which means that
+	we can take any equally spaced images to create the gif with an
+	appropriate resolution, time to compute, and file size. For example,
+	n=20 means that every 20 images will be used thus significantly reducing
+	how long it takes to compile."""
+)
+
+#-- Get the arguments
+args = parser.parse_args()
+project_file = ''.join(args.prjfile)
+channel = ''.join(args.channel)
+num_steps = args.num_steps[0]
+
+# ------------------------------ Run the program ------------------------------
+
+domain, material, seismic, electromag = loadproject(
+    project_file,
+    Domain(),
+    Material(),
+    Model(),
+    Model()
+)
+
+# Define some plotting inputs
+domain.cpml = int(domain.cpml)
+domain.nx = int(domain.nx) + 2*domain.cpml
+domain.ny = int(domain.ny) + 2*domain.cpml
+domain.nz = int(domain.nz) + 2*domain.cpml
+ncells = domain.nx*domain.ny*domain.nz
+
+# Create the coordinate system
+# domain.dx = float(domain.dx[0])
+# domain.dy = float(domain.dy[0])
+# domain.dz = float(domain.dz[0])
+
+X = np.linspace(1, domain.nx, num = domain.nx)*domain.dx
+Y = np.linspace(1, domain.nx, num = domain.ny)*domain.dy
+Z = np.linspace(domain.nz, 1, num = domain.nz)*domain.dz
+x = np.zeros([domain.nx, domain.ny, domain.nz])
+y = np.zeros([domain.nx, domain.ny, domain.nz])
+z = np.zeros([domain.nx, domain.ny, domain.nz])
+
+for i in range(0, domain.nx):
+    for j in range(0, domain.ny):
+        for k in range(0, domain.nz):
+            x[i,j,k] = X[i]
+            y[i,j,k] = Y[j]
+            z[i,j,k] = Z[k]
+
+# Add the source location to plot
+if channel == 'Ex' or channel == 'Ey' or channel == 'Ez':
+    electromag.x = float(electromag.x)
+    electromag.y = float(electromag.y)
+    electromag.z = float(electromag.z)
+    ex = electromag.x/domain.dx + domain.cpml+1
+    ey = electromag.y/domain.dy + domain.cpml+1
+    ez = electromag.z/domain.dz + domain.cpml+1
+    source_location = np.array([ex, ey, ez])
+    dt = float(electromag.dt)
+else:
+    seismic.x = float(seismic.x)
+    seismic.y = float(seismic.y)
+    seismic.z = float(seismic.z)
+    sx = seismic.x/domain.dx + domain.cpml+1
+    sy = seismic.y/domain.dy + domain.cpml+1
+    sz = seismic.z/domain.dz + domain.cpml+1
+    source_location = np.array([sx, sy, sz])
+    dt = float(seismic.dt)
+
+# Proceed accordingly to the channel flag
+
+# Check if the .dat files are still around
+files = glob.glob(channel + '*.dat')
+ind = 0
+files.sort()
+
+# We'll start counting with the first frame
+n=num_steps
+for fn in files:
+    if n == num_steps:
+        dat = read_dat(fn,channel,domain, single=True)
+        
+        # Zero out any values below our given threshold
+        duration = dt*ind
+
+		# Reset the countern = 1
+        ind = ind + 1
+        n = 1
+
+        vtkfilename = "./image" + channel + "." + str(ind)
+        imageToVTK(vtkfilename, cellData = {"Displacement" : dat} )
+
+    else:
+        ind = ind + 1
+        n = n + 1
```

## Comparing `seidart-1.1.0.dist-info/LICENSE.txt` & `seidart-1.5.0.dist-info/LICENSE.txt`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,674 +1,674 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<https://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<https://www.gnu.org/licenses/why-not-lgpl.html>.
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<https://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

## Comparing `seidart-1.1.0.dist-info/METADATA` & `seidart-1.5.0.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,759 +1,759 @@
-Metadata-Version: 2.1
-Name: seidart
-Version: 1.1.0
-Summary: seidarT is a 2 and 2.5d seismic and electromagnetic modeling suite.
-Author-email: Steven Bernsen <spbernsen@alaska.edu>, Christopher Gerbi <christopher.gerbi@maine.edu>
-Maintainer-email: Steven Bernsen <spbernsen@alaska.edu>, Christopher Gerbi <christopher.gerbi@maine.edu>
-License: GNU GENERAL PUBLIC LICENSE
-                               Version 3, 29 June 2007
-        
-         Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
-         Everyone is permitted to copy and distribute verbatim copies
-         of this license document, but changing it is not allowed.
-        
-                                    Preamble
-        
-          The GNU General Public License is a free, copyleft license for
-        software and other kinds of works.
-        
-          The licenses for most software and other practical works are designed
-        to take away your freedom to share and change the works.  By contrast,
-        the GNU General Public License is intended to guarantee your freedom to
-        share and change all versions of a program--to make sure it remains free
-        software for all its users.  We, the Free Software Foundation, use the
-        GNU General Public License for most of our software; it applies also to
-        any other work released this way by its authors.  You can apply it to
-        your programs, too.
-        
-          When we speak of free software, we are referring to freedom, not
-        price.  Our General Public Licenses are designed to make sure that you
-        have the freedom to distribute copies of free software (and charge for
-        them if you wish), that you receive source code or can get it if you
-        want it, that you can change the software or use pieces of it in new
-        free programs, and that you know you can do these things.
-        
-          To protect your rights, we need to prevent others from denying you
-        these rights or asking you to surrender the rights.  Therefore, you have
-        certain responsibilities if you distribute copies of the software, or if
-        you modify it: responsibilities to respect the freedom of others.
-        
-          For example, if you distribute copies of such a program, whether
-        gratis or for a fee, you must pass on to the recipients the same
-        freedoms that you received.  You must make sure that they, too, receive
-        or can get the source code.  And you must show them these terms so they
-        know their rights.
-        
-          Developers that use the GNU GPL protect your rights with two steps:
-        (1) assert copyright on the software, and (2) offer you this License
-        giving you legal permission to copy, distribute and/or modify it.
-        
-          For the developers' and authors' protection, the GPL clearly explains
-        that there is no warranty for this free software.  For both users' and
-        authors' sake, the GPL requires that modified versions be marked as
-        changed, so that their problems will not be attributed erroneously to
-        authors of previous versions.
-        
-          Some devices are designed to deny users access to install or run
-        modified versions of the software inside them, although the manufacturer
-        can do so.  This is fundamentally incompatible with the aim of
-        protecting users' freedom to change the software.  The systematic
-        pattern of such abuse occurs in the area of products for individuals to
-        use, which is precisely where it is most unacceptable.  Therefore, we
-        have designed this version of the GPL to prohibit the practice for those
-        products.  If such problems arise substantially in other domains, we
-        stand ready to extend this provision to those domains in future versions
-        of the GPL, as needed to protect the freedom of users.
-        
-          Finally, every program is threatened constantly by software patents.
-        States should not allow patents to restrict development and use of
-        software on general-purpose computers, but in those that do, we wish to
-        avoid the special danger that patents applied to a free program could
-        make it effectively proprietary.  To prevent this, the GPL assures that
-        patents cannot be used to render the program non-free.
-        
-          The precise terms and conditions for copying, distribution and
-        modification follow.
-        
-                               TERMS AND CONDITIONS
-        
-          0. Definitions.
-        
-          "This License" refers to version 3 of the GNU General Public License.
-        
-          "Copyright" also means copyright-like laws that apply to other kinds of
-        works, such as semiconductor masks.
-        
-          "The Program" refers to any copyrightable work licensed under this
-        License.  Each licensee is addressed as "you".  "Licensees" and
-        "recipients" may be individuals or organizations.
-        
-          To "modify" a work means to copy from or adapt all or part of the work
-        in a fashion requiring copyright permission, other than the making of an
-        exact copy.  The resulting work is called a "modified version" of the
-        earlier work or a work "based on" the earlier work.
-        
-          A "covered work" means either the unmodified Program or a work based
-        on the Program.
-        
-          To "propagate" a work means to do anything with it that, without
-        permission, would make you directly or secondarily liable for
-        infringement under applicable copyright law, except executing it on a
-        computer or modifying a private copy.  Propagation includes copying,
-        distribution (with or without modification), making available to the
-        public, and in some countries other activities as well.
-        
-          To "convey" a work means any kind of propagation that enables other
-        parties to make or receive copies.  Mere interaction with a user through
-        a computer network, with no transfer of a copy, is not conveying.
-        
-          An interactive user interface displays "Appropriate Legal Notices"
-        to the extent that it includes a convenient and prominently visible
-        feature that (1) displays an appropriate copyright notice, and (2)
-        tells the user that there is no warranty for the work (except to the
-        extent that warranties are provided), that licensees may convey the
-        work under this License, and how to view a copy of this License.  If
-        the interface presents a list of user commands or options, such as a
-        menu, a prominent item in the list meets this criterion.
-        
-          1. Source Code.
-        
-          The "source code" for a work means the preferred form of the work
-        for making modifications to it.  "Object code" means any non-source
-        form of a work.
-        
-          A "Standard Interface" means an interface that either is an official
-        standard defined by a recognized standards body, or, in the case of
-        interfaces specified for a particular programming language, one that
-        is widely used among developers working in that language.
-        
-          The "System Libraries" of an executable work include anything, other
-        than the work as a whole, that (a) is included in the normal form of
-        packaging a Major Component, but which is not part of that Major
-        Component, and (b) serves only to enable use of the work with that
-        Major Component, or to implement a Standard Interface for which an
-        implementation is available to the public in source code form.  A
-        "Major Component", in this context, means a major essential component
-        (kernel, window system, and so on) of the specific operating system
-        (if any) on which the executable work runs, or a compiler used to
-        produce the work, or an object code interpreter used to run it.
-        
-          The "Corresponding Source" for a work in object code form means all
-        the source code needed to generate, install, and (for an executable
-        work) run the object code and to modify the work, including scripts to
-        control those activities.  However, it does not include the work's
-        System Libraries, or general-purpose tools or generally available free
-        programs which are used unmodified in performing those activities but
-        which are not part of the work.  For example, Corresponding Source
-        includes interface definition files associated with source files for
-        the work, and the source code for shared libraries and dynamically
-        linked subprograms that the work is specifically designed to require,
-        such as by intimate data communication or control flow between those
-        subprograms and other parts of the work.
-        
-          The Corresponding Source need not include anything that users
-        can regenerate automatically from other parts of the Corresponding
-        Source.
-        
-          The Corresponding Source for a work in source code form is that
-        same work.
-        
-          2. Basic Permissions.
-        
-          All rights granted under this License are granted for the term of
-        copyright on the Program, and are irrevocable provided the stated
-        conditions are met.  This License explicitly affirms your unlimited
-        permission to run the unmodified Program.  The output from running a
-        covered work is covered by this License only if the output, given its
-        content, constitutes a covered work.  This License acknowledges your
-        rights of fair use or other equivalent, as provided by copyright law.
-        
-          You may make, run and propagate covered works that you do not
-        convey, without conditions so long as your license otherwise remains
-        in force.  You may convey covered works to others for the sole purpose
-        of having them make modifications exclusively for you, or provide you
-        with facilities for running those works, provided that you comply with
-        the terms of this License in conveying all material for which you do
-        not control copyright.  Those thus making or running the covered works
-        for you must do so exclusively on your behalf, under your direction
-        and control, on terms that prohibit them from making any copies of
-        your copyrighted material outside their relationship with you.
-        
-          Conveying under any other circumstances is permitted solely under
-        the conditions stated below.  Sublicensing is not allowed; section 10
-        makes it unnecessary.
-        
-          3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-        
-          No covered work shall be deemed part of an effective technological
-        measure under any applicable law fulfilling obligations under article
-        11 of the WIPO copyright treaty adopted on 20 December 1996, or
-        similar laws prohibiting or restricting circumvention of such
-        measures.
-        
-          When you convey a covered work, you waive any legal power to forbid
-        circumvention of technological measures to the extent such circumvention
-        is effected by exercising rights under this License with respect to
-        the covered work, and you disclaim any intention to limit operation or
-        modification of the work as a means of enforcing, against the work's
-        users, your or third parties' legal rights to forbid circumvention of
-        technological measures.
-        
-          4. Conveying Verbatim Copies.
-        
-          You may convey verbatim copies of the Program's source code as you
-        receive it, in any medium, provided that you conspicuously and
-        appropriately publish on each copy an appropriate copyright notice;
-        keep intact all notices stating that this License and any
-        non-permissive terms added in accord with section 7 apply to the code;
-        keep intact all notices of the absence of any warranty; and give all
-        recipients a copy of this License along with the Program.
-        
-          You may charge any price or no price for each copy that you convey,
-        and you may offer support or warranty protection for a fee.
-        
-          5. Conveying Modified Source Versions.
-        
-          You may convey a work based on the Program, or the modifications to
-        produce it from the Program, in the form of source code under the
-        terms of section 4, provided that you also meet all of these conditions:
-        
-            a) The work must carry prominent notices stating that you modified
-            it, and giving a relevant date.
-        
-            b) The work must carry prominent notices stating that it is
-            released under this License and any conditions added under section
-            7.  This requirement modifies the requirement in section 4 to
-            "keep intact all notices".
-        
-            c) You must license the entire work, as a whole, under this
-            License to anyone who comes into possession of a copy.  This
-            License will therefore apply, along with any applicable section 7
-            additional terms, to the whole of the work, and all its parts,
-            regardless of how they are packaged.  This License gives no
-            permission to license the work in any other way, but it does not
-            invalidate such permission if you have separately received it.
-        
-            d) If the work has interactive user interfaces, each must display
-            Appropriate Legal Notices; however, if the Program has interactive
-            interfaces that do not display Appropriate Legal Notices, your
-            work need not make them do so.
-        
-          A compilation of a covered work with other separate and independent
-        works, which are not by their nature extensions of the covered work,
-        and which are not combined with it such as to form a larger program,
-        in or on a volume of a storage or distribution medium, is called an
-        "aggregate" if the compilation and its resulting copyright are not
-        used to limit the access or legal rights of the compilation's users
-        beyond what the individual works permit.  Inclusion of a covered work
-        in an aggregate does not cause this License to apply to the other
-        parts of the aggregate.
-        
-          6. Conveying Non-Source Forms.
-        
-          You may convey a covered work in object code form under the terms
-        of sections 4 and 5, provided that you also convey the
-        machine-readable Corresponding Source under the terms of this License,
-        in one of these ways:
-        
-            a) Convey the object code in, or embodied in, a physical product
-            (including a physical distribution medium), accompanied by the
-            Corresponding Source fixed on a durable physical medium
-            customarily used for software interchange.
-        
-            b) Convey the object code in, or embodied in, a physical product
-            (including a physical distribution medium), accompanied by a
-            written offer, valid for at least three years and valid for as
-            long as you offer spare parts or customer support for that product
-            model, to give anyone who possesses the object code either (1) a
-            copy of the Corresponding Source for all the software in the
-            product that is covered by this License, on a durable physical
-            medium customarily used for software interchange, for a price no
-            more than your reasonable cost of physically performing this
-            conveying of source, or (2) access to copy the
-            Corresponding Source from a network server at no charge.
-        
-            c) Convey individual copies of the object code with a copy of the
-            written offer to provide the Corresponding Source.  This
-            alternative is allowed only occasionally and noncommercially, and
-            only if you received the object code with such an offer, in accord
-            with subsection 6b.
-        
-            d) Convey the object code by offering access from a designated
-            place (gratis or for a charge), and offer equivalent access to the
-            Corresponding Source in the same way through the same place at no
-            further charge.  You need not require recipients to copy the
-            Corresponding Source along with the object code.  If the place to
-            copy the object code is a network server, the Corresponding Source
-            may be on a different server (operated by you or a third party)
-            that supports equivalent copying facilities, provided you maintain
-            clear directions next to the object code saying where to find the
-            Corresponding Source.  Regardless of what server hosts the
-            Corresponding Source, you remain obligated to ensure that it is
-            available for as long as needed to satisfy these requirements.
-        
-            e) Convey the object code using peer-to-peer transmission, provided
-            you inform other peers where the object code and Corresponding
-            Source of the work are being offered to the general public at no
-            charge under subsection 6d.
-        
-          A separable portion of the object code, whose source code is excluded
-        from the Corresponding Source as a System Library, need not be
-        included in conveying the object code work.
-        
-          A "User Product" is either (1) a "consumer product", which means any
-        tangible personal property which is normally used for personal, family,
-        or household purposes, or (2) anything designed or sold for incorporation
-        into a dwelling.  In determining whether a product is a consumer product,
-        doubtful cases shall be resolved in favor of coverage.  For a particular
-        product received by a particular user, "normally used" refers to a
-        typical or common use of that class of product, regardless of the status
-        of the particular user or of the way in which the particular user
-        actually uses, or expects or is expected to use, the product.  A product
-        is a consumer product regardless of whether the product has substantial
-        commercial, industrial or non-consumer uses, unless such uses represent
-        the only significant mode of use of the product.
-        
-          "Installation Information" for a User Product means any methods,
-        procedures, authorization keys, or other information required to install
-        and execute modified versions of a covered work in that User Product from
-        a modified version of its Corresponding Source.  The information must
-        suffice to ensure that the continued functioning of the modified object
-        code is in no case prevented or interfered with solely because
-        modification has been made.
-        
-          If you convey an object code work under this section in, or with, or
-        specifically for use in, a User Product, and the conveying occurs as
-        part of a transaction in which the right of possession and use of the
-        User Product is transferred to the recipient in perpetuity or for a
-        fixed term (regardless of how the transaction is characterized), the
-        Corresponding Source conveyed under this section must be accompanied
-        by the Installation Information.  But this requirement does not apply
-        if neither you nor any third party retains the ability to install
-        modified object code on the User Product (for example, the work has
-        been installed in ROM).
-        
-          The requirement to provide Installation Information does not include a
-        requirement to continue to provide support service, warranty, or updates
-        for a work that has been modified or installed by the recipient, or for
-        the User Product in which it has been modified or installed.  Access to a
-        network may be denied when the modification itself materially and
-        adversely affects the operation of the network or violates the rules and
-        protocols for communication across the network.
-        
-          Corresponding Source conveyed, and Installation Information provided,
-        in accord with this section must be in a format that is publicly
-        documented (and with an implementation available to the public in
-        source code form), and must require no special password or key for
-        unpacking, reading or copying.
-        
-          7. Additional Terms.
-        
-          "Additional permissions" are terms that supplement the terms of this
-        License by making exceptions from one or more of its conditions.
-        Additional permissions that are applicable to the entire Program shall
-        be treated as though they were included in this License, to the extent
-        that they are valid under applicable law.  If additional permissions
-        apply only to part of the Program, that part may be used separately
-        under those permissions, but the entire Program remains governed by
-        this License without regard to the additional permissions.
-        
-          When you convey a copy of a covered work, you may at your option
-        remove any additional permissions from that copy, or from any part of
-        it.  (Additional permissions may be written to require their own
-        removal in certain cases when you modify the work.)  You may place
-        additional permissions on material, added by you to a covered work,
-        for which you have or can give appropriate copyright permission.
-        
-          Notwithstanding any other provision of this License, for material you
-        add to a covered work, you may (if authorized by the copyright holders of
-        that material) supplement the terms of this License with terms:
-        
-            a) Disclaiming warranty or limiting liability differently from the
-            terms of sections 15 and 16 of this License; or
-        
-            b) Requiring preservation of specified reasonable legal notices or
-            author attributions in that material or in the Appropriate Legal
-            Notices displayed by works containing it; or
-        
-            c) Prohibiting misrepresentation of the origin of that material, or
-            requiring that modified versions of such material be marked in
-            reasonable ways as different from the original version; or
-        
-            d) Limiting the use for publicity purposes of names of licensors or
-            authors of the material; or
-        
-            e) Declining to grant rights under trademark law for use of some
-            trade names, trademarks, or service marks; or
-        
-            f) Requiring indemnification of licensors and authors of that
-            material by anyone who conveys the material (or modified versions of
-            it) with contractual assumptions of liability to the recipient, for
-            any liability that these contractual assumptions directly impose on
-            those licensors and authors.
-        
-          All other non-permissive additional terms are considered "further
-        restrictions" within the meaning of section 10.  If the Program as you
-        received it, or any part of it, contains a notice stating that it is
-        governed by this License along with a term that is a further
-        restriction, you may remove that term.  If a license document contains
-        a further restriction but permits relicensing or conveying under this
-        License, you may add to a covered work material governed by the terms
-        of that license document, provided that the further restriction does
-        not survive such relicensing or conveying.
-        
-          If you add terms to a covered work in accord with this section, you
-        must place, in the relevant source files, a statement of the
-        additional terms that apply to those files, or a notice indicating
-        where to find the applicable terms.
-        
-          Additional terms, permissive or non-permissive, may be stated in the
-        form of a separately written license, or stated as exceptions;
-        the above requirements apply either way.
-        
-          8. Termination.
-        
-          You may not propagate or modify a covered work except as expressly
-        provided under this License.  Any attempt otherwise to propagate or
-        modify it is void, and will automatically terminate your rights under
-        this License (including any patent licenses granted under the third
-        paragraph of section 11).
-        
-          However, if you cease all violation of this License, then your
-        license from a particular copyright holder is reinstated (a)
-        provisionally, unless and until the copyright holder explicitly and
-        finally terminates your license, and (b) permanently, if the copyright
-        holder fails to notify you of the violation by some reasonable means
-        prior to 60 days after the cessation.
-        
-          Moreover, your license from a particular copyright holder is
-        reinstated permanently if the copyright holder notifies you of the
-        violation by some reasonable means, this is the first time you have
-        received notice of violation of this License (for any work) from that
-        copyright holder, and you cure the violation prior to 30 days after
-        your receipt of the notice.
-        
-          Termination of your rights under this section does not terminate the
-        licenses of parties who have received copies or rights from you under
-        this License.  If your rights have been terminated and not permanently
-        reinstated, you do not qualify to receive new licenses for the same
-        material under section 10.
-        
-          9. Acceptance Not Required for Having Copies.
-        
-          You are not required to accept this License in order to receive or
-        run a copy of the Program.  Ancillary propagation of a covered work
-        occurring solely as a consequence of using peer-to-peer transmission
-        to receive a copy likewise does not require acceptance.  However,
-        nothing other than this License grants you permission to propagate or
-        modify any covered work.  These actions infringe copyright if you do
-        not accept this License.  Therefore, by modifying or propagating a
-        covered work, you indicate your acceptance of this License to do so.
-        
-          10. Automatic Licensing of Downstream Recipients.
-        
-          Each time you convey a covered work, the recipient automatically
-        receives a license from the original licensors, to run, modify and
-        propagate that work, subject to this License.  You are not responsible
-        for enforcing compliance by third parties with this License.
-        
-          An "entity transaction" is a transaction transferring control of an
-        organization, or substantially all assets of one, or subdividing an
-        organization, or merging organizations.  If propagation of a covered
-        work results from an entity transaction, each party to that
-        transaction who receives a copy of the work also receives whatever
-        licenses to the work the party's predecessor in interest had or could
-        give under the previous paragraph, plus a right to possession of the
-        Corresponding Source of the work from the predecessor in interest, if
-        the predecessor has it or can get it with reasonable efforts.
-        
-          You may not impose any further restrictions on the exercise of the
-        rights granted or affirmed under this License.  For example, you may
-        not impose a license fee, royalty, or other charge for exercise of
-        rights granted under this License, and you may not initiate litigation
-        (including a cross-claim or counterclaim in a lawsuit) alleging that
-        any patent claim is infringed by making, using, selling, offering for
-        sale, or importing the Program or any portion of it.
-        
-          11. Patents.
-        
-          A "contributor" is a copyright holder who authorizes use under this
-        License of the Program or a work on which the Program is based.  The
-        work thus licensed is called the contributor's "contributor version".
-        
-          A contributor's "essential patent claims" are all patent claims
-        owned or controlled by the contributor, whether already acquired or
-        hereafter acquired, that would be infringed by some manner, permitted
-        by this License, of making, using, or selling its contributor version,
-        but do not include claims that would be infringed only as a
-        consequence of further modification of the contributor version.  For
-        purposes of this definition, "control" includes the right to grant
-        patent sublicenses in a manner consistent with the requirements of
-        this License.
-        
-          Each contributor grants you a non-exclusive, worldwide, royalty-free
-        patent license under the contributor's essential patent claims, to
-        make, use, sell, offer for sale, import and otherwise run, modify and
-        propagate the contents of its contributor version.
-        
-          In the following three paragraphs, a "patent license" is any express
-        agreement or commitment, however denominated, not to enforce a patent
-        (such as an express permission to practice a patent or covenant not to
-        sue for patent infringement).  To "grant" such a patent license to a
-        party means to make such an agreement or commitment not to enforce a
-        patent against the party.
-        
-          If you convey a covered work, knowingly relying on a patent license,
-        and the Corresponding Source of the work is not available for anyone
-        to copy, free of charge and under the terms of this License, through a
-        publicly available network server or other readily accessible means,
-        then you must either (1) cause the Corresponding Source to be so
-        available, or (2) arrange to deprive yourself of the benefit of the
-        patent license for this particular work, or (3) arrange, in a manner
-        consistent with the requirements of this License, to extend the patent
-        license to downstream recipients.  "Knowingly relying" means you have
-        actual knowledge that, but for the patent license, your conveying the
-        covered work in a country, or your recipient's use of the covered work
-        in a country, would infringe one or more identifiable patents in that
-        country that you have reason to believe are valid.
-        
-          If, pursuant to or in connection with a single transaction or
-        arrangement, you convey, or propagate by procuring conveyance of, a
-        covered work, and grant a patent license to some of the parties
-        receiving the covered work authorizing them to use, propagate, modify
-        or convey a specific copy of the covered work, then the patent license
-        you grant is automatically extended to all recipients of the covered
-        work and works based on it.
-        
-          A patent license is "discriminatory" if it does not include within
-        the scope of its coverage, prohibits the exercise of, or is
-        conditioned on the non-exercise of one or more of the rights that are
-        specifically granted under this License.  You may not convey a covered
-        work if you are a party to an arrangement with a third party that is
-        in the business of distributing software, under which you make payment
-        to the third party based on the extent of your activity of conveying
-        the work, and under which the third party grants, to any of the
-        parties who would receive the covered work from you, a discriminatory
-        patent license (a) in connection with copies of the covered work
-        conveyed by you (or copies made from those copies), or (b) primarily
-        for and in connection with specific products or compilations that
-        contain the covered work, unless you entered into that arrangement,
-        or that patent license was granted, prior to 28 March 2007.
-        
-          Nothing in this License shall be construed as excluding or limiting
-        any implied license or other defenses to infringement that may
-        otherwise be available to you under applicable patent law.
-        
-          12. No Surrender of Others' Freedom.
-        
-          If conditions are imposed on you (whether by court order, agreement or
-        otherwise) that contradict the conditions of this License, they do not
-        excuse you from the conditions of this License.  If you cannot convey a
-        covered work so as to satisfy simultaneously your obligations under this
-        License and any other pertinent obligations, then as a consequence you may
-        not convey it at all.  For example, if you agree to terms that obligate you
-        to collect a royalty for further conveying from those to whom you convey
-        the Program, the only way you could satisfy both those terms and this
-        License would be to refrain entirely from conveying the Program.
-        
-          13. Use with the GNU Affero General Public License.
-        
-          Notwithstanding any other provision of this License, you have
-        permission to link or combine any covered work with a work licensed
-        under version 3 of the GNU Affero General Public License into a single
-        combined work, and to convey the resulting work.  The terms of this
-        License will continue to apply to the part which is the covered work,
-        but the special requirements of the GNU Affero General Public License,
-        section 13, concerning interaction through a network will apply to the
-        combination as such.
-        
-          14. Revised Versions of this License.
-        
-          The Free Software Foundation may publish revised and/or new versions of
-        the GNU General Public License from time to time.  Such new versions will
-        be similar in spirit to the present version, but may differ in detail to
-        address new problems or concerns.
-        
-          Each version is given a distinguishing version number.  If the
-        Program specifies that a certain numbered version of the GNU General
-        Public License "or any later version" applies to it, you have the
-        option of following the terms and conditions either of that numbered
-        version or of any later version published by the Free Software
-        Foundation.  If the Program does not specify a version number of the
-        GNU General Public License, you may choose any version ever published
-        by the Free Software Foundation.
-        
-          If the Program specifies that a proxy can decide which future
-        versions of the GNU General Public License can be used, that proxy's
-        public statement of acceptance of a version permanently authorizes you
-        to choose that version for the Program.
-        
-          Later license versions may give you additional or different
-        permissions.  However, no additional obligations are imposed on any
-        author or copyright holder as a result of your choosing to follow a
-        later version.
-        
-          15. Disclaimer of Warranty.
-        
-          THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-        APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-        HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-        OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-        THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-        PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-        IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-        ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-        
-          16. Limitation of Liability.
-        
-          IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-        WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-        THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-        GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-        USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-        DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-        PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-        EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-        SUCH DAMAGES.
-        
-          17. Interpretation of Sections 15 and 16.
-        
-          If the disclaimer of warranty and limitation of liability provided
-        above cannot be given local legal effect according to their terms,
-        reviewing courts shall apply local law that most closely approximates
-        an absolute waiver of all civil liability in connection with the
-        Program, unless a warranty or assumption of liability accompanies a
-        copy of the Program in return for a fee.
-        
-                             END OF TERMS AND CONDITIONS
-        
-                    How to Apply These Terms to Your New Programs
-        
-          If you develop a new program, and you want it to be of the greatest
-        possible use to the public, the best way to achieve this is to make it
-        free software which everyone can redistribute and change under these terms.
-        
-          To do so, attach the following notices to the program.  It is safest
-        to attach them to the start of each source file to most effectively
-        state the exclusion of warranty; and each file should have at least
-        the "copyright" line and a pointer to where the full notice is found.
-        
-            <one line to give the program's name and a brief idea of what it does.>
-            Copyright (C) <year>  <name of author>
-        
-            This program is free software: you can redistribute it and/or modify
-            it under the terms of the GNU General Public License as published by
-            the Free Software Foundation, either version 3 of the License, or
-            (at your option) any later version.
-        
-            This program is distributed in the hope that it will be useful,
-            but WITHOUT ANY WARRANTY; without even the implied warranty of
-            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-            GNU General Public License for more details.
-        
-            You should have received a copy of the GNU General Public License
-            along with this program.  If not, see <https://www.gnu.org/licenses/>.
-        
-        Also add information on how to contact you by electronic and paper mail.
-        
-          If the program does terminal interaction, make it output a short
-        notice like this when it starts in an interactive mode:
-        
-            <program>  Copyright (C) <year>  <name of author>
-            This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-            This is free software, and you are welcome to redistribute it
-            under certain conditions; type `show c' for details.
-        
-        The hypothetical commands `show w' and `show c' should show the appropriate
-        parts of the General Public License.  Of course, your program's commands
-        might be different; for a GUI interface, you would use an "about box".
-        
-          You should also get your employer (if you work as a programmer) or school,
-        if any, to sign a "copyright disclaimer" for the program, if necessary.
-        For more information on this, and how to apply and follow the GNU GPL, see
-        <https://www.gnu.org/licenses/>.
-        
-          The GNU General Public License does not permit incorporating your program
-        into proprietary programs.  If your program is a subroutine library, you
-        may consider it more useful to permit linking proprietary applications with
-        the library.  If this is what you want to do, use the GNU Lesser General
-        Public License instead of this License.  But first, please read
-        <https://www.gnu.org/licenses/why-not-lgpl.html>.
-        
-Project-URL: homepage, https://github.com/sbernsen/SeidarT
-Project-URL: documentation, https://umainedynamics.github.io/SeidarT/index.html
-Classifier: Programming Language :: Python :: 3
-Classifier: License :: OSI Approved :: GNU Affero General Public License v3
-Classifier: Operating System :: OS Independent
-Classifier: Framework :: Matplotlib
-Classifier: Topic :: Scientific/Engineering :: Physics
-Classifier: Intended Audience :: Science/Research
-Classifier: Natural Language :: English
-Classifier: Development Status :: 4 - Beta
-Requires-Python: >=3.11
-Description-Content-Type: text/markdown
-License-File: LICENSE.txt
-Requires-Dist: numpy
-Requires-Dist: scipy
-Requires-Dist: matplotlib
-Requires-Dist: pandas
-Requires-Dist: mplstereonet
-Requires-Dist: pyevtk
-Requires-Dist: glob2
-
-# SeidarT
-
-<!-- ### Table of Contents -->
-<!-- [Introduction](#introduction)  
-[Installation](#install)  
-[Auto-Install](#auto-installation) 
-[Manual Install](#manual-installation)  
-[Hardware Requirements](#hardware-requirements)  
-[Operating System Requirements](#operating-system-requirements)   -->
-
-Full documentation appears in the docs folder. 
-
-[comment]: ======================================================================
-
-## Introduction <a name="introduction"></a>
-
-The Seismic and Radar Toolbox (SeidarT) is a collaboration between researchers at the Universities of Maine and Washington to provide an open source platform for forward modeling mechanical and electromagnetic wave propagation. The major objective of the project is to easily and quickly implement isotropic and anisotropic complex geometries and/or velocity structures to develop prior constraints for - not limited too - investigating, estimating, and imaging englacial ice structure, sub-glacial boundary conditions on the sub-regional scale. Larger problems would require the curvature of the Earth to be taken into consideration, but many glacier seismic and radar experiments do not expand into regional parameter estimation and velocity modeling.
-
-Much of the Staggered Grid FDTD code has been adopted from the *SEISMIC_CPML* software provided by [Computational Infrastucture for Geophysics (CIG)](https://geodynamics.org/cig/software/). Further details to the backend numerical code can be found in the [References](#references) section below.
-
-## Installation <a name="install"></a>
-
-The dynamical programming language of **Python3** is used as a command line interface to run the more computationally extensive modeling schemes in **Fortran**. There are a number of ways to install this software depending on your desired level of control over the process. Most users should be fine with the "automatic installation" in the [section below](#auto-install).
-
-SeidarT package binaries are publicly availble on the [PyPi repository](https://pypi.org/project/seidart/) and source code can be found at github (not yet public). 
-
-### "Auto" installation <a name="auto-install"></a>
-
-Extract the *install* directory from the *install.tar.gz* or *install.bz* for Unix/Linux or Windows users, respectively
-
-There are 2 install scripts, *full_install.sh* and *full_install.bat*, which will cover Linux, MacOS 13 and 14, and Windows , respectively. It's not necessary to know or do much more than execute a few command line entries via a bash terminal or powershell terminal. A virtual environment is created using the Miniconda/Anaconda package manager. This will avoid causing system incompatibilities and complicated software dependencies. Documentation for managing conda environments with Miniconda or Anaconda can be found [here](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html). The full Anaconda release has a GUI called Navigator for managing environments. This can be found [here](https://docs.anaconda.com/free/navigator/tutorials/manage-environments/).  
-
-The *full_install.?* checks for an Anaconda/Miniconda and will install it if it isn't found. If Anaconda/Miniconda is not defined in your 'PATH' variable than it will be installed using the default install location. After installing the Conda package, the *seidart* environment is built using pre-defined dependencies in a YAML (Yet Another Markup Language) file. Both *Bash* executables and Python modules are built during install. In order to use either, the environment must be active. This can be easily done from the *Bash* command line interface (CLI) using the command
-```
-conda activate seidart
-```
-
-[comment]: ======================================================================
-### Manual installation<a name="manual-install-pip"></a>
-
-The full repo can be found on GitHub and hosted on PyPi. *SeidarT* has been tested on Python 3.11 and is not yet supported with Python 3.12. For users that prefer building virtual environments with Anaconda, the install folder contains the *seidart-environment.yml* or it can be found in the root directory of the GitHub repo. The command 
-```
-conda env create -f seidart-environment.yml
-```
-will install all dependencies and the *seidart* package. For users who prefer more control in their installation, their is a small list of dependencies that must be met. These are:  *gcc*>10, *gfortran*, *ghostscript*, *imagemagick*, *numpy*, *pandas*, *matplotlib*, *scipy*, *glob2*, *pyevtk*, *mplstereonet*. Following install of all dependencies, 
-```
-pip install seidart
-```
-will pull and install the package from PyPi. 
-
-### Hardware Requirements <a name="hardware-requirement"></a>
-
-*SeidarT* was tested and developed on a quad core 5th gen i7 processor with 16 Gb of RAM without any burden on the system so a typical modern laptop is sufficient for many application. When running models with large domains or a high number of time steps, the computational load is obviously increased, however the storage requirements become more significant. It can be easy to fill up 10's of Gb of storage, but an external drive can resolve that problem. The Apple M-chips may have compatability issues with particular types of software and Python packages, but we have maintained a relatively simple design along with leveraging some of the most commonly used Python packages which should help to mitigate any issues with computing on an M-chip. 
-
-### Operating System Requirements <a name="operating-system"></a>
-
-All of the development was carried out on a Linux operating system and limited to Debian, Ubuntu, Solus 2, and Fedora. No compatibility issues between Linux flavors arose. The binaries are built on Github Actions for Windows 10 and 11 (latest), MacOS 13 and 14 (latest), and most flavors of Linux. Cross-platform usability is one of the core tenets in the development of the software and needs to be maintained in future development. 
+Metadata-Version: 2.1
+Name: seidart
+Version: 1.5.0
+Summary: seidarT is a 2 and 2.5d seismic and electromagnetic modeling suite.
+Author-email: Steven Bernsen <steven.bernsen@maine.edu>, Christopher Gerbi <christopher.gerbi@maine.edu>
+Maintainer-email: Steven Bernsen <steven.bernsen@maine.edu>, Christopher Gerbi <christopher.gerbi@maine.edu>
+License: GNU GENERAL PUBLIC LICENSE
+                               Version 3, 29 June 2007
+        
+         Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+         Everyone is permitted to copy and distribute verbatim copies
+         of this license document, but changing it is not allowed.
+        
+                                    Preamble
+        
+          The GNU General Public License is a free, copyleft license for
+        software and other kinds of works.
+        
+          The licenses for most software and other practical works are designed
+        to take away your freedom to share and change the works.  By contrast,
+        the GNU General Public License is intended to guarantee your freedom to
+        share and change all versions of a program--to make sure it remains free
+        software for all its users.  We, the Free Software Foundation, use the
+        GNU General Public License for most of our software; it applies also to
+        any other work released this way by its authors.  You can apply it to
+        your programs, too.
+        
+          When we speak of free software, we are referring to freedom, not
+        price.  Our General Public Licenses are designed to make sure that you
+        have the freedom to distribute copies of free software (and charge for
+        them if you wish), that you receive source code or can get it if you
+        want it, that you can change the software or use pieces of it in new
+        free programs, and that you know you can do these things.
+        
+          To protect your rights, we need to prevent others from denying you
+        these rights or asking you to surrender the rights.  Therefore, you have
+        certain responsibilities if you distribute copies of the software, or if
+        you modify it: responsibilities to respect the freedom of others.
+        
+          For example, if you distribute copies of such a program, whether
+        gratis or for a fee, you must pass on to the recipients the same
+        freedoms that you received.  You must make sure that they, too, receive
+        or can get the source code.  And you must show them these terms so they
+        know their rights.
+        
+          Developers that use the GNU GPL protect your rights with two steps:
+        (1) assert copyright on the software, and (2) offer you this License
+        giving you legal permission to copy, distribute and/or modify it.
+        
+          For the developers' and authors' protection, the GPL clearly explains
+        that there is no warranty for this free software.  For both users' and
+        authors' sake, the GPL requires that modified versions be marked as
+        changed, so that their problems will not be attributed erroneously to
+        authors of previous versions.
+        
+          Some devices are designed to deny users access to install or run
+        modified versions of the software inside them, although the manufacturer
+        can do so.  This is fundamentally incompatible with the aim of
+        protecting users' freedom to change the software.  The systematic
+        pattern of such abuse occurs in the area of products for individuals to
+        use, which is precisely where it is most unacceptable.  Therefore, we
+        have designed this version of the GPL to prohibit the practice for those
+        products.  If such problems arise substantially in other domains, we
+        stand ready to extend this provision to those domains in future versions
+        of the GPL, as needed to protect the freedom of users.
+        
+          Finally, every program is threatened constantly by software patents.
+        States should not allow patents to restrict development and use of
+        software on general-purpose computers, but in those that do, we wish to
+        avoid the special danger that patents applied to a free program could
+        make it effectively proprietary.  To prevent this, the GPL assures that
+        patents cannot be used to render the program non-free.
+        
+          The precise terms and conditions for copying, distribution and
+        modification follow.
+        
+                               TERMS AND CONDITIONS
+        
+          0. Definitions.
+        
+          "This License" refers to version 3 of the GNU General Public License.
+        
+          "Copyright" also means copyright-like laws that apply to other kinds of
+        works, such as semiconductor masks.
+        
+          "The Program" refers to any copyrightable work licensed under this
+        License.  Each licensee is addressed as "you".  "Licensees" and
+        "recipients" may be individuals or organizations.
+        
+          To "modify" a work means to copy from or adapt all or part of the work
+        in a fashion requiring copyright permission, other than the making of an
+        exact copy.  The resulting work is called a "modified version" of the
+        earlier work or a work "based on" the earlier work.
+        
+          A "covered work" means either the unmodified Program or a work based
+        on the Program.
+        
+          To "propagate" a work means to do anything with it that, without
+        permission, would make you directly or secondarily liable for
+        infringement under applicable copyright law, except executing it on a
+        computer or modifying a private copy.  Propagation includes copying,
+        distribution (with or without modification), making available to the
+        public, and in some countries other activities as well.
+        
+          To "convey" a work means any kind of propagation that enables other
+        parties to make or receive copies.  Mere interaction with a user through
+        a computer network, with no transfer of a copy, is not conveying.
+        
+          An interactive user interface displays "Appropriate Legal Notices"
+        to the extent that it includes a convenient and prominently visible
+        feature that (1) displays an appropriate copyright notice, and (2)
+        tells the user that there is no warranty for the work (except to the
+        extent that warranties are provided), that licensees may convey the
+        work under this License, and how to view a copy of this License.  If
+        the interface presents a list of user commands or options, such as a
+        menu, a prominent item in the list meets this criterion.
+        
+          1. Source Code.
+        
+          The "source code" for a work means the preferred form of the work
+        for making modifications to it.  "Object code" means any non-source
+        form of a work.
+        
+          A "Standard Interface" means an interface that either is an official
+        standard defined by a recognized standards body, or, in the case of
+        interfaces specified for a particular programming language, one that
+        is widely used among developers working in that language.
+        
+          The "System Libraries" of an executable work include anything, other
+        than the work as a whole, that (a) is included in the normal form of
+        packaging a Major Component, but which is not part of that Major
+        Component, and (b) serves only to enable use of the work with that
+        Major Component, or to implement a Standard Interface for which an
+        implementation is available to the public in source code form.  A
+        "Major Component", in this context, means a major essential component
+        (kernel, window system, and so on) of the specific operating system
+        (if any) on which the executable work runs, or a compiler used to
+        produce the work, or an object code interpreter used to run it.
+        
+          The "Corresponding Source" for a work in object code form means all
+        the source code needed to generate, install, and (for an executable
+        work) run the object code and to modify the work, including scripts to
+        control those activities.  However, it does not include the work's
+        System Libraries, or general-purpose tools or generally available free
+        programs which are used unmodified in performing those activities but
+        which are not part of the work.  For example, Corresponding Source
+        includes interface definition files associated with source files for
+        the work, and the source code for shared libraries and dynamically
+        linked subprograms that the work is specifically designed to require,
+        such as by intimate data communication or control flow between those
+        subprograms and other parts of the work.
+        
+          The Corresponding Source need not include anything that users
+        can regenerate automatically from other parts of the Corresponding
+        Source.
+        
+          The Corresponding Source for a work in source code form is that
+        same work.
+        
+          2. Basic Permissions.
+        
+          All rights granted under this License are granted for the term of
+        copyright on the Program, and are irrevocable provided the stated
+        conditions are met.  This License explicitly affirms your unlimited
+        permission to run the unmodified Program.  The output from running a
+        covered work is covered by this License only if the output, given its
+        content, constitutes a covered work.  This License acknowledges your
+        rights of fair use or other equivalent, as provided by copyright law.
+        
+          You may make, run and propagate covered works that you do not
+        convey, without conditions so long as your license otherwise remains
+        in force.  You may convey covered works to others for the sole purpose
+        of having them make modifications exclusively for you, or provide you
+        with facilities for running those works, provided that you comply with
+        the terms of this License in conveying all material for which you do
+        not control copyright.  Those thus making or running the covered works
+        for you must do so exclusively on your behalf, under your direction
+        and control, on terms that prohibit them from making any copies of
+        your copyrighted material outside their relationship with you.
+        
+          Conveying under any other circumstances is permitted solely under
+        the conditions stated below.  Sublicensing is not allowed; section 10
+        makes it unnecessary.
+        
+          3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+        
+          No covered work shall be deemed part of an effective technological
+        measure under any applicable law fulfilling obligations under article
+        11 of the WIPO copyright treaty adopted on 20 December 1996, or
+        similar laws prohibiting or restricting circumvention of such
+        measures.
+        
+          When you convey a covered work, you waive any legal power to forbid
+        circumvention of technological measures to the extent such circumvention
+        is effected by exercising rights under this License with respect to
+        the covered work, and you disclaim any intention to limit operation or
+        modification of the work as a means of enforcing, against the work's
+        users, your or third parties' legal rights to forbid circumvention of
+        technological measures.
+        
+          4. Conveying Verbatim Copies.
+        
+          You may convey verbatim copies of the Program's source code as you
+        receive it, in any medium, provided that you conspicuously and
+        appropriately publish on each copy an appropriate copyright notice;
+        keep intact all notices stating that this License and any
+        non-permissive terms added in accord with section 7 apply to the code;
+        keep intact all notices of the absence of any warranty; and give all
+        recipients a copy of this License along with the Program.
+        
+          You may charge any price or no price for each copy that you convey,
+        and you may offer support or warranty protection for a fee.
+        
+          5. Conveying Modified Source Versions.
+        
+          You may convey a work based on the Program, or the modifications to
+        produce it from the Program, in the form of source code under the
+        terms of section 4, provided that you also meet all of these conditions:
+        
+            a) The work must carry prominent notices stating that you modified
+            it, and giving a relevant date.
+        
+            b) The work must carry prominent notices stating that it is
+            released under this License and any conditions added under section
+            7.  This requirement modifies the requirement in section 4 to
+            "keep intact all notices".
+        
+            c) You must license the entire work, as a whole, under this
+            License to anyone who comes into possession of a copy.  This
+            License will therefore apply, along with any applicable section 7
+            additional terms, to the whole of the work, and all its parts,
+            regardless of how they are packaged.  This License gives no
+            permission to license the work in any other way, but it does not
+            invalidate such permission if you have separately received it.
+        
+            d) If the work has interactive user interfaces, each must display
+            Appropriate Legal Notices; however, if the Program has interactive
+            interfaces that do not display Appropriate Legal Notices, your
+            work need not make them do so.
+        
+          A compilation of a covered work with other separate and independent
+        works, which are not by their nature extensions of the covered work,
+        and which are not combined with it such as to form a larger program,
+        in or on a volume of a storage or distribution medium, is called an
+        "aggregate" if the compilation and its resulting copyright are not
+        used to limit the access or legal rights of the compilation's users
+        beyond what the individual works permit.  Inclusion of a covered work
+        in an aggregate does not cause this License to apply to the other
+        parts of the aggregate.
+        
+          6. Conveying Non-Source Forms.
+        
+          You may convey a covered work in object code form under the terms
+        of sections 4 and 5, provided that you also convey the
+        machine-readable Corresponding Source under the terms of this License,
+        in one of these ways:
+        
+            a) Convey the object code in, or embodied in, a physical product
+            (including a physical distribution medium), accompanied by the
+            Corresponding Source fixed on a durable physical medium
+            customarily used for software interchange.
+        
+            b) Convey the object code in, or embodied in, a physical product
+            (including a physical distribution medium), accompanied by a
+            written offer, valid for at least three years and valid for as
+            long as you offer spare parts or customer support for that product
+            model, to give anyone who possesses the object code either (1) a
+            copy of the Corresponding Source for all the software in the
+            product that is covered by this License, on a durable physical
+            medium customarily used for software interchange, for a price no
+            more than your reasonable cost of physically performing this
+            conveying of source, or (2) access to copy the
+            Corresponding Source from a network server at no charge.
+        
+            c) Convey individual copies of the object code with a copy of the
+            written offer to provide the Corresponding Source.  This
+            alternative is allowed only occasionally and noncommercially, and
+            only if you received the object code with such an offer, in accord
+            with subsection 6b.
+        
+            d) Convey the object code by offering access from a designated
+            place (gratis or for a charge), and offer equivalent access to the
+            Corresponding Source in the same way through the same place at no
+            further charge.  You need not require recipients to copy the
+            Corresponding Source along with the object code.  If the place to
+            copy the object code is a network server, the Corresponding Source
+            may be on a different server (operated by you or a third party)
+            that supports equivalent copying facilities, provided you maintain
+            clear directions next to the object code saying where to find the
+            Corresponding Source.  Regardless of what server hosts the
+            Corresponding Source, you remain obligated to ensure that it is
+            available for as long as needed to satisfy these requirements.
+        
+            e) Convey the object code using peer-to-peer transmission, provided
+            you inform other peers where the object code and Corresponding
+            Source of the work are being offered to the general public at no
+            charge under subsection 6d.
+        
+          A separable portion of the object code, whose source code is excluded
+        from the Corresponding Source as a System Library, need not be
+        included in conveying the object code work.
+        
+          A "User Product" is either (1) a "consumer product", which means any
+        tangible personal property which is normally used for personal, family,
+        or household purposes, or (2) anything designed or sold for incorporation
+        into a dwelling.  In determining whether a product is a consumer product,
+        doubtful cases shall be resolved in favor of coverage.  For a particular
+        product received by a particular user, "normally used" refers to a
+        typical or common use of that class of product, regardless of the status
+        of the particular user or of the way in which the particular user
+        actually uses, or expects or is expected to use, the product.  A product
+        is a consumer product regardless of whether the product has substantial
+        commercial, industrial or non-consumer uses, unless such uses represent
+        the only significant mode of use of the product.
+        
+          "Installation Information" for a User Product means any methods,
+        procedures, authorization keys, or other information required to install
+        and execute modified versions of a covered work in that User Product from
+        a modified version of its Corresponding Source.  The information must
+        suffice to ensure that the continued functioning of the modified object
+        code is in no case prevented or interfered with solely because
+        modification has been made.
+        
+          If you convey an object code work under this section in, or with, or
+        specifically for use in, a User Product, and the conveying occurs as
+        part of a transaction in which the right of possession and use of the
+        User Product is transferred to the recipient in perpetuity or for a
+        fixed term (regardless of how the transaction is characterized), the
+        Corresponding Source conveyed under this section must be accompanied
+        by the Installation Information.  But this requirement does not apply
+        if neither you nor any third party retains the ability to install
+        modified object code on the User Product (for example, the work has
+        been installed in ROM).
+        
+          The requirement to provide Installation Information does not include a
+        requirement to continue to provide support service, warranty, or updates
+        for a work that has been modified or installed by the recipient, or for
+        the User Product in which it has been modified or installed.  Access to a
+        network may be denied when the modification itself materially and
+        adversely affects the operation of the network or violates the rules and
+        protocols for communication across the network.
+        
+          Corresponding Source conveyed, and Installation Information provided,
+        in accord with this section must be in a format that is publicly
+        documented (and with an implementation available to the public in
+        source code form), and must require no special password or key for
+        unpacking, reading or copying.
+        
+          7. Additional Terms.
+        
+          "Additional permissions" are terms that supplement the terms of this
+        License by making exceptions from one or more of its conditions.
+        Additional permissions that are applicable to the entire Program shall
+        be treated as though they were included in this License, to the extent
+        that they are valid under applicable law.  If additional permissions
+        apply only to part of the Program, that part may be used separately
+        under those permissions, but the entire Program remains governed by
+        this License without regard to the additional permissions.
+        
+          When you convey a copy of a covered work, you may at your option
+        remove any additional permissions from that copy, or from any part of
+        it.  (Additional permissions may be written to require their own
+        removal in certain cases when you modify the work.)  You may place
+        additional permissions on material, added by you to a covered work,
+        for which you have or can give appropriate copyright permission.
+        
+          Notwithstanding any other provision of this License, for material you
+        add to a covered work, you may (if authorized by the copyright holders of
+        that material) supplement the terms of this License with terms:
+        
+            a) Disclaiming warranty or limiting liability differently from the
+            terms of sections 15 and 16 of this License; or
+        
+            b) Requiring preservation of specified reasonable legal notices or
+            author attributions in that material or in the Appropriate Legal
+            Notices displayed by works containing it; or
+        
+            c) Prohibiting misrepresentation of the origin of that material, or
+            requiring that modified versions of such material be marked in
+            reasonable ways as different from the original version; or
+        
+            d) Limiting the use for publicity purposes of names of licensors or
+            authors of the material; or
+        
+            e) Declining to grant rights under trademark law for use of some
+            trade names, trademarks, or service marks; or
+        
+            f) Requiring indemnification of licensors and authors of that
+            material by anyone who conveys the material (or modified versions of
+            it) with contractual assumptions of liability to the recipient, for
+            any liability that these contractual assumptions directly impose on
+            those licensors and authors.
+        
+          All other non-permissive additional terms are considered "further
+        restrictions" within the meaning of section 10.  If the Program as you
+        received it, or any part of it, contains a notice stating that it is
+        governed by this License along with a term that is a further
+        restriction, you may remove that term.  If a license document contains
+        a further restriction but permits relicensing or conveying under this
+        License, you may add to a covered work material governed by the terms
+        of that license document, provided that the further restriction does
+        not survive such relicensing or conveying.
+        
+          If you add terms to a covered work in accord with this section, you
+        must place, in the relevant source files, a statement of the
+        additional terms that apply to those files, or a notice indicating
+        where to find the applicable terms.
+        
+          Additional terms, permissive or non-permissive, may be stated in the
+        form of a separately written license, or stated as exceptions;
+        the above requirements apply either way.
+        
+          8. Termination.
+        
+          You may not propagate or modify a covered work except as expressly
+        provided under this License.  Any attempt otherwise to propagate or
+        modify it is void, and will automatically terminate your rights under
+        this License (including any patent licenses granted under the third
+        paragraph of section 11).
+        
+          However, if you cease all violation of this License, then your
+        license from a particular copyright holder is reinstated (a)
+        provisionally, unless and until the copyright holder explicitly and
+        finally terminates your license, and (b) permanently, if the copyright
+        holder fails to notify you of the violation by some reasonable means
+        prior to 60 days after the cessation.
+        
+          Moreover, your license from a particular copyright holder is
+        reinstated permanently if the copyright holder notifies you of the
+        violation by some reasonable means, this is the first time you have
+        received notice of violation of this License (for any work) from that
+        copyright holder, and you cure the violation prior to 30 days after
+        your receipt of the notice.
+        
+          Termination of your rights under this section does not terminate the
+        licenses of parties who have received copies or rights from you under
+        this License.  If your rights have been terminated and not permanently
+        reinstated, you do not qualify to receive new licenses for the same
+        material under section 10.
+        
+          9. Acceptance Not Required for Having Copies.
+        
+          You are not required to accept this License in order to receive or
+        run a copy of the Program.  Ancillary propagation of a covered work
+        occurring solely as a consequence of using peer-to-peer transmission
+        to receive a copy likewise does not require acceptance.  However,
+        nothing other than this License grants you permission to propagate or
+        modify any covered work.  These actions infringe copyright if you do
+        not accept this License.  Therefore, by modifying or propagating a
+        covered work, you indicate your acceptance of this License to do so.
+        
+          10. Automatic Licensing of Downstream Recipients.
+        
+          Each time you convey a covered work, the recipient automatically
+        receives a license from the original licensors, to run, modify and
+        propagate that work, subject to this License.  You are not responsible
+        for enforcing compliance by third parties with this License.
+        
+          An "entity transaction" is a transaction transferring control of an
+        organization, or substantially all assets of one, or subdividing an
+        organization, or merging organizations.  If propagation of a covered
+        work results from an entity transaction, each party to that
+        transaction who receives a copy of the work also receives whatever
+        licenses to the work the party's predecessor in interest had or could
+        give under the previous paragraph, plus a right to possession of the
+        Corresponding Source of the work from the predecessor in interest, if
+        the predecessor has it or can get it with reasonable efforts.
+        
+          You may not impose any further restrictions on the exercise of the
+        rights granted or affirmed under this License.  For example, you may
+        not impose a license fee, royalty, or other charge for exercise of
+        rights granted under this License, and you may not initiate litigation
+        (including a cross-claim or counterclaim in a lawsuit) alleging that
+        any patent claim is infringed by making, using, selling, offering for
+        sale, or importing the Program or any portion of it.
+        
+          11. Patents.
+        
+          A "contributor" is a copyright holder who authorizes use under this
+        License of the Program or a work on which the Program is based.  The
+        work thus licensed is called the contributor's "contributor version".
+        
+          A contributor's "essential patent claims" are all patent claims
+        owned or controlled by the contributor, whether already acquired or
+        hereafter acquired, that would be infringed by some manner, permitted
+        by this License, of making, using, or selling its contributor version,
+        but do not include claims that would be infringed only as a
+        consequence of further modification of the contributor version.  For
+        purposes of this definition, "control" includes the right to grant
+        patent sublicenses in a manner consistent with the requirements of
+        this License.
+        
+          Each contributor grants you a non-exclusive, worldwide, royalty-free
+        patent license under the contributor's essential patent claims, to
+        make, use, sell, offer for sale, import and otherwise run, modify and
+        propagate the contents of its contributor version.
+        
+          In the following three paragraphs, a "patent license" is any express
+        agreement or commitment, however denominated, not to enforce a patent
+        (such as an express permission to practice a patent or covenant not to
+        sue for patent infringement).  To "grant" such a patent license to a
+        party means to make such an agreement or commitment not to enforce a
+        patent against the party.
+        
+          If you convey a covered work, knowingly relying on a patent license,
+        and the Corresponding Source of the work is not available for anyone
+        to copy, free of charge and under the terms of this License, through a
+        publicly available network server or other readily accessible means,
+        then you must either (1) cause the Corresponding Source to be so
+        available, or (2) arrange to deprive yourself of the benefit of the
+        patent license for this particular work, or (3) arrange, in a manner
+        consistent with the requirements of this License, to extend the patent
+        license to downstream recipients.  "Knowingly relying" means you have
+        actual knowledge that, but for the patent license, your conveying the
+        covered work in a country, or your recipient's use of the covered work
+        in a country, would infringe one or more identifiable patents in that
+        country that you have reason to believe are valid.
+        
+          If, pursuant to or in connection with a single transaction or
+        arrangement, you convey, or propagate by procuring conveyance of, a
+        covered work, and grant a patent license to some of the parties
+        receiving the covered work authorizing them to use, propagate, modify
+        or convey a specific copy of the covered work, then the patent license
+        you grant is automatically extended to all recipients of the covered
+        work and works based on it.
+        
+          A patent license is "discriminatory" if it does not include within
+        the scope of its coverage, prohibits the exercise of, or is
+        conditioned on the non-exercise of one or more of the rights that are
+        specifically granted under this License.  You may not convey a covered
+        work if you are a party to an arrangement with a third party that is
+        in the business of distributing software, under which you make payment
+        to the third party based on the extent of your activity of conveying
+        the work, and under which the third party grants, to any of the
+        parties who would receive the covered work from you, a discriminatory
+        patent license (a) in connection with copies of the covered work
+        conveyed by you (or copies made from those copies), or (b) primarily
+        for and in connection with specific products or compilations that
+        contain the covered work, unless you entered into that arrangement,
+        or that patent license was granted, prior to 28 March 2007.
+        
+          Nothing in this License shall be construed as excluding or limiting
+        any implied license or other defenses to infringement that may
+        otherwise be available to you under applicable patent law.
+        
+          12. No Surrender of Others' Freedom.
+        
+          If conditions are imposed on you (whether by court order, agreement or
+        otherwise) that contradict the conditions of this License, they do not
+        excuse you from the conditions of this License.  If you cannot convey a
+        covered work so as to satisfy simultaneously your obligations under this
+        License and any other pertinent obligations, then as a consequence you may
+        not convey it at all.  For example, if you agree to terms that obligate you
+        to collect a royalty for further conveying from those to whom you convey
+        the Program, the only way you could satisfy both those terms and this
+        License would be to refrain entirely from conveying the Program.
+        
+          13. Use with the GNU Affero General Public License.
+        
+          Notwithstanding any other provision of this License, you have
+        permission to link or combine any covered work with a work licensed
+        under version 3 of the GNU Affero General Public License into a single
+        combined work, and to convey the resulting work.  The terms of this
+        License will continue to apply to the part which is the covered work,
+        but the special requirements of the GNU Affero General Public License,
+        section 13, concerning interaction through a network will apply to the
+        combination as such.
+        
+          14. Revised Versions of this License.
+        
+          The Free Software Foundation may publish revised and/or new versions of
+        the GNU General Public License from time to time.  Such new versions will
+        be similar in spirit to the present version, but may differ in detail to
+        address new problems or concerns.
+        
+          Each version is given a distinguishing version number.  If the
+        Program specifies that a certain numbered version of the GNU General
+        Public License "or any later version" applies to it, you have the
+        option of following the terms and conditions either of that numbered
+        version or of any later version published by the Free Software
+        Foundation.  If the Program does not specify a version number of the
+        GNU General Public License, you may choose any version ever published
+        by the Free Software Foundation.
+        
+          If the Program specifies that a proxy can decide which future
+        versions of the GNU General Public License can be used, that proxy's
+        public statement of acceptance of a version permanently authorizes you
+        to choose that version for the Program.
+        
+          Later license versions may give you additional or different
+        permissions.  However, no additional obligations are imposed on any
+        author or copyright holder as a result of your choosing to follow a
+        later version.
+        
+          15. Disclaimer of Warranty.
+        
+          THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+        APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+        HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+        OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+        THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+        PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+        IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+        ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+        
+          16. Limitation of Liability.
+        
+          IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+        WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+        THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+        GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+        USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+        DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+        PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+        EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+        SUCH DAMAGES.
+        
+          17. Interpretation of Sections 15 and 16.
+        
+          If the disclaimer of warranty and limitation of liability provided
+        above cannot be given local legal effect according to their terms,
+        reviewing courts shall apply local law that most closely approximates
+        an absolute waiver of all civil liability in connection with the
+        Program, unless a warranty or assumption of liability accompanies a
+        copy of the Program in return for a fee.
+        
+                             END OF TERMS AND CONDITIONS
+        
+                    How to Apply These Terms to Your New Programs
+        
+          If you develop a new program, and you want it to be of the greatest
+        possible use to the public, the best way to achieve this is to make it
+        free software which everyone can redistribute and change under these terms.
+        
+          To do so, attach the following notices to the program.  It is safest
+        to attach them to the start of each source file to most effectively
+        state the exclusion of warranty; and each file should have at least
+        the "copyright" line and a pointer to where the full notice is found.
+        
+            <one line to give the program's name and a brief idea of what it does.>
+            Copyright (C) <year>  <name of author>
+        
+            This program is free software: you can redistribute it and/or modify
+            it under the terms of the GNU General Public License as published by
+            the Free Software Foundation, either version 3 of the License, or
+            (at your option) any later version.
+        
+            This program is distributed in the hope that it will be useful,
+            but WITHOUT ANY WARRANTY; without even the implied warranty of
+            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+            GNU General Public License for more details.
+        
+            You should have received a copy of the GNU General Public License
+            along with this program.  If not, see <https://www.gnu.org/licenses/>.
+        
+        Also add information on how to contact you by electronic and paper mail.
+        
+          If the program does terminal interaction, make it output a short
+        notice like this when it starts in an interactive mode:
+        
+            <program>  Copyright (C) <year>  <name of author>
+            This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+            This is free software, and you are welcome to redistribute it
+            under certain conditions; type `show c' for details.
+        
+        The hypothetical commands `show w' and `show c' should show the appropriate
+        parts of the General Public License.  Of course, your program's commands
+        might be different; for a GUI interface, you would use an "about box".
+        
+          You should also get your employer (if you work as a programmer) or school,
+        if any, to sign a "copyright disclaimer" for the program, if necessary.
+        For more information on this, and how to apply and follow the GNU GPL, see
+        <https://www.gnu.org/licenses/>.
+        
+          The GNU General Public License does not permit incorporating your program
+        into proprietary programs.  If your program is a subroutine library, you
+        may consider it more useful to permit linking proprietary applications with
+        the library.  If this is what you want to do, use the GNU Lesser General
+        Public License instead of this License.  But first, please read
+        <https://www.gnu.org/licenses/why-not-lgpl.html>.
+        
+Project-URL: homepage, https://github.com/UMainedynamics/SeidarT
+Project-URL: documentation, https://umainedynamics.github.io/SeidarT/index.html
+Classifier: Programming Language :: Python :: 3
+Classifier: License :: OSI Approved :: GNU Affero General Public License v3
+Classifier: Operating System :: OS Independent
+Classifier: Framework :: Matplotlib
+Classifier: Topic :: Scientific/Engineering :: Physics
+Classifier: Intended Audience :: Science/Research
+Classifier: Natural Language :: English
+Classifier: Development Status :: 4 - Beta
+Requires-Python: >=3.11
+Description-Content-Type: text/markdown
+License-File: LICENSE.txt
+Requires-Dist: numpy
+Requires-Dist: scipy
+Requires-Dist: matplotlib
+Requires-Dist: pandas
+Requires-Dist: mplstereonet
+Requires-Dist: pyevtk
+Requires-Dist: glob2
+
+# SeidarT
+
+<!-- ### Table of Contents -->
+<!-- [Introduction](#introduction)  
+[Installation](#install)  
+[Auto-Install](#auto-installation) 
+[Manual Install](#manual-installation)  
+[Hardware Requirements](#hardware-requirements)  
+[Operating System Requirements](#operating-system-requirements)   -->
+
+Full documentation appears in the docs folder. 
+
+[comment]: ======================================================================
+
+## Introduction <a name="introduction"></a>
+
+The Seismic and Radar Toolbox (SeidarT) is a collaboration between researchers at the Universities of Maine and Washington to provide an open source platform for forward modeling mechanical and electromagnetic wave propagation. The major objective of the project is to easily and quickly implement isotropic and anisotropic complex geometries and/or velocity structures to develop prior constraints for - not limited too - investigating, estimating, and imaging englacial ice structure, sub-glacial boundary conditions on the sub-regional scale. Larger problems would require the curvature of the Earth to be taken into consideration, but many glacier seismic and radar experiments do not expand into regional parameter estimation and velocity modeling.
+
+Much of the Staggered Grid FDTD code has been adopted from the *SEISMIC_CPML* software provided by [Computational Infrastucture for Geophysics (CIG)](https://geodynamics.org/cig/software/). Further details to the backend numerical code can be found in the [References](#references) section below.
+
+## Installation <a name="install"></a>
+
+The dynamical programming language of **Python3** is used as a command line interface to run the more computationally extensive modeling schemes in **Fortran**. There are a number of ways to install this software depending on your desired level of control over the process. Most users should be fine with the "automatic installation" in the [section below](#auto-install).
+
+SeidarT package binaries are publicly availble on the [PyPi repository](https://pypi.org/project/seidart/) and source code can be found at github (not yet public). 
+
+### "Auto" installation <a name="auto-install"></a>
+
+Extract the *install* directory from the *install.tar.gz* or *install.bz* for Unix/Linux or Windows users, respectively
+
+There are 2 install scripts, *full_install.sh* and *full_install.bat*, which will cover Linux, MacOS 13 and 14, and Windows , respectively. It's not necessary to know or do much more than execute a few command line entries via a bash terminal or powershell terminal. A virtual environment is created using the Miniconda/Anaconda package manager. This will avoid causing system incompatibilities and complicated software dependencies. Documentation for managing conda environments with Miniconda or Anaconda can be found [here](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html). The full Anaconda release has a GUI called Navigator for managing environments. This can be found [here](https://docs.anaconda.com/free/navigator/tutorials/manage-environments/).  
+
+The *full_install.?* checks for an Anaconda/Miniconda and will install it if it isn't found. If Anaconda/Miniconda is not defined in your 'PATH' variable than it will be installed using the default install location. After installing the Conda package, the *seidart* environment is built using pre-defined dependencies in a YAML (Yet Another Markup Language) file. Both *Bash* executables and Python modules are built during install. In order to use either, the environment must be active. This can be easily done from the *Bash* command line interface (CLI) using the command
+```
+conda activate seidart
+```
+
+[comment]: ======================================================================
+### Manual installation<a name="manual-install-pip"></a>
+
+The full repo can be found on GitHub and hosted on PyPi. *SeidarT* has been tested on Python 3.11 and is not yet supported with Python 3.12. For users that prefer building virtual environments with Anaconda, the install folder contains the *seidart-environment.yml* or it can be found in the root directory of the GitHub repo. The command 
+```
+conda env create -f seidart-environment.yml
+```
+will install all dependencies and the *seidart* package. For users who prefer more control in their installation, their is a small list of dependencies that must be met. These are:  *gcc*>10, *gfortran*, *ghostscript*, *imagemagick*, *numpy*, *pandas*, *matplotlib*, *scipy*, *glob2*, *pyevtk*, *mplstereonet*. Following install of all dependencies, 
+```
+pip install seidart
+```
+will pull and install the package from PyPi. 
+
+### Hardware Requirements <a name="hardware-requirement"></a>
+
+*SeidarT* was tested and developed on a quad core 5th gen i7 processor with 16 Gb of RAM without any burden on the system so a typical modern laptop is sufficient for many application. When running models with large domains or a high number of time steps, the computational load is obviously increased, however the storage requirements become more significant. It can be easy to fill up 10's of Gb of storage, but an external drive can resolve that problem. The Apple M-chips may have compatability issues with particular types of software and Python packages, but we have maintained a relatively simple design along with leveraging some of the most commonly used Python packages which should help to mitigate any issues with computing on an M-chip. 
+
+### Operating System Requirements <a name="operating-system"></a>
+
+All of the development was carried out on a Linux operating system and limited to Debian, Ubuntu, Solus 2, and Fedora. No compatibility issues between Linux flavors arose. The binaries are built on Github Actions for Windows 10 and 11 (latest), MacOS 13 and 14 (latest), and most flavors of Linux. Cross-platform usability is one of the core tenets in the development of the software and needs to be maintained in future development.
```

## Comparing `seidart-1.1.0.dist-info/RECORD` & `seidart-1.5.0.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -1,27 +1,28 @@
-seidart/__init__.py,sha256=PVrfk7vRKkpJJHJU_a-ItErANR2O9hk5oFHOSiOL-Ig,127
-seidart/.libs/libcpmlfdtd.HHM64BD6ITWEAQBB4CKPKFCVIIT6G6AX.gfortran-win_amd64.dll,sha256=AvvdGtsGoSf72LJ_t2dnuSARtnrve3IZwAanQSjSAh0,1455789
-seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll,sha256=0Ba3rZu8xcMnNrfs95AsMMpy_vjrjusyJDIKTCN1PoE,713500
-seidart/fortran/__init__.py,sha256=4nOBVLNyIYohjXzZup9l2bSWdxEWZ1kckQ5ct7VKcJ4,17
-seidart/fortran/cpmlfdtd.cp311-win_amd64.pyd,sha256=ZNFiorzzYvjUT-TTd2RqSLD6UuOjjeiD8opOXcgC_M4,73728
-seidart/fortran/orientsynth.cp311-win_amd64.pyd,sha256=_uE_TtTi_5wuZ5Z22Q3zH64nt4DF17_2M2G1viDW_d0,35840
-seidart/routines/__init__.py,sha256=02YBzrjiGHhmBrXzGNuL-XNLPYP5CNaKcT-Ndy-f6R0,232
-seidart/routines/arraybuild.py,sha256=uNHkYIiw88ikuxrjh8Vz9hbNVOZ-fgrXTNKhfVEZyZE,18025
-seidart/routines/definitions.py,sha256=kmX_BT4xwE9KkurEs_XoCOs9K8b988z7c4bw-lisflc,51433
-seidart/routines/materials.py,sha256=OuHVjXLov2fDeCYZHbpJ-JpQsJt4yUC6DN2gi_2cpNg,35262
-seidart/routines/orientation_tensor.py,sha256=uqiunYoDxvVC2kLzxKgXgHq9wZONf8iFS_SGKgchZ1U,3939
-seidart/routines/prjbuild.py,sha256=kozfXfUmdXtL5q6HxKWJHN4OfdhXhyps44X5Z1uaVRo,9671
-seidart/routines/prjrun.py,sha256=HDshvBBMGAHQJvWszwn1hOHW-b5MW2n0AC73hK768sY,21596
-seidart/routines/sourcefunction.py,sha256=zg4Q-4f-PEbuk2MZ6G6L78nb1EZivl5nX5gmIP56CDA,9871
-seidart/simulations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-seidart/simulations/common_offset.py,sha256=kfS-_SjBMfbJToqrHxUH21kk2bONytmoj_BmuAYTZ_Q,8201
-seidart/visualization/__init__.py,sha256=uwwvcjJJUICSIcY8M3laZwDFwJTKty0mOBilXpkNxYk,46
-seidart/visualization/im2anim.py,sha256=UA3kq8siu-on4AmwzALi04JOKq3RtNG9Q_kleeHHNOU,7092
-seidart/visualization/imgen.py,sha256=Z61xz4lRpquQ_AEUFhuRyUVPP5AnP-OFwVr3tcKaAkU,13729
-seidart/visualization/implot.py,sha256=_HTv39e0qcbtSp2P1kxvLz6yMTVeu9Ep3alTboFfdb0,1291
-seidart/visualization/slice25d.py,sha256=RDErIsK5u7Ie6O0dtyuEaRzmDchIXYx1nv0XgiRXpQo,5280
-seidart/visualization/vtkbuild.py,sha256=Z3oyrNDEJxuo-9hrSNxlLQam_PunqQVXV2bCkd0n2mQ,4088
-seidart-1.1.0.dist-info/LICENSE.txt,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-seidart-1.1.0.dist-info/METADATA,sha256=P7gFnPQlsu6xKiqg2iI0WS97G1ai9pqQaet2S-E02cQ,48376
-seidart-1.1.0.dist-info/WHEEL,sha256=nSybvzWlmdJnHiUQSY-d7V1ycwEVUTqXiTvr2eshg44,102
-seidart-1.1.0.dist-info/top_level.txt,sha256=M8E1K6tlpjukvjp2DWa9jKXRnBorH-dxJ7QQpTb7TQI,8
-seidart-1.1.0.dist-info/RECORD,,
+seidart-1.5.0.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+seidart-1.5.0.dist-info/METADATA,sha256=k9maELWU1jadrCj33mlPK8H749iLlhqNsBHIPh9J-2A,47631
+seidart-1.5.0.dist-info/RECORD,,
+seidart-1.5.0.dist-info/top_level.txt,sha256=M8E1K6tlpjukvjp2DWa9jKXRnBorH-dxJ7QQpTb7TQI,8
+seidart-1.5.0.dist-info/WHEEL,sha256=FrRrfsr8n4oDiu2RQ4P_GNkwaRm2j8S009nGoQPBEBk,114
+seidart/__init__.py,sha256=j-8WDJ1bJ0DzMsTMaq7TWBlxWmFkXng_8A9fzPfwt_I,123
+seidart/routines/definitions.py,sha256=ncFOBj5NRp7CYr8a7MpV2ioMLi8rKYzUp5TijDRLeBk,50219
+seidart/routines/prjrun.py,sha256=v6TpP6mvgm0LooC6bpMyQKOaUy_myYiqU8AFjjVDAao,21023
+seidart/routines/materials.py,sha256=-VHsi9wExQcxKRLNlierPSr7qBC87G86wbKyQyVUCV0,34350
+seidart/routines/prjbuild.py,sha256=MtJEkBg_3HAJM2q8fzczIbfRHy4hLfptZIe5zIo8Fn0,9395
+seidart/routines/orientation_tensor.py,sha256=bVGBfSf3Hs25yd-BRXPkl46nH0xmMQZWbEK9p_YYbts,3827
+seidart/routines/__init__.py,sha256=3EUaQp9ZCw4IvB4REGNBJpZb8XefsHW4ukqjTYR2NDk,224
+seidart/routines/sourcefunction.py,sha256=WUsdAuWWJDd0cVla94XtwdJcxOV1CpoM0hVjE31-cms,9587
+seidart/routines/arraybuild.py,sha256=yhUq39UOTXOLzcdrwX15CeXuHIoSOptCRSIMHGwjzEw,19672
+seidart/fortran/orientsynth.cpython-311-x86_64-linux-gnu.so,sha256=gTZ8-a0hbKOIuWjI56Dqj3PL29e5DoIgZIM4mBYixBk,199073
+seidart/fortran/__init__.py,sha256=Il5Q9ATdX8yXqVxtP_nYqUhExzxPC_qk_WXQ_4h0exg,16
+seidart/fortran/cpmlfdtd.cpython-311-x86_64-linux-gnu.so,sha256=UHQ1jtHkrQYyyrqczoQgp1X-FM82J0A95Mkt-hRgat0,1199721
+seidart/visualization/slice25d.py,sha256=74Kt2A3-TIa7yVHY549JNL1Gp8-Xdlu1ewEjcN5dsTk,5109
+seidart/visualization/im2anim.py,sha256=QMMh3HvG2c1VxEW4nKSuZbgjhTAK_EkXP5CIVDtRKJU,6889
+seidart/visualization/__init__.py,sha256=mmitv3MjIi_iEysRfi6QunoNRRhhx0ekGP2CUGbN-JQ,44
+seidart/visualization/vtkbuild.py,sha256=cvSC4WF4Kx5Wnc6vw7hEGpRAcpcWCVbEK8RQQCjOPfc,3959
+seidart/visualization/implot.py,sha256=mjXg2H2adSvlvTcKGEPWqiMSrInZD-H3HBwTkSL3_bw,1244
+seidart/visualization/imgen.py,sha256=87xPRuXuCWCcc1BzGTzWegWP7_s2_hWYkp9CRbrNhGk,13447
+seidart/simulations/common_offset.py,sha256=HDrr0e8x0KwKrqWKz52k-8nbaia9_LQoQark81FEJPA,8347
+seidart/simulations/multioffset.py,sha256=RKmlCuprk0HTItzIPbeU7TUsZTPAuOzW0AUzw_KmMe4,8183
+seidart/simulations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+seidart.libs/libquadmath-0605fa11.so.0.0.0,sha256=i5xERc8gmYq5yeinkZ30D3XByxbJvk5b0ZbqJgY9HSM,259905
+seidart.libs/libgfortran-bbf01bbb.so.3.0.0,sha256=JkSfevfj6UZk7ssP4RA6_0xOmRz3P0A67N5cqwjT-os,1283921
```

