# Comparing `tmp/quantum-pecos-0.5.dev1.tar.gz` & `tmp/quantum_pecos-0.6.0.dev1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "quantum-pecos-0.5.dev1.tar", last modified: Wed Dec  6 01:02:51 2023, max compression
+gzip compressed data, was "quantum_pecos-0.6.0.dev1.tar", last modified: Wed May 15 17:59:06 2024, max compression
```

## Comparing `quantum-pecos-0.5.dev1.tar` & `quantum_pecos-0.6.0.dev1.tar`

### file list

```diff
@@ -1,344 +1,305 @@
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.310271 quantum-pecos-0.5.dev1/
--rw-rw-rw-   0        0        0    11563 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/LICENSE
--rw-rw-rw-   0        0        0      140 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/MANIFEST.in
--rw-rw-rw-   0        0        0      461 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/NOTICE
--rw-rw-rw-   0        0        0    17225 2023-12-06 01:02:51.309760 quantum-pecos-0.5.dev1/PKG-INFO
--rw-rw-rw-   0        0        0     2207 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/README.md
--rw-rw-rw-   0        0        0     2219 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/pyproject.toml
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.576540 quantum-pecos-0.5.dev1/python/
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.600831 quantum-pecos-0.5.dev1/python/pecos/
--rw-rw-rw-   0        0        0     2165 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.620029 quantum-pecos-0.5.dev1/python/pecos/circuit_converters/
--rw-rw-rw-   0        0        0      920 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuit_converters/__init__.py
--rw-rw-rw-   0        0        0     9686 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuit_converters/checks2circuit.py
--rw-rw-rw-   0        0        0     5401 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuit_converters/std2chs.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.645811 quantum-pecos-0.5.dev1/python/pecos/circuits/
--rw-rw-rw-   0        0        0      883 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.705688 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/
--rw-rw-rw-   0        0        0      614 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/__init__.py
--rw-rw-rw-   0        0        0     1429 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/conditionals.py
--rw-rw-rw-   0        0        0     1759 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/cops.py
--rw-rw-rw-   0        0        0     1102 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/fund.py
--rw-rw-rw-   0        0        0     1220 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/hyqc.py
--rw-rw-rw-   0        0        0     2891 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/int.py
--rw-rw-rw-   0        0        0     1259 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/misc_stmts.py
--rw-rw-rw-   0        0        0     5704 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/qops.py
--rw-rw-rw-   0        0        0     1651 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/qubits.py
--rw-rw-rw-   0        0        0     1148 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/vars.py
--rw-rw-rw-   0        0        0     4984 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/logical_circuit.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.771030 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/
--rw-rw-rw-   0        0        0      897 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/__init__.py
--rw-rw-rw-   0        0        0      832 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/barrier.py
--rw-rw-rw-   0        0        0     1062 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/block.py
--rw-rw-rw-   0        0        0     2378 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/conditionals.py
--rw-rw-rw-   0        0        0     1934 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/expr.py
--rw-rw-rw-   0        0        0      918 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/func.py
--rw-rw-rw-   0        0        0     6736 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/gates.py
--rw-rw-rw-   0        0        0     1621 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/misc.py
--rw-rw-rw-   0        0        0     5524 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/qasm.py
--rw-rw-rw-   0        0        0     1135 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/std_gates.py
--rw-rw-rw-   0        0        0     2235 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/vars.py
--rw-rw-rw-   0        0        0     9992 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/qc2phir.py
--rw-rw-rw-   0        0        0    15141 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/circuits/quantum_circuit.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.789871 quantum-pecos-0.5.dev1/python/pecos/classical_interpreters/
--rw-rw-rw-   0        0        0      586 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/classical_interpreters/__init__.py
--rw-rw-rw-   0        0        0     1569 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/classical_interpreters/classical_interpreter_abc.py
--rw-rw-rw-   0        0        0     9728 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/classical_interpreters/phir_classical_interpreter.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.794987 quantum-pecos-0.5.dev1/python/pecos/decoders/
--rw-rw-rw-   0        0        0      844 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/decoders/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.805636 quantum-pecos-0.5.dev1/python/pecos/decoders/dummy_decoder/
--rw-rw-rw-   0        0        0      794 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/decoders/dummy_decoder/__init__.py
--rw-rw-rw-   0        0        0     1228 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/decoders/dummy_decoder/dummy_decoder.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.823832 quantum-pecos-0.5.dev1/python/pecos/decoders/mwpm2d/
--rw-rw-rw-   0        0        0      752 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/decoders/mwpm2d/__init__.py
--rw-rw-rw-   0        0        0     5536 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/decoders/mwpm2d/mwpm2d.py
--rw-rw-rw-   0        0        0    18688 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/decoders/mwpm2d/precomputing.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.851276 quantum-pecos-0.5.dev1/python/pecos/engines/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.871077 quantum-pecos-0.5.dev1/python/pecos/engines/circuit_runners/
--rw-rw-rw-   0        0        0      827 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/circuit_runners/__init__.py
--rw-rw-rw-   0        0        0     3504 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/circuit_runners/standard.py
--rw-rw-rw-   0        0        0     2336 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/circuit_runners/timing_runner.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.913790 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/__init__.py
--rw-rw-rw-   0        0        0     8296 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/binarray.py
--rw-rw-rw-   0        0        0     4995 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/binarray2.py
--rw-rw-rw-   0        0        0     7410 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/classical.py
--rw-rw-rw-   0        0        0     1729 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/cvm.py
--rw-rw-rw-   0        0        0     1678 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/sim_func.py
--rw-rw-rw-   0        0        0     3991 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.933414 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/__init__.py
--rw-rw-rw-   0        0        0     1549 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/pywasm.py
--rw-rw-rw-   0        0        0     1077 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/pywasm3.py
--rw-rw-rw-   0        0        0     2598 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/wasmer.py
--rw-rw-rw-   0        0        0     7610 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/hybrid_engine.py
--rw-rw-rw-   0        0        0     5159 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/hybrid_engine_multiprocessing.py
--rw-rw-rw-   0        0        0     8335 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/engines/hybrid_engine_old.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:49.986672 quantum-pecos-0.5.dev1/python/pecos/error_models/
--rw-rw-rw-   0        0        0     1091 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/__init__.py
--rw-rw-rw-   0        0        0     1877 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/class_errors_circuit.py
--rw-rw-rw-   0        0        0     5838 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/depolarizing_error_model.py
--rw-rw-rw-   0        0        0     5829 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/error_depolar.py
--rw-rw-rw-   0        0        0     1278 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/error_model.py
--rw-rw-rw-   0        0        0     1406 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/error_model_abc.py
--rw-rw-rw-   0        0        0     1047 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/fake_error_model.py
--rw-rw-rw-   0        0        0     5892 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/generic_error_model.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.046826 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/__init__.py
--rw-rw-rw-   0        0        0      965 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_initz_bitflip.py
--rw-rw-rw-   0        0        0     1463 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_initz_bitflip_leakage.py
--rw-rw-rw-   0        0        0     1462 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_meas_bitflip.py
--rw-rw-rw-   0        0        0     1673 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_meas_bitflip_leakage.py
--rw-rw-rw-   0        0        0     1186 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_sq_bitflip.py
--rw-rw-rw-   0        0        0     1576 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_sq_depolarizing.py
--rw-rw-rw-   0        0        0     2101 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_sq_depolarizing_leakage.py
--rw-rw-rw-   0        0        0     1781 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_tq_depolarizing.py
--rw-rw-rw-   0        0        0     2592 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_tq_depolarizing_leakage.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.088174 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/__init__.py
--rw-rw-rw-   0        0        0     2164 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/gate_groups.py
--rw-rw-rw-   0        0        0     1337 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/init_noise.py
--rw-rw-rw-   0        0        0     1606 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/meas_noise.py
--rw-rw-rw-   0        0        0     1297 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/memory_noise.py
--rw-rw-rw-   0        0        0     1127 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/sq_noise.py
--rw-rw-rw-   0        0        0     3066 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/tq_noise.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.124926 quantum-pecos-0.5.dev1/python/pecos/error_models/old/
--rw-rw-rw-   0        0        0      791 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/old/__init__.py
--rw-rw-rw-   0        0        0     7435 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/old/depolar_gen.py
--rw-rw-rw-   0        0        0     5377 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/old/gatewise_gen.py
--rw-rw-rw-   0        0        0     6134 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/old/xerror_gen.py
--rw-rw-rw-   0        0        0     7139 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/old/xzerror_gen.py
--rw-rw-rw-   0        0        0     6134 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/old/zerror_gen.py
--rw-rw-rw-   0        0        0    11864 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/error_models/parent_class_error_gen.py
--rw-rw-rw-   0        0        0      894 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/errors.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.153274 quantum-pecos-0.5.dev1/python/pecos/foreign_objects/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/foreign_objects/__init__.py
--rw-rw-rw-   0        0        0     1265 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/foreign_objects/foreign_object_abc.py
--rw-rw-rw-   0        0        0     2327 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/foreign_objects/object_pool.py
--rw-rw-rw-   0        0        0     1061 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/foreign_objects/python.py
--rw-rw-rw-   0        0        0     3324 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/foreign_objects/wasmer.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.171030 quantum-pecos-0.5.dev1/python/pecos/machines/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/machines/__init__.py
--rw-rw-rw-   0        0        0     2257 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/machines/generic_machine.py
--rw-rw-rw-   0        0        0     1648 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/machines/machine_abc.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.230375 quantum-pecos-0.5.dev1/python/pecos/misc/
--rw-rw-rw-   0        0        0      821 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/misc/__init__.py
--rw-rw-rw-   0        0        0     2284 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/misc/commute.py
--rw-rw-rw-   0        0        0      895 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/misc/errors.py
--rw-rw-rw-   0        0        0     1367 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/misc/gate_groups.py
--rw-rw-rw-   0        0        0    10711 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/misc/stabilizer_funcs.py
--rw-rw-rw-   0        0        0     2016 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/misc/std_ouput.py
--rw-rw-rw-   0        0        0     3546 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/misc/symbol_library.py
--rw-rw-rw-   0        0        0     7335 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/misc/threshold_curve.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.248066 quantum-pecos-0.5.dev1/python/pecos/op_processors/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/op_processors/__init__.py
--rw-rw-rw-   0        0        0     1918 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/op_processors/generic_op_processor.py
--rw-rw-rw-   0        0        0     1138 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/op_processors/op_processor_abc.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.290206 quantum-pecos-0.5.dev1/python/pecos/qeccs/
--rw-rw-rw-   0        0        0     1167 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.322096 quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/
--rw-rw-rw-   0        0        0      752 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/__init__.py
--rw-rw-rw-   0        0        0     8051 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/circuit_implementation1.py
--rw-rw-rw-   0        0        0     8604 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/color_488.py
--rw-rw-rw-   0        0        0     3253 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/gates.py
--rw-rw-rw-   0        0        0     8968 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/instructions.py
--rw-rw-rw-   0        0        0     3859 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/gate_parent_class.py
--rw-rw-rw-   0        0        0     2212 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/helper_functions.py
--rw-rw-rw-   0        0        0     4021 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/instruction_parent_class.py
--rw-rw-rw-   0        0        0     7755 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/plot.py
--rw-rw-rw-   0        0        0     8289 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/qecc_parent_class.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.344690 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_4444/
--rw-rw-rw-   0        0        0      752 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_4444/__init__.py
--rw-rw-rw-   0        0        0     3253 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_4444/gates.py
--rw-rw-rw-   0        0        0    11270 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_4444/instructions.py
--rw-rw-rw-   0        0        0     9742 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_4444/surface_4444.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.361920 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_medial_4444/
--rw-rw-rw-   0        0        0      752 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_medial_4444/__init__.py
--rw-rw-rw-   0        0        0     3253 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_medial_4444/gates.py
--rw-rw-rw-   0        0        0    20144 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_medial_4444/instructions.py
--rw-rw-rw-   0        0        0    10399 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_medial_4444/surface_medial_4444.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.363947 quantum-pecos-0.5.dev1/python/pecos/reps/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/reps/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.400375 quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/
--rw-rw-rw-   0        0        0      618 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/__init__.py
--rw-rw-rw-   0        0        0     1474 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/block_types.py
--rw-rw-rw-   0        0        0     2151 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/data_types.py
--rw-rw-rw-   0        0        0     1947 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/op_types.py
--rw-rw-rw-   0        0        0     6993 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/pypmir.py
--rw-rw-rw-   0        0        0      691 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/types.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.439974 quantum-pecos-0.5.dev1/python/pecos/simulators/
--rw-rw-rw-   0        0        0     1582 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/__init__.py
--rw-rw-rw-   0        0        0     2295 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/compile_cython.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.450092 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/
--rw-rw-rw-   0        0        0      632 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/__init__.py
--rw-rw-rw-   0        0        0      776 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuconn.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.456144 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/
--rw-rw-rw-   0        0        0      624 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.457154 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.457154 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/eigen/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/eigen/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.464734 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/eigen/scripts/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/eigen/scripts/__init__.py
--rw-rw-rw-   0        0        0     2437 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/eigen/scripts/relicense.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.521025 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/__init__.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.539057 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/docs/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/docs/__init__.py
--rw-rw-rw-   0        0        0     2943 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/docs/benchmark.py
--rw-rw-rw-   0        0        0    12422 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/docs/conf.py
--rw-rw-rw-   0        0        0     2776 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/noxfile.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.570942 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/pybind11/
--rw-rw-rw-   0        0        0      386 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/pybind11/__init__.py
--rw-rw-rw-   0        0        0     1160 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/pybind11/__main__.py
--rw-rw-rw-   0        0        0      245 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/pybind11/_version.py
--rw-rw-rw-   0        0        0      868 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/pybind11/commands.py
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/pybind11/py.typed
--rw-rw-rw-   0        0        0    18113 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/pybind11/setup_helpers.py
--rw-rw-rw-   0        0        0     4970 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/setup.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.873187 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/__init__.py
--rw-rw-rw-   0        0        0     4771 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/conftest.py
--rw-rw-rw-   0        0        0      968 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/env.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.883839 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/extra_python_package/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/extra_python_package/__init__.py
--rw-rw-rw-   0        0        0     7699 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/extra_python_package/test_files.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.890536 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/extra_setuptools/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/extra_setuptools/__init__.py
--rw-rw-rw-   0        0        0     4304 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/extra_setuptools/test_setuphelper.py
--rw-rw-rw-   0        0        0      558 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_async.py
--rw-rw-rw-   0        0        0     5004 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_buffers.py
--rw-rw-rw-   0        0        0    17771 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_builtin_casters.py
--rw-rw-rw-   0        0        0     6796 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_call_policies.py
--rw-rw-rw-   0        0        0     6101 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_callbacks.py
--rw-rw-rw-   0        0        0     5904 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_chrono.py
--rw-rw-rw-   0        0        0    14797 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_class.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.896826 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_cmake_build/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_cmake_build/__init__.py
--rw-rw-rw-   0        0        0      206 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_cmake_build/test.py
--rw-rw-rw-   0        0        0      618 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_const_name.py
--rw-rw-rw-   0        0        0     1550 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_constants_and_functions.py
--rw-rw-rw-   0        0        0     4747 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_copy_move.py
--rw-rw-rw-   0        0        0     4100 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_custom_type_casters.py
--rw-rw-rw-   0        0        0     1137 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_custom_type_setup.py
--rw-rw-rw-   0        0        0     1647 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_docstring_options.py
--rw-rw-rw-   0        0        0    28877 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_eigen.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.909209 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_embed/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_embed/__init__.py
--rw-rw-rw-   0        0        0      251 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_embed/test_interpreter.py
--rw-rw-rw-   0        0        0      291 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_embed/test_trampoline.py
--rw-rw-rw-   0        0        0     9167 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_enum.py
--rw-rw-rw-   0        0        0     1193 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_eval.py
--rw-rw-rw-   0        0        0      123 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_eval_call.py
--rw-rw-rw-   0        0        0     9132 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_exceptions.py
--rw-rw-rw-   0        0        0    17035 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_factory_constructors.py
--rw-rw-rw-   0        0        0     3197 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_gil_scoped.py
--rw-rw-rw-   0        0        0     7581 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_iostream.py
--rw-rw-rw-   0        0        0    14147 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_kwargs_and_defaults.py
--rw-rw-rw-   0        0        0     8305 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_local_bindings.py
--rw-rw-rw-   0        0        0    18113 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_methods_and_attributes.py
--rw-rw-rw-   0        0        0     2910 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_modules.py
--rw-rw-rw-   0        0        0    12367 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_multiple_inheritance.py
--rw-rw-rw-   0        0        0    20815 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_numpy_array.py
--rw-rw-rw-   0        0        0    14434 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_numpy_dtypes.py
--rw-rw-rw-   0        0        0     9952 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_numpy_vectorize.py
--rw-rw-rw-   0        0        0     1905 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_opaque_types.py
--rw-rw-rw-   0        0        0     4485 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_operator_overloading.py
--rw-rw-rw-   0        0        0     2253 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_pickling.py
--rw-rw-rw-   0        0        0    18331 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_pytypes.py
--rw-rw-rw-   0        0        0     8034 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_sequences_and_iterators.py
--rw-rw-rw-   0        0        0     9845 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_smart_ptr.py
--rw-rw-rw-   0        0        0    11939 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_stl.py
--rw-rw-rw-   0        0        0     8223 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_stl_binders.py
--rw-rw-rw-   0        0        0      769 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_tagbased_polymorphic.py
--rw-rw-rw-   0        0        0      868 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_thread.py
--rw-rw-rw-   0        0        0      156 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_union.py
--rw-rw-rw-   0        0        0    13378 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/test_virtual_functions.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.922626 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tools/
--rw-rw-rw-   0        0        0        0 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tools/__init__.py
--rw-rw-rw-   0        0        0     1067 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tools/libsize.py
--rw-rw-rw-   0        0        0     1345 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tools/make_changelog.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.937389 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/test/
--rw-rw-rw-   0        0        0      624 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/test/__init__.py
--rw-rw-rw-   0        0        0     4497 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/test/test_python_bindings.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.986396 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/
--rw-rw-rw-   0        0        0      588 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/__init__.py
--rw-rw-rw-   0        0        0     2010 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/bindings.py
--rw-rw-rw-   0        0        0     1032 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/gates_init.py
--rw-rw-rw-   0        0        0      785 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/gates_meas.py
--rw-rw-rw-   0        0        0     3603 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/gates_sq.py
--rw-rw-rw-   0        0        0     1206 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/gates_tq.py
--rw-rw-rw-   0        0        0     1878 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/state.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:50.998852 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/
--rw-rw-rw-   0        0        0      829 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/__init__.py
--rw-rw-rw-   0        0        0     2239 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/setup.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.006654 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/src/
--rw-rw-rw-   0        0        0      752 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/src/__init__.py
--rw-rw-rw-   0        0        0     6376 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/src/logical_sign.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.018524 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_col/
--rw-rw-rw-   0        0        0      825 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_col/__init__.py
--rw-rw-rw-   0        0        0     2007 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_col/setup.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.025785 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_col/src/
--rw-rw-rw-   0        0        0     6137 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_col/src/logical_sign.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.029315 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_row/
--rw-rw-rw-   0        0        0      825 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_row/__init__.py
--rw-rw-rw-   0        0        0     2007 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_row/setup.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.030867 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_row/src/
--rw-rw-rw-   0        0        0     6137 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_row/src/logical_sign.py
--rw-rw-rw-   0        0        0     2778 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/gate_syms.py
--rw-rw-rw-   0        0        0     2646 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/parent_sim_classes.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.082154 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/
--rw-rw-rw-   0        0        0      678 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/__init__.py
--rw-rw-rw-   0        0        0     2966 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/bindings.py
--rw-rw-rw-   0        0        0      913 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/gates_init.py
--rw-rw-rw-   0        0        0     2986 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/gates_meas.py
--rw-rw-rw-   0        0        0    13371 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/gates_one_qubit.py
--rw-rw-rw-   0        0        0     8256 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/gates_two_qubit.py
--rw-rw-rw-   0        0        0     1729 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/logical_sign.py
--rw-rw-rw-   0        0        0     9572 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/state.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.141398 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/
--rw-rw-rw-   0        0        0      812 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/__init__.py
--rw-rw-rw-   0        0        0     4881 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/bindings.py
--rw-rw-rw-   0        0        0     2348 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/gates_init.py
--rw-rw-rw-   0        0        0     2733 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/gates_meas.py
--rw-rw-rw-   0        0        0     7699 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/gates_one_qubit.py
--rw-rw-rw-   0        0        0     5191 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/gates_two_qubit.py
--rw-rw-rw-   0        0        0     1251 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/helper.py
--rw-rw-rw-   0        0        0     2369 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/logical_sign.py
--rw-rw-rw-   0        0        0     4752 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/state.py
--rw-rw-rw-   0        0        0     2286 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/quantum_simulator.py
--rw-rw-rw-   0        0        0     1533 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sim_class_types.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.205040 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/
--rw-rw-rw-   0        0        0     1953 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/__init__.py
--rw-rw-rw-   0        0        0     2838 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/bindings.py
--rw-rw-rw-   0        0        0     3341 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/cmd_init.py
--rw-rw-rw-   0        0        0    11815 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/cmd_meas.py
--rw-rw-rw-   0        0        0    34274 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/cmd_one_qubit.py
--rw-rw-rw-   0        0        0    16169 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/cmd_two_qubit.py
--rw-rw-rw-   0        0        0     8064 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/logical_sign.py
--rw-rw-rw-   0        0        0     5488 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/refactor.py
--rw-rw-rw-   0        0        0    17986 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/state.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.271631 quantum-pecos-0.5.dev1/python/pecos/tools/
--rw-rw-rw-   0        0        0     1267 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/__init__.py
--rw-rw-rw-   0        0        0     6557 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/fault_tolerance_checking.py
--rw-rw-rw-   0        0        0    14256 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/fault_tolerance_checks.py
--rw-rw-rw-   0        0        0     2949 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/logic_circuit_speed.py
--rw-rw-rw-   0        0        0     7162 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/pseudo_threshold_tools.py
--rw-rw-rw-   0        0        0     3231 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/random_circuit_speed.py
--rw-rw-rw-   0        0        0    33306 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/stabilizer_verification.py
--rw-rw-rw-   0        0        0    18316 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/threshold_tools.py
--rw-rw-rw-   0        0        0     1417 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/tool_anticommute.py
--rw-rw-rw-   0        0        0     7036 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/python/pecos/tools/tool_collection.py
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.306184 quantum-pecos-0.5.dev1/python/quantum_pecos.egg-info/
--rw-rw-rw-   0        0        0    17225 2023-12-06 01:02:49.000000 quantum-pecos-0.5.dev1/python/quantum_pecos.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    16060 2023-12-06 01:02:49.000000 quantum-pecos-0.5.dev1/python/quantum_pecos.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-12-06 01:02:49.000000 quantum-pecos-0.5.dev1/python/quantum_pecos.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        2 2023-12-06 01:02:48.000000 quantum-pecos-0.5.dev1/python/quantum_pecos.egg-info/not-zip-safe
--rw-rw-rw-   0        0        0      345 2023-12-06 01:02:49.000000 quantum-pecos-0.5.dev1/python/quantum_pecos.egg-info/requires.txt
--rw-rw-rw-   0        0        0        6 2023-12-06 01:02:49.000000 quantum-pecos-0.5.dev1/python/quantum_pecos.egg-info/top_level.txt
--rw-rw-rw-   0        0        0      117 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/requirements.txt
--rw-rw-rw-   0        0        0      316 2023-12-06 01:02:51.311282 quantum-pecos-0.5.dev1/setup.cfg
-drwxrwxrwx   0        0        0        0 2023-12-06 01:02:51.305175 quantum-pecos-0.5.dev1/tests/
--rw-rw-rw-   0        0        0     2735 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/tests/test_quantum_circuits.py
--rw-rw-rw-   0        0        0     3922 2023-10-01 21:36:12.000000 quantum-pecos-0.5.dev1/tests/test_random_circuits.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.383382 quantum_pecos-0.6.0.dev1/
+-rw-rw-rw-   0        0        0    11560 2024-02-18 00:34:34.000000 quantum_pecos-0.6.0.dev1/LICENSE
+-rw-rw-rw-   0        0        0      136 2024-02-18 00:34:34.000000 quantum_pecos-0.6.0.dev1/MANIFEST.in
+-rw-rw-rw-   0        0        0      463 2024-02-18 00:34:34.000000 quantum_pecos-0.6.0.dev1/NOTICE
+-rw-rw-rw-   0        0        0    20835 2024-05-15 17:59:06.382883 quantum_pecos-0.6.0.dev1/PKG-INFO
+-rw-rw-rw-   0        0        0     5198 2024-03-10 03:52:18.000000 quantum_pecos-0.6.0.dev1/README.md
+-rw-rw-rw-   0        0        0     3243 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/pyproject.toml
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.200272 quantum_pecos-0.6.0.dev1/python/
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.207277 quantum_pecos-0.6.0.dev1/python/pecos/
+-rw-rw-rw-   0        0        0     1893 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.208932 quantum_pecos-0.6.0.dev1/python/pecos/circuit_converters/
+-rw-rw-rw-   0        0        0      942 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuit_converters/__init__.py
+-rw-rw-rw-   0        0        0     9739 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuit_converters/checks2circuit.py
+-rw-rw-rw-   0        0        0     5302 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuit_converters/std2chs.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.212661 quantum_pecos-0.6.0.dev1/python/pecos/circuits/
+-rw-rw-rw-   0        0        0      911 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.220163 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/
+-rw-rw-rw-   0        0        0      671 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/__init__.py
+-rw-rw-rw-   0        0        0     1437 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/conditionals.py
+-rw-rw-rw-   0        0        0     1708 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/cops.py
+-rw-rw-rw-   0        0        0     1086 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/fund.py
+-rw-rw-rw-   0        0        0     1225 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/hyqc.py
+-rw-rw-rw-   0        0        0     2830 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/int.py
+-rw-rw-rw-   0        0        0     1302 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/misc_stmts.py
+-rw-rw-rw-   0        0        0     5680 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/qops.py
+-rw-rw-rw-   0        0        0     1513 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/qubits.py
+-rw-rw-rw-   0        0        0     1200 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/vars.py
+-rw-rw-rw-   0        0        0     5033 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/logical_circuit.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.228167 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/
+-rw-rw-rw-   0        0        0     1028 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/__init__.py
+-rw-rw-rw-   0        0        0      852 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/barrier.py
+-rw-rw-rw-   0        0        0     1070 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/block.py
+-rw-rw-rw-   0        0        0     2283 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/conditionals.py
+-rw-rw-rw-   0        0        0     2020 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/expr.py
+-rw-rw-rw-   0        0        0      935 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/func.py
+-rw-rw-rw-   0        0        0     6986 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/gates.py
+-rw-rw-rw-   0        0        0     1592 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/misc.py
+-rw-rw-rw-   0        0        0     5616 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/qasm.py
+-rw-rw-rw-   0        0        0     1252 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/std_gates.py
+-rw-rw-rw-   0        0        0     2312 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/vars.py
+-rw-rw-rw-   0        0        0     9989 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/qc2phir.py
+-rw-rw-rw-   0        0        0    14990 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/circuits/quantum_circuit.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.230670 quantum_pecos-0.6.0.dev1/python/pecos/classical_interpreters/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/classical_interpreters/__init__.py
+-rw-rw-rw-   0        0        0     1513 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/classical_interpreters/classical_interpreter_abc.py
+-rw-rw-rw-   0        0        0    12690 2024-04-29 19:48:00.000000 quantum_pecos-0.6.0.dev1/python/pecos/classical_interpreters/phir_classical_interpreter.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.231673 quantum_pecos-0.6.0.dev1/python/pecos/decoders/
+-rw-rw-rw-   0        0        0      872 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/decoders/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.233673 quantum_pecos-0.6.0.dev1/python/pecos/decoders/dummy_decoder/
+-rw-rw-rw-   0        0        0      794 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/decoders/dummy_decoder/__init__.py
+-rw-rw-rw-   0        0        0     1171 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/decoders/dummy_decoder/dummy_decoder.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.235673 quantum_pecos-0.6.0.dev1/python/pecos/decoders/mwpm2d/
+-rw-rw-rw-   0        0        0      752 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/decoders/mwpm2d/__init__.py
+-rw-rw-rw-   0        0        0     5211 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/decoders/mwpm2d/mwpm2d.py
+-rw-rw-rw-   0        0        0    17301 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/decoders/mwpm2d/precomputing.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.239180 quantum_pecos-0.6.0.dev1/python/pecos/engines/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.241183 quantum_pecos-0.6.0.dev1/python/pecos/engines/circuit_runners/
+-rw-rw-rw-   0        0        0      885 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/circuit_runners/__init__.py
+-rw-rw-rw-   0        0        0     3508 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/circuit_runners/standard.py
+-rw-rw-rw-   0        0        0     2385 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/circuit_runners/timing_runner.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.245687 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/__init__.py
+-rw-rw-rw-   0        0        0     8608 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/binarray.py
+-rw-rw-rw-   0        0        0     5087 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/binarray2.py
+-rw-rw-rw-   0        0        0     7530 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/classical.py
+-rw-rw-rw-   0        0        0     1738 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/cvm.py
+-rw-rw-rw-   0        0        0     1661 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/sim_func.py
+-rw-rw-rw-   0        0        0     4339 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.249686 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/__init__.py
+-rw-rw-rw-   0        0        0     1654 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/pywasm.py
+-rw-rw-rw-   0        0        0     1180 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/pywasm3.py
+-rw-rw-rw-   0        0        0     2728 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/wasmer.py
+-rw-rw-rw-   0        0        0     1634 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/wasmtime.py
+-rw-rw-rw-   0        0        0     7574 2024-04-29 19:48:00.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/hybrid_engine.py
+-rw-rw-rw-   0        0        0     4968 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/hybrid_engine_multiprocessing.py
+-rw-rw-rw-   0        0        0     8509 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/engines/hybrid_engine_old.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.257691 quantum_pecos-0.6.0.dev1/python/pecos/error_models/
+-rw-rw-rw-   0        0        0     1109 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/__init__.py
+-rw-rw-rw-   0        0        0     1849 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/class_errors_circuit.py
+-rw-rw-rw-   0        0        0     5704 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/depolarizing_error_model.py
+-rw-rw-rw-   0        0        0     5604 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/error_depolar.py
+-rw-rw-rw-   0        0        0     1768 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/error_model.py
+-rw-rw-rw-   0        0        0     1368 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/error_model_abc.py
+-rw-rw-rw-   0        0        0     1035 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/fake_error_model.py
+-rw-rw-rw-   0        0        0     5851 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/generic_error_model.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.265196 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/__init__.py
+-rw-rw-rw-   0        0        0      958 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_initz_bitflip.py
+-rw-rw-rw-   0        0        0     1435 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_initz_bitflip_leakage.py
+-rw-rw-rw-   0        0        0     1450 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_meas_bitflip.py
+-rw-rw-rw-   0        0        0     1621 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_meas_bitflip_leakage.py
+-rw-rw-rw-   0        0        0     1196 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_sq_bitflip.py
+-rw-rw-rw-   0        0        0     1488 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_sq_depolarizing.py
+-rw-rw-rw-   0        0        0     1958 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_sq_depolarizing_leakage.py
+-rw-rw-rw-   0        0        0     1761 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_tq_depolarizing.py
+-rw-rw-rw-   0        0        0     2490 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_tq_depolarizing_leakage.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.269696 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/__init__.py
+-rw-rw-rw-   0        0        0     2546 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/gate_groups.py
+-rw-rw-rw-   0        0        0     1385 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/init_noise.py
+-rw-rw-rw-   0        0        0     1593 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/meas_noise.py
+-rw-rw-rw-   0        0        0     1337 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/memory_noise.py
+-rw-rw-rw-   0        0        0     1207 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/sq_noise.py
+-rw-rw-rw-   0        0        0     2943 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/tq_noise.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.273743 quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/
+-rw-rw-rw-   0        0        0      791 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/__init__.py
+-rw-rw-rw-   0        0        0     7653 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/depolar_gen.py
+-rw-rw-rw-   0        0        0     5732 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/gatewise_gen.py
+-rw-rw-rw-   0        0        0     6255 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/xerror_gen.py
+-rw-rw-rw-   0        0        0     7322 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/xzerror_gen.py
+-rw-rw-rw-   0        0        0     6255 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/zerror_gen.py
+-rw-rw-rw-   0        0        0    11841 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/parent_class_error_gen.py
+-rw-rw-rw-   0        0        0     5100 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/error_models/simple_depolarizing_error_model.py
+-rw-rw-rw-   0        0        0     1026 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/errors.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.278549 quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/__init__.py
+-rw-rw-rw-   0        0        0     1304 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/foreign_object_abc.py
+-rw-rw-rw-   0        0        0     2466 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/object_pool.py
+-rw-rw-rw-   0        0        0     1168 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/python.py
+-rw-rw-rw-   0        0        0      527 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/wasm_execution_timer_thread.py
+-rw-rw-rw-   0        0        0     3837 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/wasmer.py
+-rw-rw-rw-   0        0        0     5054 2024-05-15 17:56:54.000000 quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/wasmtime.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.281049 quantum_pecos-0.6.0.dev1/python/pecos/machines/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/machines/__init__.py
+-rw-rw-rw-   0        0        0     2356 2024-04-29 19:48:00.000000 quantum_pecos-0.6.0.dev1/python/pecos/machines/generic_machine.py
+-rw-rw-rw-   0        0        0     1591 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/machines/machine_abc.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.286554 quantum_pecos-0.6.0.dev1/python/pecos/misc/
+-rw-rw-rw-   0        0        0      840 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/misc/__init__.py
+-rw-rw-rw-   0        0        0     2240 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/misc/commute.py
+-rw-rw-rw-   0        0        0      838 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/misc/errors.py
+-rw-rw-rw-   0        0        0     1681 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/misc/gate_groups.py
+-rw-rw-rw-   0        0        0    10545 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/misc/stabilizer_funcs.py
+-rw-rw-rw-   0        0        0     1992 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/misc/std_output.py
+-rw-rw-rw-   0        0        0     3552 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/misc/symbol_library.py
+-rw-rw-rw-   0        0        0     7419 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/misc/threshold_curve.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.288678 quantum_pecos-0.6.0.dev1/python/pecos/op_processors/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/op_processors/__init__.py
+-rw-rw-rw-   0        0        0     2266 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/op_processors/generic_op_processor.py
+-rw-rw-rw-   0        0        0     1132 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/op_processors/op_processor_abc.py
+-rw-rw-rw-   0        0        0        0 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/py.typed
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.292178 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/
+-rw-rw-rw-   0        0        0     1147 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.296183 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/
+-rw-rw-rw-   0        0        0      752 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/__init__.py
+-rw-rw-rw-   0        0        0     7774 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/circuit_implementation1.py
+-rw-rw-rw-   0        0        0     7702 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/color_488.py
+-rw-rw-rw-   0        0        0     3276 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/gates.py
+-rw-rw-rw-   0        0        0     8975 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/instructions.py
+-rw-rw-rw-   0        0        0     3576 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/gate_parent_class.py
+-rw-rw-rw-   0        0        0     2262 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/helper_functions.py
+-rw-rw-rw-   0        0        0     3845 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/instruction_parent_class.py
+-rw-rw-rw-   0        0        0     7751 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/plot.py
+-rw-rw-rw-   0        0        0     8065 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/qecc_parent_class.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.298683 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_4444/
+-rw-rw-rw-   0        0        0      752 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_4444/__init__.py
+-rw-rw-rw-   0        0        0     3276 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_4444/gates.py
+-rw-rw-rw-   0        0        0    11245 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_4444/instructions.py
+-rw-rw-rw-   0        0        0     9623 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_4444/surface_4444.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.301682 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_medial_4444/
+-rw-rw-rw-   0        0        0      752 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_medial_4444/__init__.py
+-rw-rw-rw-   0        0        0     3276 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_medial_4444/gates.py
+-rw-rw-rw-   0        0        0    19744 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_medial_4444/instructions.py
+-rw-rw-rw-   0        0        0    10241 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_medial_4444/surface_medial_4444.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.302183 quantum_pecos-0.6.0.dev1/python/pecos/reps/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.308062 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/
+-rw-rw-rw-   0        0        0      635 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/__init__.py
+-rw-rw-rw-   0        0        0     1844 2024-04-29 19:48:00.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/block_types.py
+-rw-rw-rw-   0        0        0     1961 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/data_types.py
+-rw-rw-rw-   0        0        0      236 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/instr_type.py
+-rw-rw-rw-   0        0        0     1104 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/list_types.py
+-rw-rw-rw-   0        0        0     1103 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/name_resolver.py
+-rw-rw-rw-   0        0        0     3167 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/op_types.py
+-rw-rw-rw-   0        0        0    10369 2024-04-29 19:48:00.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/pypmir.py
+-rw-rw-rw-   0        0        0      812 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/types.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.312562 quantum_pecos-0.6.0.dev1/python/pecos/simulators/
+-rw-rw-rw-   0        0        0     1878 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.315066 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cointoss/
+-rw-rw-rw-   0        0        0      692 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cointoss/__init__.py
+-rw-rw-rw-   0        0        0     1661 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cointoss/bindings.py
+-rw-rw-rw-   0        0        0     1196 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cointoss/gates.py
+-rw-rw-rw-   0        0        0     1773 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cointoss/state.py
+-rw-rw-rw-   0        0        0     2185 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/compile_cython.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.316566 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/
+-rw-rw-rw-   0        0        0      698 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/__init__.py
+-rw-rw-rw-   0        0        0      776 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuconn.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.317066 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuquantum_wrapper/
+-rw-rw-rw-   0        0        0      692 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuquantum_wrapper/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.318566 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuquantum_wrapper/test/
+-rw-rw-rw-   0        0        0      624 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuquantum_wrapper/test/__init__.py
+-rw-rw-rw-   0        0        0     4489 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuquantum_wrapper/test/test_python_bindings.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.323566 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/
+-rw-rw-rw-   0        0        0      588 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/__init__.py
+-rw-rw-rw-   0        0        0     2010 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/bindings.py
+-rw-rw-rw-   0        0        0     1046 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/gates_init.py
+-rw-rw-rw-   0        0        0      785 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/gates_meas.py
+-rw-rw-rw-   0        0        0     3562 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/gates_sq.py
+-rw-rw-rw-   0        0        0     1200 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/gates_tq.py
+-rw-rw-rw-   0        0        0     1874 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/state.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.328855 quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/
+-rw-rw-rw-   0        0        0      698 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/__init__.py
+-rw-rw-rw-   0        0        0     1769 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/bindings.py
+-rw-rw-rw-   0        0        0     1046 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/gates_init.py
+-rw-rw-rw-   0        0        0     1867 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/gates_meas.py
+-rw-rw-rw-   0        0        0     9594 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/gates_one_qubit.py
+-rw-rw-rw-   0        0        0    12354 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/gates_two_qubit.py
+-rw-rw-rw-   0        0        0     3719 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/state.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.330224 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/
+-rw-rw-rw-   0        0        0      857 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/__init__.py
+-rw-rw-rw-   0        0        0     2191 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/setup.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.331224 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/src/
+-rw-rw-rw-   0        0        0      752 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/src/__init__.py
+-rw-rw-rw-   0        0        0     6362 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/src/logical_sign.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.332723 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/
+-rw-rw-rw-   0        0        0      857 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/__init__.py
+-rw-rw-rw-   0        0        0     1983 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/setup.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.333724 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/src/
+-rw-rw-rw-   0        0        0      752 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/src/__init__.py
+-rw-rw-rw-   0        0        0     6090 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/src/logical_sign.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.335231 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/
+-rw-rw-rw-   0        0        0      857 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/__init__.py
+-rw-rw-rw-   0        0        0     1983 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/setup.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.336731 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/src/
+-rw-rw-rw-   0        0        0      752 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/src/__init__.py
+-rw-rw-rw-   0        0        0     6090 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/src/logical_sign.py
+-rw-rw-rw-   0        0        0     2736 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/gate_syms.py
+-rw-rw-rw-   0        0        0     2691 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/parent_sim_classes.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.342238 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/
+-rw-rw-rw-   0        0        0      710 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/__init__.py
+-rw-rw-rw-   0        0        0     2945 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/bindings.py
+-rw-rw-rw-   0        0        0      881 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/gates_init.py
+-rw-rw-rw-   0        0        0     2985 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/gates_meas.py
+-rw-rw-rw-   0        0        0    14031 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/gates_one_qubit.py
+-rw-rw-rw-   0        0        0     7900 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/gates_two_qubit.py
+-rw-rw-rw-   0        0        0     1738 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/logical_sign.py
+-rw-rw-rw-   0        0        0     9712 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/state.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.348295 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/
+-rw-rw-rw-   0        0        0      859 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/__init__.py
+-rw-rw-rw-   0        0        0     4891 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/bindings.py
+-rw-rw-rw-   0        0        0     2213 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/gates_init.py
+-rw-rw-rw-   0        0        0     2631 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/gates_meas.py
+-rw-rw-rw-   0        0        0     6819 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/gates_one_qubit.py
+-rw-rw-rw-   0        0        0     4884 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/gates_two_qubit.py
+-rw-rw-rw-   0        0        0     1205 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/helper.py
+-rw-rw-rw-   0        0        0     2379 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/logical_sign.py
+-rw-rw-rw-   0        0        0     4977 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/state.py
+-rw-rw-rw-   0        0        0     2885 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/quantum_simulator.py
+-rw-rw-rw-   0        0        0     1409 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sim_class_types.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.355298 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/
+-rw-rw-rw-   0        0        0     1933 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/__init__.py
+-rw-rw-rw-   0        0        0     2909 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/bindings.py
+-rw-rw-rw-   0        0        0     3225 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/cmd_init.py
+-rw-rw-rw-   0        0        0    11606 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/cmd_meas.py
+-rw-rw-rw-   0        0        0    33702 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/cmd_one_qubit.py
+-rw-rw-rw-   0        0        0    15954 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/cmd_two_qubit.py
+-rw-rw-rw-   0        0        0     8070 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/logical_sign.py
+-rw-rw-rw-   0        0        0     5143 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/refactor.py
+-rw-rw-rw-   0        0        0    17202 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/state.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.361915 quantum_pecos-0.6.0.dev1/python/pecos/slr/
+-rw-rw-rw-   0        0        0     1170 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/__init__.py
+-rw-rw-rw-   0        0        0     2062 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/block.py
+-rw-rw-rw-   0        0        0     2688 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/cond_block.py
+-rw-rw-rw-   0        0        0     3124 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/cops.py
+-rw-rw-rw-   0        0        0      799 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/fund.py
+-rw-rw-rw-   0        0        0     3541 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/misc.py
+-rw-rw-rw-   0        0        0     1883 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/slr.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.362367 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/
+-rw-rw-rw-   0        0        0        0 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/__init__.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.368876 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/
+-rw-rw-rw-   0        0        0      903 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/__init__.py
+-rw-rw-rw-   0        0        0      794 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/cliffords_tq.py
+-rw-rw-rw-   0        0        0     1664 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/face_rots.py
+-rw-rw-rw-   0        0        0      126 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/hadamards.py
+-rw-rw-rw-   0        0        0     4539 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/metaclasses.py
+-rw-rw-rw-   0        0        0      297 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/misc.py
+-rw-rw-rw-   0        0        0     1272 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/paulis.py
+-rw-rw-rw-   0        0        0      870 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/projective.py
+-rw-rw-rw-   0        0        0      381 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/rots.py
+-rw-rw-rw-   0        0        0      603 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/std/phys/sqrt_paulis.py
+-rw-rw-rw-   0        0        0      878 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/util.py
+-rw-rw-rw-   0        0        0     3530 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/slr/vars.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.377383 quantum_pecos-0.6.0.dev1/python/pecos/tools/
+-rw-rw-rw-   0        0        0     1319 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/__init__.py
+-rw-rw-rw-   0        0        0     6558 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/fault_tolerance_checking.py
+-rw-rw-rw-   0        0        0    13635 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/fault_tolerance_checks.py
+-rw-rw-rw-   0        0        0     5829 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/find_cliffs.py
+-rw-rw-rw-   0        0        0     3384 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/logic_circuit_speed.py
+-rw-rw-rw-   0        0        0     7186 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/pseudo_threshold_tools.py
+-rw-rw-rw-   0        0        0     3630 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/random_circuit_speed.py
+-rw-rw-rw-   0        0        0    32511 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/stabilizer_verification.py
+-rw-rw-rw-   0        0        0    17415 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/threshold_tools.py
+-rw-rw-rw-   0        0        0     1465 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/tool_anticommute.py
+-rw-rw-rw-   0        0        0     6963 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/tools/tool_collection.py
+-rw-rw-rw-   0        0        0     3802 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/python/pecos/typed_list.py
+drwxrwxrwx   0        0        0        0 2024-05-15 17:59:06.381383 quantum_pecos-0.6.0.dev1/python/quantum_pecos.egg-info/
+-rw-rw-rw-   0        0        0    20835 2024-05-15 17:59:06.000000 quantum_pecos-0.6.0.dev1/python/quantum_pecos.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    11045 2024-05-15 17:59:06.000000 quantum_pecos-0.6.0.dev1/python/quantum_pecos.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-05-15 17:59:06.000000 quantum_pecos-0.6.0.dev1/python/quantum_pecos.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0        2 2024-03-15 23:26:47.000000 quantum_pecos-0.6.0.dev1/python/quantum_pecos.egg-info/not-zip-safe
+-rw-rw-rw-   0        0        0      471 2024-05-15 17:59:06.000000 quantum_pecos-0.6.0.dev1/python/quantum_pecos.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        6 2024-05-15 17:59:06.000000 quantum_pecos-0.6.0.dev1/python/quantum_pecos.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0      680 2024-03-15 23:25:09.000000 quantum_pecos-0.6.0.dev1/requirements.txt
+-rw-rw-rw-   0        0        0       42 2024-05-15 17:59:06.383882 quantum_pecos-0.6.0.dev1/setup.cfg
```

### Comparing `quantum-pecos-0.5.dev1/LICENSE` & `quantum_pecos-0.6.0.dev1/LICENSE`

 * *Files 0% similar despite different names*

```diff
@@ -182,15 +182,15 @@
       replaced with your own identifying information. (Don't include
       the brackets!)  The text should be enclosed in the appropriate
       comment syntax for the file format. We also recommend that a
       file or class name and description of purpose be included on the
       same "printed page" as the copyright notice for easier
       identification within third-party archives.
 
-   
+
    Copyright {yyyy} {name of copyright owner}
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

### Comparing `quantum-pecos-0.5.dev1/PKG-INFO` & `quantum_pecos-0.6.0.dev1/PKG-INFO`

 * *Files 19% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 Metadata-Version: 2.1
 Name: quantum-pecos
-Version: 0.5.dev1
-Summary: Performance Estimator of Codes On Surfaces (PECOS) is a package designed to facilitate the evaluation, study, and design of quantum error correction protocols as well as provde advanced hybrid compute execution models.
+Version: 0.6.0.dev1
+Summary: PECOS is a library/framework for the evaluation, study, and design of QEC protocols. It also provides the ability to study and evaluate the performance advanced hybrid quantum/classical compute execution models for NISQ algorithms and beyond.
 Author: The PECOS Developers
-Maintainer-email: Ciaran Ryan-Anderson <ciaran@pecos.io>
+Maintainer-email: Ciaran Ryan-Anderson <ciaran.ryan-anderson@quantinuum.com>
 License:                                  Apache License
                                    Version 2.0, January 2004
                                 http://www.apache.org/licenses/
         
            TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
         
            1. Definitions.
@@ -188,111 +188,207 @@
               replaced with your own identifying information. (Don't include
               the brackets!)  The text should be enclosed in the appropriate
               comment syntax for the file format. We also recommend that a
               file or class name and description of purpose be included on the
               same "printed page" as the copyright notice for easier
               identification within third-party archives.
         
-           
+        
            Copyright {yyyy} {name of copyright owner}
         
            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at
         
                http://www.apache.org/licenses/LICENSE-2.0
         
            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.
         
+Project-URL: documentation, https://quantum-pecos.readthedocs.io
+Project-URL: repository, https://github.com/PECOS-packages/PECOS
+Keywords: quantum,QEC,simulation,PECOS
 Classifier: Development Status :: 4 - Beta
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
 Classifier: Topic :: Scientific/Engineering :: Physics
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Classifier: Programming Language :: Python :: Implementation :: CPython
-Requires-Python: >=3.8
+Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: numpy>=1.15.0
-Requires-Dist: scipy>=1.1.0
-Requires-Dist: networkx<3,>=2.1.0
-Requires-Dist: matplotlib>=2.2.0
+Requires-Dist: phir~=0.3.0
+Requires-Dist: numpy<2.0,>=1.15.0
+Requires-Dist: scipy<2.0,>=1.1.0
+Requires-Dist: networkx<3.0,>=2.1.0
+Requires-Dist: matplotlib<4.0,>=2.2.0
 Provides-Extra: simulators
 Requires-Dist: cython; extra == "simulators"
 Requires-Dist: pybind11<3.0,>=2.2.3; extra == "simulators"
 Requires-Dist: projectq<0.9.0,>=0.5.0; extra == "simulators"
+Provides-Extra: cuda
+Requires-Dist: cuquantum-python>=23.6.0; extra == "cuda"
+Requires-Dist: cupy>=10.4.0; extra == "cuda"
+Provides-Extra: wasmtime
+Requires-Dist: wasmtime>=13.0; extra == "wasmtime"
 Provides-Extra: wasmer
 Requires-Dist: wasmer~=1.1.0; extra == "wasmer"
 Requires-Dist: wasmer_compiler_cranelift~=1.1.0; extra == "wasmer"
 Provides-Extra: visualization
 Requires-Dist: plotly~=5.9.0; extra == "visualization"
 Provides-Extra: tests
 Requires-Dist: pytest>=5.0.0; extra == "tests"
 Provides-Extra: all
 Requires-Dist: quantum-pecos[simulators]; extra == "all"
+Requires-Dist: quantum-pecos[wasmtime]; extra == "all"
 Requires-Dist: quantum-pecos[wasmer]; extra == "all"
 Requires-Dist: quantum-pecos[visualization]; extra == "all"
 Requires-Dist: quantum-pecos[tests]; extra == "all"
 
-![PECOS](docs/images/pecos_large_logo.png)
-=======================================
+# ![PECOS](branding/logo/pecos_logo_v2.png)
 
 [![PyPI version](https://badge.fury.io/py/quantum-pecos.svg)](https://badge.fury.io/py/quantum-pecos)
 [![Documentation Status](https://readthedocs.org/projects/quantum-pecos/badge/?version=latest)](https://quantum-pecos.readthedocs.io/en/latest/?badge=latest)
-[![Python Status](https://img.shields.io/badge/python-3.8%2C%203.9%2C%203.10%2C%203.11-brightgreen.svg)](https://img.shields.io/badge/python-3.8%2C%203.9%2C%203.10%2C%203.11-brightgreen.svg)
+[![Python versions](https://img.shields.io/badge/python-3.10%20%7C%203.11%20%7C%203.12-blue.svg)](https://img.shields.io/badge/python-3.9%2C%203.10%2C%203.11-blue.svg)
 [![Supported by Quantinuum](https://img.shields.io/badge/supported_by-Quantinuum-blue)](https://www.quantinuum.com/)
 
-Performance Estimator of Codes On Surfaces (PECOS) is a Python framework for studying, developing, and evaluating 
-quantum error-correction protocols as well as advance hybrid compute execution models for NISQ algorithms and beyond.
-
-PECOS aims to balance clarity, flexibility, and performance, with hopefully maximizing all three when possible.
-
-- Language: Python 3.8+ (with optional C and C++ extensions)
+**Performance Estimator of Codes On Surfaces (PECOS)** is a library/framework dedicated to the study, development, and
+evaluation of quantum error-correction protocols. It offers tools for the study and evaluation of hybrid
+quantum/classical compute execution models for NISQ algorithms and beyond.
+
+Initially conceived and developed in 2014 to verify lattice-surgery procedures presented in
+[arXiv:1407.5103](https://arxiv.org/abs/1407.5103) and released publicly in 2018, PECOS filled a significant gap in
+the QEC/QC tools available at that time. Over the years, it has grown into a framework for studying general QECCs and
+hybrid computation.
+
+With an emphasis on clarity, flexibility, and performance and catering to both QEC students and developers, PECOS is
+refined continually with these attributes in mind.
+
+## Features
+
+- Quantum Error-Correction Tools: Advanced tools for studying quantum error-correction protocols and error models.
+- Hybrid Quantum/Classical Execution: Evaluate advanced hybrid compute models, including support for classical compute,
+calls to Wasm VMs, conditional branching, and more.
+- Fast Simulation: Leverage the fast stabilizer-simulation algorithm.
+- Extensible: Add-ons and extensions support in C and C++ via Cython.
 
 ## Getting Started
 
-To get started, check out the documentation in the "docs" folder or find it online:
-
-https://quantum-pecos.readthedocs.io
+Explore the capabilities of PECOS by delving into the [official documentation](https://quantum-pecos.readthedocs.io).
 
 ## Versioning
 
-PECOS uses semantic versioning. However, until version 1.0.0, for the MAJOR.MINOR.BUG format, the role of MAJOR and 
-MINOR shifts down one. That is, going from version 0.1.0 to 0.2.0 can include API breaking.
+We follow semantic versioning principles. However, before version 1.0.0, the MAJOR.MINOR.BUG format sees the roles
+of MAJOR and MINOR shifted down a step. This means potential breaking changes might occur between MINOR increments, such
+as moving from versions 0.1.0 to 0.2.0.
 
 ## Latest Development
 
-See here for latest code in development:
-
-https://quantum-pecos.readthedocs.io/en/development/
+Stay updated with the latest developments on the
+[PECOS Development branch](https://quantum-pecos.readthedocs.io/en/development/).
 
 ## Installation
 
-Clone or download/unzip the version of PECOS you would like to use. Next, navigate to the root of the package 
-(where setup.py is located) and run:
-```
+1. Clone or download the desired version of PECOS.
+2. Navigate to the root directory, where `pyproject.toml` is located.
+3. Install using pip:
+
+```sh
 pip install .
 ```
 
-To install and continue to develop the version of PECOS located in the install folder, run the
- following instead:
+To install optional dependencies, such as for Wasm support or state vector simulations, see `pyproject.toml` for list of
+options. To install all optional dependencies use:
+
+```sh
+pip install .[all]
 ```
+
+Certain simulators have special requirements and are not installed by the command above. Installation instructions for these are provided [here](#simulators-with-special-requirements).
+
+For development, use (while including installation options as necessary):
+
+On Linux/Mac:
+
+```sh
+python -m venv .venv
+source .venv/bin/activate
+pip install -U pip setuptools
+pip install -r requirements.txt
+make metadeps
+pre-commit install
 pip install -e .
 ```
 
-## Uninstall
+On Windows:
 
-To uninstall run:
+```sh
+python -m venv .venv
+.\venv\Scripts\activate
+pip install -U pip setuptools
+pip install -r requirements.txt
+make metadeps
+pre-commit install
+pip install -e .
 ```
+
+See `Makefile` for other useful commands.
+
+Tests can be run using:
+
+```sh
+pytest tests
+```
+
+### Simulators with special requirements
+
+Certain simulators from `pecos.simulators` require external packages that are not installed by `pip install .[all]`.
+
+- `CuStateVec` requires a Linux machine with an NVIDIA GPU (see requirements [here](https://docs.nvidia.com/cuda/cuquantum/latest/getting_started/getting_started.html#dependencies-custatevec-label)). PECOS' dependencies are specified in the `[cuda]` section of `pyproject.toml` and can be installed via `pip install .[cuda]`. If installation is not successful, see alternative instructions [here](https://docs.nvidia.com/cuda/cuquantum/latest/getting_started/getting_started.html#installing-cuquantum).
+
+## Uninstall
+
+To uninstall:
+
+```sh
 pip uninstall quantum-pecos
 ```
 
+## Citing
+
+For publications utilizing PECOS, kindly cite PECOS such as:
+
+```bibtex
+@misc{pecos,
+ author={Ciaran Ryan-Anderson},
+ title={PECOS: Performance Estimator of Codes On Surfaces},
+ journal={GitHub},
+ howpublished={\url{https://github.com/PECOS-packages/PECOS}},
+ URL = {https://github.com/PECOS-packages/PECOS},
+ year={2018}
+}
+
+@phdthesis{crathesis,
+ author={Ciaran Ryan-Anderson},
+ school = {University of New Mexico},
+ title={Quantum Algorithms, Architecture, and Error Correction},
+ journal={arXiv:1812.04735},
+ year={2018}
+}
+```
+
+## License
+
+This project is licensed under the Apache-2.0 License - see the [LICENSE](./LICENSE) and [NOTICE](NOTICE) files for
+details.
+
 ## Supported by
 
-[<img src="https://assets-global.website-files.com/62b9d45fb3f64842a96c9686/6328d9f47889343caabf2639_Quantinuum%20Logo__horizontal%20blue.png" height="100">](https://www.quantinuum.com/)
+[![Quantinuum](./images/Quantinuum_(word_trademark).svg)](https://www.quantinuum.com/)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,63 +6,45 @@
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
-
-"""
-Performance Estimator of Codes On Surfaces (PECOS)
+"""Performance Estimator of Codes On Surfaces (PECOS)
 ==================================================
-
 A framework for developing, studying, and evaluating quantum error-correcting codes.
 """
 
-from importlib.metadata import version, PackageNotFoundError
+# Allow for other namespace packages
+__path__ = __import__("pkgutil").extend_path(__path__, __name__)
+
+from importlib.metadata import PackageNotFoundError, version
 
 try:
-    __version__ = version('quantum-pecos')
+    __version__ = version("quantum-pecos")
 except PackageNotFoundError:
-    __version__ = '0.0.0'
-
-# Allow for other namespace packages
-__path__ = __import__('pkgutil').extend_path(__path__, __name__)
+    __version__ = "0.0.0"
 
 # PECOS namespaces
-from . import (
-    circuits,
-    qeccs,
-    simulators,
-    error_models,
-    engines,
-    decoders,
-    circuit_converters,
-    misc,
-    tools,
-)
-from .engines import circuit_runners
-
-from .circuits.quantum_circuit import QuantumCircuit
+from pecos import circuit_converters, circuits, decoders, engines, error_models, misc, qeccs, simulators, tools
+from pecos.circuits.quantum_circuit import QuantumCircuit
+from pecos.engines import circuit_runners
 from pecos.engines.cvm.binarray import BinArray
 from pecos.engines.hybrid_engine_old import HybridEngine
 
-__copyright__ = 'Copyright 2018 The PECOS Developers. Copyright 2018 National Technology & Engineering Solutions of ' \
-                'Sandia, LLC (NTESS).'
-__license__ = 'Apache-2.0'
-__maintainer__ = 'Ciaran Ryan-Anderson'
-__email__ = 'ciaran@pecos.io'
-
 __all__ = [
-    'circuits',
-    'qeccs',
-    'simulators',
-    'error_models',
-    'circuit_runners',
-    'decoders',
-    'circuit_converters',
-    'misc',
-    'tools',
-    'QuantumCircuit',
-    'BinArray',
-    'HybridEngine',
+    "__version__",
+    "circuits",
+    "qeccs",
+    "simulators",
+    "error_models",
+    "circuit_runners",
+    "engines",
+    "decoders",
+    "circuit_converters",
+    "misc",
+    "tools",
+    "QuantumCircuit",
+    "BinArray",
+    "HybridEngine",
 ]
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuit_converters/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,18 +1,15 @@
+# Copyright 2021 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-This name space contains classes and functions for converting circuit data-structures into other circuit
-data-structures.
-"""
-
-from .std2chs import std2chs
+from pecos.circuits.logical_circuit import LogicalCircuit
+from pecos.circuits.quantum_circuit import QuantumCircuit
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuit_converters/checks2circuit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuit_converters/checks2circuit.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,268 +7,258 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Check Circuits
-==============
+"""Check Circuits
+==============.
 
 This namespace is for callables that take checks and convert them to physical quantum-circuits.
 
 Callables that can be used for general QECCs should be stored here. If a circuit implementation is specific to the QECC
 it may be stored in the QECC's folder.
 
 """
 
 from pecos.circuits import QuantumCircuit
 
 
-class Check2Circuits(object):
-    """
-    Converts checks to circuits.
-    """
+class Check2Circuits:
+    """Converts checks to circuits."""
 
-    def __init__(self):
-        self.name = 'Check2Circuits'
+    def __init__(self) -> None:
+        self.name = "Check2Circuits"
 
     @staticmethod
     def get_num_ancillas(num_checks):
-        """
-
-        Args:
+        """Args:
+        ----
             num_checks:
 
         Returns:
+        -------
 
         """
-
-        num_ancillas = num_checks
-
-        return num_ancillas
+        return num_checks
 
     def compile(self, instr, abstract_circuit, mapping=None):
         """Converts abstract circuits that have checks into an instance of ``QuantumCircuit``.
 
         Args:
+        ----
             abstract_circuit: Abstract circuit that contains checks.
             mapping (None):
 
         Returns:
+        -------
             ``QuantumCircuit``
         """
-
         make_ticks = self._check_ticks(abstract_circuit)
 
         gate_params = instr.gate_params
 
         if mapping is None:
-            mapping = gate_params.get('mapping', NoMap())
+            mapping = gate_params.get("mapping", NoMap())
 
-        forced_outcome = gate_params.get('forced_outcome', None)
+        forced_outcome = gate_params.get("forced_outcome", None)
 
         if forced_outcome is None:
-            forced_outcome = abstract_circuit.metadata.get('forced_outcome', True)
+            forced_outcome = abstract_circuit.metadata.get("forced_outcome", True)
 
         if make_ticks:
-
             largest_tick = 0
 
-            if make_ticks['max_xdatas']:
+            if make_ticks["max_xdatas"]:
                 # init H [data ticks] H meas
-                largest_tick = make_ticks['max_xdatas'] + 3
+                largest_tick = make_ticks["max_xdatas"] + 3
 
-            if make_ticks['max_zdatas']:
+            if make_ticks["max_zdatas"]:
                 # init [data ticks] meas
-                temp = make_ticks['max_zdatas'] + 1
+                temp = make_ticks["max_zdatas"] + 1
                 if temp > largest_tick:
                     largest_tick = temp
 
-            if not make_ticks['max_xdatas'] and not make_ticks['max_zdatas']:
-                raise Exception('Something very weird happened!')
+            if not make_ticks["max_xdatas"] and not make_ticks["max_zdatas"]:
+                msg = "Something very weird happened!"
+                raise Exception(msg)
 
         else:
-
             largest_tick = 0
             # find maximum tick
-            for gate_symbol, locations, params in abstract_circuit.items():
-
-                if gate_symbol == 'X check' or gate_symbol == 'Z check':
-
-                    ancilla_ticks = params['ancilla_ticks']  # Initialization of the ancilla.
-                    data_ticks = params['data_ticks']
-                    meas_ticks = params['meas_ticks']
+            for gate_symbol, _locations, params in abstract_circuit.items():
+                if gate_symbol in {"X check", "Z check"}:
+                    ancilla_ticks = params["ancilla_ticks"]  # Initialization of the ancilla.
+                    data_ticks = params["data_ticks"]
+                    meas_ticks = params["meas_ticks"]
 
                     for ticks in [ancilla_ticks, data_ticks, meas_ticks]:
-                        if isinstance(ticks, int):
-                            ticks = [ticks]
+                        tick_list = ticks
+                        if isinstance(tick_list, int):
+                            tick_list = [ticks]
 
-                        for t in ticks:
+                        for t in tick_list:
                             if t > largest_tick:
                                 largest_tick = t
 
                 else:
-                    tick = params['tick']
+                    tick = params["tick"]
 
                     if tick > largest_tick:
                         largest_tick = tick
 
         # A quantum circuit with number of ticks == ``largest_tick``
-        circuit = QuantumCircuit(largest_tick+1, **gate_params)
+        circuit = QuantumCircuit(largest_tick + 1, **gate_params)
 
         # Add circuits
         # ============
         for gate_symbol, locations, params in abstract_circuit.items():
-            if gate_symbol == 'X check' or gate_symbol == 'Z check':
-
-                datas = params['datas']
-                ancillas = params['ancillas']
+            if gate_symbol in {"X check", "Z check"}:
+                datas = params["datas"]
+                ancillas = params["ancillas"]
                 if not isinstance(ancillas, int):
                     if len(ancillas) == 1:
                         ancillas = ancillas[0]
                     else:
-                        raise Exception('This circuit compiler only accepts single ancillas per check!')
+                        msg = "This circuit compiler only accepts single ancillas per check!"
+                        raise Exception(msg)
 
                 if make_ticks:
-
                     # Come up with ticks if none have been specified.
-                    ancilla_ticks, data_ticks, meas_ticks = self.generate_ticks(make_ticks, gate_symbol, locations,
-                                                                                params)
+                    ancilla_ticks, data_ticks, meas_ticks = self.generate_ticks(
+                        make_ticks,
+                        gate_symbol,
+                        locations,
+                        params,
+                    )
 
                 else:
-                    ancilla_ticks = params['ancilla_ticks']
-                    data_ticks = params['data_ticks']
-                    meas_ticks = params['meas_ticks']
+                    ancilla_ticks = params["ancilla_ticks"]
+                    data_ticks = params["data_ticks"]
+                    meas_ticks = params["meas_ticks"]
 
                 # Add ancilla init
                 # ----------------
                 if isinstance(ancilla_ticks, int):
+                    circuit.update({"init |0>": {mapping[ancillas]}}, tick=ancilla_ticks)
 
-                    circuit.update({'init |0>': {mapping[ancillas]}}, tick=ancilla_ticks)
-
-                    if gate_symbol == 'X check':
-                        circuit.update({'H': {mapping[ancillas]}}, tick=ancilla_ticks + 1)
-                        circuit.update({'H': {mapping[ancillas]}}, tick=meas_ticks - 1)
+                    if gate_symbol == "X check":
+                        circuit.update({"H": {mapping[ancillas]}}, tick=ancilla_ticks + 1)
+                        circuit.update({"H": {mapping[ancillas]}}, tick=meas_ticks - 1)
                 else:
-                    raise Exception('Can not currently handle multiple ancilla checks!')
+                    msg = "Can not currently handle multiple ancilla checks!"
+                    raise Exception(msg)
 
                 # Add data
                 # --------
-                if hasattr(data_ticks, '__iter__'):
-
-                    if gate_symbol == 'X check':
+                if hasattr(data_ticks, "__iter__"):
+                    if gate_symbol == "X check":
                         for i, t in enumerate(data_ticks):
-                            circuit.update({'CNOT': {(mapping[ancillas], mapping[datas[i]])}}, tick=t)
-                    elif gate_symbol == 'Z check':
+                            circuit.update({"CNOT": {(mapping[ancillas], mapping[datas[i]])}}, tick=t)
+                    elif gate_symbol == "Z check":
                         for i, t in enumerate(data_ticks):
-                            circuit.update({'CNOT': {(mapping[datas[i]], mapping[ancillas])}}, tick=t)
+                            circuit.update({"CNOT": {(mapping[datas[i]], mapping[ancillas])}}, tick=t)
                 else:
-                    raise Exception('Can not currently handle single data checks!')
+                    msg = "Can not currently handle single data checks!"
+                    raise Exception(msg)
 
                 # Add ancilla measurements
                 # ------------------------
                 if isinstance(meas_ticks, int):
-
                     if forced_outcome:
-                        circuit.update({'measure Z': {mapping[ancillas]}}, tick=meas_ticks)
+                        circuit.update({"measure Z": {mapping[ancillas]}}, tick=meas_ticks)
                     else:
-                        circuit.update({'measure Z': {mapping[ancillas]}}, tick=meas_ticks, forced_outcome=0)
-                        # circuit.update({'measure Z': {ancillas}}, forced_outcome=0)
+                        circuit.update({"measure Z": {mapping[ancillas]}}, tick=meas_ticks, forced_outcome=0)
                 else:
-                    raise Exception('Can not currently handle multiple ancilla checks!')
+                    msg = "Can not currently handle multiple ancilla checks!"
+                    raise Exception(msg)
 
             else:
-                tick = params['tick']
+                tick = params["tick"]
                 circuit.update({gate_symbol: self.mapset(mapping, set(locations))}, tick=tick)
 
         return circuit  # Return QuantumCircuit and number of ancillas used in this circuit.
 
     @staticmethod
     def mapset(mapping, oldset):
-        """
-        Applies a mapping to a set.
+        """Applies a mapping to a set.
 
         Args:
+        ----
             mapping:
             oldset (set):
 
         Returns:
+        -------
 
         """
         newset = set()
 
         for e in oldset:
             newset.add(mapping[e])
 
         return newset
 
-    def _check_ticks(self, abstract_circuit):
-
+    @staticmethod
+    def _check_ticks(abstract_circuit):
         # Determine if any X checks or Z check
         # Determine if ancilla_ticks, data_ticks, or meas_ticks ever set
 
         has_ticks_set = False
         max_xdatas = 0
         max_zdatas = 0
 
         for gate_symbol, _, params in abstract_circuit.items():
-
-            if gate_symbol == 'X check' or gate_symbol == 'Z check':
-
-                ancilla_ticks = params.get('ancilla_ticks')
-                data_ticks = params.get('data_ticks')
-                meas_ticks = params.get('meas_ticks')
-                datas = params['datas']
+            if gate_symbol in {"X check", "Z check"}:
+                ancilla_ticks = params.get("ancilla_ticks")
+                data_ticks = params.get("data_ticks")
+                meas_ticks = params.get("meas_ticks")
+                datas = params["datas"]
 
                 if ancilla_ticks or data_ticks or meas_ticks:
                     has_ticks_set = True
                     break
 
-                if gate_symbol == 'X check':
+                if gate_symbol == "X check":
                     if len(datas) > max_xdatas:
                         max_xdatas = len(datas)
 
-                else:
-                    if len(datas) > max_zdatas:
-                        max_zdatas = len(datas)
+                elif len(datas) > max_zdatas:
+                    max_zdatas = len(datas)
 
         if has_ticks_set:
             return None
 
         # ticks init |0>, [H], cnots, [H], meas Z
-        return {'max_xdatas': max_xdatas, 'max_zdatas': max_zdatas}
+        return {"max_xdatas": max_xdatas, "max_zdatas": max_zdatas}
 
-    def generate_ticks(self, make_ticks_data, gate_symbol, locations, params):
+    @staticmethod
+    def generate_ticks(make_ticks_data, gate_symbol, locations, params):
         # X check: init   H    [all data ticks begin] <- H meas [slide to the left]
         # Z check: [idle] init [all data ticks begin] <- meas [slide to the left]
 
-        max_xdatas = make_ticks_data['max_xdatas']
+        max_xdatas = make_ticks_data["max_xdatas"]
 
-        if gate_symbol == 'X check':
+        if gate_symbol == "X check":
             ancilla_ticks = 0
-            data_ticks = [i + 1 for i in range(len(params['datas']))]
+            data_ticks = [i + 1 for i in range(len(params["datas"]))]
             meas_ticks = data_ticks[-1] + 2  # One extra to include the H
+        elif max_xdatas:  # If there are X checks
+            ancilla_ticks = 1
+            data_ticks = [i + 2 for i in range(len(params["datas"]))]
+            meas_ticks = data_ticks[-1] + 1
         else:
-
-            if max_xdatas:  # If there are X checks
-                ancilla_ticks = 1
-                data_ticks = [i + 2 for i in range(len(params['datas']))]
-                meas_ticks = data_ticks[-1] + 1
-            else:
-                ancilla_ticks = 0
-                data_ticks = [i + 1 for i in range(len(params['datas']))]
-                meas_ticks = data_ticks[-1] + 1
+            ancilla_ticks = 0
+            data_ticks = [i + 1 for i in range(len(params["datas"]))]
+            meas_ticks = data_ticks[-1] + 1
         return ancilla_ticks, data_ticks, meas_ticks
 
 
-class NoMap(object):
-    """
-    Default Mapping: item -> item.
-    """
+class NoMap:
+    """Default Mapping: item -> item."""
 
-    def __init__(self):
+    def __init__(self) -> None:
         pass
 
     def __getitem__(self, item):
         return item
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,14 @@
-# Copyright 2021 The PECOS Developers
+# Copyright 2018 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .quantum_circuit import QuantumCircuit
-from .logical_circuit import LogicalCircuit
+from pecos.simulators.cysparsesim_col.cysparsesim import State
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,12 +1,12 @@
-# Copyright 2022 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .hyqc import HyQC
+from pecos.reps.pypmir.pypmir import PyPMIR
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/conditionals.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/conditionals.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,22 +5,21 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .fund import Statement, Block
+from pecos.circuits.hyqc.fund import Block, Statement
 
 
 class CondStmt(Statement):
-
-    def __init__(self, symbol):
+    def __init__(self, symbol) -> None:
         self.symbol = symbol
-        super(CondStmt, self).__init__()
+        super().__init__()
         self.cond = None
         self.block = Block()
 
     def __call__(self, *stmts):
         self.block(*stmts)
         p = self.__class__(self.symbol)
         p.block = self.block
@@ -33,21 +32,20 @@
         p = self.__class__(self.symbol)
         p.block = self.block
         p.cond = stmts
 
         return p
 
 
-While = CondStmt('While')
+While = CondStmt("While")
 
 
 class CIf(CondStmt):
-
-    def __init__(self):
-        super(CIf, self).__init__('If')
+    def __init__(self) -> None:
+        super().__init__("If")
         self.else_block = None
 
     def Else(self, *stmts):
         self.else_block = Block(*stmts)
 
 
 If = CIf()
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/cops.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/cops.py`

 * *Files 25% similar despite different names*

```diff
@@ -5,96 +5,83 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .fund import Expression
+from pecos.circuits.hyqc.fund import Expression
 
 
 class COp(Expression):
-    """Classical operation"""
-    ...
+    """Classical operation."""
 
 
 class BinOp(COp):
-    """Binary Operation"""
+    """Binary Operation."""
 
-    def __init__(self, left, right):
+    def __init__(self, left, right) -> None:
         self.left = left
         self.right = right
 
 
 class CompOp(COp):
-    """Comparison Operation"""
+    """Comparison Operation."""
 
-    def __init__(self, left, right):
+    def __init__(self, left, right) -> None:
         self.left = left
         self.right = right
 
 
 class UnaryOp(COp):
-    """Unary Operation"""
+    """Unary Operation."""
 
-    def __init__(self, value):
+    def __init__(self, value) -> None:
         self.value = value
 
 
 class NOT(UnaryOp):
-    """bitwise ~a"""
-    ...
+    """bitwise ~a."""
 
 
 class XOR(BinOp):
-    """bitwise a ^ b"""
-    ...
+    """bitwise a ^ b."""
 
 
 class AND(BinOp):
-    """bitwise a & b"""
-    ...
+    """bitwise a & b."""
 
 
 class OR(BinOp):
-    """bitwise a | b"""
-    ...
+    """bitwise a | b."""
 
 
 class PLUS(BinOp):
-    """int a + b"""
-    ...
+    """int a + b."""
 
 
 class MINUS(BinOp):
-    """int a - b"""
-    ...
+    """int a - b."""
 
 
 class EQUIV(CompOp):
-    """bool a == b"""
-    ...
+    """bool a == b."""
 
 
 class NEQUIV(CompOp):
-    """bool a != b"""
+    """bool a != b."""
 
 
 class LT(CompOp):
-    """bool a < b"""
-    ...
+    """bool a < b."""
 
 
 class GT(CompOp):
-    """bool a > b"""
-    ...
+    """bool a > b."""
 
 
 class LE(CompOp):
-    """bool a <= b"""
-    ...
+    """bool a <= b."""
 
 
 class GE(CompOp):
-    """bool a > b"""
-    ...
-
+    """bool a > b."""
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/fund.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/fund.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,34 +5,29 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Fundamental definitions for HYQC.
-"""
+"""Fundamental definitions for HYQC."""
 
 
 class Statement:
     """Statements are something that do something."""
-    ...
 
 
 class Expression:
     """Expressions are something that evaluate to a values."""
-    ...
 
 
 class Block:
     """A sequence of statements."""
 
-    def __init__(self, *stmts):
-
+    def __init__(self, *stmts) -> None:
         self.statements = []
         self.extend(*stmts)
 
     def extend(self, *args):
         self.statements.extend(args)
 
     def __call__(self, *stmts):
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/hyqc.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/hyqc.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,32 +5,28 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-A Pythonic representation of hybrid quantum-classical program.
-"""
-from .fund import Block
-from . import qops
+"""A Pythonic representation of hybrid quantum-classical program."""
+from pecos.circuits.hyqc import qops
+from pecos.circuits.hyqc.fund import Block
 
 
 class HyQC(Block):
-    """Represents a full program for HyQC. A high-level ''language'' for hybrid quantum-classical computing."""
+    """Represents a full program for HyQC, a high-level ''language'' for hybrid quantum-classical computing."""
 
-    def __init__(self, *stmts):
-        super(HyQC, self).__init__(*stmts)
+    def __init__(self, *stmts) -> None:
+        super().__init__(*stmts)
 
         self.qops = qops
         self.ast = None
 
     def get_ast(self):
         """Get the abstract syntax tree for the program."""
         # TODO: get_ast
-        ...
 
     def parse(self, txt: str):
         """Parse a text representing HYQC."""
         # TODO: parse
-        ...
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/int.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/int.py`

 * *Files 24% similar despite different names*

```diff
@@ -4,126 +4,105 @@
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
+from __future__ import annotations
 
-from .vars import CVar
-from . import cops
+from pecos.circuits.hyqc import cops
+from pecos.circuits.hyqc.vars import CVar
 
 
 class Int(CVar):
+    def __init__(self, size: int, symbol: str | None = None) -> None:
+        """Representation for a collection of bits.
 
-    def __init__(self,
-                 size: int, symbol: str = None):
-        """
-        Representation for a collection of bits.
-
-        TODO:
+        Todo:
+        ----
 
         Args:
+        ----
             symbol:
             size:
         """
-
-        super(Int, self).__init__(symbol)
+        super().__init__(symbol)
         self.size = size
 
     def __getitem__(self, item):
         return Bit(self, item)
 
     def __xor__(self, other):
-        """a ^ b"""
-
+        """A ^ b."""
         return cops.XOR(self, other)
 
     def __and__(self, other):
-        """a & b"""
-
+        """A & b."""
         return cops.AND(self, other)
 
     def __or__(self, other):
-
-        """a | b"""
-
+        """A | b."""
         return cops.OR(self, other)
 
     def __eq__(self, other):
-        """a == b"""
-
+        """A == b."""
         return cops.EQUIV(self, other)
 
     def __ne__(self, other):
-        """a != b"""
-
+        """A != b."""
         return cops.NEQUIV(self, other)
 
     def __lt__(self, other):
-        """a < b"""
-
+        """A < b."""
         return cops.LT(self, other)
 
     def __gt__(self, other):
-        """a > b"""
+        """A > b."""
         return cops.GT(self, other)
 
     def __le__(self, other):
-        """a <= b"""
+        """A <= b."""
         return cops.LE(self, other)
 
     def __ge__(self, other):
-        """a >= b"""
+        """A >= b."""
         return cops.GE(self, other)
 
     def __add__(self, other):
-        """a + b"""
-        ...
+        """A + b."""
 
     def __sub__(self, other):
-        """a - b"""
-        ...
+        """A - b."""
 
     def __rshift__(self, other):
-        """a >> b"""
-        ...
+        """A >> b."""
 
     def __lshift__(self, other):
-        """a << b"""
-        ...
+        """A << b."""
 
-    def __invert__(self):
-        ...
+    def __invert__(self): ...
 
     def __ixor__(self, other):
-        """a ^= b"""
-        ...
+        """A ^= b."""
 
     def __iand__(self, other):
-        """a &= b"""
-        ...
+        """A &= b."""
 
     def __ior__(self, other):
-        """a |= b"""
-        ...
+        """A |= b."""
 
 
 class Bit(Int):
-
-    def __init__(self,
-                 ints: Int,
-                 idx: int,
-                 symbol: str = None):
-
+    def __init__(self, ints: Int, idx: int, symbol: str | None = None) -> None:
         if symbol is None:
-            symbol = f'{ints.symbol}[{idx}]'
+            symbol = f"{ints.symbol}[{idx}]"
 
-        super(Bit, self).__init__(size=1, symbol=symbol)
+        super().__init__(size=1, symbol=symbol)
         self.int = ints
         self.index = idx
 
-    def __str__(self):
-        return f'{self.symbol}'
+    def __str__(self) -> str:
+        return f"{self.symbol}"
 
-    def __repr__(self):
-        return f'<{self.__class__.__name__} {self.index} of {self.int.__repr__()[1:-1]}>'
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__} {self.index} of {self.int.__repr__()[1:-1]}>"
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/misc_stmts.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/misc_stmts.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,44 +5,40 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .fund import Statement
+from pecos.circuits.hyqc.fund import Statement
 
 
 class Include(Statement):
     """Text files to be injected into the program."""
 
-    def __init__(self, txt: str):
+    def __init__(self, txt: str) -> None:
         self.txt = txt
 
 
 class Define(Statement):
     """Pythonic definition of a gate."""
 
-    def __init__(self):
+    def __init__(self) -> None:
         # TODO: ....
         ...
 
 
 class Assign(Statement):
-
-    def __init__(self, left, right):
+    def __init__(self, left, right) -> None:
         self.left = left
         self.right = right
 
 
 class CFunc(Statement):
-
-    def __init__(self, symbol):
+    def __init__(self, symbol) -> None:
         self.symbol = symbol
         self.cargs = None
 
     def __call__(self, *cargs):
         f = CFunc(self.symbol)
         f.cargs = cargs
         return f
-
-
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/qops.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/qops.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,30 +6,30 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 import copy
+
 import numpy as np
-from .fund import Expression
 
+from pecos.circuits.hyqc.fund import Expression
 
-class QOp(Expression):
 
-    def __init__(self):
-        super(QOp, self).__init__()
+class QOp(Expression):
+    def __init__(self) -> None:
+        super().__init__()
 
 
 class QGate(QOp):
-
     # qargs: Qubits, Qubits, ...; (Qubit, Qubit)
 
-    def __init__(self):
-        super(QGate, self).__init__()
+    def __init__(self) -> None:
+        super().__init__()
         self.symbol = self.__class__.__name__
 
         self.qsize = None
         self.csize = None
 
         self.qargs = None
         self.params = None
@@ -43,312 +43,293 @@
         return g
 
     def __getitem__(self, *qargs):
         g = self.copy()
         g.qargs = qargs
         return g
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         repr_str = self.symbol
 
         if self.params:
-            str_cargs = ', '.join([str(p) for p in self.params])
-            repr_str = f'{repr_str}({str_cargs})'
+            str_cargs = ", ".join([str(p) for p in self.params])
+            repr_str = f"{repr_str}({str_cargs})"
 
-        str_qargs = ', '.join([str(q) for q in self.qargs])
-        return f'{repr_str}[{str_qargs}]'
+        str_qargs = ", ".join([str(q) for q in self.qargs])
+        return f"{repr_str}[{str_qargs}]"
 
 
 class BarrierGate(QGate):
     """A gate that prevents compilers from moving quantum gates past the barrier."""
-    ...
 
 
 Barrier = BarrierGate()
 
 
 class ResetGate(QGate):
     """Resetting a qubit to the zero state."""
-    ...
 
 
 Reset = ResetGate()
 
 
 class MeasureGate(QGate):
     """A measurement of a qubit in the Z basis."""
 
-    def __init__(self):
-        super(MeasureGate, self).__init__()
+    def __init__(self) -> None:
+        super().__init__()
         self.cout = None
 
     def __gt__(self, *cout):
         g = self.copy()
         g.cout = cout
 
         return g
 
-    def __repr__(self):
-        repr_str = super(MeasureGate, self).__repr__()
-        couts_str = ', '.join([str(c) for c in self.cout])
-        return f'{repr_str} > {couts_str}'
+    def __repr__(self) -> str:
+        repr_str = super().__repr__()
+        couts_str = ", ".join([str(c) for c in self.cout])
+        return f"{repr_str} > {couts_str}"
 
 
 Measure = MeasureGate()
 
 
 class UnitaryGate(QGate):
-    """A Unitary gate"""
+    """A Unitary gate."""
 
-    def __init__(self):
-        super(UnitaryGate, self).__init__()
+    def __init__(self) -> None:
+        super().__init__()
         self.matrix = None
 
 
 class CliffordGate(UnitaryGate):
-    """A Clifford gate"""
+    """A Clifford gate."""
 
-    def __init__(self):
-        super(CliffordGate, self).__init__()
+    def __init__(self) -> None:
+        super().__init__()
         self.csize = 0
         self.pauli_rules = None
 
 
 class PauliGate(CliffordGate):
-    """A Pauli gate"""
-    ...
+    """A Pauli gate."""
 
 
 class NonCliffordGate(UnitaryGate):
-    """A non-Clifford gate"""
-    ...
+    """A non-Clifford gate."""
 
 
 class XGate(PauliGate):
     """The Pauli X unitary."""
 
-    def __init__(self):
-
-        super(XGate, self).__init__()
+    def __init__(self) -> None:
+        super().__init__()
         self.qsize = 1
 
-        self.matrix = np.array([
-            [0, 1],
-            [1, 0],
-        ], dtype=complex)
+        self.matrix = np.array(
+            [
+                [0, 1],
+                [1, 0],
+            ],
+            dtype=complex,
+        )
 
         self.pauli_rules = {
-            'X': '+X',
-            'Y': '-Y',
-            'Z': '-Z',
+            "X": "+X",
+            "Y": "-Y",
+            "Z": "-Z",
         }
 
 
 X = XGate()
 
 
 class YGate(PauliGate):
     """The Pauli Y unitary."""
 
-    def __init__(self):
-        super(YGate, self).__init__()
+    def __init__(self) -> None:
+        super().__init__()
         self.qsize = 1
 
-        self.matrix = np.array([
-            [0, -1j],
-            [1j, 0],
-        ], dtype=complex)
+        self.matrix = np.array(
+            [
+                [0, -1j],
+                [1j, 0],
+            ],
+            dtype=complex,
+        )
 
         self.pauli_rules = {
-            'X': '-X',
-            'Y': '+Y',
-            'Z': '-Z',
+            "X": "-X",
+            "Y": "+Y",
+            "Z": "-Z",
         }
 
 
 Y = YGate()
 
 
 class ZGate(PauliGate):
     """The Pauli Z unitary."""
 
-    def __init__(self):
-        super(ZGate, self).__init__()
+    def __init__(self) -> None:
+        super().__init__()
         self.qsize = 1
 
-        self.matrix = np.array([
-            [0, -1j],
-            [1j, 0],
-        ], dtype=complex)
+        self.matrix = np.array(
+            [
+                [0, -1j],
+                [1j, 0],
+            ],
+            dtype=complex,
+        )
 
         self.pauli_rules = {
-            'X': '-X',
-            'Y': '-Y',
-            'Z': '+Z',
+            "X": "-X",
+            "Y": "-Y",
+            "Z": "+Z",
         }
 
 
 Z = ZGate()
 
 
-class SqrtXGate(CliffordGate):
-    ...
+class SqrtXGate(CliffordGate): ...
 
 
 SqrtX = SqrtXGate()
 
 
-class SqrtYGate(CliffordGate):
-    ...
+class SqrtYGate(CliffordGate): ...
 
 
 SqrtY = SqrtYGate()
 
 
-class SqrtZGate(CliffordGate):
-    ...
+class SqrtZGate(CliffordGate): ...
 
 
 S = SqrtZ = SqrtZGate()
 
 
-class SqrtXdgGate(CliffordGate):
-    ...
+class SqrtXdgGate(CliffordGate): ...
 
 
 SqrtXdg = SqrtXdgGate()
 
 
-class SqrtYdgGate(CliffordGate):
-    ...
+class SqrtYdgGate(CliffordGate): ...
 
 
 SqrtYdg = SqrtYdgGate()
 
 
-class SqrtZdgGate(CliffordGate):
-    ...
+class SqrtZdgGate(CliffordGate): ...
 
 
 Sdg = SqrtZdg = SqrtZGate()
 
 
-class RXGate(NonCliffordGate):
-    ...
+class RXGate(NonCliffordGate): ...
 
 
 RX = RXGate()
 
 
-class RYGate(NonCliffordGate):
-    ...
+class RYGate(NonCliffordGate): ...
 
 
 RY = RYGate()
 
 
-class RZGate(NonCliffordGate):
-    ...
+class RZGate(NonCliffordGate): ...
 
 
 RZ = RZGate()
 
 
-class TGate(NonCliffordGate):
-    ...
+class TGate(NonCliffordGate): ...
 
 
 T = TGate()
 
 
-class TdgGate(NonCliffordGate):
-    ...
+class TdgGate(NonCliffordGate): ...
 
 
 Tdg = TdgGate()
 
 
-class HGate(CliffordGate):
-    ...
+class HGate(CliffordGate): ...
 
 
 H = HGate()
 
 
-class FGate(CliffordGate):
-    ...
+class FGate(CliffordGate): ...
 
 
 F = FGate()
 
 
-class FdgGate(CliffordGate):
-    ...
+class FdgGate(CliffordGate): ...
 
 
 Fdg = FdgGate()
 
 
-class CXGate(CliffordGate):
-    ...
+class CXGate(CliffordGate): ...
 
 
 CNOT = CX = CXGate()
 
 
-class CYGate(CliffordGate):
-    ...
+class CYGate(CliffordGate): ...
 
 
 CY = CYGate()
 
 
-class CZGate(CliffordGate):
-    ...
+class CZGate(CliffordGate): ...
 
 
 CZ = CZGate()
 
 
-class SqrtXXGate(CliffordGate):
-    ...
+class SqrtXXGate(CliffordGate): ...
 
 
 SqrtXX = SqrtXXGate()
 
 
-class SqrtYYGate(CliffordGate):
-    ...
+class SqrtYYGate(CliffordGate): ...
 
 
 SqrtYY = SqrtYYGate()
 
 
-class SqrtZZGate(CliffordGate):
-    ...
+class SqrtZZGate(CliffordGate): ...
 
 
 SqrtZZ = SqrtZZGate()
 
 
-class SqrtXXdgGate(CliffordGate):
-    ...
+class SqrtXXdgGate(CliffordGate): ...
 
 
 SqrtXXdg = SqrtXXdgGate()
 
 
-class SqrtYYdgGate(CliffordGate):
-    ...
+class SqrtYYdgGate(CliffordGate): ...
 
 
 SqrtYYdg = SqrtYYdgGate()
 
 
-class SqrtZZdgGate(CliffordGate):
-    ...
+class SqrtZZdgGate(CliffordGate): ...
 
 
 SqrtZZdg = SqrtZZdgGate()
 
 
 # TODO: SWAP, iSWAP, Toffoli (CCNOT, CCX, TOFF)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/qubits.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/error_model_abc.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,59 +1,38 @@
-# Copyright 2022 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .vars import QVar
+from __future__ import annotations
 
+import abc
+from abc import ABCMeta
 
-class Qubits(QVar):
 
-    def __init__(self,
-                 size: int, symbol: str = None):
+class ErrorModel(metaclass=ABCMeta):
+    def __init__(self, error_params: dict) -> None:
+        self.error_params = dict(error_params)
+        self.machine = None
+        self.num_qubits = None
 
-        super(Qubits, self).__init__(symbol)
-        self.size = size
+    @abc.abstractmethod
+    def reset(self) -> None:
+        """Reset state to initialization state."""
 
-    def __getitem__(self, item):
-        return Qubit(self, item)
+    def init(self, num_qubits, machine=None):
+        self.machine = machine
+        self.num_qubits = num_qubits
 
-    def __str__(self):
-        return self.symbol
+    @abc.abstractmethod
+    def shot_reinit(self, *args, **kwargs) -> None:
+        """Run all code needed at the beginning of each shot, e.g., resetting state."""
 
-
-class Qubit(Qubits):
-
-    def __init__(self,
-                 qubits: Qubits,
-                 idx: int,
-                 symbol: str = None):
-
-        if symbol is None:
-            symbol = f'{qubits.symbol}[{idx}]'
-
-        super(Qubit, self).__init__(size=1, symbol=symbol)
-
-        self.qubits = qubits
-        self.index = idx
-
-    def __getitem__(self, item):
-        raise TypeError(f"'{self.__class__.__name__}' object is not subscriptable")
-
-    def __repr__(self):
-        return f'<{self.__class__.__name__} {self.index} of {self.qubits.symbol}>'
-
-
-"""
-class QSet(QVar):
-
-    def __init__(self, size):
-        super(QSet, self).__init__()
-        self.size = size
-        self.set = None
-"""
+    @abc.abstractmethod
+    def process(self, qops: list, **kwargs) -> list | None:
+        pass
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/hyqc/vars.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/helper.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-# Copyright 2022 The PECOS Developers
+# Copyright 2019 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .fund import Expression
+from typing import Any
 
 
-class Var(Expression):
-    """Type for variables."""
+class MakeFunc:
+    """Converts ProjectQ gate to a function."""
 
-    def __init__(self, symbol: str = None):
-        super(Var, self).__init__()
-
-        self.symbol = symbol
-
-    def __repr__(self):
-        repr_str = self.__class__.__name__
-        if self.symbol is not None:
-            repr_str = f'{repr_str}:{self.symbol}'
-        return f'<{repr_str} at {hex(id(self))}>'
-
-
-class CVar(Var):
-    """Type for classical variables."""
-    ...
-
-
-class QVar(Var):
-    """Type for quantum variables."""
-    ...
+    def __init__(self, gate, angle=False) -> None:
+        """Args:
+        ----
+            gate:
+        """
+        self.gate = gate
+        self.angle = angle
+
+    def func(self, state, qubits, **params: Any):
+        if isinstance(qubits, int):
+            qs = state.qids[qubits]
+        else:
+            qs = []
+            for q in qubits:
+                qs.append(state.qids[q])
+
+        if self.angle:
+            self.gate(params["angle"]) | qs
+        else:
+            self.gate | qs
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/logical_circuit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/logical_circuit.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,134 +7,130 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Provides class to represent a logical circuit.
-"""
+"""Provides class to represent a logical circuit."""
 
-from .quantum_circuit import QuantumCircuit
+from pecos.circuits.quantum_circuit import QuantumCircuit
 
 
 class LogicalCircuit(QuantumCircuit):
-    """
-    Data structure used to represent a logical circuit.
-    """
-
-    def __init__(self, layout=None, suppress_warning=True, **params):
+    """Data structure used to represent a logical circuit."""
 
+    def __init__(self, layout=None, suppress_warning=True, **params) -> None:
         self.layout = layout
         if self.layout is not None:
             self.qudit_set = set(self.layout.keys())
             self.num_qudits = len(self.qudit_set)
         else:
             self.num_qudits = None
             self.qudit_set = None
 
         self.suppress_warning = suppress_warning
 
         super().__init__(**params)
 
     def append(self, logical_gate, gate_locations=None, **params):
-        """
-
-        Args:
+        """Args:
+        ----
             logical_gate:
             gate_locations:
             **params:
 
         Returns:
+        -------
 
         """
-
         if gate_locations is None and not isinstance(logical_gate, dict):
             super().append(logical_gate, frozenset([None]), **params)
         else:
             super().append(logical_gate, gate_locations, **params)
 
         if self.layout is None:
-
             qecc = logical_gate.qecc
 
             self.layout = qecc.layout
             self.num_qudits = qecc.num_qudits
             self.qudit_set = qecc.qudit_set
 
             if not self.suppress_warning:
-                print('No layout given. The layout of the first QECC is assumed.')
+                print("No layout given. The layout of the first QECC is assumed.")
 
-        else:
-            if isinstance(logical_gate, dict):
-                for gate, _ in logical_gate.items():
-                    # TODO: Probably not the best... need total number of qudits
-                    qecc = gate.qecc
-                    if self.num_qudits < qecc.num_qudits:
-                        raise Exception('Number of QECC qudits greater than those in assumed layout (%s < %s)' %
-                                        (self.num_qudits, qecc.num_qudits))
-
-                    if self.qudit_set is None:
-                        raise Exception('Qudit set should be set!')
-            else:
-                qecc = logical_gate.qecc
+        elif isinstance(logical_gate, dict):
+            for gate in logical_gate:
+                # TODO: Probably not the best... need total number of qudits
+                qecc = gate.qecc
                 if self.num_qudits < qecc.num_qudits:
-                    raise Exception('Number of QECC qudits greater than those in assumed layout (%s < %s)' %
-                                    (self.num_qudits, qecc.num_qudits))
+                    msg = (
+                        f"Number of QECC qudits greater than those in assumed layout "
+                        f"({self.num_qudits} < {qecc.num_qudits})"
+                    )
+                    raise Exception(msg)
 
                 if self.qudit_set is None:
-                    raise Exception('Qudit set should be set!')
-
-    def update(self, symbol, locations=None, tick=-1, emptyappend=False, **params):
-        raise NotImplementedError('!!!')
+                    msg = "Qudit set should be set!"
+                    raise Exception(msg)
+        else:
+            qecc = logical_gate.qecc
+            if self.num_qudits < qecc.num_qudits:
+                msg = (
+                    f"Number of QECC qudits greater than those in assumed layout "
+                    f"({self.num_qudits} < {qecc.num_qudits})"
+                )
+                raise Exception(msg)
+
+            if self.qudit_set is None:
+                msg = "Qudit set should be set!"
+                raise Exception(msg)
+
+    @staticmethod
+    def update(symbol, locations=None, tick=-1, emptyappend=False, **params):
+        msg = "!!!"
+        raise NotImplementedError(msg)
 
     def discard(self, locations, tick=-1):
-        raise NotImplementedError('!!!')
+        msg = "!!!"
+        raise NotImplementedError(msg)
 
     def iter_ticks(self):
         """An iterator for looping over the various quantum circuits comprising this data structure."""
-
         for logical_tick in range(len(self)):
             for logical_gate, _, _ in self.items(tick=logical_tick):
                 for instr_index, instr_circuit in enumerate(logical_gate.circuits):
-                    params = {'logical_circuit_params': self.metadata, 'gate': logical_gate, }
+                    params = {"logical_circuit_params": self.metadata, "gate": logical_gate}
                     params.update(instr_circuit.metadata)
 
                     for tick in range(len(instr_circuit)):
                         tick_gates = instr_circuit[tick]
                         time = (logical_tick, instr_index, tick)
                         yield tick_gates, time, params
 
     def __iter__(self):
-
         for element in self._ticks:
             for gate, _, _ in element.items():
                 yield gate
 
-    def __str__(self):
-
+    def __str__(self) -> str:
         return "LogicalCircuit(%s)" % self._ticks
 
-    def __repr__(self):
-
+    def __repr__(self) -> str:
         return self.__str__()
 
     def __getitem__(self, tick):
         """Returns tick when instance[index] is used.
 
         Args:
+        ----
             tick(int): Tick index of ``self._ticks``.
 
         Returns:
+        -------
 
         """
-
         if isinstance(tick, int):
-
             return self._ticks[tick]
         else:
-            # logical_tick, instr_index, tick = tick
             logical_tick, _, _ = tick
-            tick_circuit = self[logical_tick]
-            # (logical_tick, instr_index, tick)
-            return tick_circuit
+            return self[logical_tick]
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -5,16 +5,14 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .qasm import QASM
-
-from .gates import Gate, ArgGate, MeasGate, ResetGate
-from .conditionals import CIf, CIfExpect
-from .barrier import Barrier
-from .expr import Assign
-from .misc import Comment, br
-
-from .std_gates import Measure, Reset, X, Y, Z, H, S, Sdg, T, Tdg, CNOT, CX, CY, CZ, RX, RY, RZ
+from pecos.circuits.qasm.barrier import Barrier
+from pecos.circuits.qasm.conditionals import CIf, CIfExpect
+from pecos.circuits.qasm.expr import Assign
+from pecos.circuits.qasm.gates import ArgGate, Gate, MeasGate, ResetGate
+from pecos.circuits.qasm.misc import Comment, br
+from pecos.circuits.qasm.qasm import QASM
+from pecos.circuits.qasm.std_gates import CNOT, CX, CY, CZ, RX, RY, RZ, H, Measure, Reset, S, Sdg, T, Tdg, X, Y, Z
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/barrier.py` & `quantum_pecos-0.6.0.dev1/python/pecos/slr/util.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-# Copyright 2021 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-class Barrier:
-    """Represents a barrier for operations"""
 
-    def __init__(self, *qargs):
-        self.qargs = qargs
+def str2list(qasm):
+    qasm = qasm.split("\n")
+    qasm_list = []
+    for line in qasm:
+        qasm_list.append(line.strip())
+    return qasm_list
 
-    def __str__(self):
-        qregs = ', '.join([str(a) for a in self.qargs])
-        return f'barrier {qregs}'
+
+def list2str(qasm_list):
+    return "\n".join(qasm_list)
+
+
+def rm_white_space(qasm):
+    return list2str(str2list(qasm))
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/block.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/block.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,26 +5,26 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+
 class Block:
-    def __init__(self, *args):
+    def __init__(self, *args) -> None:
         self.elements = []
         self.elements.extend(args)
 
     def append(self, arg):
         self.elements.append(arg)
 
     def extend(self, *args):
         self.elements.extend(args)
 
     def __iter__(self):
         """Recursively iterate through sub-blocks."""
-
         for e in self.elements:
             if isinstance(e, Block):
                 yield from e
             else:
                 yield e
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/conditionals.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/conditionals.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,78 +5,75 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-'''
-class CIf:
-    """Represents a if expression"""
+'''class CIf:
+"""Represents a if expression""".
 
-    def __init__(self, cond, expr, else_expr=None):
-        self.cond = cond
-        self.expr = expr
-        self.else_expr = else_expr
+def __init__(self, cond, expr, else_expr=None):
+self.cond = cond
+self.expr = expr
+self.else_expr = else_expr
 
-    def __str__(self):
-        return f'if({str(self.cond)}) {str(self.expr)}'
+def __str__(self):
+return f'if({str(self.cond)}) {str(self.expr)}'
 '''
 
+
 class CIf:
-    """Represents a if expression"""
+    """Represents a if expression."""
 
-    def __init__(self, cond, *expr, expect=None):
+    def __init__(self, cond, *expr, expect=None) -> None:
         self.cond = cond
 
         if expect is not None:
-            self.expect = f' expect({expect})'
+            self.expect = f" expect({expect})"
         else:
-            self.expect = ''
+            self.expect = ""
 
         if len(expr) == 1 and isinstance(expr[0], (tuple, list)):
-            self.expr = [expr[0], ]
+            self.expr = [expr[0]]
         else:
             self.expr = expr
 
-    def __str__(self):
-
+    def __str__(self) -> str:
         ifs = []
 
         for e in self.expr:
-            for n in str(e).split('\n'):
-                ifs.append(f'if{self.expect}({str(self.cond)}) {n}')
+            for n in str(e).split("\n"):
+                ifs.append(f"if{self.expect}({str(self.cond)}) {n}")
+
+        return "\n".join(ifs)
 
-        return '\n'.join(ifs)
 
 class CIfExpect:
-    """Represents a if expression with expression"""
+    """Represents a if expression with expression."""
 
-    def __init__(self, expect, cond, *expr):
+    def __init__(self, expect, cond, *expr) -> None:
         self.cond = cond
 
         if expect is not None:
-            self.expect = f' expect({expect})'
+            self.expect = f" expect({expect})"
         else:
-            self.expect = ''
+            self.expect = ""
 
         if len(expr) == 1 and isinstance(expr[0], (tuple, list)):
-            self.expr = [expr[0], ]
+            self.expr = [expr[0]]
         else:
             self.expr = expr
 
-    def __str__(self):
-
+    def __str__(self) -> str:
         ifs = []
 
         for e in self.expr:
-            for n in str(e).split('\n'):
-
+            for n in str(e).split("\n"):
                 ns = n.strip()
 
-                if len(ns) > 0 and not ns.startswith('//'):
-                    # ifs.append(f'if{self.expect}({str(self.cond)}) {n}')
-                    ifs.append(f'if({str(self.cond)}) {n}')
+                if len(ns) > 0 and not ns.startswith("//"):
+                    ifs.append(f"if({str(self.cond)}) {n}")
                 else:
                     ifs.append(ns)
 
-        return '\n'.join(ifs)
+        return "\n".join(ifs)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/expr.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/expr.py`

 * *Files 18% similar despite different names*

```diff
@@ -5,72 +5,72 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-class BinaryOp:
 
-    def __init__(self, sym, left, right):
+class BinaryOp:
+    def __init__(self, sym, left, right) -> None:
         self.sym = sym
         self.left = left
         self.right = right
 
-    def __str__(self):
-        return f'{str(self.left)} {self.sym} {str(self.right)}'
+    def __str__(self) -> str:
+        return f"{str(self.left)} {self.sym} {str(self.right)}"
 
 
 class Assign(BinaryOp):
-    """Assignment of a variable or number to a variable"""
+    """Assignment of a variable or number to a variable."""
 
-    def __init__(self, left, right):
-        super().__init__('=', left, right)
+    def __init__(self, left, right) -> None:
+        super().__init__("=", left, right)
 
 
 class Equiv(BinaryOp):
-    """Equivalence between two variables"""
+    """Equivalence between two variables."""
 
-    def __init__(self, left, right):
-        super().__init__('==', left, right)
+    def __init__(self, left, right) -> None:
+        super().__init__("==", left, right)
 
 
 class NE(BinaryOp):
-    """Equivalence between two variables"""
+    """Equivalence between two variables."""
 
-    def __init__(self, left, right):
-        super().__init__('!=', left, right)
+    def __init__(self, left, right) -> None:
+        super().__init__("!=", left, right)
 
 
 class GT(BinaryOp):
-    """>"""
+    """>."""
 
-    def __init__(self, left, right):
-        super().__init__('>', left, right)
+    def __init__(self, left, right) -> None:
+        super().__init__(">", left, right)
 
 
 class GE(BinaryOp):
-    """>="""
+    """>=."""
 
-    def __init__(self, left, right):
-        super().__init__('>=', left, right)
+    def __init__(self, left, right) -> None:
+        super().__init__(">=", left, right)
 
 
 class LT(BinaryOp):
-    """>"""
+    """>."""
 
-    def __init__(self, left, right):
-        super().__init__('>', left, right)
+    def __init__(self, left, right) -> None:
+        super().__init__(">", left, right)
 
 
 class LE(BinaryOp):
-    """>="""
+    """>=."""
 
-    def __init__(self, left, right):
-        super().__init__('>=', left, right)
+    def __init__(self, left, right) -> None:
+        super().__init__(">=", left, right)
 
 
 class XOR(BinaryOp):
     """Exclusive OR."""
 
-    def __init__(self, left, right):
-        super().__init__('^', left, right)
+    def __init__(self, left, right) -> None:
+        super().__init__("^", left, right)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/func.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/func.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,20 +5,21 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+
 class Func:
     """A class representing a function."""
 
-    def __init__(self, name):
+    def __init__(self, name) -> None:
         self.name = name
 
     def __call__(self, *args):
         str_args = [str(a) for a in args]
-        str_args = ', '.join(str_args)
-        return f'{self.name}({str_args})'
+        str_args = ", ".join(str_args)
+        return f"{self.name}({str_args})"
 
-    def __str__(self):
+    def __str__(self) -> str:
         return self.name
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/gates.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/gates.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,212 +5,209 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-class Gate:
 
-    def __init__(self, sym, size=None, qasm_def=None):
+class Gate:
+    def __init__(self, sym, size=None, qasm_def=None) -> None:
         self.sym = sym
         self.size = size
         self.qasm_def = qasm_def
         self.results = []
 
     def __call__(self, *qargs):
-
         if len(qargs) == 1 and isinstance(qargs[0], (list, set)):
             self.results = self._multi_call(*qargs)
 
         else:
-
             if self.size is not None and len(qargs) != self.size:
-                raise Exception(f'Supplying the incorrect number of qubits for gate to operate on. '
-                                f'#args {len(qargs)} != {self.size}')
+                msg = (
+                    f"Supplying the incorrect number of qubits for gate to operate on. "
+                    f"#args {len(qargs)} != {self.size}"
+                )
+                raise Exception(msg)
 
-            qs = ', '.join(str(a) for a in qargs)
-            self.results = [f'{self.sym} {qs}', ]
+            qs = ", ".join(str(a) for a in qargs)
+            self.results = [f"{self.sym} {qs}"]
 
         return str(self)
 
-    def __str__(self):
-
-        return '\n'.join(self.results)
+    def __str__(self) -> str:
+        return "\n".join(self.results)
 
     def _multi_call(self, *qargs):
-
         qargs = qargs[0]
 
         if len(qargs) == 0:
-            raise Exception('List of qubits is empty')
+            msg = "List of qubits is empty"
+            raise Exception(msg)
 
         results = []
         for loc in qargs:
-
             if not isinstance(loc, tuple):
-                loc = (loc, )
+                loc = (loc,)
 
             if self.size is not None and len(loc) != self.size:
-                raise Exception('Supplying the incorrect number of qubits for gate to operate on.'
-                                f'#args {len(qargs)} != {self.size}')
+                msg = (
+                    f"Supplying the incorrect number of qubits for gate to operate on. "
+                    f"#args {len(qargs)} != {self.size}"
+                )
+                raise Exception(msg)
 
-            qs = ', '.join(str(a) for a in loc)
-            results.append(f'{self.sym} {qs}')
+            qs = ", ".join(str(a) for a in loc)
+            results.append(f"{self.sym} {qs}")
 
         return results
 
-class Gate_old:
 
-    def __init__(self, sym, size=None, qasm_def=None):
+class GateOld:
+    def __init__(self, sym, size=None, qasm_def=None) -> None:
         self.sym = sym
         self.size = size
         self.qasm_def = qasm_def
         self.locs = []
 
     def __call__(self, *qargs):
-
         if len(qargs) == 1 and isinstance(qargs[0], (list, set)):
             return self._multi_call(*qargs)
 
         if self.size is not None and len(qargs) != self.size:
-            raise Exception(f'Supplying the incorrect number of qubits for gate to operate on. '
-                            f'#args {len(qargs)} != {self.size}')
+            msg = f"Supplying the incorrect number of qubits for gate to operate on. #args {len(qargs)} != {self.size}"
+            raise Exception(msg)
 
-        qs = ', '.join(str(a) for a in qargs)
-        return f'{self.sym} {qs}'
+        qs = ", ".join(str(a) for a in qargs)
+        return f"{self.sym} {qs}"
 
     def _multi_call(self, *qargs):
-
         qargs = qargs[0]
 
         if len(qargs) == 0:
-            raise Exception('List of qubits is empty')
+            msg = "List of qubits is empty"
+            raise Exception(msg)
 
         results = []
         for loc in qargs:
-
             if not isinstance(loc, tuple):
-                loc = (loc, )
+                loc = (loc,)
 
             if self.size is not None and len(loc) != self.size:
-                raise Exception('Supplying the incorrect number of qubits for gate to operate on.'
-                                f'#args {len(qargs)} != {self.size}')
-
-            qs = ', '.join(str(a) for a in loc)
-            results.append(f'{self.sym} {qs}')
-        return '\n'.join(results)
+                msg = (
+                    f"Supplying the incorrect number of qubits for gate to operate on. "
+                    f"#args {len(qargs)} != {self.size}"
+                )
+                raise Exception(msg)
+
+            qs = ", ".join(str(a) for a in loc)
+            results.append(f"{self.sym} {qs}")
+        return "\n".join(results)
 
 
 class ArgGate(Gate):
-
-    def __init__(self, sym, size=None, num_args=None, qasm_def=None):
+    def __init__(self, sym, size=None, num_args=None, qasm_def=None) -> None:
         super().__init__(sym, size, qasm_def)
         self.num_args = num_args
 
     def __call__(self, params, *qargs):
-
-        if isinstance(params, str) or isinstance(params, float) or isinstance(params, int):
+        if isinstance(params, (str, float, int)):
             params = (params,)
 
         if len(qargs) == 1 and isinstance(qargs[0], (list, set)):
             return self._multi_call(params, *qargs)
 
         if self.size is not None and len(qargs) != self.size:
-            raise Exception('Supplying the incorrect number of qubits for gate to operate on.')
+            msg = "Supplying the incorrect number of qubits for gate to operate on."
+            raise Exception(msg)
 
         if self.num_args is not None and len(params) != self.num_args:
-            raise Exception('Supplying supplying the wrong number of gate parameters.')
+            msg = "Supplying supplying the wrong number of gate parameters."
+            raise Exception(msg)
 
-        args = ', '.join(str(a) for a in params)
-        qs = ', '.join(str(a) for a in qargs)
-        return f'{self.sym}({args}) {qs}'
+        args = ", ".join(str(a) for a in params)
+        qs = ", ".join(str(a) for a in qargs)
+        return f"{self.sym}({args}) {qs}"
 
     def _multi_call(self, params, *qargs):
-
-        args = ', '.join(str(a) for a in params)
+        args = ", ".join(str(a) for a in params)
         qargs = qargs[0]
 
         if len(qargs) == 0:
-            raise Exception('List of qubits is empty')
+            msg = "List of qubits is empty"
+            raise Exception(msg)
 
         results = []
         for loc in qargs:
-
             if not isinstance(loc, tuple):
-                loc = (loc, )
+                loc = (loc,)
 
             if self.size is not None and len(loc) != self.size:
-                raise Exception('Supplying the incorrect number of qubits for gate to operate on.')
+                msg = "Supplying the incorrect number of qubits for gate to operate on."
+                raise Exception(msg)
 
-            qs = ', '.join(str(a) for a in loc)
-            results.append(f'{self.sym}({args}) {qs}')
-        return '\n'.join(results)
+            qs = ", ".join(str(a) for a in loc)
+            results.append(f"{self.sym}({args}) {qs}")
+        return "\n".join(results)
 
 
 class MeasGate(Gate):
-
-    def __init__(self):
-        super().__init__(sym='measure', size=1)
+    def __init__(self) -> None:
+        super().__init__(sym="measure", size=1)
         self.qreg = None
         self.creg = None
 
     def __call__(self, qreg):
         self.qreg = qreg
-        # return f'measure {qreg} -> {creg}'
         return self
 
     def __gt__(self, creg):
         self.creg = creg
 
         if isinstance(self.qreg, list):
             return self._multi_call(self.qreg, self.creg)
 
-        return f'measure {self.qreg} -> {creg}'
+        return f"measure {self.qreg} -> {creg}"
 
     def _multi_call(self, qargs, cargs):
         if not isinstance(qargs, list):
-            raise Exception('Both quantum and classical arguments should be a list.')
+            msg = "Both quantum and classical arguments should be a list."
+            raise TypeError(msg)
 
         results = []
 
         if isinstance(cargs, list):
-
             if len(qargs) != len(cargs):
-                raise Exception('The number of quantum and classical arguments must be the same.')
+                msg = "The number of quantum and classical arguments must be the same."
+                raise Exception(msg)
 
             for qloc, cloc in zip(qargs, cargs):
-                results.append(f'measure {qloc} -> {cloc}')
+                results.append(f"measure {qloc} -> {cloc}")
         else:
             for i, qloc in enumerate(qargs):
-                results.append(f'measure {qloc} -> {cargs}[{i}]')
+                results.append(f"measure {qloc} -> {cargs}[{i}]")
 
-        return '\n'.join(results)
+        return "\n".join(results)
 
 
 class ResetGate(Gate):
-
-    def __init__(self):
-        super().__init__(sym='reset', size=1)
+    def __init__(self) -> None:
+        super().__init__(sym="reset", size=1)
 
     def __call__(self, *qargs):
-
         if len(qargs) == 1 and isinstance(qargs[0], (list, set)):
             return self._multi_call(*qargs)
 
-        qregs = '\n'.join([f'reset {a};' for a in qargs])
-        return qregs
+        return "\n".join([f"reset {a};" for a in qargs])
 
     def _multi_call(self, *qargs):
-
         qargs = qargs[0]
 
         results = []
         for loc in qargs:
-
             if not isinstance(loc, tuple):
-                loc = (loc, )
+                loc = (loc,)
 
-            qregs = ', '.join([str(a) for a in loc])
-            results.append(f'reset {qregs}')
+            qregs = ", ".join([str(a) for a in loc])
+            results.append(f"reset {qregs}")
 
-        return '\n'.join(results)
+        return "\n".join(results)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/misc.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_meas_bitflip.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,57 +1,49 @@
-# Copyright 2021 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+import numpy as np
 
-from typing import Union
+from pecos.reps.pypmir.op_types import QOp
 
 
-class Comment:
-    """Represents a comment"""
+def noise_meas_bitflip(op: QOp, p: float):
+    """Bit-flip noise model for measurements.
 
-    def __init__(self,  *texts):
+    Args:
+    ----
+        op: Ideal quantum operation.
+        p: measurement error rate.
+    """
+    # Bit flip noise
+    # --------------
+    rand_nums = np.random.random(len(op.args)) <= p
+
+    noise = []
+
+    if np.any(rand_nums):
+        bitflips = []
+        for r, loc in zip(rand_nums, op.args):
+            if r:
+                bitflips.append(loc)
+
+        noisy_op = QOp(
+            name="Measure",
+            args=list(op.args),
+            returns=list(op.returns),
+            metadata=dict(op.metadata),
+        )
+        noisy_op.metadata["bitflips"] = bitflips
+        noise.append(noisy_op)
 
-        if isinstance(texts, str):
-            self.texts = [texts, ]
-        else:
-            self.texts = list(texts)
+        return noise
 
-    def __str__(self):
-
-        # TODO: Just insert a new blank line every time a <br> is seen. e.g., e
-
-        lines = []
-        for t in self.texts:
-
-            for ln in t.split('\n'):
-
-                ln = ln.strip()
-
-                if ln == '':
-                    lines.append('//')
-                else:
-
-                    ln = ln.replace('<br>', '</><br></>').split('</>')
-
-                    for ln2 in ln:
-
-                        ln2 = ln2.strip()
-
-                        if ln2 == '':
-                            pass
-                        elif ln2 == '<br>':
-                            lines.append('')
-                        else:
-                            lines.append(f'// {ln2}')
-
-        return '\n'.join(lines)
-
-
-br = ''
+    else:
+        return noise
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/qasm.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/qasm.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,33 +5,32 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from pathlib import Path
 
-# TODO: GateLib
-from .block import Block
-from .vars import QReg, CReg
-from .gates import Gate, ArgGate
-from . import std_gates
-from .std_gates import Measure, Reset
-from .conditionals import CIf
-from .expr import Assign
-from .func import Func
-from .barrier import Barrier
+from pecos.circuits.qasm import std_gates
+from pecos.circuits.qasm.barrier import Barrier
+from pecos.circuits.qasm.block import Block
+from pecos.circuits.qasm.conditionals import CIf
+from pecos.circuits.qasm.expr import Assign
+from pecos.circuits.qasm.func import Func
+from pecos.circuits.qasm.gates import ArgGate, Gate
+from pecos.circuits.qasm.std_gates import Measure, Reset
+from pecos.circuits.qasm.vars import CReg, QReg
 
 
 class QASM:
     """Represents an OpenQASM 2.0 circuit."""
 
-    def __init__(self, language='OPENQASM 2.0', header=True):
-
-        self.language = f'{language};'
+    def __init__(self, language="OPENQASM 2.0", header=True) -> None:
+        self.language = f"{language};"
         self.includes = []
         self.definitions = []
         self.qregs = []
         self.cregs = []
         self.body = Block()
         self.g = std_gates
         self.header = header
@@ -39,159 +38,146 @@
     def qreg(self, sym, size, declare=True):
         return QReg(self, sym, size, declare=declare)
 
     def creg(self, sym, size, declare=True):
         return CReg(self, sym, size, declare=declare)
 
     def define(self, name, params, qargs, body):
-
         param_size = 0
         if isinstance(params, str):
             param_size = 1
         elif params:
             param_size = len(params)
-            params = ','.join(params)
+            params = ",".join(params)
         else:
-            params = ''
+            params = ""
 
         size = 0
         if isinstance(qargs, str):
             size = 1
         else:
             size = len(qargs)
-            qargs = ','.join(qargs)
+            qargs = ",".join(qargs)
 
-        df_str = [f'gate {name}({params}) {qargs}', '{']
-        df_str.extend([f'   {g};' for g in body])
-        df_str.append('}')
-        df_str = '\n'.join(df_str)
+        df_str = [f"gate {name}({params}) {qargs}", "{"]
+        df_str.extend([f"   {g};" for g in body])
+        df_str.append("}")
+        df_str = "\n".join(df_str)
 
         self.definitions.append(df_str)
 
         if params:
             return ArgGate(name, size=size, num_args=param_size, qasm_def=df_str)
         else:
             return Gate(name, size=size, qasm_def=df_str)
 
     def custom(self, text: str):
         self.body.append(text)
 
     def br(self, n: int = 1):
         for _ in range(n):
-            self.body.append('')
+            self.body.append("")
 
     def comment(self, text: str, br=True):
         if br:
-            return f'\n// {text}'
+            return f"\n// {text}"
         else:
-            return f'// {text}'
+            return f"// {text}"
 
     def include(self, *args):
         for a in args:
             self.includes.append(f'include "{a}";')
 
     def block(self, *args):
-
         arg_list = []
         for a in args:
-            if '\n' in str(a):
-                arg_list.extend(str(a).split('\n'))
+            if "\n" in str(a):
+                arg_list.extend(str(a).split("\n"))
             else:
                 arg_list.append(str(a))
 
         self.body.extend(*arg_list)
 
     def block_cif(self, cond, *args):
         self.cif_block(cond, *args)
 
     def cif_block(self, cond, *args):
-
         cond = str(cond)
 
         arg_list = []
         for a in args:
-            if '\n' in str(a):
-
-                for ai in str(a).split('\n'):
-
+            if "\n" in str(a):
+                for ai in str(a).split("\n"):
                     ai = str(ai)
 
-                    if not ai.strip().startswith('//') and ai.strip() != '':
-                        arg_list.append(f'if({cond}) {str(ai)}')
+                    if not ai.strip().startswith("//") and ai.strip() != "":
+                        arg_list.append(f"if({cond}) {str(ai)}")
                     else:
-                        arg_list.append(f'{str(ai)}')
+                        arg_list.append(f"{str(ai)}")
             else:
-
                 a = str(a)
 
-                if not a.strip().startswith('//') and a.strip() != '':
-                    arg_list.append(f'if({cond}) {str(a)}')
+                if not a.strip().startswith("//") and a.strip() != "":
+                    arg_list.append(f"if({cond}) {str(a)}")
                 else:
-                    arg_list.append(f'{str(a)}')
+                    arg_list.append(f"{str(a)}")
 
         self.body.extend(*arg_list)
 
     def gate(self, sym, *args, params=None):
-
         if params:
-            return ArgGate(sym)(params=params, *args)
+            return ArgGate(sym)(*args, params=params)
         else:
             return Gate(sym)(*args)
 
     def measure(self, qreg, creg):
         return Measure(qreg, creg)
 
     def reset(self, *qargs):
         return Reset(*qargs)
 
     def barrier(self, *qargs):
         return Barrier(*qargs)
 
-    # qregs = ', '.join([str(a) for a in qargs])
-    # return f'barrier {qregs}'
-
     def cif(self, cond, expr, else_expr=None):
-
         return CIf(cond, expr, else_expr)
 
     def assign(self, left, right):
         return Assign(left, right)
 
     def func(self, name):
         return Func(name=name)
 
-    def __str__(self):
-
+    def __str__(self) -> str:
         if self.header:
             lines = [self.language]
 
             if not self.includes:
                 lines.append('include "qelib1.inc";')
             else:
                 lines.extend(self.includes)
 
-            lines.extend([f'\n{d}\n' for d in self.definitions])
+            lines.extend([f"\n{d}\n" for d in self.definitions])
 
             lines.extend([q.reg_str() for q in self.qregs])
             lines.extend([c.reg_str() for c in self.cregs])
         else:
             lines = []
 
         for line in self.body:
             line = str(line).strip()
-            if line and not line.startswith('//'):
-                if not line.endswith(';'):
-                    lines.append(f'{line};')
+            if line and not line.startswith("//"):
+                if not line.endswith(";"):
+                    lines.append(f"{line};")
                 else:
-                    lines.append(f'{line}')
+                    lines.append(f"{line}")
             else:
                 lines.append(line)
 
-        return '\n'.join(lines)
+        return "\n".join(lines)
 
     def save(self, file: str) -> str:
         """Writes qasm text to file."""
-
-        with open(file, 'w') as f:
+        with Path.open(file, "w") as f:
             f.write(str(self))
 
         return file
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qasm/vars.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qasm/vars.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,19 +6,18 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 
-from . import expr
+from pecos.circuits.qasm import expr
 
 
 class Var:
-
     def __eq__(self, other):
         return expr.Equiv(self, other)
 
     def __ne__(self, other):
         return expr.NE(self, other)
 
     def __ge__(self, other):
@@ -34,53 +33,50 @@
         return expr.LT(self, other)
 
     def __xor__(self, other):
         return expr.XOR(self, other)
 
 
 class Reg(Var):
-
-    def __init__(self, qasm, sym: str, size: int, var_type: str):
+    def __init__(self, qasm, sym: str, size: int, var_type: str) -> None:
         self.qasm = qasm
         self.sym = sym
         self.size = size
         self.var_type = var_type
 
-    def __str__(self):
-        return f'{self.sym}'
+    def __str__(self) -> str:
+        return f"{self.sym}"
 
     def reg_str(self):
-        return f'{self.var_type} {self.sym}[{self.size}];'
+        return f"{self.var_type} {self.sym}[{self.size}];"
 
     def __getitem__(self, idx):
         if idx > self.size - 1:
-            raise IndexError('list index out of range')
+            msg = "list index out of range"
+            raise IndexError(msg)
 
         return SubBit(self, idx)
 
 
 class SubBit(Var):
-
-    def __init__(self, var, idx: int):
+    def __init__(self, var, idx: int) -> None:
         self.var = var
         self.idx = idx
 
-    def __str__(self):
-        return f'{self.var.sym}[{self.idx}]'
+    def __str__(self) -> str:
+        return f"{self.var.sym}[{self.idx}]"
 
 
 class CReg(Reg):
-
-    def __init__(self, qasm, sym: str, size: int, declare=True):
-        super().__init__(qasm, sym, size, var_type='creg')
+    def __init__(self, qasm, sym: str, size: int, declare=True) -> None:
+        super().__init__(qasm, sym, size, var_type="creg")
 
         if declare:
             self.qasm.cregs.append(self)
 
 
 class QReg(Reg):
-
-    def __init__(self, qasm, sym: str, size: int, declare=True):
-        super().__init__(qasm, sym, size, var_type='qreg')
+    def __init__(self, qasm, sym: str, size: int, declare=True) -> None:
+        super().__init__(qasm, sym, size, var_type="qreg")
 
         if declare:
             self.qasm.qregs.append(self)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/qc2phir.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/qc2phir.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,17 +5,18 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-import pecos
-from copy import deepcopy
 import json
+from copy import deepcopy
+
+import pecos
 
 # TODO: Does this handle parallel gate ticks?
 
 qsym_conv = {
     "init |0>": "Init",
     "measure Z": "Measure",
     "SqrtX": "SX",
@@ -25,31 +26,28 @@
     "SqrtZ": "SZ",
     "SqrtZd": "SZdg",
     "SqrtZZ": "SZZ",
 }
 
 
 def conv_expr(expr):
-
     if "t" in expr:
-
         op = "="
 
         if expr["op"] == "=":
             # op = = -> "t = a"
-            assert "b" not in expr
+            assert "b" not in expr  # noqa: S101
             left = expr["t"]
             right = expr["a"]
         else:
             # op != = -> "t = a op b"
             left = expr["t"]
             right = {"op": expr["op"], "a": expr["a"], "b": expr["b"]}
 
     else:
-
         op = expr["op"]
         left = expr["a"]
         right = expr.get("b")
 
     if isinstance(left, dict):
         left = conv_expr(left)
 
@@ -63,28 +61,28 @@
     if isinstance(left, tuple):
         left = list(left)
 
     if isinstance(right, tuple):
         right = list(right)
 
     if op == "=":
-        new_expr["args"] = [right, ]
-        new_expr["returns"] = [left, ]
-    elif right:
+        new_expr["args"] = [right]
+        new_expr["returns"] = [left]
+    elif right is not None:
         new_expr["args"] = [left, right]
     else:
-        new_expr["args"] = [left, ]
+        new_expr["args"] = [left]
 
     return new_expr
 
 
 def to_phir_dict(qc: "pecos.QuantumCircuit") -> dict:
     """Creates a json str representation of the QuantumCircuit listing all the gates. It does not preserve ticks or
-    parallel gating of different gate types."""
-
+    parallel gating of different gate types.
+    """
     prog = {"format": "PHIR/JSON", "version": "0.1.0", "metadata": deepcopy(qc.metadata), "ops": []}
     prog["metadata"]["source_program_type"] = ["PECOS.QuantumCircuit", ["PECOS", str(pecos.__version__)]]
 
     data = {"max_qid": 0}
     if "qvars" in qc.metadata:
         qid2qsym = {k: list(v) for k, v in prog["metadata"]["qvars"].items()}
         del prog["metadata"]["qvars"]
@@ -97,15 +95,16 @@
 
         if qsym is None:
             if "qvar_spec" not in qc.metadata:
                 qsym = ["q", data["max_qid"]]
                 data["max_qid"] += 1
                 qid2qsym[qid] = qsym
             else:
-                raise Exception(f"Couldn't find qsym for qid = {qid}")
+                msg = f"Couldn't find qsym for qid = {qid}"
+                raise Exception(msg)
         return list(qsym)
 
     def find_qid2qsym(qubits):
         qs = []
         for loc in qubits:
             if isinstance(loc, (tuple, list)):
                 qtup = []
@@ -127,35 +126,33 @@
                 "block": "if",
                 "condition": current_cond,
                 "true_branch": ops_buffer,
             }
             ops.append(block)
 
     def handle_ops_buffer(current_op, ops, ops_buffer, cond, current_cond, force_flush=False):
-
         if (cond != current_cond or force_flush) and ops_buffer:
             flush_ops_buffer(ops, ops_buffer, current_cond)
             ops_buffer = []
             current_cond = cond
 
         if current_op:
             ops_buffer = ops_buffer_append(ops_buffer, current_op)
 
         return ops, ops_buffer, current_cond
 
     def ops_buffer_append(ops_buffer, current_op, compact_gates=True):
         # TODO: When you do that make sure gates don't overlap
 
         if ops_buffer and compact_gates:
-
             last_op = ops_buffer[-1]
-            if ((("qop" in last_op and "qop" in current_op and last_op["qop"] == current_op["qop"])
-                 or (last_op.get("data") == last_op.get("data") == "cvar_export"))
-                    and last_op.get("metadata") == current_op.get("metadata")):
-
+            if (
+                ("qop" in last_op and "qop" in current_op and last_op["qop"] == current_op["qop"])
+                or (last_op.get("data") == last_op.get("data") == "cvar_export")
+            ) and last_op.get("metadata") == current_op.get("metadata"):
                 if "args" in current_op:
                     # TODO: Check no overlap!
                     last_op["args"].extend(current_op["args"])
 
                 if "variables" in current_op:
                     last_op["variables"].extend(current_op["variables"])
 
@@ -167,103 +164,105 @@
         else:
             ops_buffer.append(current_op)
 
         return ops_buffer
 
     ops = prog["ops"]
 
-    for sym, size in qc.metadata.get('qvar_spec', {}).items():
-        ops.append({
-            "data": "qvar_define",
-            "data_type": "qubits",
-            "variable": sym,
-            "size": size,
-        })
-
-    for sym, size in qc.metadata.get('cvar_spec', {}).items():
-        ops.append({
-            "data": "cvar_define",
-            "data_type": "i32",
-            "variable": sym,
-            "size": size
-        })
+    for sym, size in qc.metadata.get("qvar_spec", {}).items():
+        ops.append(
+            {
+                "data": "qvar_define",
+                "data_type": "qubits",
+                "variable": sym,
+                "size": size,
+            },
+        )
+
+    for sym, size in qc.metadata.get("cvar_spec", {}).items():
+        ops.append(
+            {
+                "data": "cvar_define",
+                "data_type": "i32",
+                "variable": sym,
+                "size": size,
+            },
+        )
 
     ops_buffer = []
     current_cond = None
 
     for sym, qubits, meta in qc.items():
-
         op = {}
         metadata = deepcopy(meta) if meta else {}
 
         if sym == "cop":
             # TODO: HOW to identify mops...., need to tag at higher level
-            if metadata.get('cop_type') == 'CFunc':
+            if metadata.get("cop_type") == "CFunc":
                 op = {
-                         "cop": "ffcall",
-                         "function": metadata["func"],
-                         "args": metadata["args"],
+                    "cop": "ffcall",
+                    "function": metadata["func"],
+                    "args": metadata["args"],
                 }
 
                 if metadata["assign_vars"]:
                     op["returns"] = metadata["assign_vars"]
 
-            # {'cop_type': 'ExportCVar', 'export': 'g', 'duration': 0.0, 'cond': None}
             elif metadata.get("cop_type") == "ExportCVar":
                 del metadata["cop_type"]
                 if "duration" in metadata:
                     del metadata["duration"]
 
                 op = {
                     "data": "cvar_export",
                     "variables": [metadata["export"]],
                 }
                 del metadata["export"]
 
-            elif metadata.get('cop_type') in ['Idle', "idle"]:
+            elif metadata.get("cop_type") in ["Idle", "idle"]:
                 del metadata["cop_type"]
                 op = {
                     "mop": "Idle",
-                    "args": find_qid2qsym(qubits)
+                    "args": find_qid2qsym(qubits),
                 }
 
-            elif metadata.get('cop_type') in ['Transport', "transport"]:
+            elif metadata.get("cop_type") in ["Transport", "transport"]:
                 del metadata["cop_type"]
                 op = {
                     "mop": "Transport",
-                    "args": find_qid2qsym(qubits)
+                    "args": find_qid2qsym(qubits),
                 }
 
             elif "expr" in metadata:
-                op = conv_expr(metadata['expr'])
+                op = conv_expr(metadata["expr"])
                 del metadata["expr"]
 
             else:
                 print("!!!!!", qubits, metadata)
 
         else:  # qop
-
-            op.update({
-                "qop": qsym_conv[sym] if sym in qsym_conv else sym,
-                "args": find_qid2qsym(qubits),
-            })
+            op.update(
+                {
+                    "qop": qsym_conv.get(sym, sym),
+                    "args": find_qid2qsym(qubits),
+                },
+            )
 
             angles = None
             if "angle" in metadata:
-                angles = [metadata["angle"], ]
+                angles = [metadata["angle"]]
             elif "angles" in metadata:
                 angles = metadata["angles"]
 
             if angles:
                 op["angles"] = angles
 
             if sym.startswith("measure"):
-
                 # Getting return values:
-                if 'var' in metadata:
+                if "var" in metadata:
                     var = metadata["var"]
                     op["returns"] = [list(var)]
                     del metadata["var"]
                 elif "var_output" in metadata:
                     var_output = metadata["var_output"]
                     var_return = []
                     for q in qubits:
@@ -285,16 +284,15 @@
         if metadata:
             op["metadata"] = metadata
 
         ops, ops_buffer, current_cond = handle_ops_buffer(op, ops, ops_buffer, cond, current_cond)
 
     # Flush the buffer of any remaining operations
     if ops_buffer:
-        ops, ops_buffer, current_cond = handle_ops_buffer(None, ops, ops_buffer, None, current_cond,
-                                                          force_flush=True)
+        ops, ops_buffer, current_cond = handle_ops_buffer(None, ops, ops_buffer, None, current_cond, force_flush=True)
 
     num_qubits = len(qid2qsym)
     prog["metadata"]["num_qubits"] = num_qubits
 
     if "qvar_spec" not in qc.metadata:
         op = {
             "qop": "qvar_define",
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/circuits/quantum_circuit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/quantum_circuit.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,96 +7,97 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Contains the class ``QuantumCircuit``, which is used to represent quantum circuits.
-"""
+"""Contains the class ``QuantumCircuit``, which is used to represent quantum circuits."""
+
+from __future__ import annotations
+
 import json
-from collections import defaultdict, namedtuple
+from collections import defaultdict
 from collections.abc import MutableSequence
+from typing import Any, NamedTuple
 
-from . import qc2phir
-
-from .. import __version__
+from pecos import __version__
+from pecos.circuits import qc2phir
 
 
 class QuantumCircuit(MutableSequence):
     """A representation of a quantum circuit.
 
     Similar to [{gate_symbol: set of qudits, ...}, ...] where each element is a time step in which gates act in
     parallel.
 
     """
 
-    def __init__(self, circuit_setup=None, **metadata):
-        """
-
-        Args:
+    def __init__(self, circuit_setup=None, **metadata) -> None:
+        """Args:
             circuit_setup (None, int, list of dict):
             **params: Quantum circuit parameters.
 
         Attributes:
-            self._ticks(list of dict): A list of parallel gates. Each element is a dictionary of gate symbol => gate set.
+            self._ticks(list of dict): A list of parallel gates. Each element is a dictionary of gate symbol => gate
+            set.
             This gate dictionary is assumed to be a collection of gates that act in parallel on the qudits.
             self.active_qudits(list): If `check_overlap` == True then ``active_qudits`` will be tracked; otherwise,
             ``active_qudits`` will not be tracked.
         """
         self._gates_class = ParamGateCollection
         self._ticks_class = list
         self._ticks = self._ticks_class()
         self.metadata = metadata
         self.qudits = set()
         # TODO: If all the gates on a qudit are discarded... then the qudit will not be removed from this set... fix
 
-        if 'tracked_qudits' in metadata:
-            raise Exception('error')
+        if "tracked_qudits" in metadata:
+            msg = "error"
+            raise Exception(msg)
 
         if circuit_setup is not None:
             self._circuit_setup(circuit_setup)
 
     @property
-    def active_qudits(self, flat=False):
-        """
-        Returns the active_qudits of all the ticks.
+    def active_qudits(self):
+        """Returns the active_qudits of all the ticks.
 
         Returns:
 
         """
-
+        """
         if flat:
             active = {}
             for gates in self._ticks:
                 active.update(gates.active_qudits)
 
         else:
-            active = []
-            for gates in self._ticks:
-                active.append(gates.active_qudits)
+        """
+
+        active = []
+        for gates in self._ticks:
+            active.append(gates.active_qudits)
         return active
 
     def append(self, symbol, locations=None, **params):
         """Adds a new gate=>gate_locations (set) pair to the end of ``self.gates``.
 
         Args:
             symbol(str or dict): A gate dictionary of gate symbol => set of qudit ids or tuples of qudit ids
             locations:
 
         Example:
             >>> quantum_circuit = QuantumCircuit()
-            >>> quantum_circuit.append({'X': {0, 1, 5, 6}, 'Z':{7, 8, 9}})
-            >>> quantum_circuit.append('X', {0, 1, 3, 7})
+            >>> quantum_circuit.append({"X": {0, 1, 5, 6}, "Z": {7, 8, 9}})
+            >>> quantum_circuit.append("X", {0, 1, 3, 7})
 
         This then creates a new time step at the end of ``self._ticks`` and adds the gate to it.
 
         """
-
         gates = self._gates_class(self, symbol, locations, **params)
 
         self._ticks.append(gates)
 
     def update(self, symbol, locations=None, tick=-1, emptyappend=False, **params):
         """Updates that last group of parallel gates to include the gate acting on the set of qudits.
 
@@ -104,15 +105,14 @@
             symbol(str or dict): A gate dictionary of gate symbol => set of qudit ids or tuples of qudit ids
             locations(set or None):
             tick(int): The time (tick) when the update should occur.
             emptyappend(bool): Whether it is allowed to add an empty tick if the QuantumCircuit is empty.
             **params:
 
         """
-
         if emptyappend and len(self) == 0:
             self.add_ticks(1)
 
         self._ticks[tick].add(symbol, locations, **params)
 
     def discard(self, locations, tick=-1):
         """Discards ``locations`` for tick ``tick``.
@@ -120,57 +120,49 @@
         Args:
             locations:
             tick:
 
         Returns:
 
         """
-
         self._ticks[tick].discard(locations)
 
-    def add_ticks(self, num_ticks):
-        """
-        Makes sure that QuantumCircuit has at least `num_tick` number of ticks. If the number of ticks in the data
+    def add_ticks(self, num_ticks) -> None:
+        """Makes sure that QuantumCircuit has at least `num_tick` number of ticks. If the number of ticks in the data
         structure is less than `num_tick` then empty ticks are appended until the total number of ticks == `num_ticks`.
 
         Args:
             num_ticks:
 
-        Returns:
-
+        Returns: Nothing
         """
-
         for _ in range(num_ticks):
             self.append({})
 
     def items(self, tick=None):
         """An iterator through all gates/qudits in the quantum circuit.
 
         If ``tick`` is not None then it will iterate over only the qudits/qudits in the corresponding tick.
 
         Args:
             tick:
 
         Returns:
 
         """
-
         if tick is None:
-
             for gates in self._ticks:
                 for symbol, locations, params in gates.items():
                     yield symbol, locations, params
 
         else:
-
             for symbol, locations, params in self._ticks[tick].items():
                 yield symbol, locations, params
 
     def iter_ticks(self):
-
         for tick in range(len(self)):
             gates = self[tick]
             yield gates, tick, self.metadata
             # TODO: note this is the circuit params
             # TODO: need something like: params {logical_circuit: ..., gate: ..., qecc: ...}
 
     def insert(self, tick, item):
@@ -184,74 +176,69 @@
 
         """
         gate_dict, params = item
         gates = self._gates_class(self, gate_dict, **params)
         self._ticks.insert(tick, gates)
 
     def _circuit_setup(self, circuit_setup):
-
         if isinstance(circuit_setup, int):
             # Reserve ticks
             self.add_ticks(circuit_setup)
 
         else:
             # Build circuit from other description (a shallow copy).
             for other_tick in circuit_setup:
                 self.append(other_tick)
 
     def to_json_str(self) -> str:
         """Creates a json str representation of the QuantumCircuit listing all the gates. It does not preserve ticks or
-        parallel gating of different gate types."""
-
+        parallel gating of different gate types.
+        """
         metadata = self.metadata
 
         gates = []
         for sym, qubits, meta in self.items():
             gate = {
-                'sym': sym,
-                'qubits': list(qubits),
-                'metadata': meta,
+                "sym": sym,
+                "qubits": list(qubits),
+                "metadata": meta,
             }
             gates.append(gate)
 
         prog = {
-            'prog_type': 'PECOS.QuantumCircuit',
-            'PECOS_version': str(__version__),
-            'prog_metadata': metadata,
-            'gates': gates,
+            "prog_type": "PECOS.QuantumCircuit",
+            "PECOS_version": str(__version__),
+            "prog_metadata": metadata,
+            "gates": gates,
         }
 
         return json.dumps(prog)
 
     @staticmethod
     def _fix_json_meta(meta):
         """Fix some of the type issues for converting json rep back to a QuantumCircuit."""
-        if 'var_output' in meta:
-            meta['var_output'] = {int(k): tuple(v) for k, v in meta['var_output'].items()}
+        if "var_output" in meta:
+            meta["var_output"] = {int(k): tuple(v) for k, v in meta["var_output"].items()}
         return meta
 
     @classmethod
-    def from_json_str(cls, qc_json) -> 'QuantumCircuit':
+    def from_json_str(cls, qc_json) -> QuantumCircuit:
         """Converts a json str that represents a QuantumCircuit back into a QuantumCircuit object."""
-
         qc_dict = json.loads(qc_json)
 
-        qc_meta = qc_dict['prog_metadata']
+        qc_meta = qc_dict["prog_metadata"]
         qc = QuantumCircuit(**qc_meta)
 
-        for gate_dict in qc_dict['gates']:
-            sym = gate_dict['sym']
+        for gate_dict in qc_dict["gates"]:
+            sym = gate_dict["sym"]
 
-            qubits = gate_dict['qubits']
-            if qubits and isinstance(qubits[0], int):
-                qubits = set(qubits)
-            else:
-                qubits = set(tuple(q) for q in qubits)
+            qubits = gate_dict["qubits"]
+            qubits = set(qubits) if qubits and isinstance(qubits[0], int) else {tuple(q) for q in qubits}
 
-            meta = gate_dict['metadata']
+            meta = gate_dict["metadata"]
             meta = cls._fix_json_meta(meta)
 
             qc.append(sym, qubits, **meta)
 
         return qc
 
     def to_phir_dict(self) -> dict:
@@ -267,159 +254,138 @@
 
         Args:
             tick(int): Tick index of ``self._ticks``.
 
         Returns:
 
         """
-
         return self._ticks[tick]
 
-    def __setitem__(self, tick, item):
-
+    def __setitem__(self, tick, item) -> None:
         gate_dict, params = item
         self._ticks[tick] = self._gates_class(self, gate_dict, **params)
 
-    def __len__(self):
+    def __len__(self) -> int:
         """Used to return number of ticks when len() is used on an instance of this class.
 
         Returns:
 
         """
-
         return len(self._ticks)
 
-    def __delitem__(self, tick):
-        """Used to delete a tick. For example: del instance[key]
+    def __delitem__(self, tick) -> None:
+        """Used to delete a tick. For example: del instance[key].
 
         Args:
             tick:
 
         Returns:
 
         """
         self._ticks[tick] = self._gates_class(self)
 
-    def __str__(self):
+    def __str__(self) -> str:
         """String returned when a string representation is requested. This occurs during printing.
 
         Returns:
 
         """
         str_list = []
         for gates in self._ticks:
-            # str_list.append(dict(tick.symbols))
             tick_list = []
             for symbol, locations, params in gates.items():
                 if len(params) == 0:
-                    tick_list.append("'%s': %s" % (symbol, locations))
+                    tick_list.append(f"'{symbol}': {locations}")
                 else:
-                    tick_list.append("'%s': loc: %s - params=%s" % (symbol, locations, params))
-            tick_list = ', '.join(tick_list)
-            str_list.append('{%s}' % tick_list)
+                    tick_list.append(f"'{symbol}': loc: {locations} - params={params}")
+            tick_list = ", ".join(tick_list)
+            str_list.append("{%s}" % tick_list)
 
         if self.metadata:
-            return "QuantumCircuit(params=%s, ticks=[%s])" % (str(self.metadata), ', '.join(str_list))
+            return "QuantumCircuit(params={}, ticks=[{}])".format(str(self.metadata), ", ".join(str_list))
         else:
-            return "QuantumCircuit([%s])" % ', '.join(str_list)
-
-    def __repr__(self):
-        """
-
-        Returns:
-
-        """
+            return "QuantumCircuit([%s])" % ", ".join(str_list)
 
+    def __repr__(self) -> str:
+        """Returns:"""
         return self.__str__()
 
     def __copy__(self):
         """Create a shallow copy."""
-
         newone = QuantumCircuit()
         newone.metadata = dict(self.metadata)
-        newone._ticks = self._ticks_class(self._ticks)
+        newone._ticks = self._ticks_class(self._ticks)  # noqa: SLF001
 
         return newone
 
     def copy(self):
-        """
-        Create a shallow copy of the circuit.
+        """Create a shallow copy of the circuit.
 
         Returns:
 
         """
         return self.__copy__()
 
     def __iter__(self):
         return self.items()
 
 
 class ParamGateCollection:
-    """
-    Data structure for a tick.
-    """
+    """Data structure for a tick."""
 
-    Gate = namedtuple('Gate', 'symbol, params, locations')
+    class Gate(NamedTuple):
+        symbol: str
+        params: Any
+        locations: set[int | tuple[int]]
 
-    def __init__(self, circuit, symbol=None, locations=None, **params):
+    def __init__(self, circuit, symbol=None, locations=None, **params) -> None:
         self.circuit = circuit
         self.metadata = circuit.metadata
-        self.active_qudits = set([])
+        self.active_qudits = set()
         self.symbols = defaultdict(list)
 
         self.add(symbol, locations, **params)
 
     def add(self, symbol, locations=None, **params):
-        """
-
-        Args:
+        """Args:
             symbol:
             locations:
 
         Returns:
 
         """
-
         # If locations is None then assume symbol is a gate_dict.
-        if locations is None:
-            gate_dict = symbol
-        else:
-            gate_dict = {symbol: locations}
+        gate_dict = symbol if locations is None else {symbol: locations}
 
         self._verify_qudits(gate_dict)
 
         for gate_symbol, gate_locations in gate_dict.items():
-
             # if gate_locations:  #TODO: Why was this here?
 
             for gate in self.symbols[gate_symbol]:
                 if params == gate.params:
                     gate.locations.update(gate_locations)
                     break
             else:
                 self.symbols[gate_symbol].append(self.Gate(gate_symbol, params, gate_locations))
 
         return self
 
     def discard(self, locations):
-        """
-        Remove gate locations.
+        """Remove gate locations.
 
         Args:
             locations:
 
         Returns:
 
         """
-        for _, gate_list in self.symbols.items():
-
+        for gate_list in self.symbols.values():
             for gate in gate_list:
-
                 for location in locations:
-
                     if location in gate.locations:
                         gate.locations.discard(location)
                         break
 
         # symbols: dict-> symbol: list[gate]
 
         # Remove keys with empty locations
@@ -450,52 +416,43 @@
         Args:
             gate_dict:
         Raises:
             Exception: If qudit ids are not int or if non-parallel gates are found (i.e., a qudit ha already been acted
             on by a gate.
 
         """
-
-        for _, qudit_locations in gate_dict.items():
-
+        for qudit_locations in gate_dict.values():
             for location in qudit_locations:
-
                 # Make sure we can iterate over q.
-                if not isinstance(location, tuple):
-                    q_iter = (location,)
-                else:
-                    q_iter = location
+                q_iter = (location,) if not isinstance(location, tuple) else location
 
                 for qi in q_iter:
-
                     self.circuit.qudits.add(qi)
 
                     if qi in self.active_qudits:
-                        raise Exception('Qudit %s has already been acted on by a gate!' % str(qi))
+                        raise Exception("Qudit %s has already been acted on by a gate!" % str(qi))
                     else:
                         self.active_qudits.add(qi)
 
     def items(self, tick=None):
-        """
-        Generator to return a dictionary-like iter.
+        """Generator to return a dictionary-like iter.
+
         Returns:
 
         """
-
         for gate_symbol, gate_list in self.symbols.items():
             for gate in gate_list:
                 yield gate_symbol, gate.locations, gate.params
 
-    def __str__(self):
-
+    def __str__(self) -> str:
         tick_list = []
         for symbol, locations, params in self.items():
             if len(params) == 0:
-                tick_list.append("'%s': %s" % (symbol, locations))
+                tick_list.append(f"'{symbol}': {locations}")
             else:
-                tick_list.append("'%s': loc: %s - params=%s" % (symbol, locations, params))
-        tick_list = ', '.join(tick_list)
+                tick_list.append(f"'{symbol}': loc: {locations} - params={params}")
+        tick_list = ", ".join(tick_list)
 
         return "Tick({%s})" % tick_list
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return self.__str__()
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/classical_interpreters/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuquantum_wrapper/test/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,12 @@
-# Copyright 2023 The PECOS Developers
+# Copyright 2022 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
-# specific language governing permissions and limitations under the License.
+# specific language governing permissions and limitations under the License.
+
+# Initial author: Tyson Lawrence
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/classical_interpreters/classical_interpreter_abc.py` & `quantum_pecos-0.6.0.dev1/python/pecos/classical_interpreters/classical_interpreter_abc.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,46 +5,44 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 import abc
-from typing import Any, Generator, Optional, Sequence
+from typing import TYPE_CHECKING, Any
 
+if TYPE_CHECKING:
+    from collections.abc import Generator, Sequence
 
-class ClassicalInterpreter(metaclass=abc.ABCMeta):
 
+class ClassicalInterpreter(metaclass=abc.ABCMeta):
     def __init__(self) -> None:
         self.program = None
         self.foreign_obj = None
 
     @abc.abstractmethod
     def reset(self) -> None:
         """Reset state to initialization state."""
-        pass
 
     @abc.abstractmethod
-    def init(self, program: Any, foreign_classical_obj: Optional[object] = None) -> int:
-        pass
-
-    @abc.abstractmethod
-    def optimize(self, machine=None, error_model=None, qsim=None) -> None:
+    def init(self, program: Any, foreign_classical_obj: object | None = None) -> int:
         pass
 
     @abc.abstractmethod
     def shot_reinit(self) -> None:
         pass
 
     @abc.abstractmethod
-    def execute(self, sequence: Optional[Sequence]) -> Generator:
+    def execute(self, sequence: Sequence | None) -> Generator:
         pass
 
     @abc.abstractmethod
-    def recieve_results(self, qsim_results):
+    def receive_results(self, qsim_results):
         pass
 
     @abc.abstractmethod
     def results(self) -> dict:
-        """Dumps program final results"""
-        pass
+        """Dumps program final results."""
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/classical_interpreters/phir_classical_interpreter.py` & `quantum_pecos-0.6.0.dev1/python/pecos/classical_interpreters/phir_classical_interpreter.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,286 +5,356 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 import json
-from typing import Any, Generator, List, Optional, Sequence, Union
+import warnings
+from typing import TYPE_CHECKING, Any
 
 import numpy as np
+from phir.model import PHIRModel
 
-from pecos import QuantumCircuit
+from pecos.classical_interpreters.classical_interpreter_abc import ClassicalInterpreter
 from pecos.reps.pypmir import PyPMIR
 from pecos.reps.pypmir import types as pt
-from .classical_interpreter_abc import ClassicalInterpreter
-from ..foreign_objects.foreign_object_abc import ForeignObject
+
+if TYPE_CHECKING:
+    from collections.abc import Generator, Iterable, Sequence
+
+    from pecos import QuantumCircuit
+    from pecos.foreign_objects.foreign_object_abc import ForeignObject
 
 
 def version2tuple(v):
-    """Get version tuple from string"""
+    """Get version tuple from string."""
     return tuple(map(int, (v.split("."))))
 
 
 data_type_map = {
+    "i8": np.int8,
+    "i16": np.int16,
     "i32": np.int32,
     "i64": np.int64,
+    "u8": np.uint8,
+    "u16": np.uint16,
     "u32": np.uint32,
     "u64": np.uint64,
 }
 
+data_type_map_rev = {v: k for k, v in data_type_map.items()}
+
 
 class PHIRClassicalInterpreter(ClassicalInterpreter):
     """An interpreter that takes in a PHIR program and runs the classical side of the program."""
-    def __init__(self):
+
+    def __init__(self) -> None:
         super().__init__()
 
         self.program = None
         self.foreign_obj = None
         self.cenv = None
         self.cid2dtype = None
+        self.csym2id = None
+        self.cvar_meta = None
+
+        self.phir_validate = True
 
         self.reset()
 
+    def _reset_env(self):
+        self.cenv = []
+        self.cid2dtype = []
+
     def reset(self):
         """Reset the state to that at initialization."""
         self.program = None
         self.foreign_obj = None
-        self.cenv = []
-        self.cid2dtype = []
+        self._reset_env()
 
-    def init(self,
-             program: Union[str, dict, QuantumCircuit],
-             foreign_obj: Optional["ForeignObject"] = None) -> int:
-        """Initialize the interpreter to validate the format of the program, optimize the program representation, etc.
+    def init(self, program: str | (dict | QuantumCircuit), foreign_obj: ForeignObject | None = None) -> int:
+        """Initialize the interpreter to validate the format of the program, optimize the program representation,
+        etc.
         """
         self.program = program
         self.foreign_obj = foreign_obj
 
         # Make sure we have `program` in the correct format or convert to PHIR/dict.
         if isinstance(program, str):  # Assume it is in the PHIR/JSON format and convert to dict
-            self.program = json.loads(self.program)
-        elif isinstance(self.program, PyPMIR):
-            pass
-        elif isinstance(self.program, dict):
+            self.program = json.loads(program)
+        elif isinstance(self.program, (PyPMIR, dict)):
             pass
         else:
             self.program = self.program.to_phir_dict()
 
+        # Assume PHIR dict format, validate PHIR
+        if isinstance(self.program, dict) and self.phir_validate:
+            PHIRModel.model_validate(self.program)
+
         if isinstance(self.program, dict):
-            assert self.program["format"] in ["PHIR/JSON", "PHIR"]
-            assert version2tuple(self.program["version"]) < (0, 2, 0)
+            assert self.program["format"] in ["PHIR/JSON", "PHIR"]  # noqa: S101
+            assert version2tuple(self.program["version"]) < (0, 2, 0)  # noqa: S101
 
         # convert to a format that will, hopefully, run faster in simulation
         if not isinstance(self.program, PyPMIR):
             self.program = PyPMIR.from_phir(self.program)
 
+        self.check_ffc(self.program.foreign_func_calls, self.foreign_obj)
+
+        self.csym2id = dict(self.program.csym2id)
+        self.cvar_meta = list(self.program.cvar_meta)
+
+        self.initialize_cenv()
+
         return self.program.num_qubits
 
+    def check_ffc(self, call_list: list[str], fobj: ForeignObject):
+        if self.program.foreign_func_calls:
+            func_names = set(fobj.get_funcs())
+            not_supported = set(call_list) - func_names
+            if not_supported:
+                msg = (
+                    f"The following foreign function calls are listed in the program but not supported by the "
+                    f"supplied foreign object: {not_supported}"
+                )
+                raise Exception(msg)
+        elif not self.program.foreign_func_calls and self.foreign_obj:
+            msg = "No foreign function calls being made but foreign object is supplied."
+            raise warnings.warn(msg, stacklevel=2)
+
     def shot_reinit(self):
         """Run all code needed at the beginning of each shot, e.g., resetting state."""
-        self.cenv = []
-        self.cid2dtype = []
         self.initialize_cenv()
 
-    def optimize(self, machine=None, error_model=None, qsim=None):
-        """Engine provides an opportunity for the classical interpreter to optimize program after the other components
-        have initialized. This allows the interpreter to optimize utilizing knowledge and methods provided by other
-        simulation components."""
-        ...
-
     def initialize_cenv(self) -> None:
-        self.cenv = []
-        self.cid2dtype = []
-        for cvar in self.program.cvar_meta:
-            cvar: pt.data.CVarDefine
-            dtype = data_type_map[cvar.data_type]
+        self._reset_env()
+        if self.program:
+            for cvar in self.cvar_meta:
+                cvar: pt.data.CVarDefine
+                dtype = data_type_map[cvar.data_type]
+                self.cenv.append(dtype(0))
+                self.cid2dtype.append(dtype)
+
+    def add_cvar(self, cvar: str, dtype, size: int):
+        """Adds a new classical variable to the interpreter."""
+        if cvar not in self.csym2id:
+            cid = len(self.csym2id)
+            self.csym2id[cvar] = cid
             self.cenv.append(dtype(0))
             self.cid2dtype.append(dtype)
+            self.cvar_meta.append(
+                pt.data.CVarDefine(size=size, data_type=data_type_map_rev[dtype], cvar_id=cid, variable=cvar),
+            )
+
+    def _flatten_blocks(self, seq: Sequence):
+        """Flattens the ops of blocks to be processed by the execute() method."""
+        for op in seq:
+            if isinstance(op, pt.block.SeqBlock):
+                yield from self._flatten_blocks(op.ops)
+
+            elif isinstance(op, pt.block.IfBlock):
+                if self.eval_expr(op.condition):
+                    yield from self._flatten_blocks(op.true_branch)
+                elif op.false_branch:
+                    yield from self._flatten_blocks(op.false_branch)
+                else:  # For case of no false_branch (no else)
+                    pass
 
-    def execute(self, sequence: Sequence) -> Generator[list, Any, None]:
-        """A generator that runs through and executes classical logic and yields other operations via a buffer."""
+            else:
+                yield op
 
-        # TODO: Recursively move through the program
+    def execute(self, seq: Sequence) -> Generator[list, Any, None]:
+        """A generator that runs through and executes classical logic and yields other operations via a buffer."""
 
         op_buffer = []
 
-        for op in sequence:
-
+        for op in self._flatten_blocks(seq):
             if isinstance(op, pt.opt.QOp):
                 op_buffer.append(op)
 
                 if op.name == "Measure":
                     yield op_buffer
                     op_buffer.clear()
 
             elif isinstance(op, pt.opt.COp):
                 self.handle_cops(op)
 
-            elif (op, pt.block.IfBlock):
-                yield from self.execute_block(op)
-
             elif isinstance(op, pt.opt.MOp):
                 op_buffer.append(op)
 
+            elif op is None:
+                # TODO: Make it so None ops are not included
+                continue
+
             else:
-                print("!!!!!!!!!!!!!!", op)
+                msg = f"Statement not recognized: {op} of type: {type(op)}"
+                raise TypeError(msg)
+
+        if op_buffer:
+            yield op_buffer
 
     def get_cval(self, cvar):
-        cid = self.program.csym2id[cvar]
+        cid = self.csym2id[cvar]
         return self.cenv[cid]
 
     def get_bit(self, cvar, idx):
         val = self.get_cval(cvar) & (1 << idx)
         val >>= idx
         return val
 
-    def eval_expr(self, expr: Union[int, str, list, dict]) -> int:
+    def eval_expr(self, expr: int | str | list | pt.opt.COp) -> int | None:
+        """Evaluates integer expressions."""
+        match expr:
+            case int():
+                return expr
+
+            case str():
+                return self.get_cval(expr)
+            case list():
+                return self.get_bit(*expr)
+            case pt.opt.COp():
+                sym = expr.name
+                args = expr.args
+
+                if sym in {"~"}:  # Unary ops
+                    lhs = args[0]
+                    rhs = None
+                else:
+                    lhs, rhs = args
+                    rhs = self.eval_expr(rhs)
 
-        if isinstance(expr, int):
-            return expr
-        elif isinstance(expr, str):
-            return self.get_cval(expr)
-        elif isinstance(expr, list):
-            return self.get_bit(*expr)
-        elif isinstance(expr, dict):
-            # TODO: Expressions need to be converted to nested COps!
-            sym = expr["cop"]
-            args = expr["args"]
-
-            rhs = None
-            try:
-                lhs, rhs = args
-                rhs = self.eval_expr(rhs)
-            except ValueError:
-                lhs = args[0]
-            lhs = self.eval_expr(lhs)
-            dtype = type(lhs)
-
-            if sym == "^":
-                return dtype(lhs ^ rhs)
-            elif sym == "+":
-                return dtype(lhs + rhs)
-            elif sym == "-":
-                return dtype(lhs - rhs)
-            elif sym == '|':
-                return dtype(lhs | rhs)
-            elif sym == '&':
-                return dtype(lhs & rhs)
-            elif sym == '>>':
-                return dtype(lhs >> rhs)
-            elif sym == '<<':
-                return dtype(lhs << rhs)
-            elif sym == '*':
-                return dtype(lhs * rhs)
-            elif sym == '/':
-                dtype(lhs // rhs)
-            elif sym == '==':
-                return dtype(lhs == rhs)
-            elif sym == '!=':
-                return dtype(lhs != rhs)
-            elif sym == '<=':
-                return dtype(lhs <= rhs)
-            elif sym == '>=':
-                return dtype(lhs >= rhs)
-            elif sym == '<':
-                return dtype(lhs < rhs)
-            elif sym == '>':
-                return dtype(lhs > rhs)
-            elif sym == '%':
-                return dtype(lhs % rhs)
-            elif sym == '~':
-                return dtype(~lhs)
-            else:
-                raise ValueError(f"Unknown expression type: {sym}")
+                lhs = self.eval_expr(lhs)
+                dtype = type(lhs)
+
+                if sym == "^":
+                    return dtype(lhs ^ rhs)
+                elif sym == "+":
+                    return dtype(lhs + rhs)
+                elif sym == "-":
+                    return dtype(lhs - rhs)
+                elif sym == "|":
+                    return dtype(lhs | rhs)
+                elif sym == "&":
+                    return dtype(lhs & rhs)
+                elif sym == ">>":
+                    return dtype(lhs >> rhs)
+                elif sym == "<<":
+                    return dtype(lhs << rhs)
+                elif sym == "*":
+                    return dtype(lhs * rhs)
+                elif sym == "/":
+                    return dtype(lhs // rhs)
+                elif sym == "==":
+                    return dtype(lhs == rhs)
+                elif sym == "!=":
+                    return dtype(lhs != rhs)
+                elif sym == "<=":
+                    return dtype(lhs <= rhs)
+                elif sym == ">=":
+                    return dtype(lhs >= rhs)
+                elif sym == "<":
+                    return dtype(lhs < rhs)
+                elif sym == ">":
+                    return dtype(lhs > rhs)
+                elif sym == "%":
+                    return dtype(lhs % rhs)
+                elif sym == "~":
+                    return dtype(~lhs)
+                else:
+                    msg = f"Unknown expression type: {sym}"
+                    raise ValueError(msg)
+            case _:
+                return None
 
     def assign_int(self, cvar, val: int):
         i = None
         if isinstance(cvar, (tuple, list)):
             cvar, i = cvar
 
-        cid = self.program.csym2id[cvar]
+        cid = self.csym2id[cvar]
         dtype = self.cid2dtype[cid]
-        size = self.program.cvar_meta[cid].size
+        size = self.cvar_meta[cid].size
 
         cval = self.cenv[cid]
         val = dtype(val)
         if i is None:
             cval = val
         else:
             cval &= ~(1 << i)
             cval |= (val & 1) << i
 
         # mask off bits give the size of the register
         cval &= (1 << size) - 1
         self.cenv[cid] = cval
 
     def handle_cops(self, op):
+        """Handle the processing of classical operations."""
+
         if op.name == "=":
-            arg, = op.args
-            rtn, = op.returns
-            val = self.eval_expr(arg)
-            self.assign_int(rtn, val)
+            args = []
+            for a in op.args:
+                args.append(self.eval_expr(a))
+
+            for r, a in zip(op.returns, args):
+                self.assign_int(r, a)
 
         elif isinstance(op, pt.opt.FFCall):
             args = []
             for a in op.args:
-                if isinstance(a, str):
-                    val = self.get_cval(a)
-                else:
-                    val = self.get_bit(*a)
+                val = self.get_cval(a) if isinstance(a, str) else self.get_bit(*a)
 
                 args.append(int(val))
 
-            if "namespace" in op.metadata:
+            if op.metadata and "namespace" in op.metadata:
                 results = self.foreign_obj.exec(op.name, args, op.metadata["namespace"])
+            elif self.foreign_obj is None:
+                msg = f"Trying to call foreign function `{op.name}` but no foreign object supplied!"
+                raise Exception(msg)
             else:
                 results = self.foreign_obj.exec(op.name, args)
 
-            if isinstance(results, int):
-                cvar, = op.returns
-                self.assign_int(cvar, results)
-            else:
-                for cvar, val in zip(op.returns, results):
-                    self.assign_int(cvar, val)
-
-        else:
-            raise Exception(f"Unsupported COp: {op}")
-
-    def execute_block(self, op):
-        """Execute a block of ops."""
-
-        if isinstance(op, pt.block.IfBlock):
-            if self.eval_expr(op.condition):
-                yield from self.execute(op.true_branch)
-
-            elif op.false_branch:
-                yield from self.execute(op.false_branch)
-
-            else:
-                yield from self.execute([])
-
-        elif isinstance(op, pt.block.SeqBlock):
-            yield from self.execute(op.ops)
+            if op.returns is not None:
+                if isinstance(results, int):
+                    (cvar,) = op.returns
+                    self.assign_int(cvar, results)
+                else:
+                    for cvar, val in zip(op.returns, results):
+                        self.assign_int(cvar, val)
 
         else:
-            raise NotImplementedError(f"block not implemented! {op}")
+            msg = f"Unsupported COp: {op}"
+            raise Exception(msg)
 
-    def recieve_results(self, qsim_results: List[dict]):
+    def receive_results(self, qsim_results: list[dict]):
         """Receive measurement results and assign as needed."""
         for meas in qsim_results:
             for cvar, val in meas.items():
                 self.assign_int(cvar, val)
 
     def results(self, return_int=True) -> dict:
-        """Dumps program final results"""
-
+        """Dumps program final results."""
         result = {}
-        for csym, cid in self.program.csym2id.items():
+        for csym, cid in self.csym2id.items():
             cval = self.cenv[cid]
             if not return_int:
-                size = self.program.cvar_meta[cid].size
+                size = self.cvar_meta[cid].size
                 cval = "{:0{width}b}".format(cval, width=size)
             result[csym] = cval
 
         return result
+
+    def result_bits(self, bits: Iterable[tuple[str, int]], *, filter_private=True) -> dict[tuple[str, int], int]:
+        """Git a dictionary of bit values given an iterable of bits (which are encoded as tuple[str, int]
+        for str[int])."""
+        send_meas = {}
+        for b in bits:
+            for m, i in b:
+                m: str
+                i: int
+                if filter_private and m.startswith("__"):
+                    continue
+                send_meas[(m, i)] = self.get_bit(m, i)
+        return send_meas
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/decoders/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -6,9 +6,9 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .dummy_decoder.dummy_decoder import DummyDecoder
-from .mwpm2d.mwpm2d import MWPM2D
+from pecos.simulators.projectq import bindings
+from pecos.simulators.projectq.state import ProjectQSim
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/decoders/dummy_decoder/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/decoders/dummy_decoder/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/decoders/dummy_decoder/dummy_decoder.py` & `quantum_pecos-0.6.0.dev1/python/pecos/decoders/dummy_decoder/dummy_decoder.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,42 +1,33 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-A dummy decoder that gives no recovery (outputs do nothing) given any input.
-"""
+"""A dummy decoder that gives no recovery (outputs do nothing) given any input."""
 
 
-class DummyDecoder(object):
-    """
-    This decoder is just a simple look up decoder.
-    """
+class DummyDecoder:
+    """This decoder is just a simple look up decoder."""
 
-    def __init__(self):
+    def __init__(self) -> None:
         pass
 
     @staticmethod
     def decode(*args, **kwargs):
-        """
-
-        Args:
+        """Args:
+        ----
             *args:
             **kwargs:
 
         Returns:
+        -------
 
         """
-
-        recovery = []
-
-        return recovery
+        return []
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/decoders/mwpm2d/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/decoders/mwpm2d/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/decoders/mwpm2d/mwpm2d.py` & `quantum_pecos-0.6.0.dev1/python/pecos/decoders/mwpm2d/mwpm2d.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,156 +1,141 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 import networkx as nx
-from ...circuits import QuantumCircuit
-from . import precomputing
 
+from pecos.circuits import QuantumCircuit
+from pecos.decoders.mwpm2d import precomputing
 
-class MWPM2D(object):
-    """
-    2D minimum weight perfect matching for surface capacity assuming code capacity. (Only data error.)
+
+class MWPM2D:
+    """2D minimum weight perfect matching for surface capacity assuming code capacity. (Only data error.).
 
     A simple Minimum Weight Perfect Matching decoder. It is for 2D decoding either for code capacity modeling or ideal
     decoding.
 
     For code capacity, data errors are sprinkled before each logical gate. Then the decoder takes in syndrome
     measurements to come up with a recovery operation.
 
     """
 
     # Basic subpackage required attributes
     output = None
     input = None
 
-    def __init__(self, qecc):
-
-        instr = qecc.instruction('instr_syn_extract')
+    def __init__(self, qecc) -> None:
+        instr = qecc.instruction("instr_syn_extract")
 
         self.instr = instr
 
         self.recorded_recovery = {}  # previous: syndrome => recovery
 
         precomputed_data = precomputing.precompute(instr)
 
         self.precomputed_data = precomputed_data
 
     def decode(self, measurements, error_params=None):
-        """
-        Takes measurement results and outputs a result.
+        """Takes measurement results and outputs a result.
 
         logic_range identifies over what part of self.logic we are decoding over.
         """
-
-        syndromes = measurements.simplified(True)
+        syndromes = set(measurements.simplified(True))
 
         tuple_key = frozenset(syndromes)
 
         if tuple_key in self.recorded_recovery:
-
             return self.recorded_recovery[tuple_key]
 
         else:
-
             recovery = QuantumCircuit(1)
 
             decode_data = self.precomputed_data
 
             correction_x = []
             correction_z = []
 
             # Decode 'X' and Z separately.
-            for check_type in ['X', 'Z']:
-
-                if check_type == 'X':
-                    correction = correction_z
-                else:
-                    correction = correction_x
+            for check_type in ["X", "Z"]:
+                correction = correction_z if check_type == "X" else correction_x
 
                 check_type_decode = decode_data[check_type]
 
-                distance_graph = check_type_decode['dist_graph']
-                # closest = check_type_decode['closest_virt']
-                virtual_edge_data = check_type_decode['virtual_edge_data']
+                distance_graph = check_type_decode["dist_graph"]
+                virtual_edge_data = check_type_decode["virtual_edge_data"]
 
                 active_syn = set(syndromes)
                 # Get the real graph
                 real_graph = nx.Graph(distance_graph.subgraph(active_syn))
                 active_syn = set(real_graph.nodes())
 
                 # Add virtual nodes
                 new_name = self.itr_v_name()
-                # print 'act', active_syn
-                active_virt = set([])
+                active_virt = set()
                 for s in active_syn:
                     edge_data = virtual_edge_data[s]
                     v_name = next(new_name)
                     active_virt.add(v_name)
                     real_graph.add_edge(s, v_name, **edge_data)
-                    # print 'closest:: s:%s - v:%s, data path %s' % (s, v, edge_data['data_path'])
 
                 # Add edges between virtual nodes to allow pairing of un-needed virtual nodes
                 for vi in active_virt:
                     for vj in active_virt:
                         if vi != vj:
                             real_graph.add_edge(vi, vj, weight=0)
 
                 # Find a matching
                 matching_edges = nx.max_weight_matching(real_graph, maxcardinality=True)
                 matching = {n1: n2 for n2, n1 in matching_edges}
-                matching.update({n2: n1 for n2, n1 in matching_edges})
+                matching.update(dict(matching_edges))
 
-                nodes_paired = set([])
+                nodes_paired = set()
                 ## for n1 in real_graph.nodes():
                 real_syn = set(real_graph.nodes())
                 for n1 in syndromes & real_syn:
-
                     n2 = matching[n1]
 
                     # Don't continue if node has already been covered or path starts and ends with virtuals.
-                    if n1 in nodes_paired or (str(n1).startswith('v') and str(n2).startswith('v')):
+                    if n1 in nodes_paired or (str(n1).startswith("v") and str(n2).startswith("v")):
                         continue
 
                     nodes_paired.add(n2)
 
                     path_attr = real_graph.get_edge_data(n1, n2)
-                    correction.extend(path_attr['data_path'])
+                    correction.extend(path_attr["data_path"])
 
             correction_x = set(correction_x)
             correction_z = set(correction_z)
 
             correction_y = correction_x & correction_z
             correction_x -= correction_y
             correction_z -= correction_y
 
             if correction_z:
-                recovery.update({'Z': correction_z})
+                recovery.update({"Z": correction_z})
 
             if correction_x:
-                recovery.update({'X': correction_x})
+                recovery.update({"X": correction_x})
 
             if correction_y:
-                recovery.update({'Y': correction_y})
+                recovery.update({"Y": correction_y})
 
             self.recorded_recovery[tuple_key] = recovery
 
             return recovery
 
     @staticmethod
     def itr_v_name():
         i = 0
 
         while True:
             i += 1
-            yield 'vu' + str(i)
+            yield "vu" + str(i)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/decoders/mwpm2d/precomputing.py` & `quantum_pecos-0.6.0.dev1/python/pecos/decoders/mwpm2d/precomputing.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,592 +7,523 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-These functions build distance graphs for logical gates of qeccs.
-"""
+"""These functions build distance graphs for logical gates of qeccs."""
 
 import networkx as nx
 
 
 def precompute(instr):
-    """
-
-    Args:
+    """Args:
+    ----
         instr:
 
     Returns:
+    -------
 
     """
-
     qecc = instr.qecc
 
-    if qecc.name == '4.4.4.4 Surface Code' and qecc.circuit_compiler.name == 'Check2Circuits':
+    if qecc.name == "4.4.4.4 Surface Code" and qecc.circuit_compiler.name == "Check2Circuits":
         precomputed_data = code_surface4444(instr)
 
-    elif qecc.name == 'Medial 4.4.4.4 Surface Code' and qecc.circuit_compiler.name == 'Check2Circuits':
+    elif qecc.name == "Medial 4.4.4.4 Surface Code" and qecc.circuit_compiler.name == "Check2Circuits":
         precomputed_data = code_surface4444medial(instr)
 
     else:
-        raise Exception('Can only handle the non-medial surface code!')
+        msg = "Can only handle the non-medial surface code!"
+        raise Exception(msg)
 
     return precomputed_data
 
 
 def code_surface4444(instr):
-    """
-    Pre-computing for surface4444 class.
+    """Pre-computing for surface4444 class.
 
     This decoder is for 2D slices. It is assumed that it can decode logical instruction by logical instruction.
 
     :param logical_gate:
     :param precomputed_data: A dictionary of precomputed data used to decode syndromes of logical instructions.
     :return:
     """
-
-    if instr.symbol == 'instr_syn_extract':
-
+    if instr.symbol == "instr_syn_extract":
         # In the future go through different instructions
         decoder_data = surface4444_identity(instr)
 
     else:
-        raise Exception('Can currently only handle "instr_init_zero".')
+        msg = 'Can currently only handle "instr_init_zero".'
+        raise Exception(msg)
 
     return decoder_data
 
 
 def code_surface4444medial(instr):
-    """
-    Pre-computing for surface4444 class.
+    """Pre-computing for surface4444 class.
 
     This decoder is for 2D slices. It is assumed that it can decode logical instruction by logical instruction.
 
     :param logical_gate:
     :param precomputed_data: A dictionary of precomputed data used to decode syndromes of logical instructions.
     :return:
     """
-
-    if instr.symbol == 'instr_syn_extract':
-
+    if instr.symbol == "instr_syn_extract":
         # In the future go through different instructions
         decoder_data = surface4444medial_identity(instr)
 
     else:
-        raise Exception('Can currently only handle "instr_init_zero".')
+        msg = 'Can currently only handle "instr_init_zero".'
+        raise Exception(msg)
 
     return decoder_data
 
 
 def surface4444_identity(instr):
-    """
-    For X and Z decoding separately:
+    """For X and Z decoding separately:
 
     - Create dictionary:
 
     - Determine how virtual nodes connect to data qubits.
     - find syndromes(and virtual) edges -> data
     - Generate distance graph
     - Determine syn -> closest v and weight
 
     :param instr:
     :return:
     """
-
     # In the end... need:
     # For x and z separately:
     #
     # syn -> closest virtual node
     # edge -> data
     # distance graph
 
     qecc = instr.qecc
 
     virtual_edge_data_x = {}
     virtual_edge_data_z = {}
 
     # Create a dictionary to store precomputed information that will be used for decoding
     info = {
-        'X': {
-            'dist_graph': nx.Graph(),
-            'closest_virt': {},
-            'virtual_edge_data': virtual_edge_data_x,
+        "X": {
+            "dist_graph": nx.Graph(),
+            "closest_virt": {},
+            "virtual_edge_data": virtual_edge_data_x,
         },
-        'Z': {
-            'dist_graph': nx.Graph(),
-            'closest_virt': {},
-            'virtual_edge_data': virtual_edge_data_z,
+        "Z": {
+            "dist_graph": nx.Graph(),
+            "closest_virt": {},
+            "virtual_edge_data": virtual_edge_data_z,
         },
     }
 
     # Record what data qudits the syndrome to syndrome edges correspond to.
-    # (syn, syn/virt): data
     edges_x = {}
     edges_z = {}
 
     # syndrome-to-syndrome, fully-connected graph
-    # (syn, syn): weight
-    graph_x = info['X']['dist_graph']
-    graph_z = info['Z']['dist_graph']
+    graph_x = info["X"]["dist_graph"]
+    graph_z = info["Z"]["dist_graph"]
 
     # The closest virtual node to each syndrome
-    # syn: virt
-    closest_x = info['X']['closest_virt']
-    closest_z = info['Z']['closest_virt']
+    closest_x = info["X"]["closest_virt"]
+    closest_z = info["Z"]["closest_virt"]
 
     # The sides of the QECC patch
     sides = qecc.sides  # t, r, b, l
 
     # checks of the logical instruction
-    instr = qecc.instruction('instr_syn_extract')
+    instr = qecc.instruction("instr_syn_extract")
     abs_circ = instr.abstract_circuit
 
     # Dictionary of data qudit to syndrome-to-syndrome edge
     d2edge_x = {}
     d2edge_z = {}
 
     # Temporary graphs that will store the direct syndrome-to-syndrome edges. This will be used to create the fully
     # connected, distance graph.
     temp_graph_x = nx.Graph()
     temp_graph_z = nx.Graph()
 
     # Assume the QECC uses checks
     # add edges based on checks
     for gate_symbol, _, params in abs_circ.items():
-
-        ancilla = params['ancillas']
-        data_qubits = params['datas']
+        ancilla = params["ancillas"]
+        data_qubits = params["datas"]
 
         for data in data_qubits:
-
-            if gate_symbol == 'X check':
+            if gate_symbol == "X check":
                 edges = d2edge_x
-            elif gate_symbol == 'Z check':
+            elif gate_symbol == "Z check":
                 edges = d2edge_z
             else:
-                raise Exception('This decoder can only handle check of purely X or Z type rather than %s!'
-                                % gate_symbol)
+                raise Exception(
+                    "This decoder can only handle check of purely X or Z type rather than %s!" % gate_symbol,
+                )
 
             syn_list = edges.setdefault(data, [])
             syn_list.append(ancilla)
 
     # ---- Create virtual nodes ----- #
 
-    virt_x = set([])
-    virt_z = set([])
+    virt_x = set()
+    virt_z = set()
 
     # side: top, right, bottom, left
     # For the non-medial surface code patch, a x virtual node is paired with data qubits on the right and left sides
     # and a z virtual node is paired with data qubits on the top and bottom sides (should say what Pauli type the side
     # is.
 
     vi = 0
 
     for side_label, side_qubits in sides.items():
-
         for data in side_qubits:
-
             vi += 1
 
-            virt_node = 'v' + str(vi)
+            virt_node = "v" + str(vi)
 
             # X virtual nodes (sides left and right)
-            if side_label in ['left', 'right']:  # 1 for i = 1 and 3 => left and right
-
+            if side_label in ["left", "right"]:  # 1 for i = 1 and 3 => left and right
                 syn_list = d2edge_x.setdefault(data, [])
                 syn_list.append(virt_node)
                 virt_x.add(virt_node)
 
             # Z virtual nodes (sides top and bottom)
-            elif side_label in ['top', 'bottom']:  # 0 for i = 0 and 2 => top and bottom
-
+            elif side_label in ["top", "bottom"]:  # 0 for i = 0 and 2 => top and bottom
                 syn_list = d2edge_z.setdefault(data, [])
                 syn_list.append(virt_node)
                 virt_z.add(virt_node)
             else:
                 raise Exception('side_label "%s" not understood!' % side_label)
 
     # invert data -> edge and make sure len(edge) = 2
-    for check_type in ['X', 'Z']:
-
-        if check_type == 'X':
+    for check_type in ["X", "Z"]:
+        if check_type == "X":
             edge_dict = d2edge_x
             edges = edges_x
             temp_graph = temp_graph_x
         else:
             edge_dict = d2edge_z
             edges = edges_z
             temp_graph = temp_graph_z
 
         for data, edge in edge_dict.items():
-
             if len(edge) != 2:
-                raise Exception('There should be exactly two syndromes (virtual or not) connected to each data '
-                                'qudit. Instead, q: %s edge: %s' % (data, edge))
+                msg = (
+                    f"There should be exactly two syndromes (virtual or not) connected to each data qudit. Instead,"
+                    f" q: {data} edge: {edge}"
+                )
+                raise Exception(msg)
 
             edges[tuple(edge)] = data
             edges[(edge[1], edge[0])] = data
             temp_graph.add_edge(edge[0], edge[1])
 
     # Create distance graph
-    for check_type in ['X', 'Z']:
-
-        if check_type == 'X':
-
+    for check_type in ["X", "Z"]:
+        if check_type == "X":
             temp_graph = temp_graph_x
-            G = graph_x
+            g = graph_x
             closest = closest_x
             virt = virt_x
             edge2d = edges_x
             virtual_edge_data = virtual_edge_data_x
 
         else:
             temp_graph = temp_graph_z
-            G = graph_z
+            g = graph_z
             closest = closest_z
             virt = virt_z
             edge2d = edges_z
             virtual_edge_data = virtual_edge_data_z
 
-        pathes = nx.shortest_path(temp_graph)
+        paths = nx.shortest_path(temp_graph)
 
-        for n1, wdict in pathes.items():
+        for n1, wdict in paths.items():
             for n2, syn_path in wdict.items():
-
                 weight = len(syn_path) - 1
 
                 if weight != 0:
-
-                    # print 'n1', n1, 'n2', n2, 'AP', syn_path, 'weight', weight
-
                     # Get list of datas corresponding to the connected path between syndromes
                     data_path = []
                     s1 = syn_path[0]
                     for s2 in syn_path[1:]:
-                        # print 's1', s1, 's2', s2
-                        # print 'data', edge2d[(s1, s2)]
                         data = edge2d[(s1, s2)]
                         data_path.append(data)
                         s1 = s2
 
-                    # G.add_edge(n1, n2, weight=1.0/float(weight), syn_path=syn_path, data_path=data_path)
-                    # G.add_edge(n1, n2, weight=float(weight), syn_path=syn_path, data_path=data_path)
                     if (n1 not in virt) and (n2 not in virt):
-                        G.add_edge(n1, n2, weight=-weight, syn_path=syn_path, data_path=data_path)
-                    # elif (n1 not in virt) and (n2 in virt):
-                    #    virtual_edge_data[n2] = {'weight': -weight, 'syn_path': syn_path, 'data_path': data_path}
+                        g.add_edge(n1, n2, weight=-weight, syn_path=syn_path, data_path=data_path)
 
-        syn = set(G.nodes())
+        syn = set(g.nodes())
         syn -= virt
 
         # Find closest virtual node
-        # print 'syn', syn
-        # print 'virt', virt
 
         for s in syn:
-            shortest_len = float('inf')
+            shortest_len = float("inf")
             closest_v = None
             for v in virt:
-                sv_len = len(pathes[s][v])
-                # print '%s -> %s: %s' % (s, v, sv_len)
+                sv_len = len(paths[s][v])
                 if sv_len < shortest_len:
                     shortest_len = sv_len
                     closest_v = v
             closest[s] = closest_v
-            # print 'C', s, closest_v, shortest_len
-            # print 'closest', closest_v
 
         for s, v in closest.items():
-            # print s, '->', v
-
-            syn_path = pathes[s][v]
+            syn_path = paths[s][v]
             weight = len(syn_path) - 1
 
             data_path = []
             s1 = syn_path[0]
             for s2 in syn_path[1:]:
-                # print 's1', s1, 's2', s2
-                # print 'data', edge2d[(s1, s2)]
                 data = edge2d[(s1, s2)]
                 data_path.append(data)
                 s1 = s2
 
-            virtual_edge_data[s] = {'virtual_node': v, 'weight': -weight, 'syn_path': syn_path, 'data_path': data_path}
-            # print s, '>>', virtual_edge_data[s]
-
-    # print 'closest X', closest_x
-    # print 'closest Z', closest_z
+            virtual_edge_data[s] = {"virtual_node": v, "weight": -weight, "syn_path": syn_path, "data_path": data_path}
 
     return info
 
 
 def surface4444medial_identity(instr):
-    """
-    For X and Z decoding separately:
+    """For X and Z decoding separately:
 
     - Create dictionary:
 
     - Determine how virtual nodes connect to data qubits.
     - find syndromes(and virtual) edges -> data
     - Generate distance graph
     - Determine syn -> closest v and weight
 
     :param instr:
     :return:
     """
-
     # In the end... need:
     # For x and z separately:
     #
     # syn -> closest virtual node
     # edge -> data
     # distance graph
 
     qecc = instr.qecc
 
     virtual_edge_data_x = {}
     virtual_edge_data_z = {}
 
     # Create a dictionary to store precomputed information that will be used for decoding
     info = {
-        'X': {
-            'dist_graph': nx.Graph(),
-            'closest_virt': {},
-            'virtual_edge_data': virtual_edge_data_x,
+        "X": {
+            "dist_graph": nx.Graph(),
+            "closest_virt": {},
+            "virtual_edge_data": virtual_edge_data_x,
         },
-        'Z': {
-            'dist_graph': nx.Graph(),
-            'closest_virt': {},
-            'virtual_edge_data': virtual_edge_data_z,
+        "Z": {
+            "dist_graph": nx.Graph(),
+            "closest_virt": {},
+            "virtual_edge_data": virtual_edge_data_z,
         },
     }
 
     # Record what data qudits the syndrome to syndrome edges correspond to.
-    # (syn, syn/virt): data
     edges_x = {}
     edges_z = {}
 
     # syndrome-to-syndrome, fully-connected graph
-    # (syn, syn): weight
-    graph_x = info['X']['dist_graph']
-    graph_z = info['Z']['dist_graph']
+    graph_x = info["X"]["dist_graph"]
+    graph_z = info["Z"]["dist_graph"]
 
     # The closest virtual node to each syndrome
-    # syn: virt
-    closest_x = info['X']['closest_virt']
-    closest_z = info['Z']['closest_virt']
+    closest_x = info["X"]["closest_virt"]
+    closest_z = info["Z"]["closest_virt"]
 
     # The sides of the QECC patch
     sides = qecc.sides  # t, r, b, l
 
     # checks of the logical instruction
-    instr = qecc.instruction('instr_syn_extract')
+    instr = qecc.instruction("instr_syn_extract")
     abs_circ = instr.abstract_circuit
 
     # Dictionary of data qudit to syndrome-to-syndrome edge
     d2edge_x = {}
     d2edge_z = {}
 
     # Temporary graphs that will store the direct syndrome-to-syndrome edges. This will be used to create the fully
     # connected, distance graph.
     temp_graph_x = nx.Graph()
     temp_graph_z = nx.Graph()
 
     # Assume the QECC uses checks
     # add edges based on checks
     for gate_symbol, _, params in abs_circ.items():
-
-        data_qudits = params['datas']
-        ancilla = params['ancillas']
+        data_qudits = params["datas"]
+        ancilla = params["ancillas"]
 
         for data in data_qudits:
-
-            if gate_symbol == 'X check':
+            if gate_symbol == "X check":
                 edges = d2edge_x
-            elif gate_symbol == 'Z check':
+            elif gate_symbol == "Z check":
                 edges = d2edge_z
             else:
-                raise Exception('This decoder can only handle check of purely X or Z type rather than %s!' %
-                                gate_symbol)
+                raise Exception(
+                    "This decoder can only handle check of purely X or Z type rather than %s!" % gate_symbol,
+                )
 
             syn_list = edges.setdefault(data, [])
             syn_list.append(ancilla)
 
-    # print('x ed', d2edge_x)
-    # print('z ed', d2edge_z)
-
     # VIRTUAL NODES...
     # ---- Create virtual nodes ----- #
-    virt_x = set([])
-    virt_z = set([])
+    virt_x = set()
+    virt_z = set()
 
     # side: top, right, bottom, left
     # For the non-medial surface code patch, a x virtual node is paired with data qubits on the right and left sides
     # and a z virtual node is paired with data qubits on the top and bottom sides (should say what Pauli type the side
     # is.
 
     distance_width = qecc.width
     distance_height = qecc.height
 
     vi = 0
-    # print('sides', sides)
     for side_label, side_qubits in sides.items():
-
-        # print('side qudbits: %s' % side_qubits)
-
         for i, data in enumerate(side_qubits):
-
-            if side_label == 'top':
-
+            if side_label == "top":
                 if distance_width % 2 == 1:  # odd
-
                     if i == 0 or i % 2 == 1:
                         vi += 1
-                        virt_node = 'v' + str(vi)
+                        virt_node = "v" + str(vi)
 
                 else:  # even
-
                     if i % 2 == 0:
                         vi += 1
-                        virt_node = 'v' + str(vi)
+                        virt_node = "v" + str(vi)
 
                 syn_list = d2edge_z.setdefault(data, [])
                 syn_list.append(virt_node)
                 virt_z.add(virt_node)
 
-            elif side_label == 'bottom':
-
+            elif side_label == "bottom":
                 if i == 0 or i % 2 == 1:
                     vi += 1
-                    virt_node = 'v' + str(vi)
+                    virt_node = "v" + str(vi)
 
                 syn_list = d2edge_z.setdefault(data, [])
                 syn_list.append(virt_node)
                 virt_z.add(virt_node)
 
-            elif side_label == 'left':
-
+            elif side_label == "left":
                 if i == 0 or i % 2 == 1:
                     vi += 1
-                    virt_node = 'v' + str(vi)
+                    virt_node = "v" + str(vi)
 
                 syn_list = d2edge_x.setdefault(data, [])
                 syn_list.append(virt_node)
                 virt_x.add(virt_node)
 
-            elif side_label == 'right':
-
+            elif side_label == "right":
                 if distance_height % 2 == 1:
                     if i == 0 or i % 2 == 1:
                         vi += 1
-                        virt_node = 'v' + str(vi)
+                        virt_node = "v" + str(vi)
                 else:
-
                     if i % 2 == 0:
                         vi += 1
-                        virt_node = 'v' + str(vi)
+                        virt_node = "v" + str(vi)
 
                 syn_list = d2edge_x.setdefault(data, [])
                 syn_list.append(virt_node)
                 virt_x.add(virt_node)
             else:
                 raise Exception('side_label "%s" not understood!' % side_label)
 
-    # print('vx ed', d2edge_x)
-    # print('vz ed', d2edge_z)
-
     # invert data -> edge and make sure len(edge) = 2
-    for check_type in ['X', 'Z']:
-
-        if check_type == 'X':
+    for check_type in ["X", "Z"]:
+        if check_type == "X":
             edge_dict = d2edge_x
             edges = edges_x
             temp_graph = temp_graph_x
         else:
             edge_dict = d2edge_z
             edges = edges_z
             temp_graph = temp_graph_z
 
         for data, edge in edge_dict.items():
-
             if len(edge) != 2:
-                raise Exception('There should be exactly two syndromes (virtual or not) connected to each data '
-                                'qudit. Instead, q: %s edge: %s' % (data, edge))
+                msg = (
+                    f"There should be exactly two syndromes (virtual or not) connected to each data qudit. Instead,"
+                    f" q: {data} edge: {edge}"
+                )
+                raise Exception(msg)
 
             edges[tuple(edge)] = data
             edges[(edge[1], edge[0])] = data
             temp_graph.add_edge(edge[0], edge[1])
 
     # Create distance graph
-    for check_type in ['X', 'Z']:
-
-        if check_type == 'X':
-
+    for check_type in ["X", "Z"]:
+        if check_type == "X":
             temp_graph = temp_graph_x
-            G = graph_x
+            g = graph_x
             closest = closest_x
             virt = virt_x
             edge2d = edges_x
             virtual_edge_data = virtual_edge_data_x
 
         else:
             temp_graph = temp_graph_z
-            G = graph_z
+            g = graph_z
             closest = closest_z
             virt = virt_z
             edge2d = edges_z
             virtual_edge_data = virtual_edge_data_z
 
-        pathes = nx.shortest_path(temp_graph)
+        paths = nx.shortest_path(temp_graph)
 
-        for n1, wdict in pathes.items():
+        for n1, wdict in paths.items():
             for n2, syn_path in wdict.items():
-
                 weight = len(syn_path) - 1
 
                 if weight != 0:
-
                     # Get list of datas corresponding to the connected path between syndromes
                     data_path = []
                     s1 = syn_path[0]
                     for s2 in syn_path[1:]:
                         data = edge2d[(s1, s2)]
                         data_path.append(data)
                         s1 = s2
 
                     if (n1 not in virt) and (n2 not in virt):
-                        G.add_edge(n1, n2, weight=-weight, syn_path=syn_path, data_path=data_path)
+                        g.add_edge(n1, n2, weight=-weight, syn_path=syn_path, data_path=data_path)
 
-        syn = set(G.nodes())
+        syn = set(g.nodes())
         syn -= virt
 
         # Find closest virtual node
 
         for s in syn:
-            shortest_len = float('inf')
+            shortest_len = float("inf")
             closest_v = None
             for v in virt:
-                sv_len = len(pathes[s][v])
-                # print '%s -> %s: %s' % (s, v, sv_len)
+                sv_len = len(paths[s][v])
                 if sv_len < shortest_len:
                     shortest_len = sv_len
                     closest_v = v
             closest[s] = closest_v
 
         for s, v in closest.items():
-
-            syn_path = pathes[s][v]
+            syn_path = paths[s][v]
             weight = len(syn_path) - 1
 
             data_path = []
             s1 = syn_path[0]
             for s2 in syn_path[1:]:
                 data = edge2d[(s1, s2)]
                 data_path.append(data)
                 s1 = s2
 
-            virtual_edge_data[s] = {'virtual_node': v, 'weight': -weight, 'syn_path': syn_path, 'data_path': data_path}
+            virtual_edge_data[s] = {"virtual_node": v, "weight": -weight, "syn_path": syn_path, "data_path": data_path}
 
     return info
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/circuit_runners/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,14 +1,14 @@
+# Copyright 2018 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .standard import Standard
-from .timing_runner import TimingRunner
+from pecos.simulators.cysparsesim_row.cysparsesim import State
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/circuit_runners/standard.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/circuit_runners/standard.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,33 +7,31 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-import struct
 import os
 import random
+import struct
+
 import numpy as np
-from pecos.misc.std_ouput import StdOutput
 
+from pecos.misc.std_output import StdOutput
 
-class Standard(object):
-    """
-    This class represents a standard model for running quantum circuits and adding in errors.
-    """
 
-    def __init__(self, seed=None):
-        """
+class Standard:
+    """This class represents a standard model for running quantum circuits and adding in errors."""
 
-        Args:
+    def __init__(self, seed=None) -> None:
+        """Args:
+        ----
             seed:
         """
-
         if isinstance(seed, bool) and seed is True:
             self.seed = struct.unpack("<L", os.urandom(4))[0]
 
         elif isinstance(seed, int):
             self.seed = seed
 
         else:
@@ -41,66 +39,62 @@
 
         if self.seed:
             np.random.seed(self.seed)
             random.seed(self.seed)
 
     @staticmethod
     def run(state, circuit, error_gen=None, error_params=None, error_circuits=None, output=None):
-        """
-
-        Args:
+        """Args:
+        ----
             state:
             circuit:
             error_gen:
             error_params:
             error_circuits:
             output:
 
         Returns:
+        -------
 
         """
-
         if output is None:
             output = StdOutput()
 
         # TODO: Generate errors before running the ticks
 
         # TODO: Add maps...
 
         # Initialize errors...
         # --------------------
 
         if error_gen is None:  # No errors
-
             generate_errors = False
             if error_circuits is None:
                 error_circuits = {}
 
         else:  # new errors
-
             generate_errors = True
             error_circuits = error_gen.start(circuit, error_params)
 
         # run through the circuits...
         # ---------------------------
         for tick_circuit, time, params in circuit.iter_ticks():
-
             # ---------------
             # GENERATE ERRORS
             # ---------------
-            if params.get('error_free', False):
+            if params.get("error_free", False):
                 errors = {}
             else:
                 if generate_errors:
                     error_circuits = error_gen.generate_tick_errors(tick_circuit, time, **params)
                 errors = error_circuits.get(time, {})
 
-            before_errors = errors.get('before')
-            after_errors = errors.get('after')
-            removed = errors.get('replaced')
+            before_errors = errors.get("before")
+            after_errors = errors.get("after")
+            removed = errors.get("replaced")
 
             # --------------------
             # RUN QUANTUM CIRCUITS
             # --------------------
 
             if before_errors:
                 state.run_circuit(before_errors)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/circuit_runners/timing_runner.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/circuit_runners/timing_runner.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,70 +8,66 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from time import perf_counter as default_timer
-from .standard import Standard
 
+from pecos.engines.circuit_runners.standard import Standard
 
-class TimingRunner(Standard):
-    """
-    This class represents a standard model for running quantum circuits and adding in errors.
-    """
 
-    def __init__(self, seed=None, timer=None):
-        """
+class TimingRunner(Standard):
+    """This class represents a standard model for running quantum circuits and adding in errors."""
 
-        Args:
+    def __init__(self, seed=None, timer=None) -> None:
+        """Args:
+        ----
             seed:
         """
-
         super().__init__(seed)
 
         self.total_time = 0.0
         self.num_gates = 0
 
         if timer is None:
             self.timer = default_timer
         else:
             self.timer = timer
 
     def reset_time(self):
-        """
-        Used to clear the time data in `total_time`.
+        """Used to clear the time data in `total_time`.
 
         Returns:
+        -------
 
         """
         self.total_time = 0.0
         self.num_gates = 0
 
     def run_gates(self, state, gates, removed_locations=None):
-        """
-        Directly apply a collection of quantum gates to a state.
+        """Directly apply a collection of quantum gates to a state.
 
         Args:
+        ----
             state:
             gates:
             removed_locations:
 
         Returns:
+        -------
 
         """
-
         timer = self.timer
 
         if removed_locations is None:
-            removed_locations = set([])
+            removed_locations = set()
 
         gate_results = {}
         for symbol, physical_gate_locations, gate_kwargs in gates.items():
-
             ti = timer()
             gate_results = state.run_gate(symbol, physical_gate_locations - removed_locations, **gate_kwargs)
             tf = timer()
             self.total_time += tf - ti
             self.num_gates += len(physical_gate_locations - removed_locations)
 
         return gate_results
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/binarray.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/binarray.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,85 +4,82 @@
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
-from typing import Union, Optional
 
+from __future__ import annotations
 
-class BinArray:
-
-    def __init__(self, size: Union[int, str], value: Optional[int] = None):
 
+class BinArray:
+    def __init__(self, size: int | str, value: int | None = None) -> None:
         if isinstance(size, int):
             self.size = size
             self.array = [0] * size
 
             if value is not None:
                 self.set(value)
         elif isinstance(size, str):
             str_rep = size
 
             self.array = []
             for i in reversed(str_rep):
-                if i == '0':
+                if i == "0":
                     self.array.append(0)
-                elif i == '1':
+                elif i == "1":
                     self.array.append(1)
                 else:
-                    raise Exception(f'Can only accept a string made of 0s and 1s! Got {str_rep}.')
+                    msg = f"Can only accept a string made of 0s and 1s! Got {str_rep}."
+                    raise Exception(msg)
 
             self.size = len(self.array)
         else:
-            raise Exception(f'First argument must be int or str! Got {size} of type {type(size)}.')
+            msg = f"First argument must be int or str! Got {size} of type {type(size)}."
+            raise TypeError(msg)
 
-    def __str__(self):
-        bin_str = ['1' if self.array[i] else '0' for i in range(len(self.array) - 1, -1, -1)]
-        return ''.join(bin_str)
+    def __str__(self) -> str:
+        bin_str = ["1" if self.array[i] else "0" for i in range(len(self.array) - 1, -1, -1)]
+        return "".join(bin_str)
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return self.__str__()
 
-    def __int__(self):
+    def __int__(self) -> int:
         return int(str(self), 2)
 
     def set_clip(self, ba):
         """Take values up to the size of this BinArray. If this BinArray array is larger, fill with zeros."""
-
         if isinstance(ba, int):
             ba = BinArray(format(ba, "b"))
 
         if isinstance(ba, BinArray):
-
             for i in range(self.size):
-
                 if i >= ba.size:
                     self.array[i] = 0
                 else:
                     self.array[i] = ba.array[i]
         else:
-            raise Exception('Expected int or BinArray!')
-
-    def set(self, value: Union['BinArray', int]):
+            msg = "Expected int or BinArray!"
+            raise TypeError(msg)
 
+    def set(self, value: BinArray | int):
         value = int(value)
 
-        value = (2**self.size-1) & value
-
-        for i, b in enumerate(reversed(format(value, f'0{self.size}b'))):
+        value = (2**self.size - 1) & value
 
+        for i, b in enumerate(reversed(format(value, f"0{self.size}b"))):
             # Don't add more elements than size
             if i >= self.size:
                 break
 
             self.array[i] = int(b)
 
-        '''
+        """
         if isinstance(value, int):
             for i, b in enumerate(reversed(format(value, f'0{self.size}b'))):
 
                 # Don't add more elements than size
                 if i >= self.size:
                     break
 
@@ -93,148 +90,143 @@
                 raise Exception('Binary array must be the same size as the array being set.')
 
             # Copy the other's array into this one
             self.array = list(value.array)
 
         else:
             raise Exception(f"Can't set value of type {type(value)}")
-        '''
+        """
 
     def __getitem__(self, item):
         return self.array[item]
 
-    def __setitem__(self, key, value):
+    def __setitem__(self, key, value) -> None:
         value_temp = int(value)
 
-        if value_temp != 0 and value_temp != 1:
-            raise Exception('Can only set an element to a binary value!')
+        if value_temp not in {0, 1}:
+            msg = "Can only set an element to a binary value!"
+            raise Exception(msg)
 
         self.array[key] = value_temp
 
-    def __len__(self):
+    def __len__(self) -> int:
         return self.size
 
     def __xor__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) ^ int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __and__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) & int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __or__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) | int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __eq__(self, other):
-
         val = int(self) == int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __ne__(self, other):
-
         val = int(self) != int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __lt__(self, other):
-
         val = int(self) < int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __gt__(self, other):
-
         val = int(self) > int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __le__(self, other):
-
         val = int(self) <= int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __ge__(self, other):
-
         val = int(self) >= int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __add__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) + int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __sub__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) - int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __rshift__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) >> int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __lshift__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) << int(other)
         result = BinArray(self.size)
         result.set_clip(val)
 
         return result
 
@@ -248,41 +240,41 @@
                 result.array[i] = 1
             else:
                 result.array[i] = 0
 
         return result
 
     def __mul__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) * int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __floordiv__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) // int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
     def __mod__(self, other):
-
         if isinstance(other, BinArray) and other.size != self.size:
-            raise Exception('Can only do bitwise operations between BinArrays of the same size.')
+            msg = "Can only do bitwise operations between BinArrays of the same size."
+            raise Exception(msg)
 
         val = int(self) % int(other)
         result = BinArray(self.size)
         result.set(val)
 
         return result
 
-    def __bool__(self):
+    def __bool__(self) -> bool:
         return bool(int(self))
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/binarray2.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/binarray2.py`

 * *Files 15% similar despite different names*

```diff
@@ -5,21 +5,21 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 import numpy as np
 
 
 class BinArray2:
-
-    def __init__(self, size, value=0, dtype=np.int32):
-
+    def __init__(self, size, value=0, dtype=np.int32) -> None:
         self.size = size
         self.value = None
         self.dtype = dtype
 
         if isinstance(size, int):
             self.size = size
 
@@ -27,151 +27,146 @@
                 self.set(value)
         elif isinstance(size, str):
             self.size = len(size)
             value = int(size, 2)
             self.set(value)
 
     def set(self, value):
-
         if isinstance(value, self.dtype):
             self.value = value
         else:
-
             if isinstance(value, str):
                 value = int(value, 2)
 
             self.value = self.dtype(value)
 
     def new_val(self, value):
         b = BinArray2(self.size, value, self.dtype)
         b.clamp(self.size)
         return b
 
     def num_bits(self):
-        return len('{0:b}'.format(self.value))
+        return len(f"{self.value:b}")
 
     def check_size(self):
         if self.num_bits() > self.size:
             num = self.num_bits()
-            val = '{0:b}'.format(self.value)
-            raise Exception(f'Number of bits ({num}) exceeds size ({self.size}) for bits "{val}"!')
+            val = f"{self.value:b}"
+            msg = f'Number of bits ({num}) exceeds size ({self.size}) for bits "{val}"!'
+            raise Exception(msg)
 
     def clamp(self, size):
-
         if self.num_bits() > size:
-            bits = format(self.value, f'0{size}b')
+            bits = format(self.value, f"0{size}b")
             bits = int(bits[-size:], 2)
             self.value = self.dtype(bits)
 
     def set_clip(self, value):
-
         value = int(value)
 
-        if len('{0:b}'.format(value)) > self.size:
-            bits = format(value, f'0{self.size}b')
-            bits = int(bits[-self.size:], 2)
+        if len(f"{value:b}") > self.size:
+            bits = format(value, f"0{self.size}b")
+            bits = int(bits[-self.size :], 2)
             self.value = self.dtype(bits)
         else:
             self.value = self.dtype(value)
 
     def _set_clip(self, ba):
         """Take values up to the size of this BinArray. If this BinArray array is larger, fill with zeros."""
-
         if isinstance(ba, int):
             ba = self.new_val(ba)
 
         if isinstance(ba, BinArray2):
-
             self._set_clip(ba)
         else:
-            raise Exception('Expected int or BinArray!')
+            msg = "Expected int or BinArray!"
+            raise TypeError(msg)
 
     def __getitem__(self, item):
         return int(str(self)[self.size - item - 1])
 
-    def __setitem__(self, key, value):
+    def __setitem__(self, key, value) -> None:
         b = list(str(self))
         b[self.size - key - 1] = str(value)
-        b = ''.join(b)
+        b = "".join(b)
 
         self.set(b)
 
-    def __str__(self):
+    def __str__(self) -> str:
         self.check_size()
-        return format(self.value, f'0{self.size}b')
+        return format(self.value, f"0{self.size}b")
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return self.__str__()
 
-    def __int__(self):
+    def __int__(self) -> int:
         return int(self.value)
 
-    def __len__(self):
+    def __len__(self) -> int:
         return self.size
 
     def do_binop(self, op, other):
-
-        if hasattr(other, 'value') and isinstance(other.value, self.dtype):
+        if hasattr(other, "value") and isinstance(other.value, self.dtype):
             value = other.value
         elif isinstance(other, str):
             value = self.dtype(int(other, 2))
         else:
             value = self.dtype(other)
 
         op = getattr(self.value, op)
         value = op(value)
 
         return self.new_val(value)
 
-    def __bool__(self):
+    def __bool__(self) -> bool:
         return bool(self.value)
 
     def __xor__(self, other):
-        return self.do_binop('__xor__', other)
+        return self.do_binop("__xor__", other)
 
     def __and__(self, other):
-        return self.do_binop('__and__', other)
+        return self.do_binop("__and__", other)
 
     def __or__(self, other):
-        return self.do_binop('__or__', other)
+        return self.do_binop("__or__", other)
 
     def __eq__(self, other):
-        return self.do_binop('__eq__', other)
+        return self.do_binop("__eq__", other)
 
     def __ne__(self, other):
-        return self.do_binop('__ne__', other)
+        return self.do_binop("__ne__", other)
 
     def __lt__(self, other):
-        return self.do_binop('__lt__', other)
+        return self.do_binop("__lt__", other)
 
     def __gt__(self, other):
-        return self.do_binop('__gt__', other)
+        return self.do_binop("__gt__", other)
 
     def __le__(self, other):
-        return self.do_binop('__le__', other)
+        return self.do_binop("__le__", other)
 
     def __ge__(self, other):
-        return self.do_binop('__ge__', other)
+        return self.do_binop("__ge__", other)
 
     def __add__(self, other):
-        return self.do_binop('__add__', other)
+        return self.do_binop("__add__", other)
 
     def __sub__(self, other):
-        return self.do_binop('__sub__', other)
+        return self.do_binop("__sub__", other)
 
     def __rshift__(self, other):
-        return self.do_binop('__rshift__', other)
+        return self.do_binop("__rshift__", other)
 
     def __lshift__(self, other):
-        return self.do_binop('__lshift__', other)
+        return self.do_binop("__lshift__", other)
 
     def __invert__(self):
         return self.new_val(~self.value)
 
     def __mul__(self, other):
-        return self.do_binop('__mul__', other)
+        return self.do_binop("__mul__", other)
 
     def __floordiv__(self, other):
-        return self.do_binop('__floordiv__', other)
+        return self.do_binop("__floordiv__", other)
 
     def __mod__(self, other):
-        return self.do_binop('__floordiv__', other)
+        return self.do_binop("__floordiv__", other)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/classical.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/classical.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,94 +5,97 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .binarray import BinArray
-# from .binarray2 import BinArray2 as BinArray
+from __future__ import annotations
 
+from pecos.engines.cvm.binarray import BinArray
 
-def set_output(state, circuit, output_spec, output):
 
+def set_output(state, circuit, output_spec, output):
     if output_spec is None:
         output_spec = {}
 
-    output_spec['__pecos_scratch'] = state.num_qubits
+    output_spec["__pecos_scratch"] = state.num_qubits
 
-    if circuit.metadata.get('cvar_spec'):
-        output_spec_new = circuit.metadata['cvar_spec']
+    if circuit.metadata.get("cvar_spec"):
+        output_spec_new = circuit.metadata["cvar_spec"]
         output_spec_new.update(output_spec)
         output_spec = output_spec_new
 
     if output is None:
         output = {}
 
         if output_spec:
             for symbol, size in output_spec.items():
                 output[symbol] = BinArray(size)
 
     return output
 
 
 def eval_op(op, a, b=None, width=32):
-
     if isinstance(a, int):
         a = BinArray(width, a)
 
-    if op == '=':
+    if op == "=":
         if b:
-            raise Exception('Assignment can only have one argument (only `a`).')
+            msg = "Assignment can only have one argument (only `a`)."
+            raise Exception(msg)
 
         return a
 
-    elif op == '|':
+    elif op == "|":
         expr_eval = a | b
-    elif op == '^':
+    elif op == "^":
         expr_eval = a ^ b
-    elif op == '&':
+    elif op == "&":
         expr_eval = a & b
-    elif op == '+':
+    elif op == "+":
         expr_eval = a + b
-    elif op == '-':
+    elif op == "-":
         expr_eval = a - b
-    elif op == '>>':
+    elif op == ">>":
         expr_eval = a >> b
-    elif op == '<<':
+    elif op == "<<":
         expr_eval = a << b
-    elif op == '*':
+    elif op == "*":
         expr_eval = a * b
-    elif op == '/':
+    elif op == "/":
         expr_eval = a // b
-    elif op == '==':
+    elif op == "==":
         expr_eval = a == b
-    elif op == '!=':
+    elif op == "!=":
         expr_eval = a != b
-    elif op == '<=':
+    elif op == "<=":
         expr_eval = a <= b
-    elif op == '>=':
+    elif op == ">=":
         expr_eval = a >= b
-    elif op == '<':
+    elif op == "<":
         expr_eval = a < b
-    elif op == '>':
+    elif op == ">":
         expr_eval = a > b
-    elif op == '%':
+    elif op == "%":
         expr_eval = a % b
 
-    elif op == '~':
+    elif op == "~":
         expr_eval = ~a
 
         if b:
-
-            raise Exception('Unary operation but got another argument!!!.')
+            msg = "Unary operation but got another argument!!!."
+            raise Exception(msg)
 
     else:
-        raise Exception(f'Receive op "{op}". Only operators `=`, `~`, `|`, `^`, `&`, `+`, `-`, `<<`, and `>>` '
-                        f'have been implemented.')
+        msg = (
+            f'Receive op "{op}". Only operators `=`, `~`, `|`, `^`, `&`, `+`, `-`, `<<`, and `>>` '
+            f"have been implemented."
+        )
+        raise Exception(msg)
 
     return expr_eval
 
 
 def get_val(a, output, width):
     if isinstance(a, BinArray):
         return a
@@ -104,183 +107,172 @@
     elif isinstance(a, str):
         val = int(output[a])
 
     elif isinstance(a, int):
         val = a
 
     else:
-        raise Exception(f'Could not evaluate "{str(a)}"')
+        msg = f'Could not evaluate "{str(a)}". Wrong type, got type: {type(a)}.'
+        raise TypeError(msg)
 
     return BinArray(width, val)
 
 
 def recur_eval_op(expr_dict, output, width):
-
-    a = expr_dict.get('a')
-    op = expr_dict.get('op')
-    b = expr_dict.get('b')
-    c = expr_dict.get('c')
+    a = expr_dict.get("a")
+    op = expr_dict.get("op")
+    b = expr_dict.get("b")
+    c = expr_dict.get("c")
 
     if isinstance(a, dict):
         a = recur_eval_op(a, output, width)
 
     elif c:  # c => unary operation
-
-        if isinstance(c, dict):
-            c = recur_eval_op(c, output, width)
-        else:
-            c = get_val(c, output, width)
+        c = recur_eval_op(c, output, width) if isinstance(c, dict) else get_val(c, output, width)
 
         a = eval_op(op, c, width=width)
 
     else:
         a = get_val(a, output, width)
 
     if b:
-
-        if isinstance(b, dict):
-            b = recur_eval_op(b, output, width)
-        else:
-            b = get_val(b, output, width)
+        b = recur_eval_op(b, output, width) if isinstance(b, dict) else get_val(b, output, width)
 
         a = eval_op(op, a, b, width=width)
 
     return a
 
 
 def eval_cop(cop_expr, output, width):
-    """
-    Evaluate classical expression such as:
+    """Evaluate classical expression such as:
 
     assignment:
     t = a     BinArray = (BinArray | int)
     t[i] = a  BinArray[i] = (BinArray | int)
 
     binary operations:
     t = a o b
     t[i] = a[j] o b[k]
     """
-
     # Get `t` argument
     # ----------------
-    t = cop_expr['t']  # symbol of where the resulting value will be stored in the output
+    t = cop_expr["t"]  # symbol of where the resulting value will be stored in the output
 
     if isinstance(t, str):
         t_sym = t
         t_index = None
     elif isinstance(t, (tuple, list)) and len(t) == 2:
         t_sym = t[0]
         t_index = t[1]
     else:
-        raise Exception('`t` should be `str` or `Tuple[str, int]`!')
+        msg = "`t` should be `str` or `Tuple[str, int]`!"
+        raise Exception(msg)
 
     t_obj = output[t_sym]
 
     # Eval assignment
     # ---------------
     expr_eval = recur_eval_op(cop_expr, output, width)
 
     # Assign the final value:
     # -----------------------
     if t_index is not None:  # t[i] = ...
-
         t_obj[t_index] = expr_eval[0]
 
     else:  # t = ...
-
         t_obj.set_clip(expr_eval)
 
 
 def eval_tick_conds(tick_circuit, output):
-
     conds = []
 
-    for symbol, locations, params in tick_circuit.items():
-
-        cond_eval = eval_condition(params.get('cond'), output)
+    for _symbol, _locations, params in tick_circuit.items():
+        cond_eval = eval_condition(params.get("cond"), output)
 
         conds.append(cond_eval)
     return conds
 
 
 def eval_condition(conditional_expr, output) -> bool:
-
     # Handle if a condition might eval to something else (eval_to)
     if isinstance(conditional_expr, (tuple, list)):
         if len(conditional_expr) != 2:
-            raise Exception('Not expected conditional to have more than 2 elements.')
+            msg = "Not expected conditional to have more than 2 elements."
+            raise Exception(msg)
 
         if not isinstance(conditional_expr[1], bool):
-            raise Exception('Expecting the second conditional element to be bool.')
+            msg = "Expecting the second conditional element to be bool."
+            raise TypeError(msg)
 
-        cond_val = eval_condition(conditional_expr[0], output) == eval_condition(conditional_expr[1], output)
-        return cond_val
+        return eval_condition(conditional_expr[0], output) == eval_condition(conditional_expr[1], output)
 
     if conditional_expr:
-
-        a = conditional_expr['a']
-        b = conditional_expr['b']
-        op = conditional_expr['op']
+        a = conditional_expr["a"]
+        b = conditional_expr["b"]
+        op = conditional_expr["op"]
 
         if isinstance(a, str):
             a = output[a]  # str -> BinArray
         elif isinstance(a, (tuple, list)) and len(a) == 2:
             a = output[a[0]][a[1]]  # (str, int) -> int (1 or 0)
         else:
-            raise Exception('`a` should be `str` or `Tuple[str, int]`!')
+            msg = "`a` should be `str` or `Tuple[str, int]`!"
+            raise Exception(msg)
 
         if isinstance(b, str):
             b = output[b]  # str -> BinArray
         elif isinstance(b, (tuple, list)) and len(b) == 2:
             b = output[b[0]][b[1]]  # (str, int) -> int (1 or 0)
         elif isinstance(b, int):
             pass
         else:
-            raise Exception('`b` should be `str` or `Tuple[str, int]` or `int`!')
+            msg = "`b` should be `str` or `Tuple[str, int]` or `int`!"
+            raise Exception(msg)
 
-        if op == '==':            
+        if op == "==":
             return bool(a.__eq__(b))
 
-        if op == '!=':
+        if op == "!=":
             return bool(a.__ne__(b))
 
-        elif op == '^':
+        elif op == "^":
             return bool(a.__xor__(b).__int__())
 
-        elif op == '|':
+        elif op == "|":
             return bool(a.__or__(b).__int__())
 
-        elif op == '&':
+        elif op == "&":
             return bool(a.__and__(b).__int__())
 
-        elif op == '<':
+        elif op == "<":
             return a.__lt__(b)
 
-        elif op == '>':
+        elif op == ">":
             return a.__gt__(b)
 
-        elif op == '<=':
+        elif op == "<=":
             return a.__le__(b)
 
-        elif op == '>=':
+        elif op == ">=":
             return a.__ge__(b)
 
-        elif op == '>>':
+        elif op == ">>":
             return a.__rshift__(b)
 
-        elif op == '<<':
+        elif op == "<<":
             return a.__lshift__(b)
 
-        elif op == '~':
+        elif op == "~":
             return a.__invert__()
 
-        elif op == '*':
+        elif op == "*":
             return a.__mul__()
 
-        elif op == '/':
+        elif op == "/":
             return a.__floordiv__()
 
         else:
-            raise Exception('Comparison operator not recognized!')
+            msg = "Comparison operator not recognized!"
+            raise Exception(msg)
 
     else:
         return True
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/cvm.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/cvm.py`

 * *Files 11% similar despite different names*

```diff
@@ -4,37 +4,39 @@
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
-class CVM:
 
-    def __init__(self,
-                 ccop_vm=None,
-                 cinterpreter=None,
-                 sim_debug=None,
-                 ) -> None:
-        """
-        Classical Virtual Machine, which is responsible for executing classical functions and statements.
+from __future__ import annotations
+
+
+class CVM:
+    def __init__(
+        self,
+        ccop_vm=None,
+        cinterpreter=None,
+        sim_debug=None,
+    ) -> None:
+        """Classical Virtual Machine, which is responsible for executing classical functions and statements.
 
         Attributes:
+        ----------
             ccop_vm: A VM representing the computing environment of a classical co-processor. This generally provides
                 external classical functions that are usually problem specific.
             cinterpreter: Provides an interpreter for generic classical statements. For example, boolean operations,
                 assignments, comparisons, etc.
-            sim_debug: A collection of functions used in the simulation environment to provide additional information that
-                may not typically be available to a physical quantum device.
+            sim_debug: A collection of functions used in the simulation environment to provide additional information
+                that may not typically be available to a physical quantum device.
         """
-
         self.state = {}
 
         self.ccop_vm = ccop_vm
         self.cinterpreter = cinterpreter
         self.sim_debug = sim_debug
 
     def reset_state(self):
         self.state = ()
 
-    def exec(self, func_name, args):
-        ...
+    def exec(self, func_name, args): ...
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/sim_func.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/sim_func.py`

 * *Files 18% similar despite different names*

```diff
@@ -5,25 +5,26 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+
 def sim_print(runner, *args):
     syms = [s for s, _ in args]
-    syms = ', '.join(syms)
-    print(f'sim_print({syms}):')
-    for i, (sym, b) in enumerate(args):
-        print(f'    {sym}: {str(b)} ({int(b)})')
+    syms = ", ".join(syms)
+    print(f"sim_print({syms}):")
+    for sym, b in args:
+        print(f"    {sym}: {str(b)} ({int(b)})")
     print()
 
 
 def sim_test(runner, *args):
-    print(f'SIM TEST!')
+    print("SIM TEST!")
 
 
 def sim_get_amp(runner, key_state):
     st = str(key_state[0][1])
     return runner.state.get_amps(st)
 
 
@@ -42,20 +43,19 @@
 
 def sim_noise_on(runner, *args):
     runner.generate_errors = True
     return sim_noise(runner)
 
 
 sim_funcs = {
-    'sim_test': sim_test,
-    'sim_print': sim_print,
-    'sim_get_amp': sim_get_amp,
-    'sim_get_amps': sim_get_amps,
-
-    'sim_noise': sim_noise,
-    'sim_noise_off': sim_noise_off,
-    'sim_noise_on': sim_noise_on,
+    "sim_test": sim_test,
+    "sim_print": sim_print,
+    "sim_get_amp": sim_get_amp,
+    "sim_get_amps": sim_get_amps,
+    "sim_noise": sim_noise,
+    "sim_noise_off": sim_noise_off,
+    "sim_noise_on": sim_noise_on,
 }
 
 
 def sim_exec(func, runner, *args):
     return sim_funcs[func](runner, *args)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,118 +6,120 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 import pickle
+from pathlib import Path
 
-from .wasm_vms.pywasm import read_pywasm
-from .wasm_vms.pywasm3 import read_pywasm3
-from .wasm_vms.wasmer import read_wasmer
-
+from pecos.engines.cvm.binarray import BinArray
+from pecos.engines.cvm.sim_func import sim_exec
+from pecos.engines.cvm.wasm_vms.pywasm import read_pywasm
+from pecos.engines.cvm.wasm_vms.pywasm3 import read_pywasm3
+from pecos.engines.cvm.wasm_vms.wasmer import read_wasmer
+from pecos.engines.cvm.wasm_vms.wasmtime import read_wasmtime
 from pecos.errors import MissingCCOPError
-from .binarray import BinArray
-# from .binarray2 import BinArray2 as BinArray
-
-from .sim_func import sim_exec
 
 
 def read_pickle(picklefile):
     """Read in either a file path or byte object meant to be a pickled class used to define the ccop."""
     if isinstance(picklefile, str):  # filename
-        with open(picklefile, 'rb') as f:
-            return pickle.load(f)
+        with Path.open(picklefile, "rb") as f:
+            return pickle.load(f)  # noqa: S301
     else:
-        return pickle.loads(picklefile)  # byte object
+        return pickle.loads(picklefile)  # byte object  # noqa: S301
 
 
 def get_ccop(circuit):
-    if circuit.metadata.get('ccop'):
-        ccop = circuit.metadata['ccop']
-        ccop_type = circuit.metadata['ccop_type']
+    if circuit.metadata.get("ccop"):
+        ccop = circuit.metadata["ccop"]
+        ccop_type = circuit.metadata["ccop_type"]
 
         if ccop_type is None:
-            ccop_type = 'wasmer'
+            ccop_type = "wasmtime"
 
         # Set self.ccop
         # ------------------------------------------------
-        if ccop_type in ['py', 'python']:
+        if ccop_type in {"py", "python"}:
             ccop = read_pickle(ccop)
 
-        elif ccop_type == 'pywasm':
+        elif ccop_type == "wasmtime":
+            ccop = read_wasmtime(ccop)
+
+        elif ccop_type == "pywasm":
             ccop = read_pywasm(ccop)
 
-        elif ccop_type == 'pywasm3':
+        elif ccop_type == "pywasm3":
             ccop = read_pywasm3(ccop)
 
-        elif ccop_type == 'wasmer' or ccop_type == 'wasmer_cl':
-            ccop = read_wasmer(ccop, compiler='wasmer_cl')
+        elif ccop_type in {"wasmer", "wasmer_cl"}:
+            ccop = read_wasmer(ccop, compiler="wasmer_cl")
 
-        elif ccop_type == 'wasmer_llvm':
+        elif ccop_type == "wasmer_llvm":
             ccop = read_wasmer(ccop, compiler=ccop_type)
 
-        elif ccop_type in ['obj', 'object']:
-            ccop = ccop
+        elif ccop_type in {"obj", "object"}:
+            pass
 
         else:
-            raise Exception(f'Got ccop object but ccop_type "{ccop_type}" is unknown or not supported!')
+            msg = f'Got ccop object but ccop_type "{ccop_type}" is unknown or not supported!'
+            raise Exception(msg)
 
         # Call the CCOP object initialization method.
-        ccop.exec('init', [])
+        ccop.exec("init", [])
 
     else:
         ccop = None
 
     return ccop
 
 
 def eval_cfunc(runner, params, output):
-
-    func = params['func']
-    assign_vars = params['assign_vars']
-    args = params['args']
+    func = params["func"]
+    assign_vars = params["assign_vars"]
+    args = params["args"]
 
     valargs = []
     for sym in args:
         valargs.append((sym, output[sym]))
 
     try:
-        if runner.debug and func.startswith('sim_'):
+        if runner.debug and func.startswith("sim_"):
             vals = sim_exec(func, runner, valargs)
 
         else:
             vals = runner.ccop.exec(func, valargs, debug=runner.debug)
 
     except AttributeError:
-
-        ccop = runner.circuit.metadata['ccop']
-        ccop_type = runner.circuit.metadata['ccop_type']
+        ccop = runner.circuit.metadata["ccop"]
+        ccop_type = runner.circuit.metadata["ccop_type"]
 
         if ccop is None:
-            raise MissingCCOPError('Wasm not supplied but requested!')
+            msg = f"Wasm ({ccop_type}) function not found: {func} with args: {args}"
+            raise MissingCCOPError(msg) from AttributeError
 
-        raise MissingCCOPError(f'Classical coprocessor object not assigned or missing exec method. '
-                               f'Wasm-type = {ccop_type}')
+        msg = f"Classical coprocessor object not assigned or missing exec method. Wasm-type = {ccop_type}"
+        raise MissingCCOPError(msg) from AttributeError
 
     if assign_vars:
         if len(assign_vars) == 1:
             a_obj = output[assign_vars[0]]
-            if runner.debug and func.startswith('sim_'):
+            if runner.debug and func.startswith("sim_"):
                 output[assign_vars[0]] = vals
             else:
                 b = BinArray(a_obj.size, int(vals))
                 a_obj.set(b)
 
         else:
             for asym, b in zip(assign_vars, vals):
                 a_obj = output[asym]
 
-                if runner.debug and func.startswith('sim_'):
+                if runner.debug and func.startswith("sim_"):
                     output[asym] = b
                 else:
-
                     if isinstance(b, int):
                         b = BinArray(a_obj.size, int(b))
                         a_obj.set(b)
                     else:
-                        raise NotImplementedError('Only int return values are supported currently')
+                        msg = "Only int return values are supported currently"
+                        raise NotImplementedError(msg)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/pywasm.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/pywasm.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,43 +5,44 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+import contextlib
 from io import BytesIO
 
-try:
+with contextlib.suppress(ImportError):
     import pywasm
-except ImportError:
-    pass
 
 
 def read_pywasm(wasm):
     """Read in either a file path or byte object meant for use with pywasm to define the ccop."""
     if isinstance(wasm, str):
         p = pywasm.load(wasm)
     else:
         reader = BytesIO(wasm)
         module = pywasm.binary.Module.from_reader(reader)
         p = pywasm.Runtime(module)
 
     class PywasmReader:
-
-        def __init__(self, p):
+        def __init__(self, p) -> None:
             self.p = p
             self.func_exports = self.get_funcs()
 
         def get_funcs(self):
             fs = []
             for f in self.p.machine.module.export_list:
-                if str(f.value).startswith('FunctionAddress'):
+                if str(f.value).startswith("FunctionAddress"):
                     fs.append(str(f.name))
 
             return fs
 
         def exec(self, func, args, debug=False):
             args = [int(b) for _, b in args]
             return self.p.exec(func, args)
 
+        def teardown(self):
+            pass  # Only needed for wasmtime
+
     return PywasmReader(p)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/pywasm3.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/pywasm3.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,31 +4,31 @@
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
+import contextlib
 
-try:
+with contextlib.suppress(ImportError):
     import wasm3
-except ImportError:
-    pass
 
 
 def read_pywasm3(wasm, stack_size=1000000):
-
     env = wasm3.Environment()
     rt = env.new_runtime(stack_size)
     mod = env.parse_module(wasm)
     rt.load(mod)
 
     class Reader:
-
-        def __init__(self, rt):
+        def __init__(self, rt) -> None:
             self.rt = rt
 
         def exec(self, func, args, debug=False):
             args = [int(b) for _, b in args]
             return self.rt.find_function(func)(*args)
 
+        def teardown(self):
+            pass  # Only needed for wasmtime
+
     return Reader(rt)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/cvm/wasm_vms/wasmer.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/cvm/wasm_vms/wasmer.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,77 +5,74 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Union
+from __future__ import annotations
+
+import contextlib
 import sys
-from ..sim_func import sim_funcs
+from pathlib import Path
+
+from pecos.engines.cvm.sim_func import sim_funcs
 
-try:
-    from wasmer import engine, Store, Module, Instance
-except ImportError:
-    pass
+with contextlib.suppress(ImportError):
+    from wasmer import Instance, Module, Store, engine
 
-try:
+with contextlib.suppress(ImportError):
     from wasmer_compiler_cranelift import Compiler as CompilerCranelift
-except ImportError:
-    pass
 
-try:
+with contextlib.suppress(ImportError):
     from wasmer_compiler_llvm import Compiler as CompilerLLVM
-except ImportError:
-    pass
 
 
-def read_wasmer(path, compiler='wasm_cl'):
+def read_wasmer(path, compiler="wasm_cl"):
     """Helper method to create a wasmer instance."""
 
     class WasmerInstance:
         """Wrapper class to create a wasmer instance and access its functions."""
 
-        if 'wasmer' not in sys.modules:
-            raise ImportError('wasmer is being called but not installed! Install "wasmer"')
+        if "wasmer" not in sys.modules:
+            msg = 'wasmer is being called but not installed! Install "wasmer"'
+            raise ImportError(msg)
 
         # '"wasmer_compiler_cranelift"!')
 
-        def __init__(self, file: Union[str, bytes], compiler='wasm_cl'):
-
+        def __init__(self, file: str | bytes, compiler="wasm_cl") -> None:
             if isinstance(file, str):
-                with open(file, 'rb') as f:
+                with Path.open(file, "rb") as f:
                     wasm_b = f.read()
             else:
                 wasm_b = file
 
-            if compiler == 'wasm_llvm':
-                store = Store(engine.JIT(CompilerLLVM))
-            else:
-                store = Store(engine.JIT(CompilerCranelift))
+            store = Store(engine.JIT(CompilerLLVM)) if compiler == "wasm_llvm" else Store(engine.JIT(CompilerCranelift))
 
             module = Module(store, wasm_b)
             instance = Instance(module)
 
             self.wasm = instance
             self.module = module
 
         def get_funcs(self):
             fs = []
             for f in self.module.exports:
-                if str(f.type).startswith('FunctionType'):
+                if str(f.type).startswith("FunctionType"):
                     fs.append(str(f.name))
 
             return fs
 
         def exec(self, func_name, args, debug=False):
-
-            if debug and func_name.startswith('sim_'):
+            if debug and func_name.startswith("sim_"):
                 method = sim_funcs[func_name]
                 return method(*args)
 
             else:
                 method = getattr(self.wasm.exports, func_name)
                 args = [int(b) for _, b in args]
                 return method(*args)
 
+        def teardown(self):
+            pass  # Only needed for wasmtime
+
     return WasmerInstance(path, compiler)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/hybrid_engine.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/hybrid_engine.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,43 +5,55 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 import random
-from typing import Any, Optional
+from typing import TYPE_CHECKING, Any
 
 import numpy as np
 
-from pecos.classical_interpreters.phir_classical_interpreter import ClassicalInterpreter, PHIRClassicalInterpreter
-from pecos.error_models.error_model import ErrorModel, NoErrorModel
-from pecos.foreign_objects.foreign_object_abc import ForeignObject
-from pecos.machines.generic_machine import GenericMachine, Machine
-from pecos.op_processors.generic_op_processor import GenericOpProc, OpProcessor
+from pecos.classical_interpreters.phir_classical_interpreter import PHIRClassicalInterpreter
+from pecos.engines import hybrid_engine_multiprocessing
+from pecos.error_models.error_model import NoErrorModel
+from pecos.machines.generic_machine import GenericMachine
+from pecos.op_processors.generic_op_processor import GenericOpProc
 from pecos.simulators.quantum_simulator import QuantumSimulator
-from . import hybrid_engine_multiprocessing
 
+if TYPE_CHECKING:
+    from pecos.classical_interpreters.phir_classical_interpreter import ClassicalInterpreter
+    from pecos.error_models.error_model import ErrorModel
+    from pecos.foreign_objects.foreign_object_abc import ForeignObject
+    from pecos.machines.generic_machine import Machine
+    from pecos.op_processors.generic_op_processor import OpProcessor
 
-class HybridEngine:
 
-    def __init__(self,
-                 cinterp: Optional[ClassicalInterpreter] = None,
-                 qsim: Optional[QuantumSimulator] = None,
-                 machine: Optional[Machine] = None,
-                 error_model: Optional[ErrorModel] = None,
-                 op_processor: Optional[OpProcessor] = None) -> None:
+class HybridEngine:
+    """A simulation engine which is capable of running noisy hybrid classical/quantum programs."""
 
+    def __init__(
+        self,
+        cinterp: ClassicalInterpreter | None = None,
+        qsim: QuantumSimulator | str | None = None,
+        machine: Machine | None = None,
+        error_model: ErrorModel | None = None,
+        op_processor: OpProcessor | None = None,
+    ) -> None:
         self.seed = None
 
         self.cinterp = cinterp
         if self.cinterp is None:
             self.cinterp = PHIRClassicalInterpreter()
 
+        self._internal_cinterp = PHIRClassicalInterpreter()
+
         self.qsim = qsim
         if self.qsim is None:
             self.qsim = QuantumSimulator()
         elif isinstance(self.qsim, str):
             self.qsim = QuantumSimulator(self.qsim)
 
         self.machine = machine
@@ -67,137 +79,138 @@
 
     def init(self):
         """Reset the state of `Engine` before a simulation run."""
         self.results = {}
         self.multisim_process_info = {}
 
     def reset_all(self):
-        """Reset to the state of initialization"""
+        """Reset to the state of initialization."""
         self.cinterp.reset()
+        self._internal_cinterp.reset()
         self.qsim.reset()
         self.machine.reset()
         self.error_model.reset()
         self.op_processor.reset()
         self.init()
 
-    def initialize_sim_components(self,
-                                  program: Any,
-                                  foreign_object: Optional["ForeignObject"] = None,
-                                  machine_params: Optional[dict] = None,
-                                  error_params: Optional[dict] = None) -> None:
+    def initialize_sim_components(
+        self,
+        program: Any,
+        foreign_object: ForeignObject | None = None,
+    ) -> None:
         """Get objects to initialize before potentially running many simulations."""
-
         self.init()
         if foreign_object is not None:
             foreign_object.init()
         num_qubits = self.cinterp.init(program, foreign_object)
-        self.machine.init(machine_params, num_qubits)
-        self.error_model.init(error_params, num_qubits, self.machine)
+        self._internal_cinterp.init(program, foreign_object)
+        self.machine.init(num_qubits)
+        self.error_model.init(num_qubits, self.machine)
         self.op_processor.init()
         self.qsim.init(num_qubits)
 
     def shot_reinit_components(self) -> None:
         """Tells components that a new shot is starting and to run any tasks necessary, such as resetting their
-        states."""
-
+        states.
+        """
         self.cinterp.shot_reinit()
+        self._internal_cinterp.shot_reinit()
+        for i in range(self.machine.num_qubits):
+            self._internal_cinterp.add_cvar(f"__q{i}__", np.uint8, 1)
         self.machine.shot_reinit()
         self.error_model.shot_reinit()
         self.op_processor.shot_reinit()
         self.qsim.shot_reinit()
 
     @staticmethod
     def use_seed(seed=None) -> int:
         """Use a seed to set random number generators."""
         if seed is None:
             seed = np.random.randint(np.iinfo(np.int32).max)
         np.random.seed(seed)
         random.seed(seed)
         return seed
 
-    def results_accumulator(self,
-                            shot_results: dict) -> None:
+    def results_accumulator(self, shot_results: dict) -> None:
         """Combines the results of individual runs together."""
-
         for k, v in shot_results.items():
             self.results.setdefault(k, []).append(v)
 
-    def run(self,
-            program,
-            foreign_object: "ForeignObject" = None,
-            shots: int = 1,
-            error_params: dict = None,
-            machine_params: dict = None,
-            seed: int = None,
-            initialize: bool = True,
-            optimize: bool = True,
-            return_int=False) -> dict:
-        """
-        Main method to run simulations.
+    def run(
+        self,
+        program,
+        foreign_object: ForeignObject = None,
+        *,
+        shots: int = 1,
+        seed: int | None = None,
+        initialize: bool = True,
+        return_int=False,
+    ) -> dict:
+        """Main method to run simulations.
 
         Args:
+        ----
             program:
             foreign_object:
             shots:
-            error_params:
-            machine_params:
             seed:
             initialize:
-            optimize:
             return_int:
 
         Returns:
+        -------
 
         """
-
-        # TODO: ErrorModel
-        # TODO: Machine: EM -> Machine (leakage/qubit loss)
-        # TODO: Leakage
         # TODO: Qubit loss
 
+        measurements = MeasData()
+
         if initialize:
             self.seed = self.use_seed(seed)
-            self.initialize_sim_components(program, foreign_object, machine_params, error_params)
-
-        if optimize:
-            # Potentially, optimize program for running simulations
-            self.cinterp.optimize(self.op_processor, self.qsim)
+            self.initialize_sim_components(program, foreign_object)
 
         for _ in range(shots):
-
             self.shot_reinit_components()
 
-            # Execute classical program till quantum sim is needed
+            # Execute the classical program till quantum sim is needed
             for buffered_ops in self.cinterp.execute(self.cinterp.program.ops):
+                # Process ops, e.g., use `machine` and `error_model` to generate noisy qops & cops
+                noisy_buffered_ops = self.op_processor.process(buffered_ops)
 
-                # Process ops, e.g., use `machine` and `error_model` to generate noisy qops
-                noisy_buffered_qops = self.op_processor.process(buffered_ops)
-
-                measurements = self.qsim.run(noisy_buffered_qops)
+                # TODO: Think about the safety of evolving the internal registers...
+                # TODO: Maybe make the error model explicitly declare internal registers...
 
-                # Allows noise to be dependent on measurement outcomes and to alter measurements
-                measurements = self.op_processor.process_meas(measurements)
+                # Process noisy operations
+                measurements.clear()
+                for noisy_qops in self._internal_cinterp.execute(noisy_buffered_ops):
+                    temp_meas = self.qsim.run(noisy_qops)
+                    self._internal_cinterp.receive_results(temp_meas)
+                    measurements.extend(temp_meas)
 
-                self.cinterp.recieve_results(measurements)
+                transmit_meas = self._internal_cinterp.result_bits(measurements)
+                self.cinterp.receive_results([transmit_meas])
 
             self.results_accumulator(self.cinterp.results(return_int))
 
         return self.results
 
-    def run_multisim(self,
-                     program,
-                     foreign_object: "ForeignObject" = None,
-                     shots: int = 1,
-                     error_params: dict = None,
-                     machine_params: dict = None,
-                     seed: int = None,
-                     pool_size: int = 1) -> dict:
-        """Parallelized running of the sim"""
-
-        return hybrid_engine_multiprocessing.run_multisim(self,
-                                                          program=program,
-                                                          foreign_object=foreign_object,
-                                                          shots=shots,
-                                                          error_params=error_params,
-                                                          machine_params=machine_params,
-                                                          seed=seed,
-                                                          pool_size=pool_size)
+    def run_multisim(
+        self,
+        program,
+        foreign_object: ForeignObject = None,
+        shots: int = 1,
+        seed: int | None = None,
+        pool_size: int = 1,
+    ) -> dict:
+        """Parallelized running of the sim."""
+        return hybrid_engine_multiprocessing.run_multisim(
+            self,
+            program=program,
+            foreign_object=foreign_object,
+            shots=shots,
+            seed=seed,
+            pool_size=pool_size,
+        )
+
+
+class MeasData(list):
+    """Class representing a collection of measurements."""
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/hybrid_engine_multiprocessing.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/hybrid_engine_multiprocessing.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,38 +5,37 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 import multiprocessing
 import sys
 from os import getpid
-from typing import Tuple
 from warnings import warn
 
 import numpy as np
 
-
 # TODO: Add runtime data to multisim_proc_info
 
 
-def run_multisim(eng,
-                 program,
-                 foreign_object: object = None,
-                 shots: int = 1,
-                 error_params: dict = None,
-                 machine_params: dict = None,
-                 seed: int = None,
-                 optimize: bool = True,
-                 pool_size: int = 1,
-                 reset_engine: bool = True):
-    """Parallelize the running of the sim"""
-
+def run_multisim(
+    eng,
+    program,
+    foreign_object: object = None,
+    *,
+    shots: int = 1,
+    seed: int | None = None,
+    pool_size: int = 1,
+    reset_engine: bool = True,
+):
+    """Parallelize the running of the sim."""
     if reset_engine:
         eng.reset_all()
 
     # Don't use more resource than is needed
     pool_size = min(pool_size, shots)
 
     # divide up the shots among the pool
@@ -51,20 +50,16 @@
         foreign_object = foreign_object.to_dict()
 
     # Create the list of kwargs to launch the run_sim instances
     kwargs = {
         "program": program,
         "foreign_object": foreign_object,
         "shots": shots,
-        "error_params": error_params,
-        "machine_params": machine_params,
         "seed": seed,
         "initialize": True,
-        "optimize": optimize,
-
     }
 
     np.random.seed(seed)
     max_value = np.iinfo(np.int32).max
 
     manager = multiprocessing.Manager()
     queue = manager.Queue()
@@ -85,79 +80,81 @@
         presults = pool.map(worker_wrapper, args)
 
     msg_dict = {}
     while not queue.empty():
         pid, msg_type, msg_data = queue.get()
         msg_dict.setdefault(pid, {})
         if isinstance(msg_data, str):
-            msg_dict[pid].setdefault(msg_type, '')
+            msg_dict[pid].setdefault(msg_type, "")
             msg_dict[pid][msg_type] += msg_data
         else:
-            raise Exception(f"msg_data type {type(msg_data)} not currently handled!")
+            msg = f"msg_data type {type(msg_data)} not currently handled!"
+            raise TypeError(msg)
 
     # Combine results
     results = {}
     errors = []
     process_info = []
     for r, pinfo in presults:
-
         pid = pinfo["pid"]
         i = pinfo["i"]
         msgs = msg_dict.get(pid, {})
         pinfo["messages"] = msgs
         if "error" in msgs:
             errors.append((i, pid, msgs["error"]))
 
         process_info.append(pinfo)
         for key, value in r.items():
             if isinstance(value, list):
                 results.setdefault(key, []).extend(value)
             else:
-                raise Exception(f'Unexpected results! Got a result dict with a value of type: {type(value)}')
+                msg = f"Unexpected results! Got a result dict with a value of type: {type(value)}"
+                raise TypeError(msg)
 
     eng.multisim_process_info = process_info
 
     if errors:
         for i, pid, error_msg in errors:
-            warn(f"process {i} with pid = {pid} had this error message: {error_msg}")
-        raise MultisimError("Processes experienced errors!")
+            warn(f"process {i} with pid = {pid} had this error message: {error_msg}", stacklevel=2)
+        msg = "Processes experienced errors!"
+        raise MultisimError(msg)
 
     return results
 
 
 class MultisimError(Exception):
     pass
 
 
-def worker_wrapper(args) -> Tuple[dict, dict]:
-    """A wrapper to pass kwargs onto run for multiprocess.pool.map"""
+def worker_wrapper(args) -> tuple[dict, dict]:
+    """A wrapper to pass kwargs onto run for multiprocess.pool.map."""
     queue, run, pkwargs, i = args
     pid = getpid()
 
     sys.stdout = WriteStream(queue, pid, "stdout")
     sys.stderr = WriteStream(queue, pid, "stderr")
 
-    run_info = {'i': i, 'pid': pid, 'seed': pkwargs["seed"], 'shots': pkwargs['shots']}
+    run_info = {"i": i, "pid": pid, "seed": pkwargs["seed"], "shots": pkwargs["shots"]}
 
     # TODO: Find a more elegant solution.
     foreign_object = pkwargs["foreign_object"]
     if isinstance(foreign_object, dict) and hasattr(foreign_object["fobj_class"], "from_dict"):
-            pkwargs["foreign_object"] = foreign_object["fobj_class"].from_dict(foreign_object)
+        pkwargs["foreign_object"] = foreign_object["fobj_class"].from_dict(foreign_object)
 
     results = {}
     try:
         results = run(**pkwargs)
-    except Exception as e:
+    except Exception as e:  # noqa: BLE001
         queue.put((pid, "error", str(e)))
 
     return results, run_info
 
 
 class WriteStream:
-    def __init__(self, q, pid: int, stream_type: str):
+    def __init__(self, q, pid: int, stream_type: str) -> None:
         self.queue = q
         self.stream_type = stream_type
         self.pid = pid
 
     def write(self, msg):
         self.queue.put((self.pid, self.stream_type, msg))
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/engines/hybrid_engine_old.py` & `quantum_pecos-0.6.0.dev1/python/pecos/engines/hybrid_engine_old.py`

 * *Files 6% similar despite different names*

```diff
@@ -17,26 +17,25 @@
 
 from pecos.engines.cvm.classical import BinArray, eval_condition, eval_cop, set_output
 from pecos.engines.cvm.wasm import eval_cfunc, get_ccop
 from pecos.error_models.fake_error_model import FakeErrorModel
 from pecos.errors import NotSupportedGateError
 
 
-class HybridEngine(object):
-    """
-    This class represents a standard model for running quantum circuits and adding in errors.
-    """
+class HybridEngine:
+    """This class represents a standard model for running quantum circuits and adding in errors."""
 
-    def __init__(self, seed=None, debug=False, regwidth: int = 32):
+    def __init__(self, seed=None, debug=False, regwidth: int = 32) -> None:
         """
 
         Args:
             seed:
+            debug:
+            regwidth:
         """
-
         self.debug = debug
         self.state = None
         self.circuit = None
         self.regwidth = regwidth
 
         if isinstance(seed, bool) and seed is True:
             self.seed = struct.unpack("<L", os.urandom(4))[0]
@@ -51,189 +50,189 @@
             np.random.seed(self.seed)
             random.seed(self.seed)
 
         self.ccop = None
 
         self.generate_errors = None
 
-    def run(self, state, circuit, error_gen=None, error_params=None, error_circuits=None, output=None,
-            output_spec=None, circ_inspector=None):
-
+    def run(
+        self,
+        state,
+        circuit,
+        error_gen=None,
+        error_params=None,
+        error_circuits=None,
+        output=None,
+        output_spec=None,
+        circ_inspector=None,
+    ):
         output = set_output(state, circuit, output_spec, output)
         output_export = {}
 
         self.circuit = circuit
         self.ccop = get_ccop(circuit)
 
         if error_circuits:
             error_gen = FakeErrorModel(error_circuits)
         elif error_gen is None:
-            error_gen = FakeErrorModel(dict())  # No errors
+            error_gen = FakeErrorModel({})  # No errors
 
         # Initialize errors...
         # --------------------
         self.generate_errors = True
         error_circuits = error_gen.start(circuit, error_params)
 
         # run through the circuits...
         # ---------------------------
         for tick_circuit, time, params in circuit.iter_ticks():
-
             # ---------------
             # GENERATE ERRORS
             # ---------------
-            if params.get('error_free', False):
+            if params.get("error_free", False):
                 errors = {}
             else:
                 error_circuits = error_gen.generate_tick_errors(tick_circuit, time, output, **params)
                 errors = error_circuits.get(time, {})
 
             # TODO: Need run the error generator whether we want errors or not because of leakage
             # TODO: Handle applying leakage without generating new errors
             if self.generate_errors:
-                before_errors = errors.get('before')
-                after_errors = errors.get('after')
+                before_errors = errors.get("before")
+                after_errors = errors.get("after")
             else:
                 before_errors = {}
                 after_errors = {}
 
-            removed = errors.get('replaced')
+            removed = errors.get("replaced")
 
             # --------------------
             # RUN QUANTUM CIRCUITS
             # --------------------
 
             if before_errors:
                 self.run_circuit(state, output, output_export, before_errors, error_gen)
 
             # ideal tick circuit
             # ------------------
-            self.run_circuit(state, output, output_export, tick_circuit, error_gen,
-                             removed_locations=removed)
+            self.run_circuit(state, output, output_export, tick_circuit, error_gen, removed_locations=removed)
 
             if circ_inspector:
                 circ_inspector.analyze(tick_circuit, time, output)
 
             if after_errors:
                 self.run_circuit(state, output, output_export, after_errors, error_gen)
 
         if output_export:
             output = output_export
 
+        if self.ccop:
+            self.ccop.teardown()  # Tear down WASM execution context
+
         return output, error_circuits
 
-    def run_circuit(self,
-                    state,
-                    output,
-                    output_export,
-                    circuit,
-                    error_gen,
-                    removed_locations=None):
-        """
+    def run_circuit(self, state, output, output_export, circuit, error_gen, removed_locations=None):
+        """Args:
 
-        Args:
             circuit (QuantumCircuit): A circuit instance or object with an appropriate items() generator.
             removed_locations:
 
         Returns (list): If output is True then the circuit output is returned. Note that this output format may differ
         from what a ``circuit_runner`` will return for the same method named ``run_circuit``.
 
         """
-
         self.state = state
 
         if removed_locations is None:
             removed_locations = set()
 
         for symbol, locations, params in circuit.items():
-
-            if params.get('skip'):
+            if params.get("skip"):
                 continue
 
-            eval_cond2 = eval_condition(params.get('cond2'), output) if params.get('cond2') else True
-
-            if eval_condition(params.get('cond'), output) and eval_cond2:
+            eval_cond2 = eval_condition(params.get("cond2"), output) if params.get("cond2") else True
 
+            if eval_condition(params.get("cond"), output) and eval_cond2:
                 # Run quantum simulator
-                if symbol == 'cop':
-
-                    if params.get('cop_type') == 'Idle' or params.get('is_transport') or params.get('syn_cvar') \
-                            or params.get('cop_type') == 'Sleep':
+                if symbol == "cop":
+                    if (
+                        params.get("cop_type") == "Idle"
+                        or params.get("is_transport")
+                        or params.get("syn_cvar")
+                        or params.get("cop_type") == "Sleep"
+                    ):
                         pass
 
-                    elif params.get('cop_type') == 'CFunc':
+                    elif params.get("cop_type") == "CFunc":
                         eval_cfunc(self, params, output)
 
-                    elif params.get('expr'):
-                        eval_cop(params.get('expr'), output, width=self.regwidth)
+                    elif params.get("expr"):
+                        eval_cop(params.get("expr"), output, width=self.regwidth)
 
-                    elif params.get('cop_type') == 'ExportCVar':
-                        sym = params['export']
+                    elif params.get("cop_type") == "ExportCVar":
+                        sym = params["export"]
                         val = output[sym]
 
                         if isinstance(val, str):
                             output_export[sym] = val
                         elif isinstance(val, BinArray):
                             output_export[sym] = BinArray(str(val))
                         else:
-                            raise Exception(f'This output type `{type(val)}` not handled at export!')
+                            msg = f"This output type `{type(val)}` not handled at export!"
+                            raise Exception(msg)
 
-                    elif not params.get('comment') and not params.get('linebreak') and not params.get('barrier'):
-                        print('recieved:', symbol, locations, params)
-                        raise Exception('A cop must have an `expr`, `comment`, `linebreak`, or `barrier` entry!')
+                    elif not params.get("comment") and not params.get("linebreak") and not params.get("barrier"):
+                        print("received:", symbol, locations, params)
+                        msg = "A cop must have an `expr`, `comment`, `linebreak`, or `barrier` entry!"
+                        raise Exception(msg)
 
-                elif symbol == 'eop':  # special error triggering operation
+                elif symbol == "eop":  # special error triggering operation
                     pass
 
                 else:  # quantum operation
-
                     self.run_gate(state, output, symbol, locations - removed_locations, **params)
 
-                    if symbol == 'leak':
+                    if symbol == "leak":
                         error_gen.leaked_qubits |= locations
 
-                    elif symbol == 'unleak |0>' or symbol == 'unleak |1>':
+                    elif symbol == {"unleak |0>", "unleak |1>"}:
                         error_gen.leaked_qubits -= locations
 
-
     @staticmethod
-    def run_gate(state,
-                 output,
-                 symbol: str,
-                 locations,
-                 **params):
+    def run_gate(state, output, symbol: str, locations, **params):
         """
+
         Args:
             state:
             output:
             symbol:
             locations:
             **params:
 
         Returns:
 
         """
 
-        if params.get('simulate_gate', True):
-
+        if params.get("simulate_gate", True):
             for location in locations:
-
                 try:
                     result = state.bindings[symbol](state, location, **params)
-                except KeyError as e:
+                except KeyError:
                     if symbol not in state.bindings:
-                        raise NotSupportedGateError(f'The gate "{symbol}" is not available for this simulator: '
-                                                    f'{type(state)}. Metadata: {params}')
+                        msg = (
+                            f'The gate "{symbol}" is not available for this simulator: {type(state)}. '
+                            f"Metadata: {params}"
+                        )
+                        raise NotSupportedGateError(msg) from KeyError
                     else:
-                        raise e
+                        raise
 
                 sym = None
                 indx = None
-                if params.get('var'):
-                    sym, indx = params.get('var')
-                elif params.get('var_output'):
-                    sym, indx = params.get('var_output')[location]
+                if params.get("var"):
+                    sym, indx = params.get("var")
+                elif params.get("var_output"):
+                    sym, indx = params.get("var_output")[location]
 
                 if sym:
                     if not result:
                         result = 0
                     output[sym][indx] = result
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,13 +6,13 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .class_errors_circuit import ErrorCircuits
+from pecos.error_models.class_errors_circuit import ErrorCircuits
 from pecos.error_models.old.depolar_gen import DepolarModel
+from pecos.error_models.old.gatewise_gen import GatewiseModel
 from pecos.error_models.old.xerror_gen import XModel
-from pecos.error_models.old.zerror_gen import ZModel
 from pecos.error_models.old.xzerror_gen import XZModel
-from pecos.error_models.old.gatewise_gen import GatewiseModel
+from pecos.error_models.old.zerror_gen import ZModel
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/class_errors_circuit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/class_errors_circuit.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,48 +7,43 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-# from collections import OrderedDict
-
 
 class ErrorCircuits(dict):
-    """
-    Used to store error circuits.
-    """
-
-    def __init__(self):
+    """Used to store error circuits."""
 
+    def __init__(self) -> None:
         super().__init__()
 
     def add_circuits(self, time: int, before_faults=None, after_faults=None, replaced_locations=None):
-        """
-        Add error circuits and gate locations to ignore (replaced_locations).
+        """Add error circuits and gate locations to ignore (replaced_locations).
 
         Args:
+        ----
             time:
             before_faults:
             after_faults:
             replaced_locations:
 
         Returns:
+        -------
 
         """
-
         error_dict = {}
 
         if before_faults and len(before_faults) > 0:
-            before_faults.metadata['circuit_type'] = 'faults'
-            error_dict['before'] = before_faults
+            before_faults.metadata["circuit_type"] = "faults"
+            error_dict["before"] = before_faults
 
         if after_faults and len(after_faults) > 0:
-            after_faults.metadata['circuit_type'] = 'faults'
-            error_dict['after'] = after_faults
+            after_faults.metadata["circuit_type"] = "faults"
+            error_dict["after"] = after_faults
 
         if replaced_locations and len(replaced_locations) > 0:
-            error_dict['replaced'] = replaced_locations
+            error_dict["replaced"] = replaced_locations
 
         if error_dict:
             self[time] = error_dict
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/depolarizing_error_model.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/depolarizing_error_model.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,139 +5,157 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import List, Union
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
 
 import numpy as np
 
+from pecos.error_models.error_model_abc import ErrorModel
+from pecos.error_models.noise_impl.noise_initz_bitflip import noise_initz_bitflip
+from pecos.error_models.noise_impl.noise_meas_bitflip import noise_meas_bitflip
+from pecos.error_models.noise_impl.noise_sq_depolarizing import noise_sq_depolarizing
+from pecos.error_models.noise_impl.noise_tq_depolarizing import noise_tq_depolarizing
 from pecos.error_models.noise_impl_old.gate_groups import one_qubits, two_qubits
-from .error_model_abc import ErrorModel
-from ..reps.pypmir.block_types import SeqBlock
-from ..reps.pypmir.op_types import QOp
-
-from .noise_impl.noise_initz_bitflip import noise_initz_bitflip
-from .noise_impl.noise_sq_depolarizing import noise_sq_depolarizing
-from .noise_impl.noise_tq_depolarizing import noise_tq_depolarizing
-from .noise_impl.noise_meas_bitflip import noise_meas_bitflip
+
+if TYPE_CHECKING:
+    from pecos.reps.pypmir.block_types import SeqBlock
+    from pecos.reps.pypmir.op_types import QOp
 
 two_qubit_paulis = {
-    'IX', 'IY', 'IZ',
-    'XI', 'XX', 'XY', 'XZ',
-    'YI', 'YX', 'YY', 'YZ',
-    'ZI', 'ZX', 'ZY', 'ZZ',
+    "IX",
+    "IY",
+    "IZ",
+    "XI",
+    "XX",
+    "XY",
+    "XZ",
+    "YI",
+    "YX",
+    "YY",
+    "YZ",
+    "ZI",
+    "ZX",
+    "ZY",
+    "ZZ",
 }
 SYMMETRIC_P2_PAULI_MODEL = {p: 1 / 15 for p in two_qubit_paulis}
 
 one_qubit_paulis = {
-    'X', 'Y', 'Z',
+    "X",
+    "Y",
+    "Z",
 }
 SYMMETRIC_P1_PAULI_MODEL = {p: 1 / 3 for p in one_qubit_paulis}
 
 
 class DepolarizingErrorModel(ErrorModel):
     """Parameterized error mode."""
 
-    def __init__(self):
-
-        super().__init__()
+    def __init__(self, error_params: dict) -> None:
+        super().__init__(error_params=error_params)
         self._eparams = None
 
     def reset(self):
         """Reset error generator for another round of syndrome extraction."""
-        return DepolarizingErrorModel()
-
-    def init(self, error_params, num_qubits, machine=None):
+        return DepolarizingErrorModel(error_params=self.error_params)
 
+    def init(self, num_qubits, machine=None):
         self.machine = machine
 
-        if not error_params:
-            raise Exception('Error params not set!')
+        if not self.error_params:
+            msg = "Error params not set!"
+            raise Exception(msg)
 
-        self._eparams = dict(error_params)
+        self._eparams = dict(self.error_params)
         self._scale()
 
         if "p1_error_model" not in self._eparams:
             self._eparams["p1_error_model"] = SYMMETRIC_P1_PAULI_MODEL
 
         if "p2_error_model" not in self._eparams:
             self._eparams["p2_error_model"] = SYMMETRIC_P2_PAULI_MODEL
 
         if "p2_mem" in self._eparams and "p2_mem_error_model" not in self._eparams:
             self._eparams["p2_mem_error_model"] = SYMMETRIC_P2_PAULI_MODEL
 
     def _scale(self):
-
         # conversion from average error to total error
-        self._eparams['p1'] *= (3 / 2)
-        self._eparams['p2'] *= (5 / 4)
+        self._eparams["p1"] *= 3 / 2
+        self._eparams["p2"] *= 5 / 4
 
-        scale = self._eparams.get('scale', 1.0)
-        self._eparams['p1'] *= scale
-        self._eparams['p2'] *= scale
+        scale = self._eparams.get("scale", 1.0)
+        self._eparams["p1"] *= scale
+        self._eparams["p2"] *= scale
 
-        if isinstance(self._eparams['p_meas'], tuple):
-            self._eparams['p_meas'] = np.mean(self._eparams['p_meas'])
+        if isinstance(self._eparams["p_meas"], tuple):
+            self._eparams["p_meas"] = np.mean(self._eparams["p_meas"])
 
-        self._eparams['p_meas'] *= scale
-        self._eparams['p_init'] *= scale
+        self._eparams["p_meas"] *= scale
+        self._eparams["p_init"] *= scale
 
     def shot_reinit(self) -> None:
         """Run all code needed at the beginning of each shot, e.g., resetting state."""
-        pass
-
-    def process(self, qops: List[QOp], call_back=None) -> List[Union[QOp, SeqBlock]]:
 
+    def process(self, qops: list[QOp], call_back=None) -> list[QOp | SeqBlock]:
         noisy_ops = []
 
         for op in qops:
-
             qops_after = None
             qops_before = None
             erroneous_ops = None
 
             # ########################################
             # INITS WITH X NOISE
-            if op.name in ['init |0>', "Init", "Init +Z"]:
-                qops_after = noise_initz_bitflip_leakage(op,
-                                                         p=self._eparams['p_init'],
-                                                         machine=self.machine)
+            if op.name in ["init |0>", "Init", "Init +Z"]:
+                qops_after = noise_initz_bitflip(
+                    op,
+                    p=self._eparams["p_init"],
+                )
 
             # ########################################
             # ONE QUBIT GATES
             elif op.name in one_qubits:
-                erroneous_ops = noise_sq_depolarizing_leakage(op,
-                                                              p=self._eparams['p1'],
-                                                              noise_dict=self._eparams["p1_error_model"],
-                                                              machine=self.machine)
+                erroneous_ops = noise_sq_depolarizing(
+                    op,
+                    p=self._eparams["p1"],
+                    noise_dict=self._eparams["p1_error_model"],
+                )
 
             # ########################################
             # TWO QUBIT GATES
             elif op.name in two_qubits:
-                qops_after = noise_tq_depolarizing_leakage(op,
-                                                           p=self._eparams['p2'],
-                                                           noise_dict=self._eparams["p2_error_model"],
-                                                           machine=self.machine)
-
-                if self._eparams.get('p2_mem'):
-                    qops_mem = noise_tq_depolarizing_leakage(op,
-                                                             p=self._eparams["p2_mem"],
-                                                             noise_dict=self._eparams["p2_mem_error_model"],
-                                                             machine=self.machine)
+                qops_after = noise_tq_depolarizing(
+                    op,
+                    p=self._eparams["p2"],
+                    noise_dict=self._eparams["p2_error_model"],
+                )
+
+                if self._eparams.get("p2_mem"):
+                    qops_mem = noise_tq_depolarizing(
+                        op,
+                        p=self._eparams["p2_mem"],
+                        noise_dict=self._eparams["p2_mem_error_model"],
+                    )
 
                     if qops_after:
                         qops_after = qops_after.extend(qops_mem)
 
             # ########################################
             # MEASURE X NOISE
-            elif op.name in ['measure Z', "Measure", "Measure +Z"]:
-                erroneous_ops = noise_meas_bitflip_leakage(op, p=self._eparams['p_meas'], machine=self.machine)
+            elif op.name in ["measure Z", "Measure", "Measure +Z"]:
+                erroneous_ops = noise_meas_bitflip(
+                    op,
+                    p=self._eparams["p_meas"],
+                )
 
             else:
                 raise Exception("This error model doesn't handle gate: %s!" % op.name)
 
             if qops_before:
                 noisy_ops.extend(qops_before)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/error_depolar.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/error_depolar.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,140 +6,129 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 import numpy as np
-from pecos.error_models.parent_class_error_gen import ParentErrorModel
-from pecos.error_models.class_errors_circuit import ErrorCircuits
+
 from pecos.circuits import QuantumCircuit
 from pecos.engines.cvm.classical import eval_condition
-
-from pecos.error_models.noise_impl_old.gate_groups import (two_qubits, one_qubits)
-
+from pecos.error_models.class_errors_circuit import ErrorCircuits
+from pecos.error_models.noise_impl_old.gate_groups import one_qubits, two_qubits
 from pecos.error_models.noise_impl_old.init_noise import noise_init_bitflip
 from pecos.error_models.noise_impl_old.meas_noise import noise_meas_bitflip
 from pecos.error_models.noise_impl_old.memory_noise import noise_tq_mem
 from pecos.error_models.noise_impl_old.sq_noise import noise_depolarizing_sq_gate
 from pecos.error_models.noise_impl_old.tq_noise import noise_two_qubit_gates_depolarizing_with_noiseless
+from pecos.error_models.parent_class_error_gen import ParentErrorModel
 
 
 class DepolarizingErrorModel(ParentErrorModel):
     """Parameterized error model for Beta and ARC1."""
 
-    def __init__(self):
-
+    def __init__(self) -> None:
         super().__init__()
 
         self.qubit_set = set()
 
-        # self.default_error_params = dict(error_params_depolar)
-
         self.error_circuits = None
         self.error_params = None
         self.circuit = None
 
     def scaling(self):
-
         # conversion from average error to total error
-        self.error_params['p1'] *= (3 / 2)
-        self.error_params['p2'] *= (5 / 4)
+        self.error_params["p1"] *= 3 / 2
+        self.error_params["p2"] *= 5 / 4
 
-        scale = self.error_params.get('scale', 1.0)
-        self.error_params['p1'] *= scale
-        self.error_params['p2'] *= scale
+        scale = self.error_params.get("scale", 1.0)
+        self.error_params["p1"] *= scale
+        self.error_params["p2"] *= scale
 
-        if isinstance(self.error_params['p_meas'], tuple):
-            self.error_params['p_meas'] = np.mean(self.error_params['p_meas'])
+        if isinstance(self.error_params["p_meas"], tuple):
+            self.error_params["p_meas"] = np.mean(self.error_params["p_meas"])
 
-        self.error_params['p_meas'] *= scale
-        self.error_params['p_init'] *= scale
+        self.error_params["p_meas"] *= scale
+        self.error_params["p_init"] *= scale
 
     def start(self, circuit, error_params, reset_leakage=True):
-
-        self.qubit_set = set(range(circuit.metadata['num_qubits']))
+        self.qubit_set = set(range(circuit.metadata["num_qubits"]))
 
         self.error_circuits = ErrorCircuits()
         self.circuit = circuit
 
         # if error_params is None:
-        #     error_params = {}
 
         if not error_params:
-            raise Exception('Error params not set!')
+            msg = "Error params not set!"
+            raise Exception(msg)
 
-        # self.error_params = dict(self.default_error_params)
         self.error_params = {}
         self.error_params.update(error_params)
 
         self.scaling()  # scale self.error_params params
 
-        if not self.error_params.get('noiseless_qubits'):
-            self.error_params['noiseless_qubits'] = set()
-        self.error_params['noiseless_qubits'] = set(self.error_params['noiseless_qubits'])
+        if not self.error_params.get("noiseless_qubits"):
+            self.error_params["noiseless_qubits"] = set()
+        self.error_params["noiseless_qubits"] = set(self.error_params["noiseless_qubits"])
 
         return self.error_circuits
 
     def generate_tick_errors(self, tick_circuit, time, output=None, reset_leakage=False, **params):
         """The method that gets called each circuit tick to generate circuit noise for that tick."""
-
         # Get the tick
         tick_index = time[-1] if isinstance(time, tuple) else time
 
         circuit = tick_circuit.circuit
 
         before = QuantumCircuit()  # Faults that occur before the tick
         after = QuantumCircuit()  # Faults the occur after the tick
         remove_locations = set()  # gate locations to remove
 
         for symbol, locations, metadata in circuit.items(tick_index):
+            cond = metadata.get("cond")
 
-            cond = metadata.get('cond')
-
-            if symbol == 'cop':
-
+            if symbol == "cop":
                 pass
 
             # ########################################
             # INITS WITH X NOISE
-            elif symbol == 'init |0>':
-                noisy = set(locations) - self.error_params['noiseless_qubits']
-                noise_init_bitflip(noisy, after, 'X', p=self.error_params['p_init'])
+            elif symbol == "init |0>":
+                noisy = set(locations) - self.error_params["noiseless_qubits"]
+                noise_init_bitflip(noisy, after, "X", p=self.error_params["p_init"])
 
             # ########################################
             # ONE QUBIT GATES
             elif symbol in one_qubits:
-
                 if eval_condition(cond, output):
-                    noisy = set(locations) - self.error_params['noiseless_qubits']
-                    noise_depolarizing_sq_gate(noisy, after, p=self.error_params['p1'])
+                    noisy = set(locations) - self.error_params["noiseless_qubits"]
+                    noise_depolarizing_sq_gate(noisy, after, p=self.error_params["p1"])
 
             # ########################################
             # TWO QUBIT GATES
             elif symbol in two_qubits:
-
                 if eval_condition(cond, output):
-                    noise_two_qubit_gates_depolarizing_with_noiseless(locations, after,
-                                                                      p=self.error_params['p2'],
-                                                                      noiseless_qubits=self.error_params['noiseless_qubits'])
+                    noise_two_qubit_gates_depolarizing_with_noiseless(
+                        locations,
+                        after,
+                        p=self.error_params["p2"],
+                        noiseless_qubits=self.error_params["noiseless_qubits"],
+                    )
 
-                    if self.error_params['p2_mem']:
-                        noise_tq_mem(locations, after, p=self.error_params['p2_mem'])
+                    if self.error_params["p2_mem"]:
+                        noise_tq_mem(locations, after, p=self.error_params["p2_mem"])
 
             # ########################################
             # MEASURE X NOISE
-            elif symbol == 'measure Z':
+            elif symbol == "measure Z":
                 if eval_condition(cond, output):
-                    noisy = set(locations) - self.error_params['noiseless_qubits']
-                    noise_meas_bitflip(noisy, metadata, after, p=self.error_params['p_meas'])
+                    noisy = set(locations) - self.error_params["noiseless_qubits"]
+                    noise_meas_bitflip(noisy, metadata, after, p=self.error_params["p_meas"])
 
-            elif symbol == 'repump':
-                pass
-            elif symbol in {'leak', 'unleak'}:
+            elif symbol in {"repump", "leak", "unleak"}:
                 pass
 
             else:
                 raise Exception("This error model doesn't handle gate: %s!" % symbol)
 
         self.error_circuits.add_circuits(time, before, after, remove_locations)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/error_model.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/error_model.py`

 * *Files 13% similar despite different names*

```diff
@@ -5,29 +5,44 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Callable, Optional, Union
+from __future__ import annotations
 
-from .error_model_abc import ErrorModel
+from typing import Callable
+
+from pecos.error_models.error_model_abc import ErrorModel
+from pecos.reps.pypmir.op_types import EMOp, MOp, QOp
 
 
 class NoErrorModel(ErrorModel):
     """Represents having no error model."""
 
+    def __init__(self):
+        super().__init__(error_params={})
+
     def reset(self) -> None:
         """Reset state to initialization state."""
-        pass
 
-    def init(self, error_params, num_qubits, machine=None):
-        super().init(error_params, num_qubits, machine)
+    def init(self, num_qubits, machine=None):
+        super().init(num_qubits=num_qubits, machine=machine)
         if self.error_params:
-            raise Exception("No error model is being utilized but error parameters are being provided!")
+            msg = "No error model is being utilized but error parameters are being provided!"
+            raise Exception(msg)
 
     def shot_reinit(self):
         pass
 
-    def process(self, qops: list, call_back: Optional[Callable] = None) -> Union[list, None]:
-        return qops
+    def process(self, ops: list, call_back: Callable | None = None) -> list | None:
+        noisy_ops = []
+        for op in ops:
+            if isinstance(op, QOp):
+                noisy_ops.append(op)
+            elif isinstance(op, (MOp, EMOp)):
+                pass
+            else:
+                msg = f"Operation type '{type(op)}' is not supported!"
+                raise NotImplementedError(msg)
+        return noisy_ops
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/error_model_abc.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/gates_init.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,37 +5,24 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-import abc
-from abc import ABCMeta
-from typing import Union
-
-
-class ErrorModel(metaclass=ABCMeta):
-
-    def __init__(self):
-        self.error_params = None
-        self.machine = None
-        self.num_qubits = None
-
-    @abc.abstractmethod
-    def reset(self) -> None:
-        """Reset state to initialization state."""
-        pass
-
-    def init(self, error_params, num_qubits, machine=None):
-        self.machine = machine
-        self.error_params = error_params
-        self.num_qubits = num_qubits
-
-    @abc.abstractmethod
-    def shot_reinit(self, *args, **kwargs) -> None:
-        """Run all code needed at the beginning of each shot, e.g., resetting state."""
-        pass
-
-    @abc.abstractmethod
-    def process(self, qops: list, **kwargs) -> Union[list, None]:
-        pass
+from typing import Any
+
+from pecos.simulators.custatevec.gates_meas import meas_z
+from pecos.simulators.custatevec.gates_one_qubit import X
+
+
+def init_zero(state, qubit: int, **params: Any) -> None:
+    """Initialise or reset the qubit to state |0>
+
+    Args:
+        state: An instance of CuStateVec
+        qubit: The index of the qubit to be initialised
+    """
+    result = meas_z(state, qubit)
+
+    if result:
+        X(state, qubit)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/fake_error_model.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/fake_error_model.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,18 +9,17 @@
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from pecos.error_models.parent_class_error_gen import ParentErrorModel
 
 
 class FakeErrorModel(ParentErrorModel):
-
-    def __init__(self, error_circuits):
-        super(FakeErrorModel, self).__init__()
+    def __init__(self, error_circuits) -> None:
+        super().__init__()
         self.error_circuits = error_circuits
         self.leaked_qubits = set()
 
     def start(self, *args, **kwargs):
         return self.error_circuits
 
     def generate_tick_errors(self, *args, **kwargs):
-        return self.error_circuits
+        return self.error_circuits
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/generic_error_model.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/generic_error_model.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,139 +5,154 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import List, Union
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
 
 import numpy as np
 
+from pecos.error_models.error_model_abc import ErrorModel
+from pecos.error_models.noise_impl.noise_initz_bitflip_leakage import noise_initz_bitflip_leakage
+from pecos.error_models.noise_impl.noise_meas_bitflip_leakage import noise_meas_bitflip_leakage
+from pecos.error_models.noise_impl.noise_sq_depolarizing_leakage import noise_sq_depolarizing_leakage
+from pecos.error_models.noise_impl.noise_tq_depolarizing_leakage import noise_tq_depolarizing_leakage
 from pecos.error_models.noise_impl_old.gate_groups import one_qubits, two_qubits
-from .error_model_abc import ErrorModel
-from ..reps.pypmir.block_types import SeqBlock
-from ..reps.pypmir.op_types import QOp
-
-from .noise_impl.noise_initz_bitflip_leakage import noise_initz_bitflip_leakage
-from .noise_impl.noise_sq_depolarizing_leakage import noise_sq_depolarizing_leakage
-from .noise_impl.noise_tq_depolarizing_leakage import noise_tq_depolarizing_leakage
-from .noise_impl.noise_meas_bitflip_leakage import noise_meas_bitflip_leakage
+
+if TYPE_CHECKING:
+    from pecos.reps.pypmir.block_types import SeqBlock
+    from pecos.reps.pypmir.op_types import QOp
 
 two_qubit_paulis = {
-    'IX', 'IY', 'IZ',
-    'XI', 'XX', 'XY', 'XZ',
-    'YI', 'YX', 'YY', 'YZ',
-    'ZI', 'ZX', 'ZY', 'ZZ',
+    "IX",
+    "IY",
+    "IZ",
+    "XI",
+    "XX",
+    "XY",
+    "XZ",
+    "YI",
+    "YX",
+    "YY",
+    "YZ",
+    "ZI",
+    "ZX",
+    "ZY",
+    "ZZ",
 }
 SYMMETRIC_P2_PAULI_MODEL = {p: 1 / 15 for p in two_qubit_paulis}
 
 one_qubit_paulis = {
-    'X', 'Y', 'Z',
+    "X",
+    "Y",
+    "Z",
 }
 SYMMETRIC_P1_PAULI_MODEL = {p: 1 / 3 for p in one_qubit_paulis}
 
 
 class GenericErrorModel(ErrorModel):
     """Parameterized error mode."""
 
-    def __init__(self):
-
-        super().__init__()
+    def __init__(self, error_params: dict) -> None:
+        super().__init__(error_params=error_params)
         self._eparams = None
 
     def reset(self):
         """Reset error generator for another round of syndrome extraction."""
-        return GenericErrorModel()
-
-    def init(self, error_params, num_qubits, machine=None):
+        return GenericErrorModel(error_params=self.error_params)
 
+    def init(self, num_qubits, machine=None):
         self.machine = machine
 
-        if not error_params:
-            raise Exception('Error params not set!')
+        if not self.error_params:
+            msg = "Error params not set!"
+            raise Exception(msg)
 
-        self._eparams = dict(error_params)
+        self._eparams = dict(self.error_params)
         self._scale()
 
         if "p1_error_model" not in self._eparams:
             self._eparams["p1_error_model"] = SYMMETRIC_P1_PAULI_MODEL
 
         if "p2_error_model" not in self._eparams:
             self._eparams["p2_error_model"] = SYMMETRIC_P2_PAULI_MODEL
 
         if "p2_mem" in self._eparams and "p2_mem_error_model" not in self._eparams:
             self._eparams["p2_mem_error_model"] = SYMMETRIC_P2_PAULI_MODEL
 
     def _scale(self):
-
         # conversion from average error to total error
-        self._eparams['p1'] *= (3 / 2)
-        self._eparams['p2'] *= (5 / 4)
+        self._eparams["p1"] *= 3 / 2
+        self._eparams["p2"] *= 5 / 4
 
-        scale = self._eparams.get('scale', 1.0)
-        self._eparams['p1'] *= scale
-        self._eparams['p2'] *= scale
+        scale = self._eparams.get("scale", 1.0)
+        self._eparams["p1"] *= scale
+        self._eparams["p2"] *= scale
 
-        if isinstance(self._eparams['p_meas'], tuple):
-            self._eparams['p_meas'] = np.mean(self._eparams['p_meas'])
+        if isinstance(self._eparams["p_meas"], tuple):
+            self._eparams["p_meas"] = np.mean(self._eparams["p_meas"])
 
-        self._eparams['p_meas'] *= scale
-        self._eparams['p_init'] *= scale
+        self._eparams["p_meas"] *= scale
+        self._eparams["p_init"] *= scale
 
     def shot_reinit(self) -> None:
         """Run all code needed at the beginning of each shot, e.g., resetting state."""
-        pass
-
-    def process(self, qops: List[QOp], call_back=None) -> List[Union[QOp, SeqBlock]]:
 
+    def process(self, qops: list[QOp], call_back=None) -> list[QOp | SeqBlock]:
         noisy_ops = []
 
         for op in qops:
-
             qops_after = None
             qops_before = None
             erroneous_ops = None
 
             # ########################################
             # INITS WITH X NOISE
-            if op.name in ['init |0>', "Init", "Init +Z"]:
-                qops_after = noise_initz_bitflip_leakage(op,
-                                                         p=self._eparams['p_init'],
-                                                         machine=self.machine)
+            if op.name in ["init |0>", "Init", "Init +Z"]:
+                qops_after = noise_initz_bitflip_leakage(op, p=self._eparams["p_init"], machine=self.machine)
 
             # ########################################
             # ONE QUBIT GATES
             elif op.name in one_qubits:
-                erroneous_ops = noise_sq_depolarizing_leakage(op,
-                                                              p=self._eparams['p1'],
-                                                              noise_dict=self._eparams["p1_error_model"],
-                                                              machine=self.machine)
+                erroneous_ops = noise_sq_depolarizing_leakage(
+                    op,
+                    p=self._eparams["p1"],
+                    noise_dict=self._eparams["p1_error_model"],
+                    machine=self.machine,
+                )
 
             # ########################################
             # TWO QUBIT GATES
             elif op.name in two_qubits:
-                qops_after = noise_tq_depolarizing_leakage(op,
-                                                           p=self._eparams['p2'],
-                                                           noise_dict=self._eparams["p2_error_model"],
-                                                           machine=self.machine)
-
-                if self._eparams.get('p2_mem'):
-                    qops_mem = noise_tq_depolarizing_leakage(op,
-                                                             p=self._eparams["p2_mem"],
-                                                             noise_dict=self._eparams["p2_mem_error_model"],
-                                                             machine=self.machine)
+                qops_after = noise_tq_depolarizing_leakage(
+                    op,
+                    p=self._eparams["p2"],
+                    noise_dict=self._eparams["p2_error_model"],
+                    machine=self.machine,
+                )
+
+                if self._eparams.get("p2_mem"):
+                    qops_mem = noise_tq_depolarizing_leakage(
+                        op,
+                        p=self._eparams["p2_mem"],
+                        noise_dict=self._eparams["p2_mem_error_model"],
+                        machine=self.machine,
+                    )
 
                     if qops_after:
                         qops_after = qops_after.extend(qops_mem)
 
             # ########################################
             # MEASURE X NOISE
-            elif op.name in ['measure Z', "Measure", "Measure +Z"]:
-                erroneous_ops = noise_meas_bitflip_leakage(op, p=self._eparams['p_meas'], machine=self.machine)
+            elif op.name in ["measure Z", "Measure", "Measure +Z"]:
+                erroneous_ops = noise_meas_bitflip_leakage(op, p=self._eparams["p_meas"], machine=self.machine)
 
             else:
                 raise Exception("This error model doesn't handle gate: %s!" % op.name)
 
             if qops_before:
                 noisy_ops.extend(qops_before)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/classical_interpreters/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_initz_bitflip.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_initz_bitflip.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,24 +5,21 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
-import numpy as np
 
-from .noise_sq_bitflip import noise_sq_bitflip
+from pecos.error_models.noise_impl.noise_sq_bitflip import noise_sq_bitflip
+from pecos.reps.pypmir.op_types import QOp
 
 
-def noise_initz_bitflip(op: QOp,
-                        p: float):
+def noise_initz_bitflip(op: QOp, p: float):
     """The noise model for qubit (re)initialization.
 
-
     Args:
+    ----
         op: Ideal quantum operation.
         p: Probability of bitflip.
     """
-
     return noise_sq_bitflip(op, p)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_initz_bitflip_leakage.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_initz_bitflip_leakage.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,29 +5,26 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
-from .noise_initz_bitflip import noise_initz_bitflip
+from pecos.error_models.noise_impl.noise_initz_bitflip import noise_initz_bitflip
+from pecos.reps.pypmir.op_types import QOp
 
 
-def noise_initz_bitflip_leakage(op: QOp,
-                                p: float,
-                                machine):
+def noise_initz_bitflip_leakage(op: QOp, p: float, machine):
     """The noise model for qubit (re)initialization, including leakage support.
 
-
     Args:
+    ----
         op: Ideal quantum operation.
         p: Probability of bitflip.
     """
-
     args = set(op.args)
     leaked = machine.leaked_qubits & args
 
     noise = []
     noisy_ops = machine.unleak(leaked)
     if noise:
         noise.extend(noisy_ops)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_meas_bitflip.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/memory_noise.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,51 +1,39 @@
-# Copyright 2023 The PECOS Developers
+# Copyright 2021 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
-import numpy as np
-
+from __future__ import annotations
 
-def noise_meas_bitflip(op: QOp,
-                       p: float):
-    """Bit-flip noise model for measurements.
+from typing import TYPE_CHECKING
 
-    Args:
-        op: Ideal quantum operation.
-        p: measurement error rate.
-    """
+import numpy as np
 
-    # Bit flip noise
-    # --------------
-    rand_nums = np.random.random(len(op.args)) <= p
+if TYPE_CHECKING:
+    from pecos import QuantumCircuit
 
-    noise = []
 
-    if np.any(rand_nums):
+def noise_tq_mem(locations: set[tuple[int, int]], after: QuantumCircuit, p: float) -> None:
+    """The memory noise model for idling qubits.
 
-        bitflips = []
-        for r, loc in zip(rand_nums, op.args):
+    Args:
+    ----
+        locations: Set of qubits the ideal gates act on.
+        after: QuantumCircuit collecting the noise that occurs after the ideal gates.
+    """
+    err_qubits = set()
+    for locs in locations:
+        rand_nums = np.random.random(len(locs)) <= p
 
+        for r, loc in zip(rand_nums, locs):
             if r:
-                bitflips.append(loc)
-
-        noisy_op = QOp(
-            name="Measure",
-            args=list(op.args),
-            returns=list(op.returns),
-            metadata=dict(op.metadata)
-        )
-        noisy_op.metadata["bitflips"] = bitflips
-        noise.append(noisy_op)
-
-        return noise
+                err_qubits.add(loc)
 
-    else:
-        return noise
+    if err_qubits:
+        after.append("Z", err_qubits)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_meas_bitflip_leakage.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_meas_bitflip_leakage.py`

 * *Files 7% similar despite different names*

```diff
@@ -5,53 +5,50 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
 import numpy as np
 
+from pecos.reps.pypmir.op_types import QOp
 
-def noise_meas_bitflip_leakage(op: QOp,
-                               p: float,
-                               machine):
+
+def noise_meas_bitflip_leakage(op: QOp, p: float, machine):
     """Bit-flip noise model for measurements.
 
     Args:
+    ----
         op: Ideal quantum operation.
         p: measurement error rate.
     """
-
     # Bit flip noise
     # --------------
     rand_nums = np.random.random(len(op.args)) <= p
 
     noise = []
 
     leakded = machine.leaked_qubits & set(op.args)
     if leakded:
         noisy_ops = machine.meas_leaked(leakded)
         noise.extend(noisy_ops)
 
     if np.any(rand_nums):
-
         bitflips = []
         for r, loc in zip(rand_nums, op.args):
-
             if r:
                 bitflips.append(loc)
 
         noisy_op = QOp(
             name="Measure",
             args=list(op.args),
             returns=list(op.returns),
-            metadata=dict(op.metadata)
+            metadata=dict(op.metadata),
         )
         noisy_op.metadata["bitflips"] = bitflips
         noise.append(noisy_op)
 
         return noise
 
     else:
-        return noise
+        return noise
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_sq_bitflip.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_sq_bitflip.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,33 +5,33 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
 import numpy as np
 
+from pecos.reps.pypmir.op_types import QOp
 
-def noise_sq_bitflip(op: QOp,
-                     p: float):
-    """The noise model for qubit (re)initialization.
 
+def noise_sq_bitflip(op: QOp, p: float):
+    """The noise model for qubit (re)initialization.
 
     Args:
+    ----
         op: Ideal quantum operation.
         p: Probability of bitflip.
     """
-
     rand_nums = np.random.random(len(op.args)) <= p
 
     if np.any(rand_nums):
         flip_locs = []
         for r, loc in zip(rand_nums, op.args):
             if r:
                 flip_locs.append(loc)
 
             return [QOp(name="X", args=flip_locs, metadata={})]
+        return None
 
     else:
         return None
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_sq_depolarizing.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_sq_depolarizing.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,22 +5,20 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
 import numpy as np
 
+from pecos.reps.pypmir.op_types import QOp
 
-def noise_sq_depolarizing(op: QOp,
-                          p: float,
-                          noise_dict: dict):
 
+def noise_sq_depolarizing(op: QOp, p: float, noise_dict: dict):
     rand_nums = np.random.random(len(op.args)) <= p
 
     noise = {}
     if np.any(rand_nums):
         for r, loc in zip(rand_nums, op.args):
             if r:
                 rand = np.random.random()
@@ -32,18 +30,16 @@
                         noise.setdefault(fault1, []).append(loc)
                         break
 
     if noise:
         buffered_ops = []
 
         if noise:
-
             for sym, args in noise.items():
-                buffered_ops.append(op)
-                buffered_ops.append(QOp(name=sym, args=args, metadata={}))
+                buffered_ops.extend((op, QOp(name=sym, args=args, metadata={})))
 
         else:
             buffered_ops.append(op)
 
         return buffered_ops
 
     return None
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_sq_depolarizing_leakage.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_sq_depolarizing_leakage.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,23 +5,20 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
 import numpy as np
 
+from pecos.reps.pypmir.op_types import QOp
 
-def noise_sq_depolarizing_leakage(op: QOp,
-                                  p: float,
-                                  noise_dict: dict,
-                                  machine):
 
+def noise_sq_depolarizing_leakage(op: QOp, p: float, noise_dict: dict, machine):
     args = set(op.args)
     leaked = machine.leaked_qubits & args
 
     if leaked:
         not_leaked = args - leaked
         noisy_op = QOp(name=op.name, args=list(not_leaked), metadata=dict(op.metadata))
     else:
@@ -42,22 +39,20 @@
                         noise.setdefault(fault1, []).append(loc)
                         break
 
     if noise or leaked:
         buffered_ops = []
 
         if noise:
-
             for sym, args in noise.items():
                 if sym == "L":
                     leak_ops = machine.leak(set(noise["L"]))
                     buffered_ops.extend(leak_ops)
                 else:
-                    buffered_ops.append(noisy_op)
-                    buffered_ops.append(QOp(name=sym, args=args, metadata={}))
+                    buffered_ops.extend((noisy_op, QOp(name=sym, args=args, metadata={})))
 
         else:
             buffered_ops.append(noisy_op)
 
         return buffered_ops
 
     return None
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_tq_depolarizing.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_tq_depolarizing.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,21 +5,20 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
 import numpy as np
 
+from pecos.reps.pypmir.op_types import QOp
 
-def noise_tq_depolarizing(op: QOp,
-                          p: float,
-                          noise_dict: dict):
+
+def noise_tq_depolarizing(op: QOp, p: float, noise_dict: dict):
     rand_nums = np.random.random(len(op.args)) <= p
 
     if np.any(rand_nums):
         noise = {}
         for r, loc in zip(rand_nums, op.args):
             if r:
                 rand = np.random.random()
@@ -33,15 +32,16 @@
                             noise.setdefault(fault1, []).append(loc1)
                         if fault2 != "I":
                             noise.setdefault(fault2, []).append(loc2)
                         break
 
         if noise:
             if "L" in noise:
-                raise NotImplementedError("Not implemented yet!")
+                msg = "Not implemented yet!"
+                raise NotImplementedError(msg)
 
             buffered_ops = []
             for sym, args in noise.items():
                 buffered_ops.append(QOp(name=sym, args=args, metadata={}))
             return buffered_ops
 
-    return None
+    return None
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl/noise_tq_depolarizing_leakage.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/noise_tq_depolarizing_leakage.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,24 +5,21 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...reps.pypmir.op_types import QOp
 import numpy as np
 
+from pecos.reps.pypmir.op_types import QOp
 
-def noise_tq_depolarizing_leakage(op: QOp,
-                                  p: float,
-                                  noise_dict: dict,
-                                  machine):
-    """Two-qubit gate depolarizing noise plus leakage."""
 
+def noise_tq_depolarizing_leakage(op: QOp, p: float, noise_dict: dict, machine):
+    """Two-qubit gate depolarizing noise plus leakage."""
     # TODO: precompute, in PyPMIR, a flattened version of args
     args = set()
     for a in op.args:
         for q in a:
             args.add(q)
 
     leaked = machine.leaked_qubits & args
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/init_noise.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/meas_noise.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,30 +5,36 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Sequence
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
 import numpy as np
-from pecos import QuantumCircuit
 
+if TYPE_CHECKING:
+    from pecos import QuantumCircuit
 
-def noise_init_bitflip(locations: Sequence[int],
-                       after: QuantumCircuit,
-                       flip: str,
-                       p: float) -> None:
-    """The noise model for qubit (re)initialization.
 
+def noise_meas_bitflip(locations: set[int], metadata: dict, after: QuantumCircuit, p: float) -> None:
+    """Bit-flip noise model for measurements.
 
     Args:
+    ----
         locations: Set of qubits the ideal gates act on.
+        metadata: Extra information about the gate.
         after: QuantumCircuit collecting the noise that occurs after the ideal gates.
-        flip: The symbol for what Pauli operator should be applied if an initialization fault occurs.
+        flip: The symbol for what Pauli operator should be applied if a measurement fault occurs.
     """
-
+    # Bit flip noise
+    # --------------
     rand_nums = np.random.random(len(locations)) <= p
 
     for r, loc in zip(rand_nums, locations):
         if r:
-            after.append(flip, {loc})
+            var = metadata["var_output"][loc] if metadata.get("var_output") else metadata["var"]
+
+            after.append("cop", {loc}, expr={"t": var, "a": var, "op": "^", "b": 1})  # flip output bit
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/meas_noise.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/init_noise.py`

 * *Files 19% similar despite different names*

```diff
@@ -5,40 +5,33 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Set
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
 import numpy as np
-from pecos import QuantumCircuit
+
+if TYPE_CHECKING:
+    from collections.abc import Sequence
+
+    from pecos import QuantumCircuit
 
 
-def noise_meas_bitflip(
-        locations: Set[int],
-        metadata: dict,
-        after: QuantumCircuit,
-        p: float) -> None:
-    """Bit-flip noise model for measurements.
+def noise_init_bitflip(locations: Sequence[int], after: QuantumCircuit, flip: str, p: float) -> None:
+    """The noise model for qubit (re)initialization.
 
     Args:
+    ----
         locations: Set of qubits the ideal gates act on.
-        metadata: Extra information about the gate.
         after: QuantumCircuit collecting the noise that occurs after the ideal gates.
-        flip: The symbol for what Pauli operator should be applied if a measurement fault occurs.
+        flip: The symbol for what Pauli operator should be applied if an initialization fault occurs.
     """
-
-    # Bit flip noise
-    # --------------
     rand_nums = np.random.random(len(locations)) <= p
 
     for r, loc in zip(rand_nums, locations):
-
         if r:
-
-            if metadata.get('var_output'):
-                var = metadata['var_output'][loc]
-            else:
-                var = metadata['var']
-
-            after.append('cop', {loc}, expr={'t': var, 'a': var, 'op': '^', 'b': 1})  # flip output bit
+            after.append(flip, {loc})
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/memory_noise.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cointoss/gates.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,37 +1,41 @@
-# Copyright 2021 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Set, Tuple
+from typing import Any
+
 import numpy as np
-from pecos import QuantumCircuit
 
 
-def noise_tq_mem(locations: Set[Tuple[int, int]],
-                 after: QuantumCircuit,
-                 p: float) -> None:
-    """The memory noise model for idling qubits.
+def ignore_gate(state, qubits: int, **params: Any) -> None:
+    """
+    Ignore the gate.
 
     Args:
-        locations: Set of qubits the ideal gates act on.
-        after: QuantumCircuit collecting the noise that occurs after the ideal gates.
+        state: An instance of ``CoinToss``.
+        qubits: The qubits the gate was applied to.
+
+    Returns:
+
     """
 
-    err_qubits = set()
-    for locs in locations:
-        rand_nums = np.random.random(len(locs)) <= p
 
-        for r, loc in zip(rand_nums, locs):
+def measure(state, qubits: int, **params: Any):
+    """
+    Return |1> with probability ``state.prob`` or |0> otherwise.
+
+    Args:
+        state: An instance of ``CoinToss``.
+        qubit: The qubit the measurement is applied to.
 
-            if r:
-                err_qubits.add(loc)
+    Returns:
 
-    if err_qubits:
-        after.append('Z', err_qubits)
+    """
+    return 1 if np.random.random() < state.prob else 0
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/sq_noise.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/sq_noise.py`

 * *Files 18% similar despite different names*

```diff
@@ -5,25 +5,27 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Set
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
 import numpy as np
-from pecos import QuantumCircuit
-from .gate_groups import error_one_paulis_collection
 
+from pecos.error_models.noise_impl_old.gate_groups import error_one_paulis_collection
 
-def noise_depolarizing_sq_gate(
-        locations: Set[int],
-        after: QuantumCircuit,
-        p: float) -> None:
-    """Apply a symmetric depolarizing noise model."""
+if TYPE_CHECKING:
+    from pecos import QuantumCircuit
 
+
+def noise_depolarizing_sq_gate(locations: set[int], after: QuantumCircuit, p: float) -> None:
+    """Apply a symmetric depolarizing noise model."""
     rand_nums = np.random.random(len(locations)) <= p
 
     for r, loc in zip(rand_nums, locations):
         if r:
             err = np.random.choice(error_one_paulis_collection)
             after.append(err, {loc})
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/noise_impl_old/tq_noise.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl_old/tq_noise.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,79 +5,80 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Set, Tuple, Optional
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
 import numpy as np
-from pecos import QuantumCircuit
-from .gate_groups import error_one_paulis_collection, error_two_paulis_collection
 
+from pecos.error_models.noise_impl_old.gate_groups import error_one_paulis_collection, error_two_paulis_collection
+
+if TYPE_CHECKING:
+    from pecos import QuantumCircuit
 
-def noise_depolarizing_two_qubit_gates(locations: Set[Tuple[int, int]],
-                                       after: QuantumCircuit,
-                                       p: float) -> None:
+
+def noise_depolarizing_two_qubit_gates(locations: set[tuple[int, int]], after: QuantumCircuit, p: float) -> None:
     """Symmetric depolarizing noise for two-qubit gates.
 
     # TODO: Describe noise model
 
     Args:
+    ----
         locations: Set of tuples of qubit pairs the ideal gates act on.
         after: QuantumCircuit collecting the noise that occurs after the ideal gates.
     """
-
     rand_nums = np.random.random(len(locations)) <= p
 
     for r, (loc1, loc2) in zip(rand_nums, locations):
-
         if r:
-
             index = np.random.choice(len(error_two_paulis_collection))
             err1, err2 = error_two_paulis_collection[index]
 
             if err1:
                 after.append(err1, {loc1})
 
             if err2:
                 after.append(err2, {loc2})
 
 
-def noise_two_qubit_gates_depolarizing_with_noiseless(locations: Set[Tuple[int, int]],
-                                                      after: QuantumCircuit,
-                                                      p: float,
-                                                      noiseless_qubits: Optional[Set[int]] = None) -> None:
+def noise_two_qubit_gates_depolarizing_with_noiseless(
+    locations: set[tuple[int, int]],
+    after: QuantumCircuit,
+    p: float,
+    noiseless_qubits: set[int] | None = None,
+) -> None:
     """Noise for two-qubit gates.
 
     Args:
+    ----
         locations: Set of tuples of qubit pairs the ideal gates act on.
         after: QuantumCircuit collecting the noise that occurs after the ideal gates.
     """
-
     rand_nums = np.random.random(len(locations)) <= p
 
     for r, (loc1, loc2) in zip(rand_nums, locations):
-
         if r:
-
             if loc1 in noiseless_qubits and loc1 in noiseless_qubits:
                 continue
 
             elif loc1 in noiseless_qubits:
                 err = np.random.choice(error_one_paulis_collection)
                 after.append(err, {loc2})
 
             elif loc2 in noiseless_qubits:
                 err = np.random.choice(error_one_paulis_collection)
                 after.append(err, {loc1})
 
             else:
-
                 index = np.random.choice(len(error_two_paulis_collection))
                 err1, err2 = error_two_paulis_collection[index]
 
                 if err1:
                     after.append(err1, {loc1})
 
                 if err2:
-                    after.append(err2, {loc2})
+                    after.append(err2, {loc2})
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/old/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/old/depolar_gen.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/xzerror_gen.py`

 * *Files 25% similar despite different names*

```diff
@@ -7,184 +7,178 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Simple error generator meant to demonstrate a basic error generator that produces errors.
-"""
-from pecos.error_models.class_errors_circuit import ErrorCircuits
+"""Simple error generator meant to demonstrate a basic error generator that produces errors."""
+
+from __future__ import annotations
+
+from typing import ClassVar
+
 from pecos.circuits.quantum_circuit import QuantumCircuit
+from pecos.error_models.class_errors_circuit import ErrorCircuits
 from pecos.error_models.parent_class_error_gen import ParentErrorModel
 
 
-class DepolarModel(ParentErrorModel):
-    """
-    A simple error generator for the depolarizing model.
+class XZModel(ParentErrorModel):
+    """A simple error generator for the depolarizing model.
 
     This error generator does not allow much modification of the error model.
     """
 
-    measurements = {'measure X', 'measure Y', 'measure Z'}
-    inits = {'init |0>', 'init |1>', 'init |+>', 'init |->', 'init |+i>', 'init |-i>'}
-    two_qubits = {'CNOT', 'CZ', 'SWAP', 'G'}
-
-    inits_z = {'init |0>', 'init |1>'}
-    inits_x = {'init |+>', 'init |->'}
-    inits_y = {'init |+i>', 'init |-i>'}
-
-    error_two_paulis_collection = [
-        ('I', 'X'), ('I', 'Y'), ('I', 'Z'),
-        ('X', 'I'), ('X', 'X'), ('X', 'Y'), ('X', 'Z'),
-        ('Y', 'I'), ('Y', 'X'), ('Y', 'Y'), ('Y', 'Z'),
-        ('Z', 'I'), ('Z', 'X'), ('Z', 'Y'), ('Z', 'Z')]
-
-    def __init__(self, model_level='circuit', has_idle_errors=False, perp_errors=False):
-        """
-
-        Args:
+    measurements: ClassVar[set[str]] = {"measure X", "measure Y", "measure Z"}
+    inits: ClassVar[set[str]] = {"init |0>", "init |1>", "init |+>", "init |->", "init |+i>", "init |-i>"}
+    two_qubits: ClassVar[set[str]] = {"CNOT", "CZ", "SWAP", "G"}
+
+    inits_z: ClassVar[set[str]] = {"init |0>", "init |1>"}
+    inits_x: ClassVar[set[str]] = {"init |+>", "init |->"}
+    inits_y: ClassVar[set[str]] = {"init |+i>", "init |-i>"}
+
+    error_two_paulis_collection: ClassVar[list[tuple[str, str]]] = [
+        ("I", "X"),
+        ("I", "Z"),
+        ("X", "I"),
+        ("X", "X"),
+        ("X", "Z"),
+        ("Z", "I"),
+        ("Z", "X"),
+        ("Z", "Z"),
+    ]
+
+    def __init__(self, model_level="circuit", has_idle_errors=False, perp_errors=False) -> None:
+        """Args:
+        ----
             model_level(str):
             has_idle_errors(bool):
             perp_errors(bool):
         """
-
         super().__init__()
 
         self.has_idle_errors = has_idle_errors
-        self.perp_errors = perp_errors
+        self.perp_error = perp_errors
 
         self.gen = self.generator_class()
-        self.gen.set_gate_group('measurements', self.measurements)
-        self.gen.set_gate_group('inits', self.inits)
-        self.gen.set_gate_group('two_qubits', self.two_qubits)
-
-        xerror = self.gen.ErrorStaticSymbol('X')
-        zerror = self.gen.ErrorStaticSymbol('Z')
-        xerror_before = self.gen.ErrorStaticSymbol('X', after=False)
-        zerror_before = self.gen.ErrorStaticSymbol('Z', after=False)
-        pauli_errors = self.gen.ErrorSet({'X', 'Y', 'Z'})
-        pauli_errors_before = self.gen.ErrorSet({'X', 'Y', 'Z'}, after=False)
+        self.gen.set_gate_group("measurements", self.measurements)
+        self.gen.set_gate_group("inits", self.inits)
+        self.gen.set_gate_group("two_qubits", self.two_qubits)
+
+        xerror = self.gen.ErrorStaticSymbol("X")
+        zerror = self.gen.ErrorStaticSymbol("Z")
+        xerror_before = self.gen.ErrorStaticSymbol("X", after=False)
+        zerror_before = self.gen.ErrorStaticSymbol("Z", after=False)
+        pauli_errors = self.gen.ErrorSet({"X", "Z"})
+        pauli_errors_before = self.gen.ErrorSet({"X", "Z"}, after=False)
         two_pauli_errors = self.gen.ErrorSetTwoQuditTensorProduct(self.error_two_paulis_collection)
 
-        if model_level == 'code_capacity':
-
+        if model_level == "code_capacity":
             self.has_data_errors = True
             self.has_unitary_errors = False
             self.has_meas_errors = False
 
             # Data qubit errors
-            self.gen.set_gate_error('data', pauli_errors.error_func)
+            self.gen.set_gate_error("data", pauli_errors.error_func)
 
             # Don't generate any other errors
 
-        elif model_level == 'phenomenological':
-
+        elif model_level == "phenomenological":
             self.has_data_errors = True
             self.has_unitary_errors = False
             self.has_meas_errors = True
 
             # Generate data errors
-            self.gen.set_default_error('data', pauli_errors.error_func)
+            self.gen.set_default_error("data", pauli_errors.error_func)
 
             # Generate measurement errors
-            self.gen.set_group_error('measurements', pauli_errors_before.error_func)
+            self.gen.set_group_error("measurements", pauli_errors_before.error_func)
             # Don't generate any other errors
 
-        elif model_level == 'circuit':
-
+        elif model_level == "circuit":
             self.has_data_errors = False
             self.has_unitary_errors = True
             self.has_meas_errors = True
 
             # Don't generate data errors
-            self.gen.set_gate_error('data', False)  # Don't generate errors for data qudits.
+            self.gen.set_gate_error("data", False)  # Don't generate errors for data qudits.
 
             # Generate measurement errors (before errors)
-            self.gen.set_group_error('measurements', pauli_errors_before.error_func)
+            self.gen.set_group_error("measurements", pauli_errors_before.error_func)
             # Set two-qubits
-            self.gen.set_group_error('two_qubits', two_pauli_errors.error_func)
+            self.gen.set_group_error("two_qubits", two_pauli_errors.error_func)
             # By default generate pauli errors. (It is expected that this is only for one-qubit and init gates.)
             self.gen.set_default_error(pauli_errors.error_func)
         else:
-            raise Exception('Can not handle model_level == %s' % model_level)
+            raise Exception("Can not handle model_level == %s" % model_level)
 
         # If errors need to be perpendicular to inits and measurements.
-        if self.perp_errors and model_level != 'code_capacity':
-            self.gen.set_gate_error('measure X', zerror_before.error_func)
-            self.gen.set_gate_error('measure Y', zerror_before.error_func)
-            self.gen.set_gate_error('measure Z', xerror_before.error_func)
-
-            if model_level == 'circuit':
-                self.gen.set_gate_group('Z on inits', {'init |+>', 'init |->', 'init |+i>', 'init |-i>', })
-                self.gen.set_gate_group('X on inits', {'init |0>', 'init |1>', })
-                self.gen.set_group_error('Z on inits', zerror.error_func)
-                self.gen.set_group_error('X on inits', xerror.error_func)
+        if self.perp_error and model_level != "code_capacity":
+            self.gen.set_gate_error("measure X", zerror_before.error_func)
+            self.gen.set_gate_error("measure Y", zerror_before.error_func)
+            self.gen.set_gate_error("measure Z", xerror_before.error_func)
+
+            if model_level == "circuit":
+                self.gen.set_group_error(self.inits_x, zerror.error_func)
+                self.gen.set_group_error(self.inits_y, zerror.error_func)
+                self.gen.set_group_error(self.inits_z, xerror.error_func)
 
         if has_idle_errors:
-            self.gen.set_gate_error('idle', pauli_errors.error_func)
+            self.gen.set_gate_error("idle", pauli_errors.error_func)
 
     def start(self, circuit, error_params):
-        """
-        Start up at the beginning of a circuit simulation.
+        """Start up at the beginning of a circuit simulation.
 
         Args:
+        ----
             circuit:
             error_params:
 
         Returns:
+        -------
 
         """
-
         self.error_circuits = ErrorCircuits()
         self.circuit = circuit
         self.error_params = error_params
 
         return self.error_circuits
 
     def generate_tick_errors(self, tick_circuit, time, **params):
-        """
-        Returns before errors, after errors, and replaced locations for the given key (args).
+        """Returns before errors, after errors, and replaced locations for the given key (args).
 
         Returns:
+        -------
 
         """
-
-        if isinstance(time, tuple):
-            tick_index = time[-1]
-        else:
-            tick_index = time
+        tick_index = time[-1] if isinstance(time, tuple) else time
 
         circuit = tick_circuit.circuit
 
         # Simple model where for each gate there is a probability "p" for an X, Y, or Z error to occur.
 
         before = QuantumCircuit()
         after = QuantumCircuit()
-        replace = set([])
-
-        # if circuit.qudits != circuit.active_qudits:
-        #     raise Exception(circuit.active_qudits, circuit.qudits)
+        replace = set()
 
         # Data errors
         # -----------
         if self.has_data_errors and tick_index == 0:
-            data_qudits = params['data_qudit_set']
-            self.gen.create_errors(self, 'data', data_qudits, after, before, replace)
+            data_qudit_set = params["data_qudit_set"]
+
+            self.gen.create_errors(self, "data", data_qudit_set, after, before, replace)
 
         # unitary and measurement errors
         # ------------------------------
         if self.has_meas_errors or self.has_unitary_errors:
-            for symbol, gate_locations, _ in circuit.items(tick=tick_index):
-
+            for symbol, gate_locations, _ in circuit.items(tick_index):
                 self.gen.create_errors(self, symbol, gate_locations, after, before, replace)
 
         # idle errors
         # -----------
         if self.has_idle_errors:
             inactive_qudits = circuit.qudits - circuit.active_qudits[tick_index]
-            self.gen.create_errors(self, 'idle', inactive_qudits, after, before, replace)
+            self.gen.create_errors(self, "idle", inactive_qudits, after, before, replace)
 
         self.error_circuits.add_circuits(time, before, after)
 
         return self.error_circuits
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/old/gatewise_gen.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/gatewise_gen.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,52 +7,81 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Simple error generator meant to demonstrate a basic error generator that produces errors.
-"""
-from pecos.error_models.class_errors_circuit import ErrorCircuits
+"""Simple error generator meant to demonstrate a basic error generator that produces errors."""
+
+from __future__ import annotations
+
+from typing import ClassVar
+
 from pecos.circuits.quantum_circuit import QuantumCircuit
+from pecos.error_models.class_errors_circuit import ErrorCircuits
 from pecos.error_models.parent_class_error_gen import ParentErrorModel
 
 
 class GatewiseModel(ParentErrorModel):
-    """
-    A simple error generator for the depolarizing model.
+    """A simple error generator for the depolarizing model.
 
     This error generator does not allow much modification of the error model.
     """
 
-    measurements = {'measure X', 'measure Y', 'measure Z'}
-    inits = {'init |0>', 'init |1>', 'init |+>', 'init |->', 'init |+i>', 'init |-i>'}
-    two_qubits = {'CNOT', 'CZ', 'SWAP', 'G'}
-    one_qubits = {'I', 'X', 'Y', 'Z', 'Q', 'Qd', 'R', 'Rd', 'S', 'Sd', 'H', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
-                  'H+z+x', 'H-z-x', 'H+y-z', 'H-y-z', 'H-x+y', 'H-x-y',
-                  'F1', 'F1d', 'F2', 'F2d', 'F3', 'F3d', 'F4', 'F4d'
-                  }
-
-    inits_z = {'init |0>', 'init |1>'}
-    inits_x = {'init |+>', 'init |->'}
-    inits_y = {'init |+i>', 'init |-i>'}
+    measurements: ClassVar[set[str]] = {"measure X", "measure Y", "measure Z"}
+    inits: ClassVar[set[str]] = {"init |0>", "init |1>", "init |+>", "init |->", "init |+i>", "init |-i>"}
+    two_qubits: ClassVar[set[str]] = {"CNOT", "CZ", "SWAP", "G"}
+    one_qubits: ClassVar[set[str]] = {
+        "I",
+        "X",
+        "Y",
+        "Z",
+        "Q",
+        "Qd",
+        "R",
+        "Rd",
+        "S",
+        "Sd",
+        "H",
+        "H1",
+        "H2",
+        "H3",
+        "H4",
+        "H5",
+        "H6",
+        "H+z+x",
+        "H-z-x",
+        "H+y-z",
+        "H-y-z",
+        "H-x+y",
+        "H-x-y",
+        "F1",
+        "F1d",
+        "F2",
+        "F2d",
+        "F3",
+        "F3d",
+        "F4",
+        "F4d",
+    }
+
+    inits_z: ClassVar[set[str]] = {"init |0>", "init |1>"}
+    inits_x: ClassVar[set[str]] = {"init |+>", "init |->"}
+    inits_y: ClassVar[set[str]] = {"init |+i>", "init |-i>"}
 
-    def __init__(self):
-        """
-
-        """
+    def __init__(self) -> None:
+        """ """
 
         super().__init__()
         self.gen = self.generator_class()
-        self.gen.set_gate_group('measurements', self.measurements)
-        self.gen.set_gate_group('inits', self.inits)
-        self.gen.set_gate_group('two_qubits', self.two_qubits)
-        self.gen.set_gate_group('one_qubits', self.one_qubits)
+        self.gen.set_gate_group("measurements", self.measurements)
+        self.gen.set_gate_group("inits", self.inits)
+        self.gen.set_gate_group("two_qubits", self.two_qubits)
+        self.gen.set_gate_group("one_qubits", self.one_qubits)
 
         # Inherit gen methods
         self.set_gate_error = self.gen.set_gate_error
         self.set_group_error = self.gen.set_group_error
         self.set_default_error = self.gen.set_default_error
         self.set_gate_group = self.gen.set_gate_group
 
@@ -60,94 +89,85 @@
 
         # Inherit error function classes
         self.ErrorStaticSymbol = self.gen.ErrorStaticSymbol
         self.ErrorSet = self.gen.ErrorSet
         self.ErrorSetTwoQuditTensorProduct = self.gen.ErrorSetTwoQuditTensorProduct
 
     def start(self, circuit, error_params):
-        """
-        Start up at the beginning of a circuit simulation.
+        """Start up at the beginning of a circuit simulation.
 
         Args:
+        ----
             circuit:
             error_params:
 
         Returns:
+        -------
 
         """
-
         self.error_circuits = ErrorCircuits()
         self.circuit = circuit
         self.error_params = error_params
 
         return self.error_circuits
 
     def generate_tick_errors(self, tick_circuit, time, **params):
-        """
-        Returns before errors, after errors, and replaced locations for the given key (args).
+        """Returns before errors, after errors, and replaced locations for the given key (args).
 
         Returns:
+        -------
 
         """
-
-        if isinstance(time, tuple):
-            tick_index = time[-1]
-        else:
-            tick_index = time
+        tick_index = time[-1] if isinstance(time, tuple) else time
 
         circuit = tick_circuit.circuit
 
         # Simple model where for each gate there is a probability "p" for an X, Y, or Z error to occur.
 
         before = QuantumCircuit()
         after = QuantumCircuit()
-        replace = set([])
+        replace = set()
 
         # Data errors
         # -----------
-        if tick_index == 0 and 'data' in self.gen.error_func_dict:
-            data_qudit_set = params['data_qudit_set']
-            self.gen.create_errors(self, 'data', data_qudit_set, after, before, replace)
+        if tick_index == 0 and "data" in self.gen.error_func_dict:
+            data_qudit_set = params["data_qudit_set"]
+            self.gen.create_errors(self, "data", data_qudit_set, after, before, replace)
 
         # unitary and measurement errors
         # ------------------------------
         for symbol, gate_locations, _ in circuit.items(tick_index):
-
             self.gen.create_errors(self, symbol, gate_locations, after, before, replace)
 
         # idle errors
         # -----------
-        if 'idle' in self.gen.error_func_dict:
-
+        if "idle" in self.gen.error_func_dict:
             inactive_qudits = circuit.qudits - circuit.active_qudits[tick_index]
 
-            if tick_index == 0 and 'data' in self.gen.error_func_dict:
-                data_qudit_set = params['data_qudit_set']
+            if tick_index == 0 and "data" in self.gen.error_func_dict:
+                data_qudit_set = params["data_qudit_set"]
                 inactive_qudits -= data_qudit_set
 
-            self.gen.create_errors(self, 'idle', inactive_qudits, after, before, replace)
+            self.gen.create_errors(self, "idle", inactive_qudits, after, before, replace)
 
         self.error_circuits.add_circuits(time, before, after)
 
-        # return {'before': before, 'after': after}
-
         return self.error_circuits
 
     def get_gate_error(self, symbol, gate_locations, error_params):
-        """
-
-        Args:
+        """Args:
+        ----
             symbol:
             gate_locations:
             error_params:
 
         Returns:
+        -------
 
         """
-
         self.error_params = error_params
 
         before = QuantumCircuit()
         after = QuantumCircuit()
-        replace = set([])
+        replace = set()
         self.gen.create_errors(self, symbol, gate_locations, after, before, replace)
         return after, before, replace
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/old/xerror_gen.py` & `quantum_pecos-0.6.0.dev1/python/pecos/tools/fault_tolerance_checking.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,171 +1,195 @@
-# Copyright 2018 The PECOS Developers
-# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
-# DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
+# Copyright 2022 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Simple error generator meant to demonstrate a basic error generator that produces errors.
-"""
-from pecos.error_models.class_errors_circuit import ErrorCircuits
-from pecos.circuits.quantum_circuit import QuantumCircuit
-from pecos.error_models.parent_class_error_gen import ParentErrorModel
+from __future__ import annotations
 
+from itertools import permutations, product
+from typing import TYPE_CHECKING, Callable
 
-class XModel(ParentErrorModel):
-    """
-    A simple error generator for the depolarizing model.
+from pecos import QuantumCircuit
+from pecos.engines.circuit_runners import Standard
+from pecos.simulators import SparseSim
+
+if TYPE_CHECKING:
+    from collections.abc import Sequence
+
+
+def find_pauli_fault(
+    qcirc: QuantumCircuit,
+    wt: int,
+    fail_func: Callable,
+    num_qubits: int | None = None,
+    simulator: str = "stabilizer",
+    *,
+    verbose: bool = True,
+    failure_break: bool = True,
+) -> list[dict | tuple[dict, dict]]:
+    """Determines if there is a Pauli fault for the entire quantum circuit.
+
+    TODO: Need to be able to only check a portion of the circuit.
+    TODO: Need to add Wasm support.
+
+    Args:
+    ----
+        qcirc: QuantumCircuit
+        wt: Number of errors to apply.
+        fail_func: A callable (e.g., function) that determines if a result fails.
+        num_qubits: Number of qubits in the circuit.
+        simulator: Simulator used to generate the state.
+        verbose: Whether to print out information.
+        failure_break: Whether to break at first failure.
+
+    Returns:
+    -------
+        A list of errors that caused failure
 
-    This error generator does not allow much modification of the error model.
     """
+    failure = False
 
-    measurements = {'measure X', 'measure Y', 'measure Z'}
-    inits = {'init |0>', 'init |1>', 'init |+>', 'init |->', 'init |+i>', 'init |-i>'}
-    two_qubits = {'CNOT', 'CZ', 'SWAP', 'G'}
-
-    inits_z = {'init |0>', 'init |1>'}
-    inits_x = {'init |+>', 'init |->'}
-    inits_y = {'init |+i>', 'init |-i>'}
-
-    error_two_paulis_collection = [
-        ('I', 'X'), ('X', 'I'), ('X', 'X')]
-
-    def __init__(self, model_level='circuit', has_idle_errors=False):
-        """
-
-        Args:
-            model_level(str):
-            has_idle_errors(bool):
-        """
-
-        super().__init__()
-
-        self.has_idle_errors = has_idle_errors
-
-        self.gen = self.generator_class()
-        self.gen.set_gate_group('measurements', self.measurements)
-        self.gen.set_gate_group('inits', self.inits)
-        self.gen.set_gate_group('two_qubits', self.two_qubits)
-
-        xerror = self.gen.ErrorStaticSymbol('X')
-        xerror_before = self.gen.ErrorStaticSymbol('X', after=False)
-        two_pauli_errors = self.gen.ErrorSetTwoQuditTensorProduct(self.error_two_paulis_collection)
-
-        if model_level == 'code_capacity':
-
-            self.has_data_errors = True
-            self.has_unitary_errors = False
-            self.has_meas_errors = False
-            self.has_idle_errors = False
-
-            # Data qubit errors
-            self.gen.set_gate_error('data', xerror.error_func)
-
-            # Don't generate any other errors
-
-        elif model_level == 'phenomenological':
-
-            self.has_data_errors = True
-            self.has_unitary_errors = False
-            self.has_meas_errors = True
-            self.has_idle_errors = False
-
-            # Generate data errors
-            self.gen.set_default_error('data', xerror.error_func)
-
-            # Generate measurement errors
-            self.gen.set_group_error('measurements', xerror_before.error_func)
-            # Don't generate any other errors
-
-        elif model_level == 'circuit':
-
-            self.has_data_errors = False
-            self.has_unitary_errors = True
-            self.has_meas_errors = True
-
-            # Don't generate data errors
-            self.gen.set_gate_error('data', False)  # Don't generate errors for data qudits.
+    failure_circs = []
 
-            # Generate measurement errors (before errors)
-            self.gen.set_group_error('measurements', xerror_before.error_func)
-            # Set two-qubits
-            self.gen.set_group_error('two_qubits', two_pauli_errors.error_func)
-            # By default generate pauli errors. (It is expected that this is only for one-qubit and init gates.)
-            self.gen.set_default_error(xerror.error_func)
-        else:
-            raise Exception('Can not handle model_level == %s' % model_level)
-
-        if has_idle_errors:
-            self.gen.set_gate_error('idle', xerror.error_func)
-
-    def start(self, circuit, error_params):
-        """
-        Start up at the beginning of a circuit simulation.
-
-        Args:
-            circuit:
-            error_params:
-
-        Returns:
-
-        """
-
-        self.error_circuits = ErrorCircuits()
-        self.circuit = circuit
-        self.error_params = error_params
-
-        return self.error_circuits
-
-    def generate_tick_errors(self, tick_circuit, time, **params):
-        """
-        Returns before errors, after errors, and replaced locations for the given key (args).
-
-        Returns:
-
-        """
-
-        if isinstance(time, tuple):
-            tick_index = time[-1]
-        else:
-            tick_index = time
-
-        circuit = tick_circuit.circuit
-
-        # Simple model where for each gate there is a probability "p" for an X, Y, or Z error to occur.
-
-        before = QuantumCircuit()
-        after = QuantumCircuit()
-        replace = set([])
-
-        # Data errors
-        # -----------
-        if self.has_data_errors and tick_index == 0:
-            data_qudit_set = params['data_qudit_set']
-
-            self.gen.create_errors(self, 'data', data_qudit_set, after, before, replace)
+    """
+    if simulator is None:
+        simulator = SparseSim
+    """
 
-        # unitary and measurement errors
-        # ------------------------------
-        if self.has_meas_errors or self.has_unitary_errors:
-            for symbol, gate_locations, _ in circuit.items(tick_index):
+    if num_qubits is None:
+        num_qubits = qcirc.metadata["num_qubits"]
 
-                self.gen.create_errors(self, symbol, gate_locations, after, before, replace)
+    for err in get_wt_paulis(qcirc, wt, make_qc=True):
+        # output = run_sim(qcirc, shots=1, simulator=simulator, error_circuits=err)
+        circ_sim = Standard()
+        state = SparseSim(num_qubits)
+        output, _ = circ_sim.run(state, qcirc, error_circuits=err)
+
+        if fail_func(output):
+            failure = True
+
+            if verbose:
+                print("Results:", output)
+                print()
+                print("Error:", err)
+                print("-------------")
+                print()
+
+            failure_circs.append(err)
+
+            if failure_break:
+                break
+
+    if not failure and verbose:
+        print(f"Fault tolerant to {wt} gates going bad!")
+
+    return failure_circs
+
+
+def get_all_spacetime(qcirc: QuantumCircuit, initial_qubits: Sequence[int] | None = None):
+    """Determine all the spacetime locations of gates/error events."""
+    if initial_qubits is not None:
+        for q in initial_qubits:
+            yield {"tick": -1, "location": (q,), "before": True, "symbol": "init |0>", "metadata": {}}
+
+    for gates, tick, _ in qcirc.iter_ticks():
+        for sym, locations, metadata in gates.items():
+            for loc in locations:
+                if isinstance(loc, int):
+                    loc = (loc,)
+
+                yield {
+                    "tick": tick,
+                    "location": loc,
+                    "before": sym.startswith("meas"),
+                    "symbol": sym,
+                    "metadata": metadata,
+                }
+
+
+def get_wt_paulis(circ: QuantumCircuit, wt: int, initial_qubits: Sequence[int] | None = None, *, make_qc: bool = True):
+    """A generator of all combinations of Pauli faults of a given weight.
+
+    Args:
+    ----
+        circ:
+        wt:
+        initial_qubits:
+        make_qc:
 
-        # idle errors
-        # -----------
-        if self.has_idle_errors:
-            inactive_qudits = circuit.qudits - circuit.active_qudits[tick_index]
-            self.gen.create_errors(self, 'idle', inactive_qudits, after, before, replace)
+    Returns:
+    -------
 
-        self.error_circuits.add_circuits(time, before, after)
+    """
+    # get the spacetime locations that will have errors
+    for gate_data in permutations(get_all_spacetime(circ, initial_qubits), wt):
+        iter_list = []
+        tick_list = []
+        loc_list = []
+        before_list = []
+        cond_list = []
+
+        # for the error locations, create the pauli error iterators
+        for gate_dict in gate_data:
+            # tick, locs, after
+            tick = gate_dict["tick"]
+            locs = gate_dict["location"]
+            before = gate_dict["before"]
+
+            paulis = product("IXYZ", repeat=len(locs))
+            next(paulis)  # skip ('I', ..., 'I'), which is the first element
+            iter_list.append(paulis)
+
+            tick_list.append(tick)
+            loc_list.append(locs)
+            before_list.append(before)
+            cond = gate_dict["metadata"].get("cond")
+            cond_list.append(cond)
+
+        # get all combinations of these possible pauli errors
+        for pauli_errs in product(*iter_list):
+            tick_dict_after = {}
+            tick_dict_before = {}
+            cond_dict = {}
+
+            for errs, tick, locs, before, cond in zip(pauli_errs, tick_list, loc_list, before_list, cond_list):
+                tick_dict = tick_dict_before if before else tick_dict_after
+
+                gate_dict = tick_dict.setdefault(tick, {})
+                cond_dict[tick] = cond
+
+                for p, q in zip(errs, locs):
+                    if p != "I":
+                        loc_set = gate_dict.setdefault(p, set())
+                        loc_set.add(q)
+
+            if make_qc:
+                error = {}
+
+                for t, pdict in tick_dict_after.items():
+                    error_tick = error.setdefault(t, {})
+                    if cond_dict.get(t):
+                        qc = QuantumCircuit()
+                        qc.append(pdict, cond=cond_dict.get(t))
+                        error_tick["after"] = qc
+                    else:
+                        error_tick["after"] = QuantumCircuit([pdict])
+
+                for t, pdict in tick_dict_before.items():
+                    error_tick = error.setdefault(t, {})
+                    if cond_dict.get(t):
+                        qc = QuantumCircuit()
+                        qc.append(pdict, cond=cond_dict.get(t))
+                        error_tick["before"] = qc
+                    else:
+                        error_tick["before"] = QuantumCircuit([pdict])
 
-        # return {'before': before, 'after': after}
+                yield error
 
-        return self.error_circuits
+            else:
+                yield tick_dict_after, tick_dict_before
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/old/xzerror_gen.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/old/depolar_gen.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,182 +7,187 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Simple error generator meant to demonstrate a basic error generator that produces errors.
-"""
-from pecos.error_models.class_errors_circuit import ErrorCircuits
+"""Simple error generator meant to demonstrate a basic error generator that produces errors."""
+
+from __future__ import annotations
+
+from typing import ClassVar
+
 from pecos.circuits.quantum_circuit import QuantumCircuit
+from pecos.error_models.class_errors_circuit import ErrorCircuits
 from pecos.error_models.parent_class_error_gen import ParentErrorModel
 
 
-class XZModel(ParentErrorModel):
-    """
-    A simple error generator for the depolarizing model.
+class DepolarModel(ParentErrorModel):
+    """A simple error generator for the depolarizing model.
 
     This error generator does not allow much modification of the error model.
     """
 
-    measurements = {'measure X', 'measure Y', 'measure Z'}
-    inits = {'init |0>', 'init |1>', 'init |+>', 'init |->', 'init |+i>', 'init |-i>'}
-    two_qubits = {'CNOT', 'CZ', 'SWAP', 'G'}
-
-    inits_z = {'init |0>', 'init |1>'}
-    inits_x = {'init |+>', 'init |->'}
-    inits_y = {'init |+i>', 'init |-i>'}
-
-    error_two_paulis_collection = [
-        ('I', 'X'), ('I', 'Z'),
-        ('X', 'I'), ('X', 'X'), ('X', 'Z'),
-        ('Z', 'I'), ('Z', 'X'), ('Z', 'Z')]
-
-    def __init__(self, model_level='circuit', has_idle_errors=False, perp_errors=False):
-        """
-
-        Args:
+    measurements: ClassVar[set[str]] = {"measure X", "measure Y", "measure Z"}
+    inits: ClassVar[set[str]] = {"init |0>", "init |1>", "init |+>", "init |->", "init |+i>", "init |-i>"}
+    two_qubits: ClassVar[set[str]] = {"CNOT", "CZ", "SWAP", "G"}
+
+    inits_z: ClassVar[set[str]] = {"init |0>", "init |1>"}
+    inits_x: ClassVar[set[str]] = {"init |+>", "init |->"}
+    inits_y: ClassVar[set[str]] = {"init |+i>", "init |-i>"}
+
+    error_two_paulis_collection: ClassVar[list[tuple[str, str]]] = [
+        ("I", "X"),
+        ("I", "Y"),
+        ("I", "Z"),
+        ("X", "I"),
+        ("X", "X"),
+        ("X", "Y"),
+        ("X", "Z"),
+        ("Y", "I"),
+        ("Y", "X"),
+        ("Y", "Y"),
+        ("Y", "Z"),
+        ("Z", "I"),
+        ("Z", "X"),
+        ("Z", "Y"),
+        ("Z", "Z"),
+    ]
+
+    def __init__(self, model_level="circuit", has_idle_errors=False, perp_errors=False) -> None:
+        """Args:
+        ----
             model_level(str):
             has_idle_errors(bool):
             perp_errors(bool):
         """
-
         super().__init__()
 
         self.has_idle_errors = has_idle_errors
-        self.perp_error = perp_errors
+        self.perp_errors = perp_errors
 
         self.gen = self.generator_class()
-        self.gen.set_gate_group('measurements', self.measurements)
-        self.gen.set_gate_group('inits', self.inits)
-        self.gen.set_gate_group('two_qubits', self.two_qubits)
-
-        xerror = self.gen.ErrorStaticSymbol('X')
-        zerror = self.gen.ErrorStaticSymbol('Z')
-        xerror_before = self.gen.ErrorStaticSymbol('X', after=False)
-        zerror_before = self.gen.ErrorStaticSymbol('Z', after=False)
-        pauli_errors = self.gen.ErrorSet({'X', 'Z'})
-        pauli_errors_before = self.gen.ErrorSet({'X', 'Z'}, after=False)
+        self.gen.set_gate_group("measurements", self.measurements)
+        self.gen.set_gate_group("inits", self.inits)
+        self.gen.set_gate_group("two_qubits", self.two_qubits)
+
+        xerror = self.gen.ErrorStaticSymbol("X")
+        zerror = self.gen.ErrorStaticSymbol("Z")
+        xerror_before = self.gen.ErrorStaticSymbol("X", after=False)
+        zerror_before = self.gen.ErrorStaticSymbol("Z", after=False)
+        pauli_errors = self.gen.ErrorSet({"X", "Y", "Z"})
+        pauli_errors_before = self.gen.ErrorSet({"X", "Y", "Z"}, after=False)
         two_pauli_errors = self.gen.ErrorSetTwoQuditTensorProduct(self.error_two_paulis_collection)
 
-        if model_level == 'code_capacity':
-
+        if model_level == "code_capacity":
             self.has_data_errors = True
             self.has_unitary_errors = False
             self.has_meas_errors = False
 
             # Data qubit errors
-            self.gen.set_gate_error('data', pauli_errors.error_func)
+            self.gen.set_gate_error("data", pauli_errors.error_func)
 
             # Don't generate any other errors
 
-        elif model_level == 'phenomenological':
-
+        elif model_level == "phenomenological":
             self.has_data_errors = True
             self.has_unitary_errors = False
             self.has_meas_errors = True
 
             # Generate data errors
-            self.gen.set_default_error('data', pauli_errors.error_func)
+            self.gen.set_default_error("data", pauli_errors.error_func)
 
             # Generate measurement errors
-            self.gen.set_group_error('measurements', pauli_errors_before.error_func)
+            self.gen.set_group_error("measurements", pauli_errors_before.error_func)
             # Don't generate any other errors
 
-        elif model_level == 'circuit':
-
+        elif model_level == "circuit":
             self.has_data_errors = False
             self.has_unitary_errors = True
             self.has_meas_errors = True
 
             # Don't generate data errors
-            self.gen.set_gate_error('data', False)  # Don't generate errors for data qudits.
+            self.gen.set_gate_error("data", False)  # Don't generate errors for data qudits.
 
             # Generate measurement errors (before errors)
-            self.gen.set_group_error('measurements', pauli_errors_before.error_func)
+            self.gen.set_group_error("measurements", pauli_errors_before.error_func)
             # Set two-qubits
-            self.gen.set_group_error('two_qubits', two_pauli_errors.error_func)
+            self.gen.set_group_error("two_qubits", two_pauli_errors.error_func)
             # By default generate pauli errors. (It is expected that this is only for one-qubit and init gates.)
             self.gen.set_default_error(pauli_errors.error_func)
         else:
-            raise Exception('Can not handle model_level == %s' % model_level)
+            raise Exception("Can not handle model_level == %s" % model_level)
 
         # If errors need to be perpendicular to inits and measurements.
-        if self.perp_error and model_level != 'code_capacity':
-            self.gen.set_gate_error('measure X', zerror_before.error_func)
-            self.gen.set_gate_error('measure Y', zerror_before.error_func)
-            self.gen.set_gate_error('measure Z', xerror_before.error_func)
-
-            if model_level == 'circuit':
-                self.gen.set_group_error(self.inits_x, zerror.error_func)
-                self.gen.set_group_error(self.inits_y, zerror.error_func)
-                self.gen.set_group_error(self.inits_z, xerror.error_func)
+        if self.perp_errors and model_level != "code_capacity":
+            self.gen.set_gate_error("measure X", zerror_before.error_func)
+            self.gen.set_gate_error("measure Y", zerror_before.error_func)
+            self.gen.set_gate_error("measure Z", xerror_before.error_func)
+
+            if model_level == "circuit":
+                self.gen.set_gate_group("Z on inits", {"init |+>", "init |->", "init |+i>", "init |-i>"})
+                self.gen.set_gate_group("X on inits", {"init |0>", "init |1>"})
+                self.gen.set_group_error("Z on inits", zerror.error_func)
+                self.gen.set_group_error("X on inits", xerror.error_func)
 
         if has_idle_errors:
-            self.gen.set_gate_error('idle', pauli_errors.error_func)
+            self.gen.set_gate_error("idle", pauli_errors.error_func)
 
     def start(self, circuit, error_params):
-        """
-        Start up at the beginning of a circuit simulation.
+        """Start up at the beginning of a circuit simulation.
 
         Args:
+        ----
             circuit:
             error_params:
 
         Returns:
+        -------
 
         """
-
         self.error_circuits = ErrorCircuits()
         self.circuit = circuit
         self.error_params = error_params
 
         return self.error_circuits
 
     def generate_tick_errors(self, tick_circuit, time, **params):
-        """
-        Returns before errors, after errors, and replaced locations for the given key (args).
+        """Returns before errors, after errors, and replaced locations for the given key (args).
 
         Returns:
+        -------
 
         """
-
-        if isinstance(time, tuple):
-            tick_index = time[-1]
-        else:
-            tick_index = time
+        tick_index = time[-1] if isinstance(time, tuple) else time
 
         circuit = tick_circuit.circuit
 
         # Simple model where for each gate there is a probability "p" for an X, Y, or Z error to occur.
 
         before = QuantumCircuit()
         after = QuantumCircuit()
-        replace = set([])
+        replace = set()
+
+        # if circuit.qudits != circuit.active_qudits:
 
         # Data errors
         # -----------
         if self.has_data_errors and tick_index == 0:
-            data_qudit_set = params['data_qudit_set']
-
-            self.gen.create_errors(self, 'data', data_qudit_set, after, before, replace)
+            data_qudits = params["data_qudit_set"]
+            self.gen.create_errors(self, "data", data_qudits, after, before, replace)
 
         # unitary and measurement errors
         # ------------------------------
         if self.has_meas_errors or self.has_unitary_errors:
-            for symbol, gate_locations, _ in circuit.items(tick_index):
-
+            for symbol, gate_locations, _ in circuit.items(tick=tick_index):
                 self.gen.create_errors(self, symbol, gate_locations, after, before, replace)
 
         # idle errors
         # -----------
         if self.has_idle_errors:
             inactive_qudits = circuit.qudits - circuit.active_qudits[tick_index]
-            self.gen.create_errors(self, 'idle', inactive_qudits, after, before, replace)
+            self.gen.create_errors(self, "idle", inactive_qudits, after, before, replace)
 
         self.error_circuits.add_circuits(time, before, after)
 
-        # return {'before': before, 'after': after}
-
         return self.error_circuits
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/error_models/parent_class_error_gen.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/parent_class_error_gen.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,342 +7,314 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Simple error generator meant to demonstrate a basic error generator that produces errors.
-"""
+"""Simple error generator meant to demonstrate a basic error generator that produces errors."""
 import numpy as np
-from .class_errors_circuit import ErrorCircuits
 
+from pecos.error_models.class_errors_circuit import ErrorCircuits
 
-class ParentErrorModel(object):
-    """
-    A simple error generator for the depolarizing model.
+
+class ParentErrorModel:
+    """A simple error generator for the depolarizing model.
 
     This error generator does not allow much modification of the error model.
     """
 
-    def __init__(self):
-        """
-
-        """
+    def __init__(self) -> None:
+        """ """
         self.error_circuits = None
 
         self.error_params = None
         self.circuit = None
         self.generator_class = Generator
 
     def start(self, circuit, error_params):
-        """
-        Start up at the beginning of a circuit simulation.
+        """Start up at the beginning of a circuit simulation.
 
         Args:
+        ----
             circuit:
             error_params:
 
         Returns:
+        -------
 
         """
-
         self.error_circuits = ErrorCircuits()
         self.circuit = circuit
         self.error_params = error_params
 
         return self.error_circuits
 
     def generate_tick_errors(self, tick_circuit, time, **params):
-        """
-        Returns before errors, after errors, and replaced locations for the given key (args).
+        """Returns before errors, after errors, and replaced locations for the given key (args).
 
         Returns:
+        -------
 
         """
-
         return {}
 
 
 class Generator:
-    """
-    Class that keeps track of how errors are generated for each gate and groups of gates. It also has a method for
+    """Class that keeps track of how errors are generated for each gate and groups of gates. It also has a method for
     generating errors.
     """
 
-    def __init__(self):
+    def __init__(self) -> None:
         self.gate_groups = {}
         self.error_func_dict = {}
-        self.default_error_tuple = (False, 'p')
+        self.default_error_tuple = (False, "p")
 
     def set_gate_group(self, group_symbol, gate_set):
-        """
-
-        Args:
+        """Args:
+        ----
             group_symbol: Symbol representing the group.
             gate_set: Iterable of gate symbols.
 
         Returns: None
 
         """
         self.gate_groups[group_symbol] = set(gate_set)
 
     def in_group(self, group_symbol, gate_symbol):
-        """
-        Returns whether the `gate_symbol` is in the group represented by `group_symbol`.
+        """Returns whether the `gate_symbol` is in the group represented by `group_symbol`.
 
         Args:
+        ----
             group_symbol:
             gate_symbol:
 
         Returns:
+        -------
 
         """
-
         return gate_symbol in self.gate_groups[group_symbol]
 
-    def set_gate_error(self, gate_symbol, error_func, error_param='p', after=True):
-        """
-        Sets the errors for a gate.
+    def set_gate_error(self, gate_symbol, error_func, error_param="p", after=True):
+        """Sets the errors for a gate.
 
         Args:
+        ----
             gate_symbol: The gate symbol that is being evaluated for errors.
             error_func (callable, iterable, str, bool, None): A callable to generate errors or an iterable of gate
             symbols from which errors are uniformly drawn from. It can also be a str that represents an gate error that
             is always returned if an error occurs.
             error_param: What error parameter determines if an error occurs or not. Error functions will be given the
             error_params are an argument so more detailed error distributions can be created.
             after (bool):
 
         Returns: None
 
         """
-
         if error_func is True:
             self.error_func_dict[gate_symbol] = (True, error_param)
 
         elif error_func is False:
-
             self.error_func_dict[gate_symbol] = False
 
         elif isinstance(error_func, str):
             error_func = self.ErrorStaticSymbol(error_func, after=after).error_func
             self.error_func_dict[gate_symbol] = (error_func, error_param)
 
-        elif hasattr(error_func, '__iter__'):
-
+        elif hasattr(error_func, "__iter__"):
             error_func = list(error_func)
 
             first = error_func[0]
-            if (isinstance(first, str) and first not in ['CNOT', 'II', 'CZ', 'SWAP', 'G2']) or \
-                    not hasattr(first, '__iter__'):
+            if (isinstance(first, str) and first not in ["CNOT", "II", "CZ", "SWAP", "G2"]) or not hasattr(
+                first,
+                "__iter__",
+            ):
                 error_func = self.ErrorSet(error_func, after=after).error_func
             else:
                 error_func = self.ErrorSetMultiQuditGate(error_func, after=after).error_func
 
             self.error_func_dict[gate_symbol] = (error_func, error_param)
 
         else:
             self.error_func_dict[gate_symbol] = (error_func, error_param)
 
-    def set_group_error(self, group_symbol, error_func, error_param='p', after=True):
-        """
-        Sets the errors for a group of gates.
+    def set_group_error(self, group_symbol, error_func, error_param="p", after=True):
+        """Sets the errors for a group of gates.
 
         Args:
+        ----
             group_symbol:
             error_func:
             error_param (str):
             after (bool)
 
         Returns: None
 
         """
-
         for symbol in self.gate_groups[group_symbol]:
-
             if symbol in self.error_func_dict:
-                print('Overriding gate error for gate: %s.' % symbol)
+                print("Overriding gate error for gate: %s." % symbol)
 
             self.set_gate_error(symbol, error_func, error_param, after)
 
-    def set_default_error(self, error_func, error_param='p'):
-        """
-        Sets the default error if gate is not found.
+    def set_default_error(self, error_func, error_param="p"):
+        """Sets the default error if gate is not found.
 
         Args:
+        ----
             error_func:
             error_param:
 
         Returns: None
 
         """
-
         self.default_error_tuple = (error_func, error_param)
 
     def create_errors(self, err_gen, gate_symbol, locations, after, before, replace, **kwargs):
-        """
-        Used to determine if an error occurs and if so, calls the error function to determine errors.
+        """Used to determine if an error occurs and if so, calls the error function to determine errors.
 
         It also updates the `error_circuit` with the errors.
 
         Args:
+        ----
             err_gen:
             gate_symbol:
             locations:
             after:
             before:
             replace:
 
         Returns: None
 
         """
-
         error_func, error_param = self.error_func_dict.get(gate_symbol, self.default_error_tuple)
 
         if error_func is True:  # Default error
             # Use the default error function.
             error_func = self.default_error_tuple[0]
             # If no default error has been defined then no error will be applied.
 
         if error_func is False:  # No errors
-            return
+            return None
 
         p = err_gen.error_params[error_param]
 
         if p is True:  # Error always occurs
-
             for loc in locations:
                 error_func(after, before, replace, loc, err_gen.error_params, **kwargs)
 
             return locations
 
         else:
-
-            rand_nums = np.random.random(len(locations))  # Create len(locations) number of random float between 0 and 1.
-            rand_nums = rand_nums <= p  # Bolean evaluation of random number <= p
+            # Create len(locations) number of random float between 0 and 1.
+            rand_nums = np.random.random(len(locations))
+            rand_nums = rand_nums <= p  # Boolean evaluation of random number <= p
 
             # TODO: Think about using the numpy function vectorize...
-            error_locations = set([])
+            error_locations = set()
 
             for i, loc in enumerate(locations):
                 if rand_nums[i]:
                     error_locations.add(loc)
                     error_func(after, before, replace, loc, err_gen.error_params, **kwargs)
 
             return error_locations
 
     class ErrorStaticSymbol:
-        """
-        Class used to create a callable that just returns a symbol.
-        """
+        """Class used to create a callable that just returns a symbol."""
 
-        def __init__(self, symbol, after=True):
+        def __init__(self, symbol, after=True) -> None:
             self.data = symbol
 
             if after:
                 self.error_func = self.error_func_after
             else:
                 self.error_func = self.error_func_before
 
         def error_func_after(self, after, before, replace, location, error_params):
-
             after.update(self.data, {location}, emptyappend=True)
 
         def error_func_before(self, after, before, replace, location, error_params):
-
             before.update(self.data, {location}, emptyappend=True)
 
     class ErrorSet:
-        """
-        Class used to create a callable that returns an element from the error_set with uniform distribution.
-        """
-
-        def __init__(self, error_set, after=True):
+        """Class used to create a callable that returns an element from the error_set with uniform distribution."""
 
+        def __init__(self, error_set, after=True) -> None:
             self.data = np.array(list(error_set))
 
             if after:
                 self.error_func = self.error_func_after
             else:
                 self.error_func = self.error_func_before
 
         def error_func_after(self, after, before, replace, location, error_params):
-
             after.update(np.random.choice(self.data), {location}, emptyappend=True)
 
         def error_func_before(self, after, before, replace, location, error_params):
-
             before.update(np.random.choice(self.data), {location}, emptyappend=True)
 
     class ErrorSetMultiQuditGate:
-        """
-        Class used to create a callable that returns an element from the error_set with uniform distribution.
-        """
-
-        def __init__(self, error_set, after=True):
+        """Class used to create a callable that returns an element from the error_set with uniform distribution."""
 
+        def __init__(self, error_set, after=True) -> None:
             try:
                 self.data = np.array(list(error_set))
             except ValueError:
                 error_set[0] = (error_set[0],)
                 self.data = np.array(list(error_set))
 
             if after:
                 self.error_func = self.error_func_after
             else:
                 self.error_func = self.error_func_before
 
         def error_func_after(self, after, before, replace, location, error_params):
-
-            # error_symbols = np.random.choice(self.data)
-
             # Choose an error symbol or tuple of symbols:
             indx = np.random.choice(len(self.data))
             error_symbols = self.data[indx]
 
             if isinstance(error_symbols, (tuple, np.ndarray)) and len(error_symbols) > 1:
                 for sym, loc in zip(error_symbols, location):
-                    if sym != 'I':
+                    if sym != "I":
                         after.update(sym, {loc}, emptyappend=True)
 
             elif isinstance(error_symbols, str):
-                if error_symbols != 'I':
+                if error_symbols != "I":
                     after.update(error_symbols, {location}, emptyappend=True)
 
             elif isinstance(error_symbols, tuple) and len(error_symbols) == 1:
                 error_symbols = error_symbols[0]
-                if error_symbols != 'I':
+                if error_symbols != "I":
                     after.update(error_symbols, {location}, emptyappend=True)
             else:
-                raise Exception("Only tuples and strings are currently accepted")
+                msg = "Only tuples and strings are currently accepted"
+                raise Exception(msg)
 
         def error_func_before(self, after, before, replace, location, error_params):
-
-            # error_symbols = np.random.choice(self.data)
             indx = np.random.choice(len(self.data))
             error_symbols = self.data[indx]
 
             if isinstance(error_symbols, np.ndarray) and len(error_symbols) > 1:
                 for sym, loc in zip(error_symbols, location):
-                    if sym != 'I':
+                    if sym != "I":
                         before.update(sym, {loc}, emptyappend=True)
             elif isinstance(error_symbols, str):
-                if error_symbols != 'I':
+                if error_symbols != "I":
                     before.update(error_symbols, {location}, emptyappend=True)
 
             elif isinstance(error_symbols, tuple) and len(error_symbols) == 1:
                 error_symbols = error_symbols[0]
-                if error_symbols != 'I':
+                if error_symbols != "I":
                     before.update(error_symbols, {location}, emptyappend=True)
             else:
-                raise Exception("Only tuples and strings are currently accepted")
+                msg = "Only tuples and strings are currently accepted"
+                raise Exception(msg)
 
     class ErrorSetTwoQuditTensorProduct(ErrorSetMultiQuditGate):
         """Created just to preserve the functionality of other error models.
 
         Creates a uniform distribution... not a tensor product.
         """
 
-        def __init__(self, error_set, after=True):
+        def __init__(self, error_set, after=True) -> None:
             super().__init__(error_set, after)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/errors.py` & `quantum_pecos-0.6.0.dev1/python/pecos/errors.py`

 * *Files 16% similar despite different names*

```diff
@@ -4,20 +4,26 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+
 class PECOSError(Exception):
     """Base exception raised by PECOS."""
-    pass
 
 
 class NotSupportedGateError(PECOSError):
     """Indicates a gate not supported by a simulator."""
-    pass
 
 
-class MissingCCOPError(PECOSError):
+class WasmError(PECOSError):
+    """Base WASM-related exception type"""
+
+
+class MissingCCOPError(WasmError):
     """Indicates missing a classical function library."""
-    pass
+
+
+class WasmRuntimeError(WasmError):
+    """Indicates a runtime WASM error."""
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/foreign_objects/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/error_models/noise_impl/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/foreign_objects/foreign_object_abc.py` & `quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/foreign_object_abc.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,32 +5,32 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 import abc
-from typing import Any, List, Sequence
+from typing import TYPE_CHECKING
 
+if TYPE_CHECKING:
+    from collections.abc import Sequence
 
-class ForeignObject(metaclass=abc.ABCMeta):
 
+class ForeignObject(metaclass=abc.ABCMeta):
     @abc.abstractmethod
     def init(self) -> None:
         """Initialize object before a set of simulations."""
-        pass
 
     @abc.abstractmethod
     def new_instance(self) -> None:
         """Create new instance/internal state."""
-        pass
 
     @abc.abstractmethod
-    def get_funcs(self) -> List[str]:
+    def get_funcs(self) -> list[str]:
         """Get a list of function names available from the object."""
-        pass
 
     @abc.abstractmethod
-    def exec(self, func_name: str, args: Sequence) -> Any:
+    def exec(self, func_name: str, args: Sequence) -> tuple:
         """Execute a function given a list of arguments."""
-        pass
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/foreign_objects/object_pool.py` & `quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/object_pool.py`

 * *Files 13% similar despite different names*

```diff
@@ -5,57 +5,62 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Any, List, Optional, Sequence
+from __future__ import annotations
 
-from .foreign_object_abc import ForeignObject
+from typing import TYPE_CHECKING
+
+from pecos.foreign_objects.foreign_object_abc import ForeignObject
+
+if TYPE_CHECKING:
+    from collections.abc import Sequence
 
 
 class NamedObjectPool(ForeignObject):
     """A collection of objections that can be access via this class."""
 
-    def __init__(self, **objects: ForeignObject):
+    def __init__(self, **objects: ForeignObject) -> None:
         self.objs = objects
-        self.default = objects["default"] if "default" in objects else None
+        self.default = objects.get("default", None)
 
     def new_instance(self) -> None:
         """Create new instance/internal state."""
         for obj in self.objs.values():
             obj.new_instance()
 
     def init(self) -> None:
         """Initialize object before running a series of experiments."""
         for obj in self.objs.values():
             obj.init()
 
     def shot_reinit(self) -> None:
         """Call before each shot to, e.g., reset variables."""
-
         for obj in self.objs.values():
             if "shot_reinit" in obj.get_funcs():
                 obj.exec("shot_reinit", [])
 
-    def add(self, namespace: str, obj: ForeignObject):
+    def add(self, namespace: str, obj: ForeignObject) -> None:
         if namespace in self.objs:
-            raise Exception(f"Object named '{namespace}' already exists!")
+            msg = f"Object named '{namespace}' already exists!"
+            raise Exception(msg)
         else:
             self.objs[namespace] = obj
 
-    def get_funcs(self) -> List[str]:
+    def get_funcs(self) -> list[str]:
         """Get a list of function names available from the object."""
         return []
 
-    def exec(self, func_name: str, args: Sequence, namespace: Optional[str] = None) -> Any:
+    def exec(self, func_name: str, args: Sequence, namespace: str | None = None) -> tuple:
         """Execute a function given a list of arguments."""
-
         if namespace is None:
             obj = self.default
         elif namespace not in self.objs:
-            raise Exception(f"Object named '{namespace}' not recognized!")
+            msg = f"Object named '{namespace}' not recognized!"
+            raise Exception(msg)
         else:
             obj = self.objs[namespace]
 
         return obj.exec(func_name, args)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/foreign_objects/python.py` & `quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/python.py`

 * *Files 15% similar despite different names*

```diff
@@ -5,24 +5,26 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 import inspect
-from typing import Any, Sequence
+from typing import TYPE_CHECKING
+
+from pecos.foreign_objects.foreign_object_abc import ForeignObject
 
-from .foreign_object_abc import ForeignObject
+if TYPE_CHECKING:
+    from collections.abc import Sequence
 
 
 class PythonObj(ForeignObject):
-    """A Python object with an interface consistent with "foreign objects." """
+    """A Python object with an interface consistent with "foreign objects."."""
 
-    def get_funcs(self):
+    def get_funcs(self) -> list[str]:
         return [attr for attr in dir(self) if inspect.ismethod(getattr(self, attr))]
 
-    def exec(self,
-             func_name: str,
-             args: Sequence) -> Any:
-
+    def exec(self, func_name: str, args: Sequence) -> tuple:
         return getattr(self, func_name)(*args)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/foreign_objects/wasmer.py` & `quantum_pecos-0.6.0.dev1/python/pecos/slr/cond_block.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,103 +1,84 @@
-# Copyright 2022 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Any, Optional, Sequence, Union
 
-from wasmer import FunctionType, Instance, Module, Store, engine
-from wasmer_compiler_cranelift import Compiler as Cranelift
+from pecos.slr.block import Block
 
-from .foreign_object_abc import ForeignObject
 
-
-class WasmerObj(ForeignObject):
-    """Wrapper class to create a Wasmer instance and access its functions.
-
-    For more info on using Wasmer, see: https://wasmerio.github.io/wasmer-python/api/wasmer/wasmer.html
-    """
-
-    def __init__(self,
-                 file: Union[str, bytes],
-                 compiler: Optional[object] = None) -> None:
-
-        self.compiler = compiler
-
-        if isinstance(file, str):
-            with open(file, 'rb') as f:
-                wasm_bytes = f.read()
-        else:
-            wasm_bytes = file
-
-        self.wasm_bytes = wasm_bytes
-
-        self.module = None
-        self.instance = None
-        self.func_names = None
-
-        self.spin_up_wasm()
-
-    def init(self) -> None:
-        """Initialize object before running a series of experiments."""
-        self.new_instance()
-        self.get_funcs()
-
-        if "init" not in self.get_funcs():
-            raise Exception("Missing `init()` from Wasm module.")
-
-        self.exec("init", [])
-
-    def shot_reinit(self) -> None:
-        """Call before each shot to, e.g., reset variables."""
-        if "shot_reinit" in self.get_funcs():
-            self.exec("shot_reinit", [])
-
-    def new_instance(self) -> None:
-        """Reset object internal state."""
-        self.instance = Instance(self.module)
-
-    def spin_up_wasm(self):
-
-        compiler = self.compiler
-        if compiler is None:
-            compiler = Cranelift
-
-        store = Store(engine.JIT(compiler))
-
-        self.module = Module(store, self.wasm_bytes)
-        self.new_instance()
-
-    def get_funcs(self):
-
-        if self.func_names is None:
-            fs = []
-            for f in self.module.exports:
-                if isinstance(f.type, FunctionType):
-                    fs.append(str(f.name))
-
-            self.func_names = fs
-
-        return self.func_names
-
-    def exec(self,
-             func_name: str,
-             args: Sequence) -> Any:
-
-        func = getattr(self.instance.exports, func_name)
-        params = func.type.params
-        if len(args) != len(params):
-            raise TypeError(f"Wasmer function `{func_name}` takes {len(params)} args and {len(args)} were given!")
-        return func(*args)
-
-    def to_dict(self):
-        return {"fobj_class": WasmerObj, "wasm_bytes": self.wasm_bytes}
-
-    @staticmethod
-    def from_dict(wasmer_dict: dict):
-        return wasmer_dict["fobj_class"](wasmer_dict["wasm_bytes"])
+class CondBlock(Block):
+    def __init__(self, *args, cond=None, ops=None):
+        if cond is None and args:
+            if len(args) > 1:
+                msg = "Expected a single condition."
+                raise Exception(msg)
+            cond = args[0]
+            args = ()
+
+        super().__init__(*args, ops=ops, vargs=None, allow_no_ops=True)
+        self.cond = cond
+
+    def extend(self, *ops):
+        raise NotImplementedError
+
+    def _extend(self, *ops):
+        super().extend(*ops)
+        return self
+
+
+class If(CondBlock):
+    def __init__(self, *args, cond=None, then_block=None, else_block=None):
+        super().__init__(*args, cond=cond, ops=then_block)
+        self.else_block = None if else_block is None else self.Else(else_block)
+
+    def Then(self, *args):
+        self._extend(*args)
+        return self
+
+    def Else(self, *args):
+        raise NotImplementedError
+
+    def qasm(self):
+        qasm = []
+
+        cond = self.cond.qasm()
+
+        for op in self.ops:
+            for q in op.qasm().split("\n"):
+                # TODO: Make this more eloquent....
+                q = q.strip()
+                if q != "" and not q.startswith("//"):
+                    for qi in q.split(";"):
+                        qi = qi.strip()
+                        if qi != "" and not qi.startswith("//"):
+                            qasm.append(f"if({cond}) {qi};")
+                else:
+                    qasm.append(q)
+
+        return "\n".join(qasm)
+
+
+class Repeat(CondBlock):
+    def __init__(self, cond=None):
+        if not isinstance(cond, int):
+            msg = f"Condition for Repeat block must be an int! Got type: {type(cond)}"
+            raise TypeError(msg)
+        super().__init__(cond=cond)
+
+    def block(self, *args):
+        super()._extend(*args)
+        return self
+
+    def qasm(self):
+        qasm = []
+        for _ in range(self.cond):
+            for op in self.ops:
+                qasm.append(op.qasm())
+        return "\n".join(qasm)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/machines/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/machines/generic_machine.py` & `quantum_pecos-0.6.0.dev1/python/pecos/machines/generic_machine.py`

 * *Files 19% similar despite different names*

```diff
@@ -5,61 +5,61 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .machine_abc import Machine
-from ..reps.pypmir.op_types import QOp
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from pecos.machines.machine_abc import Machine
+from pecos.reps.pypmir.op_types import QOp
+
+if TYPE_CHECKING:
+    from pecos.reps.pypmir.op_types import MOp
 
 
 class GenericMachine(Machine):
     """Represents generic, abstract machine."""
 
-    def __init__(self, error_model=None, num_qubits=None):
-        super().__init__(error_model, num_qubits)
-        self.leaked_qubits = None
-        self.lost_qubits = None
-
-    def reset(self) -> None:
-        """Reset state to initialization state."""
+    def __init__(self, num_qubits: int | None = None) -> None:
+        super().__init__(num_qubits=num_qubits)
+        self.qubit_set = set()
         self.leaked_qubits = set()
         self.lost_qubits = set()
 
-    def init(self, machine_params=None, num_qubits=None):
-        if machine_params:
-            self.machine_params = machine_params
+    def reset(self) -> None:
+        """Reset state to initialization state."""
+        self.leaked_qubits.clear()
+        self.lost_qubits.clear()
 
+    def init(self, num_qubits: int | None = None) -> None:
         self.num_qubits = num_qubits
+        self.qubit_set = set(range(num_qubits))
 
-    def shot_reinit(self):
+    def shot_reinit(self) -> None:
         self.reset()
 
-    def process_op(self, op):
-        pass
-
-    def process(self, op_buffer: list) -> list:
-
+    def process(self, op_buffer: list[QOp | MOp]) -> list:
         for op in op_buffer:
-            if "mop" in op:
+            if "mop" in op.name:
                 print("MOP >", op)
 
         return op_buffer
 
-    def leak(self, qubits: set):
+    def leak(self, qubits: set[int]) -> list[QOp]:
         """Starts tracking qubits as leaked qubits and calls the quantum simulation appropriately to trigger leakage."""
         self.leaked_qubits |= qubits
-        return [QOp(name="Init", args=list(qubits), metadata={})]
+        return [QOp(name="Init", args=list(qubits))]
 
-    def unleak(self, qubits: set):
+    def unleak(self, qubits: set[int]) -> list[QOp]:
         """Untrack qubits as leaked qubits and calls the quantum simulation appropriately to trigger leakage."""
         self.leaked_qubits -= qubits
+        return []
 
-    def meas_leaked(self, qubits: set):
-        # measuring = self.leaked_qubits & set(op.args)
+    def meas_leaked(self, qubits: set[int]) -> list[QOp]:
         self.leaked_qubits -= qubits
-        noisy_ops = [
-            QOp(name="Init -Z", args=list(qubits), metadata={}),
+        return [
+            QOp(name="Init -Z", args=list(qubits)),
         ]
-        return noisy_ops
-
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/machines/machine_abc.py` & `quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/block_types.py`

 * *Files 23% similar despite different names*

```diff
@@ -5,46 +5,51 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-import abc
-from typing import Any, Optional
+from __future__ import annotations
 
+from typing import TYPE_CHECKING
 
-class Machine(metaclass=abc.ABCMeta):
+from pecos.reps.pypmir.instr_type import Instr
 
-    def __init__(self,
-                 machine_params=None,
-                 num_qubits=None,
-                 metadata: Optional[dict] = None,
-                 pos: Optional[Any] = None):
-        self.machine_params = machine_params
-        self.num_qubits = num_qubits
-        self.metadata = metadata
-        self.pos = pos
-
-    @abc.abstractmethod
-    def reset(self) -> None:
-        """Reset state to initialization state."""
-        pass
-
-    @abc.abstractmethod
-    def init(self,
-             machine_params: dict = None,
-             num_qubits: Optional[int] = None) -> None:
-        pass
-
-    @abc.abstractmethod
-    def shot_reinit(self) -> None:
-        """Run all code needed at the beginning of each shot, e.g., resetting state."""
-        pass
-
-    @abc.abstractmethod
-    def process(self, op_buffer: list) -> list:
-        pass
-
-    @abc.abstractmethod
-    def process(self, op_buffer: list) -> list:
-        pass
+if TYPE_CHECKING:
+    from pecos.reps.pypmir.op_types import COp, Op, QOp
+
+
+class Block(Instr):
+    """General block type."""
+
+
+class SeqBlock(Block):
+    """A generic sequence block. This is not meant to indicate parallelism or lack of it but is just a way to structure
+    operations/blocks."""
+
+    def __init__(self, ops: list[Op | Block], metadata: dict | None = None) -> None:
+        super().__init__(metadata=metadata)
+        self.ops = ops
+
+
+class QParallelBlock(SeqBlock):
+    """A block to indicate that a collection of QOps are applied in parallel."""
+
+    def __init__(self, ops: list[QOp], metadata: dict | None = None) -> None:
+        super().__init__(ops=ops, metadata=metadata)
+
+
+class IfBlock(Block):
+    """If/else block."""
+
+    def __init__(
+        self,
+        condition: COp,
+        true_branch: list[Op],
+        false_branch: list[Op] | None = None,
+        metadata: dict | None = None,
+    ) -> None:
+        super().__init__(metadata=metadata)
+        self.condition = condition
+        self.true_branch = true_branch
+        self.false_branch = false_branch
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/misc/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/misc/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,9 +6,9 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .threshold_curve import threshold_fit
-from . import commute
+from pecos.misc import commute
+from pecos.misc.threshold_curve import threshold_fit
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/misc/commute.py` & `quantum_pecos-0.6.0.dev1/python/pecos/misc/commute.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,51 +7,45 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Used to determine if two operators (circuits) commute.
+"""Used to determine if two operators (circuits) commute.
 
 The main use case for this is to determine if an ideal recovery operator would change a logical sign or not.
 """
 
 
 def qubit_pauli(first_circuit, second_circuit):
-
     if len(first_circuit) != 1 or len(second_circuit) != 1:
-        raise Exception('Circuits are expected to only have one tick.')
+        msg = "Circuits are expected to only have one tick."
+        raise Exception(msg)
 
-    first_xs = set([])
-    first_zs = set([])
+    first_xs = set()
+    first_zs = set()
     for symbol, gate_locations, _ in first_circuit.items():
-
-        if symbol == 'X':
+        if symbol == "X":
             first_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             first_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             first_xs.update(gate_locations)
             first_zs.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
-    second_xs = set([])
-    second_zs = set([])
+    second_xs = set()
+    second_zs = set()
     for symbol, gate_locations, _ in second_circuit.items():
-
-        if symbol == 'X':
+        if symbol == "X":
             second_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             second_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             second_xs.update(gate_locations)
             second_zs.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
-    if (len(first_xs & second_zs) + len(first_zs & second_xs)) % 2:
-        return False
-    else:
-        return True
+    return not (len(first_xs & second_zs) + len(first_zs & second_xs)) % 2
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/misc/errors.py` & `quantum_pecos-0.6.0.dev1/python/pecos/misc/errors.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,22 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2019 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 
 class PECOSTypeError(TypeError):
     """General gate error."""
-    pass
 
 
 class GateError(Exception):
     """General gate errors."""
-    pass
 
 
 class GateOverlapError(GateError):
     """Raised when gates act on qudits that are already being acted on."""
-    pass
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/misc/stabilizer_funcs.py` & `quantum_pecos-0.6.0.dev1/python/pecos/misc/stabilizer_funcs.py`

 * *Files 8% similar despite different names*

```diff
@@ -11,56 +11,51 @@
 # specific language governing permissions and limitations under the License.
 
 
 def circ2set(circuit):
     qudit_xs = set()
     qudit_zs = set()
     for gate, qubits in circuit:
-        if gate == 'X':
+        if gate == "X":
             qudit_xs = qubits
-        elif gate == 'Z':
+        elif gate == "Z":
             qudit_zs = qubits
         else:
             raise Exception('Operator "%s" not handled for logical ops!' % gate)
 
     return qudit_xs, qudit_zs
 
 
 def op_commutes(stab_xs, stab_zs, commute_with):
-
     # Does the stabilizer anti-commute with any of the stabilizers in the stabilizer state?
 
     anticom_stabs = set()
 
     for q in stab_xs:
         anticom_stabs ^= commute_with.col_z[q]  # stabilizers that anti-commute with q
 
-    # print(len(anticom_stabs))
-
     for q in stab_zs:
         anticom_stabs ^= commute_with.col_x[q]  # stabilizers that anti-commute with q
 
-    # print(len(anticom_stabs))
-
     return not len(anticom_stabs)
 
 
 def find_stab(state, stab_xs, stab_zs):
-    """
-    Find the sign of the logical operator.
+    """Find the sign of the logical operator.
 
     Args:
+    ----
         state:
         stab_xs:
         stab_zs:
 
     Returns:
+    -------
 
     """
-    # print(stab_xs, stab_zs)
 
     if len(stab_xs) == 0 and len(stab_zs) == 0:
         return True
 
     stab_xs = set(stab_xs)
     stab_zs = set(stab_zs)
 
@@ -80,57 +75,56 @@
             built_up_xs ^= stabs.row_x[stab_id]
             built_up_zs ^= stabs.row_z[stab_id]
 
     # Compare with logical operator
     built_up_xs ^= stab_xs
     built_up_zs ^= stab_zs
 
-    if len(built_up_xs) != 0 or len(built_up_zs) != 0:
-        # print('x...', built_up_xs)
-        # print('z...', built_up_zs)
-        return False  # Not found in stabilizer state
-    else:
-        return True  # Stabilizer has been found
+    # Whether a stabilizer has been found
+    return not (len(built_up_xs) != 0 or len(built_up_zs) != 0)
 
 
 def remove_stab(state, stab_xs, stab_zs, destab_xs, destab_zs):
-
     # make sure stabs and destabs anti-commute
     # ----------------------------------------
     if (len(stab_xs & destab_zs) + len(stab_zs & destab_xs)) % 2 == 0:
-        raise Exception('Stabilizer and destabilizers do not anti-commute.')
+        msg = "Stabilizer and destabilizers do not anti-commute."
+        raise Exception(msg)
 
     logical_xs = stab_xs
     logical_zs = stab_zs
     delogical_xs = destab_xs
     delogical_zs = destab_zs
 
     stabs = state.stabs
     destabs = state.destabs
 
     anticom_x = len(logical_xs & delogical_zs) % 2
     anticom_z = len(logical_zs & delogical_xs) % 2
 
     if not (anticom_x + anticom_z % 2):
-        raise Exception("Logical and delogical supplied do not anti-commute!")
+        msg = "Logical and delogical supplied do not anti-commute!"
+        raise Exception(msg)
 
     # We want the supplied logical operator to be in the stabilizer group and
     #  the supplied delogical to not be in the stabilizers (we want it to end up being the logical op's destabilizer)
 
     # The following two function calls are wasteful because we will need some of what they discover... such as all the
     #  stabilizers that have destabilizers that anti-commute with the logical operator...
     #  But it is assumed that the user is not calling this function that often... so we can be wasteful...
 
     # Check logical is a stabilizer (we want to remove it from the stabilizers)
     if is_not_stabilizer(state, stab_xs, stab_zs):
-        raise Exception("Supplied stabilizer is NOT in the current stabilizer group!")
+        msg = "Supplied stabilizer is NOT in the current stabilizer group!"
+        raise Exception(msg)
 
     # Check delogical is not a stabilizer
     if not is_not_stabilizer(state, destab_xs, destab_zs):
-        raise Exception("Supplied delogical IS in the current stabilizer group!")
+        msg = "Supplied delogical IS in the current stabilizer group!"
+        raise Exception(msg)
 
     # Now that everything seems fine so far...
     # We need to remove the logical operator and insure the delogical partner is also a logical operator and not an
     # error
 
     # Step 1 - Get the logical operator as a stabilizer... well we are going to remove it so we actually don't need to
     #   group multiply to get it back... rather we just need to determine which stabilizer we will remove and update the
@@ -189,15 +183,14 @@
 
     # --------------------------------
     # Step 2 - Update destabilizers
 
     # Row
     # ---
     for gen in build_stabs:
-
         destabs.row_x[gen] ^= destabs.row_x[removed_id]
         destabs.row_z[gen] ^= destabs.row_z[removed_id]
 
     # Column
     # ---
     for q in destabs.row_x[removed_id]:
         destabs.col_x[q] ^= build_stabs
@@ -238,22 +231,20 @@
 
     delog_anticom = set()
 
     for s, qubits in enumerate(stabs.row_z):
         overlap = delogical_xs & qubits
 
         if len(overlap) % 2:  # Odd overlap
-
             delog_anticom.add(s)
 
     for s, qubits in enumerate(stabs.row_x):
         overlap = delogical_zs & qubits
 
         if len(overlap) % 2:  # Odd overlap
-
             delog_anticom.add(s)
 
     # Now do rowsum on these with the logical operator
 
     for gen in delog_anticom:
         stabs.row_x[gen] ^= logical_xs
         stabs.row_z[gen] ^= logical_zs
@@ -265,41 +256,37 @@
         stabs.col_z[q] ^= delog_anticom
 
     # Update the sign on these
     if logical_minus:
         stabs.signs_minus ^= delog_anticom
 
     if logical_i:
-
         # Find two is (carry operation)
         two_is = stabs.signs_i & delog_anticom
         stabs.signs_minus ^= two_is
 
         stabs.signs_i ^= delog_anticom
 
 
 def is_not_stabilizer(state, qubits_x, qubits_z):
-
     stabs = state.stabs
     destabs = state.destabs
 
     # ----- Anti-commutes with stabilizers? ----- #
 
     for qubits in stabs.row_z:
         overlap = qubits_x & qubits
 
         if len(overlap) % 2:  # Odd overlap
-
             return 1  # Zs do not commute
 
     for qubits in stabs.row_x:
         overlap = qubits_z & qubits
 
         if len(overlap) % 2:  # Odd overlap
-
             return 1  # Xs do not commute
 
     # ----- In the stabilizer group? ----- #
 
     build_stabs = set()
 
     for q in qubits_x:
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/misc/std_ouput.py` & `quantum_pecos-0.6.0.dev1/python/pecos/misc/std_output.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,58 +7,49 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-# from collections import OrderedDict
-
 
 class StdOutput(dict):
-    """
-    Class used to record results of gates (typically, measurements).
+    """Class used to record results of gates (typically, measurements).
 
     (logical space, logical time) -> time(tick) -> {location: result}
     """
 
-    def __init__(self, *args, **kwargs):
-
+    def __init__(self, *args, **kwargs) -> None:
         super().__init__(*args, **kwargs)
 
     def record(self, result_dict, time):
-        """
-
-        Args:
+        """Args:
+        ----
             result_dict:
             time:
 
         Returns:
+        -------
 
         """
-
         if result_dict:
-
             logical_dict = self.setdefault(time, {})
             logical_dict.update(result_dict)
 
     def simplified(self, last=False):
-        """
-        Gives output in a simplified version. {logical coord=>{set of locations}, ...}
-
+        """Gives output in a simplified version. {logical coord=>{set of locations}, ...}.
 
         Outputs the syndromes of the final logical instruction.
 
         Returns:
+        -------
 
         """
-
         simple = {}
         for time, results in self.items():
-
             fired = set(results.keys())
 
             simple[time] = fired
 
         if last and simple:
             # Get the last coordinate
             keys = simple.keys()
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/misc/symbol_library.py` & `quantum_pecos-0.6.0.dev1/python/pecos/misc/symbol_library.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,82 +1,75 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2019 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Any, Callable, Optional, Dict
+from __future__ import annotations
+
 from collections import defaultdict
+from typing import Any, Callable
 
 
-class SymbolLibrary(object):
-    """
-    A library of objects and constructors of objects, where the objects are specified by symbols (strings) and
+class SymbolLibrary:
+    """A library of objects and constructors of objects, where the objects are specified by symbols (strings) and
     parameters that are used to construct the object.
 
     Attributes:
+    ----------
         constructors (Dict[str, Callable]): A dictionary of constructors.
         default_constructor:
         library (DefaultDict[str, Set[object]]: A dictionary of objects.
     """
 
-    def __init__(self):
-
+    def __init__(self) -> None:
         self.constructors = {}
         self.default_constructor = None
         self.library = defaultdict(set)
 
-    def add(self,
-            symbol: str,
-            obj: Any,
-            params: Dict[str, Any]) -> None:
-        """
-        Adds an object to `library`.
+    def add(self, symbol: str, obj: Any, params: dict[str, Any]) -> None:
+        """Adds an object to `library`.
 
         Args:
+        ----
             symbol (str): A string representing an object constructed.
             obj (object): Object to be stored.
             params (Dict[str, Any]): Parameters used to construct the object corresponding to `symbol`.
 
         Returns:
+        -------
 
         """
-
         self.library[symbol].add((obj, params))
 
-    def get(self,
-            symbol: str,
-            params: Dict[str, Any],
-            default: Optional[Any] = None) -> Any:
-        """
-        Get an instance associated with `symbol` that has the parameters `params`.
+    def get(self, symbol: str, params: dict[str, Any], default: Any | None = None) -> Any:
+        """Get an instance associated with `symbol` that has the parameters `params`.
 
         Args:
+        ----
             symbol (str): A string representing an object constructed.
             params (Dict[str, Any]): Parameters used to construct the object corresponding to `symbol`.
             default (Optional[Any]): Default value to return if a object could not be found or a constructed.
 
         Returns:
+        -------
 
         """
-
         obj_set = self.library.get(symbol)
 
         if obj_set:
-
             for instance, inst_params in obj_set:
                 if params == inst_params:
                     return instance
+            return None
 
         else:
             constructor = self.constructors.get(symbol)
 
             if constructor:
                 instance = constructor(**params)
 
@@ -85,26 +78,25 @@
 
             else:
                 return default
 
             self.library[symbol].add((instance, params))
             return instance
 
-    def add_constructor(self,
-                        symbol: str,
-                        constructor: Callable[..., Any]) -> None:
-        """
-        Add a constructor of a circuit.
+    def add_constructor(self, symbol: str, constructor: Callable[..., Any]) -> None:
+        """Add a constructor of a circuit.
 
         Args:
+        ----
             symbol (str): A string representing an object constructed.
             constructor (Callable): A callable that returns an object.
 
         Returns:
+        -------
             None
 
         """
-
         if not isinstance(constructor, Callable):
-            raise Exception('Constructor must be a callable.')
+            msg = f"Constructor must be a callable. Got type: {type(constructor)}"
+            raise TypeError(msg)
 
         self.constructors[symbol] = constructor
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/misc/threshold_curve.py` & `quantum_pecos-0.6.0.dev1/python/pecos/misc/threshold_curve.py`

 * *Files 8% similar despite different names*

```diff
@@ -10,290 +10,290 @@
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 import numpy as np
 from scipy.optimize import curve_fit
 
 
-def func(X, pth, v0, a, b, c):
-    """
-    Function that represents the curve to fit error rates to in order to determine the threshold. (see:
-    arXiv:quant-ph/0207088)
+def func(x, pth, v0, a, b, c):
+    """Function that represents the curve to fit error rates to in order to determine the threshold. (see:
+    arXiv:quant-ph/0207088).
 
     Probabilities are fine as long as p > 1/(4*distance). See paper by Watson and Barrett (arXiv:1312.5213).
 
     Args:
-        X:
+    ----
+        x:
         a:
         b:
         c:
         pth:
         v0:
 
     Returns:
+    -------
 
     """
-    p, dist = X
+    p, dist = x
 
     x = (p - pth) * np.power(dist, 1.0 / v0)
 
     return a + b * x + c * np.power(x, 2)
 
 
-def func2(X, pth, v0, a, b, c, d, u):
-    """
-    Function that represents the curve to fit error rates to in order to determine the threshold. (see:
-    arXiv:quant-ph/0207088)
+def func2(x, pth, v0, a, b, c, d, u):
+    """Function that represents the curve to fit error rates to in order to determine the threshold. (see:
+    arXiv:quant-ph/0207088).
 
     Probabilities are fine as long as p > 1/(4*distance). See paper by Watson and Barrett (arXiv:1312.5213).
 
     Args:
-        X:
+    ----
+        x:
         a:
         b:
         c:
         pth:
         v0:
 
     Returns:
+    -------
 
     """
-    p, dist = X
+    p, dist = x
 
     x = (p - pth) * np.power(dist, 1.0 / v0)
 
     z = a + b * x + c * np.power(x, 2)
 
     z += d * np.power(dist, -1.0 / u)
 
     return z
 
 
-def func3(X,  pth, v0, a, b, c, d, uodd, ueven):
-    """
-    Function that represents the curve to fit error rates to in order to determine the threshold. (see:
-    arXiv:quant-ph/0207088)
+def func3(x, pth, v0, a, b, c, d, uodd, ueven):
+    """Function that represents the curve to fit error rates to in order to determine the threshold. (see:
+    arXiv:quant-ph/0207088).
 
     Probabilities are fine as long as p > 1/(4*distance). See paper by Watson and Barrett (arXiv:1312.5213).
 
     Args:
-        X:
+    ----
+        x:
         a:
         b:
         c:
         pth:
         v0:
 
     Returns:
+    -------
 
     """
-    p, dist = X
+    p, dist = x
 
     x = (p - pth) * np.power(dist, 1.0 / v0)
 
-    z = np.where(bool(dist % 2), d*np.power(dist, -1.0/uodd), d*np.power(dist, -1.0/ueven))
+    z = np.where(bool(dist % 2), d * np.power(dist, -1.0 / uodd), d * np.power(dist, -1.0 / ueven))
 
     z += a + b * x + c * np.power(x, 2)
 
     return z
 
 
-def func4(X, pth, v0, a, b):
-    """
-    Function that represents the curve to fit error rates to in order to determine the threshold. (see:
-    arXiv:quant-ph/0207088)
+def func4(x, pth, v0, a, b):
+    """Function that represents the curve to fit error rates to in order to determine the threshold. (see:
+    arXiv:quant-ph/0207088).
 
     Probabilities are fine as long as p > 1/(4*distance). See paper by Watson and Barrett (arXiv:1312.5213).
 
     Args:
-        X:
+    ----
+        x:
         a:
         b:
         c:
         pth:
         v0:
 
     Returns:
+    -------
 
     """
-    p, dist = X
+    p, dist = x
 
     x = (p - pth) * np.power(dist, 1.0 / v0)
 
-    z = a * np.exp(-b*np.power(x, v0))
-
-    return z
+    return a * np.exp(-b * np.power(x, v0))
 
 
-def func5(X, pth, v0, a, b, c, d):
-    """
-    Function that represents the curve to fit error rates to in order to determine the threshold. (see:
-    arXiv:quant-ph/0207088)
+def func5(x, pth, v0, a, b, c, d):
+    """Function that represents the curve to fit error rates to in order to determine the threshold. (see:
+    arXiv:quant-ph/0207088).
 
     Probabilities are fine as long as p > 1/(4*distance). See paper by Watson and Barrett (arXiv:1312.5213).
 
     Args:
-        X:
+    ----
+        x:
         a:
         b:
         c:
         pth:
         v0:
 
     Returns:
+    -------
 
     """
-    p, dist = X
+    p, dist = x
 
     x = (p - pth) * np.power(dist, 1.0 / v0)
 
     return a + b * x + c * np.power(x, 2) + d * np.power(x, 3)
 
 
-def func6(X, a, pth):
-    """
-    Function that represents the curve to fit error rates to in order to determine the threshold. (see:
-    arXiv:quant-ph/0207088)
+def func6(x, a, pth):
+    """Function that represents the curve to fit error rates to in order to determine the threshold. (see:
+    arXiv:quant-ph/0207088).
 
     Probabilities are fine as long as p > 1/(4*distance). See paper by Watson and Barrett (arXiv:1312.5213).
 
     Args:
-        X:
+    ----
+        x:
         a:
         b:
         c:
         pth:
         v0:
 
     Returns:
+    -------
 
     """
-    p, dist = X
+    p, dist = x
 
-    return a * np.power(p/pth, dist/2)
+    return a * np.power(p / pth, dist / 2)
 
 
 def threshold_fit(plist, dlist, plog, func, p0, maxfev=100000, **kwargs):
-    """
-
-    Args:
+    """Args:
+    ----
         plist: List of ps.
         dlist: List of distances.
         plog: List of logical error rates.
         func: Function to fit to.
         maxfev:
 
     Returns:
+    -------
 
     """
-
     popt, pcov = curve_fit(func, (plist, dlist), plog, p0, maxfev=maxfev, **kwargs)
 
     var = np.diag(pcov)
     stdev = np.sqrt(var)
 
     return popt, stdev
 
 
 def jackknife_pd(plist, dlist, plog, func, p0, maxfev=100000, verbose=True):
-
     opt_list = []
     cov_list = []
     for i in range(len(plog)):
         p_copy = np.delete(plist, i)
         plog_copy = np.delete(plog, i)
         dlist_copy = np.delete(dlist, i)
 
         result = threshold_fit(p_copy, dlist_copy, plog_copy, func, p0, maxfev)
         opt_list.append(result[0])
         cov_list.append(result[1])
 
         if verbose:
-            print('removed index: %s' % i)
-            print('p = %s, d = %s' % (plist[i], dlist[i]))
-            print('parameter values:', result[0])
-            print('parameter stds: %s\n' % result[1])
+            print("removed index: %s" % i)
+            print(f"p = {plist[i]}, d = {dlist[i]}")
+            print("parameter values:", result[0])
+            print("parameter stds: %s\n" % result[1])
 
     est = np.mean(opt_list, axis=0)
     std = np.std(opt_list, axis=0)
 
-    print('Mean: %s' % est)
-    print('Std: %s' % std)
+    print("Mean: %s" % est)
+    print("Std: %s" % std)
 
     return est, std
 
 
-def jackknife_p(plist, dlist, plog,p0, maxfev=100000, verbose=True):
-
+def jackknife_p(plist, dlist, plog, p0, maxfev=100000, verbose=True):
     opt_list = []
     cov_list = []
-    uplist = sorted(list(set(plist)))
+    uplist = sorted(set(plist))
     for p in uplist:
         mask = plist != p
         p_copy = plist[mask]
         plog_copy = plog[mask]
         dlist_copy = dlist[mask]
 
         result = threshold_fit(p_copy, dlist_copy, plog_copy, p0, maxfev)
         opt_list.append(result[0])
         cov_list.append(result[1])
 
         if verbose:
-            print('removed p: %s' % p)
-            print('parameter values:', result[0])
-            print('parameter stds: %s\n' % result[1])
+            print("removed p: %s" % p)
+            print("parameter values:", result[0])
+            print("parameter stds: %s\n" % result[1])
 
     est = np.mean(opt_list, axis=0)
     std = np.std(opt_list, axis=0)
 
-    print('Mean: %s' % est)
-    print('Std: %s' % std)
+    print("Mean: %s" % est)
+    print("Std: %s" % std)
 
     return est, std
 
 
 def jackknife_d(plist, dlist, plog, p0, maxfev=100000, verbose=True):
-
     opt_list = []
     cov_list = []
 
-    udlist = sorted(list(set(dlist)))
+    udlist = sorted(set(dlist))
     for d in udlist:
         mask = dlist != d
         p_copy = plist[mask]
         plog_copy = plog[mask]
         dlist_copy = dlist[mask]
 
         result = threshold_fit(p_copy, dlist_copy, plog_copy, p0, maxfev)
         opt_list.append(result[0])
         cov_list.append(result[1])
 
         if verbose:
-            print('removed d: %s' % d)
-            print('parameter values:', result[0])
-            print('parameter stds: %s\n' % result[1])
+            print("removed d: %s" % d)
+            print("parameter values:", result[0])
+            print("parameter stds: %s\n" % result[1])
 
     est = np.mean(opt_list, axis=0)
     std = np.std(opt_list, axis=0)
 
-    print('Mean: %s' % est)
-    print('Std: %s' % std)
+    print("Mean: %s" % est)
+    print("Std: %s" % std)
 
     return est, std
 
 
 def get_est(value_is, label, verbose=True):
     v_est = sum(value_is) / len(value_is)
     v_est_std = np.std(value_is)
 
     if verbose:
-        print('%s_est: %s (mean) +- %s (std)' % (label, v_est, v_est_std))
+        print(f"{label}_est: {v_est} (mean) +- {v_est_std} (std)")
 
     return v_est, v_est_std
 
 
 def get_i(result, symbol, value_list, verbose=True):
     value_i = result[symbol][0]
     value_list.append(value_i)
 
     if verbose:
-        print('%s_i = %s' % (symbol, value_i))
+        print(f"{symbol}_i = {value_i}")
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/op_processors/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/machines/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/op_processors/generic_op_processor.py` & `quantum_pecos-0.6.0.dev1/python/pecos/op_processors/generic_op_processor.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,56 +5,58 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import List
+from __future__ import annotations
 
+from typing import TYPE_CHECKING
+
+from pecos.op_processors.op_processor_abc import OpProcessor
 from pecos.reps.pypmir import types as pt
-from .op_processor_abc import OpProcessor
 
+if TYPE_CHECKING:
+    from pecos.error_models.error_model_abc import ErrorModel
+    from pecos.machines.machine_abc import Machine
 
-class GenericOpProc(OpProcessor):
 
-    def __init__(self, machine=None, error_model=None):
+class GenericOpProc(OpProcessor):
+    def __init__(self, machine: Machine | None = None, error_model: ErrorModel | None = None) -> None:
         self.machine = machine
         self.error_model = error_model
 
     def reset(self) -> None:
         """Reset state to initialization state."""
-        pass
 
     def init(self) -> None:
         pass
 
-    def attach_machine(self, machine):
+    def attach_machine(self, machine: Machine) -> None:
         self.machine = machine
 
-    def attach_error_model(self, error_model):
+    def attach_error_model(self, error_model: ErrorModel) -> None:
         self.error_model = error_model
 
     def shot_reinit(self) -> None:
         pass
 
-    def process(self, buffered_ops) -> list:
-
+    def process(self, buffered_ops: list) -> list:
         buffered_noisy_qops = []
         for op in buffered_ops:
-
             if isinstance(op, pt.opt.MOp):
-                noisy_ops = self.machine.process([op])
-
+                ops = self.machine.process([op])
+                noisy_ops = self.error_model.process(ops)
             elif isinstance(op, pt.opt.QOp):
                 noisy_ops = self.error_model.process([op])
             else:
-                raise Exception(f"This operation processor only handles MOps and QOps! Received type: {type(op)}")
+                msg = f"This operation processor only handles MOps and QOps! Received type: {type(op)}"
+                raise TypeError(msg)
 
             if noisy_ops:
                 buffered_noisy_qops.extend(noisy_ops)
 
         return buffered_noisy_qops
 
-    def process_meas(self, measurements: List[dict]) -> List[dict]:
+    def process_meas(self, measurements: list[dict]) -> list[dict]:
         return measurements
-
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/op_processors/op_processor_abc.py` & `quantum_pecos-0.6.0.dev1/python/pecos/op_processors/op_processor_abc.py`

 * *Files 7% similar despite different names*

```diff
@@ -5,32 +5,32 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 import abc
 
 
 class OpProcessor(metaclass=abc.ABCMeta):
-
     @abc.abstractmethod
     def reset(self) -> None:
         """Reset state to initialization state."""
-        pass
 
     @abc.abstractmethod
-    def init(self, *args, **kwargs) -> None:
+    def init(self) -> None:
         pass
 
     @abc.abstractmethod
-    def shot_reinit(self, *args, **kwargs) -> None:
+    def shot_reinit(self) -> None:
         pass
 
     @abc.abstractmethod
-    def process(self, buffered_ops) -> list:
+    def process(self, buffered_ops: list) -> list:
         pass
 
     @abc.abstractmethod
     def process_meas(self, measurements: dict) -> dict:
         pass
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,16 +6,15 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .surface_medial_4444.surface_medial_4444 import SurfaceMedial4444
-from .surface_4444.surface_4444 import Surface4444
-from .color_488.color_488 import Color488
-# from .surface_triangular_4444.surface_triangular_4444 import SurfaceTriangular4444
+from pecos.qeccs.color_488.color_488 import Color488
+from pecos.qeccs.gate_parent_class import LogicalGate
+from pecos.qeccs.instruction_parent_class import LogicalInstruction
 
 # Parent Classes:
-from .qecc_parent_class import QECC
-from .gate_parent_class import LogicalGate
-from .instruction_parent_class import LogicalInstruction
+from pecos.qeccs.qecc_parent_class import QECC
+from pecos.qeccs.surface_4444.surface_4444 import Surface4444
+from pecos.qeccs.surface_medial_4444.surface_medial_4444 import SurfaceMedial4444
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/circuit_implementation1.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/circuit_implementation1.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,236 +7,215 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...circuits import QuantumCircuit
+from pecos.circuits import QuantumCircuit
 
 
-class OneAncillaPerCheck(object):
-    """
-    Class that describes an implementation of the 4.8.8 color code with one ancilla per face.
-    """
+class OneAncillaPerCheck:
+    """Class that describes an implementation of the 4.8.8 color code with one ancilla per face."""
 
-    def __init__(self, square_x_ticks=None, square_z_ticks=None, octagon_x_ticks=None, octagon_z_ticks=None):
-        """
-
-        Args:
+    def __init__(self, square_x_ticks=None, square_z_ticks=None, octagon_x_ticks=None, octagon_z_ticks=None) -> None:
+        """Args:
+        ----
             square_x_ticks:
             square_z_ticks:
             octagon_x_ticks:
             octagon_z_ticks:
         """
 
-        # print('!!!', square_x_ticks)
-
         if square_x_ticks is None:
             # 8 ticks
-            square_x_ticks = [0, 1,  # init, H ticks
-                              2, 3, 4, 5,  # Data ticks
-                              6, 7]  # H, meas ticks
+            square_x_ticks = [0, 1, 2, 3, 4, 5, 6, 7]  # init, H ticks  # Data ticks  # H, meas ticks
 
         if square_z_ticks is None:
             # 6 ticks
-            square_z_ticks = [12,  # int tick
-                              13, 14, 15, 16,
-                              17]  # meas tick
+            square_z_ticks = [12, 13, 14, 15, 16, 17]  # int tick  # meas tick
 
         if octagon_x_ticks is None:
             # 12 ticks
-            octagon_x_ticks = [0, 1,  # init, H ticks
-                               2, 3, 4, 5, 6, 7, 8, 9,  # Data ticks
-                               10, 11]  # H, meas ticks
+            octagon_x_ticks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]  # init, H ticks  # Data ticks  # H, meas ticks
 
         if octagon_z_ticks is None:
             # 10 ticks
-            octagon_z_ticks = [12,  # int tick
-                               13, 14, 15, 16, 17, 18, 19, 20,  # Data ticks
-                               21]  # meas tick
+            octagon_z_ticks = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21]  # int tick  # Data ticks  # meas tick
 
         self.square_x_ticks = square_x_ticks
         self.square_z_ticks = square_z_ticks
         self.octagon_x_ticks = octagon_x_ticks
         self.octagon_z_ticks = octagon_z_ticks
 
     @staticmethod
     def get_num_ancillas(num_checks):
-        """
-
-        Args:
+        """Args:
+        ----
             num_checks:
 
         Returns:
+        -------
 
         """
-
-        num_ancillas = int(num_checks/2)
-
-        return num_ancillas
+        return int(num_checks / 2)
 
     def compile(self, instr, abstract_circuit, mapping=None):
-        """
-
-        Args:
+        """Args:
+        ----
             abstract_circuit:
             mapping:
             **gate_params:
 
         Returns:
+        -------
 
         """
-
         gate_params = instr.gate_params
 
         if mapping is None:
-            mapping = gate_params.get('mapping')
+            mapping = gate_params.get("mapping")
 
-        square_x_ticks = gate_params.get('square_x_ticks', self.square_x_ticks)
-        square_z_ticks = gate_params.get('square_z_ticks', self.square_z_ticks)
-        octagon_x_ticks = gate_params.get('octagon_x_ticks', self.octagon_x_ticks)
-        octagon_z_ticks = gate_params.get('octagon_z_ticks', self.octagon_z_ticks)
+        square_x_ticks = gate_params.get("square_x_ticks", self.square_x_ticks)
+        square_z_ticks = gate_params.get("square_z_ticks", self.square_z_ticks)
+        octagon_x_ticks = gate_params.get("octagon_x_ticks", self.octagon_x_ticks)
+        octagon_z_ticks = gate_params.get("octagon_z_ticks", self.octagon_z_ticks)
 
         largest_tick = []
         largest_tick.extend(square_x_ticks)
         largest_tick.extend(square_z_ticks)
         largest_tick.extend(octagon_x_ticks)
         largest_tick.extend(octagon_z_ticks)
         largest_tick = max(largest_tick)
 
         circuit = QuantumCircuit(largest_tick + 1, **gate_params)
 
         if len(square_x_ticks) != 8:  # data + 4
-            raise Exception('`square_x_ticks` should be of length : init tick, H tick, 4 data ticks, H tick, meas tick')
+            msg = "`square_x_ticks` should be of length : init tick, H tick, 4 data ticks, H tick, meas tick"
+            raise Exception(msg)
 
         if len(square_z_ticks) != 6:  # data + 2
-            raise Exception('`square_z_ticks` should be of length : init tick, 4 data ticks, meas tick')
+            msg = "`square_z_ticks` should be of length : init tick, 4 data ticks, meas tick"
+            raise Exception(msg)
 
         if len(octagon_x_ticks) != 12:  # data + 4
-            raise Exception('`octagon_x_ticks` should be of length : init tick, H tick, 8 data ticks, H tick, meas tick')
+            msg = "`octagon_x_ticks` should be of length : init tick, H tick, 8 data ticks, H tick, meas tick"
+            raise Exception(msg)
 
         if len(octagon_z_ticks) != 10:  # data + 2
-            raise Exception('`octagon_z_ticks` should be of length : init tick, 8 data ticks, meas tick')
+            msg = "`octagon_z_ticks` should be of length : init tick, 8 data ticks, meas tick"
+            raise Exception(msg)
 
         for check_type, locations, params in abstract_circuit.items():
-            polygon = params.get('polygon')
+            polygon = params.get("polygon")
 
             if polygon is None:  # This is an actual circuit element
                 if mapping:
-                    circuit.update({check_type: self.mapset(mapping, set(locations))}, tick=params['tick'])
+                    circuit.update({check_type: self.mapset(mapping, set(locations))}, tick=params["tick"])
                 else:
-                    circuit.update({check_type: set(locations)}, tick=params['tick'])
+                    circuit.update({check_type: set(locations)}, tick=params["tick"])
             else:
-                ancilla = list(locations)[0]
-                datas = params['datas']
+                ancilla = next(iter(locations))
+                datas = params["datas"]
 
-                if polygon == 'square':
-                    if check_type == 'X check':
-                        ticks = square_x_ticks
-                    else:
-                        ticks = square_z_ticks
+                if polygon == "square":
+                    ticks = square_x_ticks if check_type == "X check" else square_z_ticks
 
                 else:
-                    if check_type == 'X check':
-                        ticks = octagon_x_ticks
-                    else:
-                        ticks = octagon_z_ticks
+                    ticks = octagon_x_ticks if check_type == "X check" else octagon_z_ticks
 
                 self._create_check(circuit, polygon, ticks, check_type, datas, ancilla, mapping)
 
         return circuit
 
     @staticmethod
     def mapset(mapping, oldset):
-        """
-        Applies a mapping to a set.
+        """Applies a mapping to a set.
 
         Args:
+        ----
             mapping:
             oldset (set):
 
         Returns:
+        -------
 
         """
         newset = set()
 
         for e in oldset:
             newset.add(mapping[e])
 
         return newset
 
     def _create_check(self, circuit, polygon, ticks, check_type, datas, ancilla, mapping):
-        """
-
-        Args:
+        """Args:
+        ----
             circuit:
             polygon:
             ticks:
             check_type:
             datas:
             ancilla:
             mapping:
 
         Returns:
+        -------
 
         """
-
-        if polygon == 'square':
-
+        if polygon == "square":
             sides = 4
 
             if len(datas) != sides:
-                raise Exception('Squares must have 4 datas!')
+                msg = "Squares must have 4 datas!"
+                raise Exception(msg)
         else:
-
             sides = 8
 
             if len(datas) != sides:
-                raise Exception('Octagons must have 8 datas!')
+                msg = "Octagons must have 8 datas!"
+                raise Exception(msg)
 
-        if check_type == 'X check':
+        if check_type == "X check":
             h1_tick = ticks[1]
-            data_ticks = ticks[2:sides+2]
+            data_ticks = ticks[2 : sides + 2]
             h2_tick = ticks[-2]
 
             if mapping is None:
-                circuit.update({'H': {ancilla}}, tick=h1_tick)
-                circuit.update({'H': {ancilla}}, tick=h2_tick)
+                circuit.update({"H": {ancilla}}, tick=h1_tick)
+                circuit.update({"H": {ancilla}}, tick=h2_tick)
 
                 # CNOTs...
 
                 for d, t in zip(datas, data_ticks):
                     if d is not None:
-                        circuit.update({'CNOT': {(ancilla, d)}}, tick=t)
+                        circuit.update({"CNOT": {(ancilla, d)}}, tick=t)
             else:
-                circuit.update({'H': {mapping[ancilla]}}, tick=h1_tick)
-                circuit.update({'H': {mapping[ancilla]}}, tick=h2_tick)
+                circuit.update({"H": {mapping[ancilla]}}, tick=h1_tick)
+                circuit.update({"H": {mapping[ancilla]}}, tick=h2_tick)
 
                 for d, t in zip(datas, data_ticks):
                     if d is not None:
-                        circuit.update({'CNOT': {(mapping[ancilla], mapping[d])}}, tick=t)
+                        circuit.update({"CNOT": {(mapping[ancilla], mapping[d])}}, tick=t)
 
         else:  # Z check
-            data_ticks = ticks[1:sides+1]
+            data_ticks = ticks[1 : sides + 1]
 
             if mapping is None:
-
                 for d, t in zip(datas, data_ticks):
                     if d is not None:
-                        circuit.update({'CNOT': {(d, ancilla)}}, tick=t)
+                        circuit.update({"CNOT": {(d, ancilla)}}, tick=t)
             else:
-
                 for d, t in zip(datas, data_ticks):
                     if d is not None:
-                        circuit.update({'CNOT': {(mapping[d], mapping[ancilla])}}, tick=t)
+                        circuit.update({"CNOT": {(mapping[d], mapping[ancilla])}}, tick=t)
 
         init_tick = ticks[0]
         meas_tick = ticks[-1]
 
         if mapping is None:
-            circuit.update({'init |0>': {ancilla}}, tick=init_tick)
-            circuit.update({'measure Z': {ancilla}}, tick=meas_tick)
+            circuit.update({"init |0>": {ancilla}}, tick=init_tick)
+            circuit.update({"measure Z": {ancilla}}, tick=meas_tick)
 
         else:
-            circuit.update({'init |0>': {mapping[ancilla]}}, tick=init_tick)
-            circuit.update({'measure Z': {mapping[ancilla]}}, tick=meas_tick)
+            circuit.update({"init |0>": {mapping[ancilla]}}, tick=init_tick)
+            circuit.update({"measure Z": {mapping[ancilla]}}, tick=meas_tick)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/color_488.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/color_488.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,88 +1,80 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-    repetition_z
-    ~~~~~~~~~~~~
+"""repetition_z
+~~~~~~~~~~~~.
 
-    Generates circuits for the repetition code in the Z-Basis.
+Generates circuits for the repetition code in the Z-Basis.
 """
-from ..qecc_parent_class import QECC
-# from ...circuit_converters.checks2circuit import Check2Circuits
-from .circuit_implementation1 import OneAncillaPerCheck
-from .instructions import InstrSynExtraction, InstrInitZero, InstrInitPlus
-from .gates import GateIdentity, GateInitZero, GateInitPlus
+from pecos.qeccs.color_488.circuit_implementation1 import OneAncillaPerCheck
+from pecos.qeccs.color_488.gates import GateIdentity, GateInitPlus, GateInitZero
+from pecos.qeccs.color_488.instructions import InstrInitPlus, InstrInitZero, InstrSynExtraction
+from pecos.qeccs.qecc_parent_class import QECC
 
 
 class Color488(QECC):
-    """
-    Canonical triangular color-code on a 4.8.8 lattice.
-    """
-
-    def __init__(self, distance=None, **qecc_params):
+    """Canonical triangular color-code on a 4.8.8 lattice."""
 
+    def __init__(self, distance=None, **qecc_params) -> None:
         # TODO: Need to switch to codes each having a class defining how classes are implemented. From that we get the
         # layout and ancillas. We don't need a general circuit conversion script... The default implementation may
         # still be overridden.
         # TODO: A layout with syndomes should be created and the implementation should use this is create a physical
         # layout. -> tanner_graph, layout
 
         if distance is not None:
-            qecc_params['distance'] = distance
+            qecc_params["distance"] = distance
 
         super().__init__(**qecc_params)
 
         # Give name for others classes to identify this code
         # --------------------------------------------------
-        self.name = '4.8.8 Color Code'
+        self.name = "4.8.8 Color Code"
 
         # QECC parameters:
         # ----------------
         self.qecc_params = qecc_params
 
         # Create dictionaries to associate symbols to gate and instruction classes.
         self.sym2gate_class, self.sym2instruction_class = self._set_symbols()
 
         # d - distance
-        self.distance = qecc_params['distance']
+        self.distance = qecc_params["distance"]
 
         if self.distance % 2 == 0:
-            raise Exception('This code requires an odd distance!')
+            msg = "This code requires an odd distance!"
+            raise Exception(msg)
 
         # n - number of data qubits
-        self.num_data_qudits = int((self.distance**2 - 1)*0.5 + self.distance)
+        self.num_data_qudits = int((self.distance**2 - 1) * 0.5 + self.distance)
 
         # k - number of logical qubits
         self.num_logical_qudits = 1
 
         # number of syndrome bits
         self.num_syndromes = self.num_data_qudits - self.num_logical_qudits
 
         # --------------------------------------------------------------------------------------------------------------
         # Determine number of ancillas to reserve given the check circuit implementation and, perhaps, the logical
         # gate circuits implemented by this class.
         # --------------------------------------------------------------------------------------------------------------
-        self.circuit_compiler = qecc_params.get('circuit_compiler', OneAncillaPerCheck())
+        self.circuit_compiler = qecc_params.get("circuit_compiler", OneAncillaPerCheck())
         self.num_ancilla_qudits = self.circuit_compiler.get_num_ancillas(self.num_syndromes)
 
         # Total number of qudits.
-        # self.num_qudits = self.num_data_qudits + self.num_ancilla_qudits
-        # print(self.num_qudits, self.num_data_qudits, self.num_ancilla_qudits)
         # self.qudit_set, self.data_qudit_set, self.ancilla_qudit_set will be determined when creating the layout.
 
         # Determine QECC geometry
         # -----------------------
         self.lattice_width = None
         self.lattice_height = None
         self.lattice_dimensions = {}
@@ -91,151 +83,120 @@
 
         # Create side information
         # Allows other classes (e.g., decoders) to understand the orientation of the code
         self.sides = self._determine_sides()
 
     @staticmethod
     def _set_symbols():
-
         # gate and instruction symbol bindings
         # ------------------------------------
         # gate symbol => gate class
         sym2gate_class = {
-            'I': GateIdentity,
-            'init |0>': GateInitZero,
-            'init |+>': GateInitPlus,
+            "I": GateIdentity,
+            "init |0>": GateInitZero,
+            "init |+>": GateInitPlus,
         }
 
         # instruction symbol => instr. class
         sym2instruction_class = {
-            'instr_syn_extract': InstrSynExtraction,
-            'instr_init_zero': InstrInitZero,
-            'instr_init_plus': InstrInitPlus,
+            "instr_syn_extract": InstrSynExtraction,
+            "instr_init_zero": InstrInitZero,
+            "instr_init_plus": InstrInitPlus,
         }
 
         return sym2gate_class, sym2instruction_class
 
     @staticmethod
     def _get_distance(params):
-        """
-        Check and set the distance
+        """Check and set the distance
         :return:
         """
-
-        distance = params.get('distance')
+        distance = params.get("distance")
 
         if distance is not None:
             distance_width = distance_height = distance
 
         else:
-            distance_width = params.get('distance_width')  # The width of the code. == Z? distance
-            distance_height = params.get('distance_height')  # The height of the code. == X? distance
+            distance_width = params.get("distance_width")  # The width of the code. == Z? distance
+            distance_height = params.get("distance_height")  # The height of the code. == X? distance
             distance = min(distance_width, distance_height)
 
         return distance, distance_height, distance_width
 
     def _generate_layout(self):
-        """
-        Creates the layout dictionary which describes the location of the qubits in the code.
-
-        """
-
+        """Creates the layout dictionary which describes the location of the qubits in the code."""
         self.lattice_height = 4 * self.distance - 4
         self.lattice_width = 2 * self.distance - 2
         data_ids = self._data_id_iter()
         ancilla_ids = self._ancilla_id_iter()
 
         self.lattice_dimensions = {
-            'width': self.lattice_width,
-            'height': self.lattice_height
+            "width": self.lattice_width,
+            "height": self.lattice_height,
         }
 
         # Determine the position of things
         for y in range(self.lattice_width + 1):
             for x in range(self.lattice_height + 1):
-
-                if (x, y) == (x, x + 2) and x % 2 == 1 and y % 8 == 3:
-
-                    # self._add_node(x, y, ancilla_ids)
-                    pass
-
-                elif (x, y) == (4 * self.distance - y, y) and x % 2 == 1 and y % 8 == 7:
-                    # self._add_node(x, y, ancilla_ids)
+                if ((x, y) == (x, x + 2) and x % 2 == 1 and y % 8 == 3) or (
+                    (x, y) == (4 * self.distance - y, y) and x % 2 == 1 and y % 8 == 7
+                ):
                     pass
 
                 elif (x, y) > (x, x) or (x, y) > (4 * self.distance - y - 2, y):
                     continue
 
                 if x % 2 == 0 and y % 2 == 0:  # Data
                     if (y / 2) % 4 == 1 or (y / 2) % 4 == 2:
-                        # self._add_node(x, y, data_ids)
                         if (x / 2) % 4 == 2 or (x / 2) % 4 == 3:
                             self._add_node(x, y, data_ids)
 
                     else:
                         if (x / 2) % 4 == 0 or (x / 2) % 4 == 1:
                             self._add_node(x, y, data_ids)
 
                 if x % 4 == 1 and y % 4 == 3:
                     self._add_node(x, y, ancilla_ids)
 
-                if y == 0:
-                    if x % 8 == 5:
-                        self._add_node(x, y, ancilla_ids)
-
-                    # elif y % 4 == 3 and x % 4 == 1:
-                    #    self._add_node(x, y, ancilla_ids)
+                if y == 0 and x % 8 == 5:
+                    self._add_node(x, y, ancilla_ids)
 
         return self.layout
 
     def _determine_sides(self):
-        """
-        Outputs a dictionary that describes the sides of the code.
+        """Outputs a dictionary that describes the sides of the code.
 
         The repetition code is essentially a line.
 
         d d d
          a a
 
         d = data
         a = ancilla
 
         :return:
         """
 
-        # width = self.lattice_width
-        # height = self.lattice_height
-
-        # right_nodes = []
         bottom_nodes = []
         left_nodes = []
 
-        # layout = self.layout
-
         # self.qubits_data is not set when this is called
 
         for d, (x, y) in self.layout.items():
-
             if (x, y) == (x, x):
                 left_nodes.append(d)
 
             # if x == 555:
-            #    right_nodes.append(d)
 
             if y == 0 and x % 2 == 0:
                 bottom_nodes.append(d)
 
-        # right_nodes.sort(reverse=True)
         bottom_nodes.sort()
         left_nodes.sort()
 
-        # right_nodes = [self.mapping[i] for i in right_nodes]
         bottom_nodes = [self.mapping[i] for i in bottom_nodes]
         left_nodes = [self.mapping[i] for i in left_nodes]
 
-        boundaries = {
-            # 'right': right_nodes,
-            'bottom': bottom_nodes,
-            'left': left_nodes
+        return {
+            "bottom": bottom_nodes,
+            "left": left_nodes,
         }
-
-        return boundaries
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/color_488/instructions.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/color_488/instructions.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,219 +7,220 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ..instruction_parent_class import LogicalInstruction
-from ...circuits.quantum_circuit import QuantumCircuit
-from ..helper_functions import pos2qudit
+from pecos.circuits.quantum_circuit import QuantumCircuit
+from pecos.qeccs.helper_functions import pos2qudit
+from pecos.qeccs.instruction_parent_class import LogicalInstruction
 
 
 class InstrSynExtraction(LogicalInstruction):
-    """
-    Instruction for a round of syndrome extraction.
+    """Instruction for a round of syndrome extraction.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
         self.abstract_circuit = QuantumCircuit(**params)
 
-        # self.data_qudit_set = self.qecc.data_qudit_set
-        # self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
-
-        self.ancilla_x_check = set([])
-        self.ancilla_z_check = set([])
+        self.ancilla_x_check = set()
+        self.ancilla_z_check = set()
 
         # Go through the ancillas and grab the data qubits that are on either side of it.
-        # layout = qecc.layout  # qudit_id => (x, y)
 
         self.pos2qudit = pos2qudit(qecc.layout)
 
         for q in sorted(self.ancilla_qudit_set):
-
             self._create_checks(q)
 
         # Determine the logical operations
         # --------------------------------
-        z_qudits = set(qecc.sides['bottom'])
-        x_qudits = set(qecc.sides['bottom'])
+        z_qudits = set(qecc.sides["bottom"])
+        x_qudits = set(qecc.sides["bottom"])
 
         logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': QuantumCircuit([{'X': x_qudits}]), 'Z': QuantumCircuit([{'Z': z_qudits}])},
+            {"X": QuantumCircuit([{"X": x_qudits}]), "Z": QuantumCircuit([{"Z": z_qudits}])},
         ]
 
         self.initial_logical_ops = logical_ops
         self.final_logical_ops = logical_ops
 
         self.logical_signs = None
         self.logical_stabilizers = None
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
 
     def _create_checks(self, ancilla):
-
         self.ancilla_x_check.add(ancilla)
         self.ancilla_z_check.add(ancilla)
 
         # look up ancilla location
         x, y = self.qecc.layout[ancilla]
 
         square = []
         octagon = []
 
-        square.append(self.pos2qudit.get((x - 1, y + 1)))
-        square.append(self.pos2qudit.get((x + 1, y + 1)))
-        square.append(self.pos2qudit.get((x - 1, y - 1)))
-        square.append(self.pos2qudit.get((x + 1, y - 1)))
+        square.extend(
+            (
+                self.pos2qudit.get((x - 1, y + 1)),
+                self.pos2qudit.get((x + 1, y + 1)),
+                self.pos2qudit.get((x - 1, y - 1)),
+                self.pos2qudit.get((x + 1, y - 1)),
+            ),
+        )
 
         found_square = False
 
         for d in square:
             if d is not None:
                 found_square = True
                 break
 
         if found_square:
-
-            self.abstract_circuit.append('X check', polygon='square', locations={ancilla}, datas=square)
-            self.abstract_circuit.append('Z check', polygon='square', locations={ancilla}, datas=square)
+            self.abstract_circuit.append("X check", polygon="square", locations={ancilla}, datas=square)
+            self.abstract_circuit.append("Z check", polygon="square", locations={ancilla}, datas=square)
 
         else:
-
             if y != 0:
-
-                octagon.append(self.pos2qudit.get((x - 1, y + 3)))
-                octagon.append(self.pos2qudit.get((x + 1, y + 3)))
-                octagon.append(self.pos2qudit.get((x - 3, y + 1)))
-                octagon.append(self.pos2qudit.get((x + 3, y + 1)))
-                octagon.append(self.pos2qudit.get((x - 3, y - 1)))
-                octagon.append(self.pos2qudit.get((x + 3, y - 1)))
-                octagon.append(self.pos2qudit.get((x - 1, y - 3)))
-                octagon.append(self.pos2qudit.get((x + 1, y - 3)))
+                octagon.extend(
+                    (
+                        self.pos2qudit.get((x - 1, y + 3)),
+                        self.pos2qudit.get((x + 1, y + 3)),
+                        self.pos2qudit.get((x - 3, y + 1)),
+                        self.pos2qudit.get((x + 3, y + 1)),
+                        self.pos2qudit.get((x - 3, y - 1)),
+                        self.pos2qudit.get((x + 3, y - 1)),
+                        self.pos2qudit.get((x - 1, y - 3)),
+                        self.pos2qudit.get((x + 1, y - 3)),
+                    ),
+                )
             else:
-
-                octagon.append(self.pos2qudit.get((x - 1, y + 2)))
-                octagon.append(self.pos2qudit.get((x + 1, y + 2)))
-                octagon.append(self.pos2qudit.get((x - 3, y)))
-                octagon.append(self.pos2qudit.get((x + 3, y)))
+                octagon.extend(
+                    (
+                        self.pos2qudit.get((x - 1, y + 2)),
+                        self.pos2qudit.get((x + 1, y + 2)),
+                        self.pos2qudit.get((x - 3, y)),
+                        self.pos2qudit.get((x + 3, y)),
+                    ),
+                )
                 octagon.extend([None, None, None, None])
 
-            self.abstract_circuit.append('X check', polygon='octagon', locations={ancilla}, datas=octagon)
-            self.abstract_circuit.append('Z check', polygon='octagon', locations={ancilla}, datas=octagon)
+            self.abstract_circuit.append("X check", polygon="octagon", locations={ancilla}, datas=octagon)
+            self.abstract_circuit.append("Z check", polygon="octagon", locations={ancilla}, datas=octagon)
 
 
 class InstrInitZero(LogicalInstruction):
-    """
-    Instruction for initializing a logical zero.
+    """Instruction for initializing a logical zero.
 
     It is just like syndrome extraction except the data qubits are initialized in the zero state at tick = 0.
 
     `ideal_meas` == True will cause the measurements to be replace with ideal measurements.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
-        self.symbol = 'instr_init_zero'
+        self.symbol = "instr_init_zero"
 
         self.data_qudit_set = self.qecc.data_qudit_set
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
 
         # This is basically syndrome extraction round where all the data qubits are initialized to zero.
-        syn_ext = qecc.instruction('instr_syn_extract', **params)
+        syn_ext = qecc.instruction("instr_syn_extract", **params)
 
         # Make a shallow copy of the abstract circuits.
         self.abstract_circuit = syn_ext.abstract_circuit.copy()
         self.abstract_circuit.params.update(params)
 
         self.ancilla_x_check = syn_ext.ancilla_x_check
         self.ancilla_z_check = syn_ext.ancilla_z_check
 
         data_qudits = syn_ext.data_qudit_set
-        self.abstract_circuit.append('init |0>', locations=data_qudits, tick=0)
+        self.abstract_circuit.append("init |0>", locations=data_qudits, tick=0)
 
         self.initial_logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': None, 'Z': None},  # None => can be anything
+            {"X": None, "Z": None},  # None => can be anything
         ]
 
         # Special for state initialization:
         # ---------------------------------
         # list of tuples of logical check and delogical stabilizer for each logical qudit.
         self.final_logical_ops = [
-            {'X': QuantumCircuit([{'Z': set(qecc.sides['bottom'])}]), 'Z': QuantumCircuit([{'X': set(qecc.sides['bottom'])}])}
+            {
+                "X": QuantumCircuit([{"Z": set(qecc.sides["bottom"])}]),
+                "Z": QuantumCircuit([{"X": set(qecc.sides["bottom"])}]),
+            },
         ]
 
         # List of corresponding logical sign. (The logical sign if the instruction is preformed ideally.)
         self.logical_signs = [0]
-        self.logical_stabilizers = ['Z']
+        self.logical_stabilizers = ["Z"]
         # ---------------------------------
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
 
 
 class InstrInitPlus(LogicalInstruction):
-    """
-    Instruction for initializing a logical plus.
+    """Instruction for initializing a logical plus.
 
     It is just like syndrome extraction except the data qubits are initialized in the plus state at tick = 0.
 
     `ideal_meas` == True will cause the measurements to be replace with ideal measurements.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
-        self.symbol = 'instr_init_plus'
+        self.symbol = "instr_init_plus"
 
         self.data_qudit_set = self.qecc.data_qudit_set
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
 
         # This is basically syndrome extraction round where all the data qubits are initialized to plus.
-        syn_ext = qecc.instruction('instr_syn_extract', **params)
+        syn_ext = qecc.instruction("instr_syn_extract", **params)
 
         # Make a shallow copy of the abstract circuits.
         self.abstract_circuit = syn_ext.abstract_circuit.copy()
         self.abstract_circuit.params.update(params)
 
         self.ancilla_x_check = syn_ext.ancilla_x_check
         self.ancilla_z_check = syn_ext.ancilla_z_check
 
         data_qudits = syn_ext.data_qudit_set
-        # self.abstract_circuit.append('init |+>', qudits=data_qudits, tick=0)
-        self.abstract_circuit.append('init |0>', locations=data_qudits, tick=0)
-        self.abstract_circuit.append('H', locations=data_qudits, tick=1)
+        self.abstract_circuit.append("init |0>", locations=data_qudits, tick=0)
+        self.abstract_circuit.append("H", locations=data_qudits, tick=1)
 
         self.initial_logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': None, 'Z': None},  # None => can be anything
+            {"X": None, "Z": None},  # None => can be anything
         ]
 
         # Special for state initialization:
         # ---------------------------------
         # list of tuples of logical check and delogical stabilizer for each logical qudit.
         self.final_logical_ops = [
-            {'X': QuantumCircuit([{'X': set(qecc.sides['bottom'])}]), 'Z': QuantumCircuit([{'Z': set(qecc.sides['bottom'])}])}
+            {
+                "X": QuantumCircuit([{"X": set(qecc.sides["bottom"])}]),
+                "Z": QuantumCircuit([{"Z": set(qecc.sides["bottom"])}]),
+            },
         ]
 
         # List of corresponding logical sign. (The logical sign if the instruction is preformed ideally.)
         self.logical_signs = [0]
-        self.logical_stabilizers = ['X']
+        self.logical_stabilizers = ["X"]
         # ---------------------------------
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/gate_parent_class.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/gate_parent_class.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,81 +7,75 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Contains the parent classes for logical gates.
-"""
-from .helper_functions import make_hashable_params
-from .helper_functions import expected_params
+"""Contains the parent classes for logical gates."""
+from pecos.qeccs.helper_functions import expected_params, make_hashable_params
 
 
-class LogicalGate(object):
-    """
-    A parent class for logical gates.
+class LogicalGate:
+    """A parent class for logical gates.
 
     The main role of logical gates is to identify the sequence of logical instructions the gate is made out of.
 
     This class has methods to return a list of logical instruction objects and a list of circuits based on a list of
     instruction symbols, which is an attribute of the class.
     """
 
-    def __init__(self, qecc, symbol, **gate_params):
-
+    def __init__(self, qecc, symbol, **gate_params) -> None:
         self.symbol = symbol
         self.qecc = qecc  # The qecc the gate is a member of.
         self.gate_params = gate_params  # Gate parameters
         self.params = self.gate_params
         self.instr_symbols = None
         self.instr_instances = []
         self.circuits = []  # The circuits of the logical instructions. (Either instr instances or a QuantumCircuit or
         # something with the same methods as a QuantumCircuit.)
-        self.error_free = gate_params.get('error_free', False)  # Whether errors should occur for this gate.
-        self.forced_outcome = gate_params.get('forced_outcome', True)  # Whether the measurements are random
+        self.error_free = gate_params.get("error_free", False)  # Whether errors should occur for this gate.
+        self.forced_outcome = gate_params.get("forced_outcome", True)  # Whether the measurements are random
         # (if True-> force -1)
         # Can choose 0 or 1.
 
         self.qecc_params_tuple = make_hashable_params(qecc.qecc_params)  # Used for hashing.
         self.gate_params_tuple = make_hashable_params(gate_params)  # Used for hashing.
 
     def final_instr(self):
-        """
-        Gives the final Logical Instruction instance.
+        """Gives the final Logical Instruction instance.
 
         Returns:
+        -------
 
         """
-
         return self.instr_instances[-1]
 
     def final_logical_stabs(self):
-        """
-        Gives the final_logical_ops dict.
-        """
+        """Gives the final_logical_ops dict."""
         return self.instr_instances[-1].final_logical_ops
 
     def expected_params(self, params, expected_set):
         expected_params(params, expected_set)
 
     def __hash__(self):
         # Added so the logical gate can be a key (gate symbol) in a ``QuantumCircuit``.
 
         # These uniquely identify the logical and do not change.
-        return hash(('gate', self.symbol, self.qecc_params_tuple, self.gate_params_tuple))
+        return hash(("gate", self.symbol, self.qecc_params_tuple, self.gate_params_tuple))
 
     def __eq__(self, other):
-        return (self.symbol, self.qecc_params_tuple,
-                self.gate_params_tuple, True) == (other.symbol, other.qecc_params_tuple, other.gate_params_tuple,
-                                                  hasattr(other, 'instr_symbols'))
+        return (self.symbol, self.qecc_params_tuple, self.gate_params_tuple, True) == (
+            other.symbol,
+            other.qecc_params_tuple,
+            other.gate_params_tuple,
+            hasattr(other, "instr_symbols"),
+        )
 
     def __ne__(self, other):
-        return not(self == other)
-
-    def __str__(self):
+        return not (self == other)
 
-        return "Logical gate: '%s' params=%s - QECC: %s params=%s - Instructions: %s" % (self.symbol, self.gate_params,
-                                                                                         self.qecc.name,
-                                                                                         self.qecc.qecc_params,
-                                                                                         self.instr_symbols)
+    def __str__(self) -> str:
+        return (
+            f"Logical gate: '{self.symbol}' params={self.gate_params} - QECC: {self.qecc.name} "
+            f"params={self.qecc.qecc_params} - Instructions: {self.instr_symbols}"
+        )
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/helper_functions.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/helper_functions.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,75 +6,74 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-A collection of useful functions.
-"""
+"""A collection of useful functions."""
 
 
 def make_hashable_params(params):
-    """
-    Checks to make sure that the parameters submitted is hashable.
+    """Checks to make sure that the parameters submitted is hashable.
 
     Args:
+    ----
         params(dict):
 
     Returns:
+    -------
 
     """
-
     tuple_params = []
 
     for key, value in params.items():
         if isinstance(value, dict):
-            dict_tuple = tuple([(key2, value2) for key2, value2 in value.items()])
+            dict_tuple = tuple(value.items())
             tuple_params.append(dict_tuple)
         else:
             if isinstance(value, (list, set)):
                 tuple_params.append((key, tuple(value)))
             else:
                 tuple_params.append((key, value))
 
     tuple_params = tuple(tuple_params)
 
     try:
         hash(tuple_params)
     except TypeError:
-        raise TypeError('The values of keywords given to this class must be hashable.')
+        msg = "The values of keywords given to this class must be hashable."
+        raise TypeError(msg) from TypeError
 
     return tuple_params
 
 
 def pos2qudit(layout):
-    """
-    Reverses the layout dictionary. Makes a new dictionary with (x, y, ...) => qudit_id
+    """Reverses the layout dictionary. Makes a new dictionary with (x, y, ...) => qudit_id.
 
     Args:
+    ----
         layout:
 
     Returns:
+    -------
 
     """
-
     return {p: qid for qid, p in layout.items()}
 
 
 def expected_params(params, expected_set):
-    """
-
-    Args:
+    """Args:
+    ----
         params(dict):
         expected_set(set):
 
     Returns:
+    -------
 
     """
-
     keys = set(params.keys())
 
     unexpected = keys - expected_set
     if unexpected:
-        raise Exception('Recieved unexpected keys (%s). Expected keys include: %s' % (unexpected, expected_set))
+        msg = f"Received unexpected keys ({unexpected}). Expected keys include: {expected_set}"
+        raise Exception(msg)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/instruction_parent_class.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/instruction_parent_class.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,100 +7,86 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Contains the parent classes for logical instructions.
-"""
-from .plot import plot_instr
-from .helper_functions import make_hashable_params
+"""Contains the parent classes for logical instructions."""
+from pecos.qeccs.helper_functions import make_hashable_params
+from pecos.qeccs.plot import plot_instr
 
 
-class LogicalInstruction(object):
-    """
-    A parent class for logical instructions.
+class LogicalInstruction:
+    """A parent class for logical instructions.
 
     Logical instructions are circuits that
     """
 
-    def __init__(self, qecc, symbol, **params):
-        """
-
-        Args:
+    def __init__(self, qecc, symbol, **params) -> None:
+        """Args:
+        ----
             qecc(QECC):
             symbol(str):
             **params:
         """
-
         self.symbol = symbol
         self.qecc = qecc  # The QECC object this instruction belongs to.
         self.params = params
         self.gate_params = self.params  # Parameters used in defining the logical instruction.
         # TODO: should this be the same as the gate parameters?
         self.abstract_circuit = None  # Abstract representation of the circuit.
         self.circuit = None  # Compiled circuit.
 
         # The following assumes the role of ancilla and data qudits stays fixed during the instruction
         self.data_qudit_set = self.qecc.data_qudit_set  # set of qudit ids corresponding to data qudits.
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set  # set of qudit ids corresponding to ancilla qudits.
         # The ancilla set may differ from qecc. (might be a subset)
 
-        self.params['data_qudit_set'] = self.data_qudit_set
-        self.params['ancilla_qudit_set'] = self.ancilla_qudit_set
+        self.params["data_qudit_set"] = self.data_qudit_set
+        self.params["ancilla_qudit_set"] = self.ancilla_qudit_set
 
         # Logical operations
         # These are the expected initial and final logical operations
         self.initial_logical_ops = {}
         self.final_logical_ops = {}
 
         self.params_tuple = make_hashable_params(params)  # Used for hashing.
 
     def plot(self, **kwargs):
         """Creates a plot of the logical instruction.
 
         Returns: None
 
         """
-
         plot_instr(self, **kwargs)
 
     def _compile_circuit(self, abstract_circuit, *args, **kwargs):
-        """
-        Create `circuit` instance from `abstract_circuit` instance for the logical instruction.
+        """Create `circuit` instance from `abstract_circuit` instance for the logical instruction.
 
         If the instruction already has a `circuit` instance, do not bother compiling.
         """
-
         compiler = self.qecc.circuit_compiler
-        compiler = self.params.get('circuit_compiler', compiler)
+        compiler = self.params.get("circuit_compiler", compiler)
 
-        # self.circuit = compiler.compile(self.abstract_circuit, mapping=self.qecc.mapping, *args, **kwargs)
         self.circuit = compiler.compile(self, abstract_circuit, *args, **kwargs)
 
     def items(self):
-        """
-        Yields: Yields the
-
-        """
-
+        """Yields: Yields the."""
         if self.circuit:
             return self.circuit.items()
         else:
-            raise Exception('')
-
-    def __str__(self):
+            msg = ""
+            raise Exception(msg)
 
-        return "[%s %s] - Logical instruction: '%s' %s" % (self.qecc.name, self.qecc.qecc_params, self.symbol,
-                                                           self.params)
+    def __str__(self) -> str:
+        return f"[{self.qecc.name} {self.qecc.qecc_params}] - Logical instruction: '{self.symbol}' {self.params}"
 
     def __hash__(self):
         # The instruction is unique. A hash can be used to identify it.
-        return hash(('instr', self.symbol, self.params_tuple))
+        return hash(("instr", self.symbol, self.params_tuple))
 
     def __eq__(self, other):
-        return (self.symbol, self.params_tuple, True) == (other.symbol, other.params_tuple, hasattr(other, 'circuit'))
+        return (self.symbol, self.params_tuple, True) == (other.symbol, other.params_tuple, hasattr(other, "circuit"))
 
     def __ne__(self, other):
-        return not(self == other)
+        return not (self == other)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/plot.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/plot.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,37 +7,44 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from matplotlib import pyplot as plt
 import networkx as nx
+from matplotlib import pyplot as plt
 
 
 # plot intsructions
-def plot_qecc(qecc, figsize=(9, 9), dpi=80, filename=None, title_font_size=16, axis_font_size=14, legend_font_size=14,
-              **kwargs):
+def plot_qecc(
+    qecc,
+    figsize=(9, 9),
+    dpi=80,
+    filename=None,
+    title_font_size=16,
+    axis_font_size=14,
+    legend_font_size=14,
+    **kwargs,
+):
     """Produces a plot of a qecc.
 
     Args:
+    ----
         qecc(QECC): The ``qecc`` instance that is to be plotted.
         figsize(tuple of int): The size of the plotted figure.
 
     Returns:
+    -------
 
     """
-
     if len(kwargs):
-        raise Exception('keys %s not recognized!' % kwargs.keys())
-
-    G = nx.DiGraph()
+        raise Exception("keys %s not recognized!" % kwargs.keys())
 
-    # x_ancillas, z_ancillas = get_ancilla_types(instr)
+    g = nx.DiGraph()
 
     mapping = qecc.mapping
 
     if mapping is None:
         mapping = NoMap()
 
     pos_old = qecc.layout
@@ -45,212 +52,241 @@
 
     qudit_nodes_data = mapset(mapping, qecc.data_qudit_set)
     qudit_nodes_ancilla = mapset(mapping, qecc.ancilla_qudit_set)
     qudit_nodes_qudit = mapset(mapping, qecc.data_qudit_set)
 
     data_labels = {}
     for i in qudit_nodes_data:
-        data_labels[i] = '$' + str(i) + '$'
+        data_labels[i] = "$" + str(i) + "$"
 
     ancilla_labels = {}
     for i in qudit_nodes_ancilla:
-        ancilla_labels[i] = '$' + str(i) + '$'
+        ancilla_labels[i] = "$" + str(i) + "$"
 
-    G.add_nodes_from(qudit_nodes_qudit)
-    plt.figure(num=None, figsize=figsize, dpi=dpi, edgecolor='k')
+    g.add_nodes_from(qudit_nodes_qudit)
+    plt.figure(num=None, figsize=figsize, dpi=dpi, edgecolor="k")
     plt.title("QECC layout: %s" % qecc.name, size=title_font_size)
 
     # Draw data qudits
-    nodes = nx.draw_networkx_nodes(G, pos=pos, nodelist=qudit_nodes_data, node_color='white',
-                                   node_shape='o', node_size=700, label='data qubit')
-    nodes.set_edgecolor('black')
+    nodes = nx.draw_networkx_nodes(
+        g,
+        pos=pos,
+        nodelist=qudit_nodes_data,
+        node_color="white",
+        node_shape="o",
+        node_size=700,
+        label="data qubit",
+    )
+    nodes.set_edgecolor("black")
 
     # Draw ancilla qudits
-    nodes = nx.draw_networkx_nodes(G, pos=pos, nodelist=qudit_nodes_ancilla, node_color='black',
-                                   node_shape='s', node_size=700, label='ancilla qubit')
-    nodes.set_edgecolor('black')
+    nodes = nx.draw_networkx_nodes(
+        g,
+        pos=pos,
+        nodelist=qudit_nodes_ancilla,
+        node_color="black",
+        node_shape="s",
+        node_size=700,
+        label="ancilla qubit",
+    )
+    nodes.set_edgecolor("black")
 
     # Label ancilla qudits
-    nx.draw_networkx_labels(G, pos=pos, labels=ancilla_labels, font_size=16, font_color='white')
+    nx.draw_networkx_labels(g, pos=pos, labels=ancilla_labels, font_size=16, font_color="white")
 
     # Label data qudits
-    nx.draw_networkx_labels(G, pos=pos, labels=data_labels, font_size=16)
+    nx.draw_networkx_labels(g, pos=pos, labels=data_labels, font_size=16)
 
     # Label nodes
-    # nx.draw_networkx_labels(G, pos=pos, labels=labels, font_size=16)
 
     ax = plt.gca()
-    ax.set_facecolor('lightgray')
-    ax.set_xlabel('x (arbitrary length units)', size=axis_font_size)
-    ax.set_ylabel('y (arbitrary length units)', size=axis_font_size)
+    ax.set_facecolor("lightgray")
+    ax.set_xlabel("x (arbitrary length units)", size=axis_font_size)
+    ax.set_ylabel("y (arbitrary length units)", size=axis_font_size)
     ax.invert_yaxis()
-    # ax.invert_xaxis()
 
-    plt.legend(labelspacing=2.5, borderpad=1.5, loc='upper left', bbox_to_anchor=(1, 1.01), fontsize=legend_font_size)
+    plt.legend(labelspacing=2.5, borderpad=1.5, loc="upper left", bbox_to_anchor=(1, 1.01), fontsize=legend_font_size)
 
     if filename:
         plt.savefig(filename)
 
     plt.show()
 
 
-def plot_instr(instr, figsize=(9, 9), dpi=80, filename=None, title_font_size=16, axis_font_size=14, legend_font_size=14,
-               **kwargs):
-    """
-
-    Args:
+def plot_instr(
+    instr,
+    figsize=(9, 9),
+    dpi=80,
+    filename=None,
+    title_font_size=16,
+    axis_font_size=14,
+    legend_font_size=14,
+    **kwargs,
+):
+    """Args:
+    ----
         instr(LogicalInstruction):
 
     Returns:
+    -------
 
     """
-
     if len(kwargs):
-        raise Exception('keys %s not recognized!' % kwargs.keys())
+        raise Exception("keys %s not recognized!" % kwargs.keys())
 
-    G = nx.DiGraph()
-
-    # x_ancillas, z_ancillas = get_ancilla_types(instr)
+    g = nx.DiGraph()
 
     mapping = instr.qecc.mapping
 
     if mapping is None:
         mapping = NoMap()
 
     pos_old = instr.qecc.layout
     pos = {mapping[q]: loc for q, loc in pos_old.items()}
 
     qudit_nodes_data = mapset(mapping, instr.data_qudit_set)
     qudit_nodes_x = mapset(mapping, instr.ancilla_x_check)
     qudit_nodes_z = mapset(mapping, instr.ancilla_z_check)
 
-    G.add_nodes_from(qudit_nodes_data)
-    G.add_nodes_from(qudit_nodes_x)
-    G.add_nodes_from(qudit_nodes_z)
-
-    edge_labels, _, _ = graph_add_directed_cnots(instr, G)
+    g.add_nodes_from(qudit_nodes_data)
+    g.add_nodes_from(qudit_nodes_x)
+    g.add_nodes_from(qudit_nodes_z)
 
-    # print(czs)
-    # print(cys)
+    edge_labels, _, _ = graph_add_directed_cnots(instr, g)
 
     labels = {}
     for i in qudit_nodes_data:
-        labels[i] = '$' + str(i) + '$'
+        labels[i] = "$" + str(i) + "$"
 
     for i in qudit_nodes_x:
-        labels[i] = '$' + str(i) + '$'
+        labels[i] = "$" + str(i) + "$"
 
     for i in qudit_nodes_z:
-        labels[i] = '$' + str(i) + '$'
+        labels[i] = "$" + str(i) + "$"
 
-    plt.figure(num=None, figsize=figsize, dpi=dpi, edgecolor='k')
-    plt.title("Logical Instruction: '%s'  QECC: %s" % (instr.symbol, instr.qecc.name), size=title_font_size)
+    plt.figure(num=None, figsize=figsize, dpi=dpi, edgecolor="k")
+    plt.title(f"Logical Instruction: '{instr.symbol}'  QECC: {instr.qecc.name}", size=title_font_size)
 
-    nx.draw_networkx_edges(G, pos=pos, arrowsize=30)
-    nx.draw_networkx_edge_labels(G, pos=pos, edge_labels=edge_labels)
+    nx.draw_networkx_edges(g, pos=pos, arrowsize=30)
+    nx.draw_networkx_edge_labels(g, pos=pos, edge_labels=edge_labels)
 
-    nodes = nx.draw_networkx_nodes(G, pos=pos, nodelist=qudit_nodes_data, node_color='lightyellow', node_size=700,
-                                   label='data qubit')
-    nodes.set_edgecolor('black')
+    nodes = nx.draw_networkx_nodes(
+        g,
+        pos=pos,
+        nodelist=qudit_nodes_data,
+        node_color="lightyellow",
+        node_size=700,
+        label="data qubit",
+    )
+    nodes.set_edgecolor("black")
 
     try:
-        nodes = nx.draw_networkx_nodes(G, pos=pos, nodelist=qudit_nodes_x, node_color='lightcoral',
-                                       node_shape='s', node_size=600, label='X ancilla')
+        nodes = nx.draw_networkx_nodes(
+            g,
+            pos=pos,
+            nodelist=qudit_nodes_x,
+            node_color="lightcoral",
+            node_shape="s",
+            node_size=600,
+            label="X ancilla",
+        )
 
-        nodes.set_edgecolor('black')
+        nodes.set_edgecolor("black")
     except AttributeError:
         pass
 
     try:
-        nodes = nx.draw_networkx_nodes(G, pos=pos, nodelist=qudit_nodes_z, node_color='powderblue',
-                                       node_shape='s', node_size=600, label='Z ancilla')
-        nodes.set_edgecolor('black')
+        nodes = nx.draw_networkx_nodes(
+            g,
+            pos=pos,
+            nodelist=qudit_nodes_z,
+            node_color="powderblue",
+            node_shape="s",
+            node_size=600,
+            label="Z ancilla",
+        )
+        nodes.set_edgecolor("black")
     except AttributeError:
         pass
 
-    nx.draw_networkx_labels(G, pos=pos, labels=labels, font_size=16)
+    nx.draw_networkx_labels(g, pos=pos, labels=labels, font_size=16)
 
     ax = plt.gca()
-    ax.set_xlabel('x (arbitrary length units)', size=axis_font_size)
-    ax.set_ylabel('y (arbitrary length units)', size=axis_font_size)
+    ax.set_xlabel("x (arbitrary length units)", size=axis_font_size)
+    ax.set_ylabel("y (arbitrary length units)", size=axis_font_size)
     ax.invert_yaxis()
-    # ax.invert_xaxis()
 
-    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
+    nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels)
 
-    plt.legend(labelspacing=2.5, borderpad=1.5, loc='upper left', bbox_to_anchor=(1, 1.01), fontsize=legend_font_size)
+    plt.legend(labelspacing=2.5, borderpad=1.5, loc="upper left", bbox_to_anchor=(1, 1.01), fontsize=legend_font_size)
 
     if filename:
         plt.savefig(filename)
 
     plt.show()
 
 
 def get_ancilla_types(instr):
-
-    x_ancillas = set([])
-    z_ancillas = set([])
+    x_ancillas = set()
+    z_ancillas = set()
     abs_circuit = instr.abstract_circuit
 
     for gate_symbol, _, params in abs_circuit.items():
-        if gate_symbol == 'X check':
-            ancilla = params['ancillas']
+        if gate_symbol == "X check":
+            ancilla = params["ancillas"]
             x_ancillas.add(ancilla)
-        elif gate_symbol == 'Z check':
-            ancilla = params['ancillas']
+        elif gate_symbol == "Z check":
+            ancilla = params["ancillas"]
             z_ancillas.add(ancilla)
 
     return x_ancillas, z_ancillas
 
 
-def graph_add_directed_cnots(instr, G):
-
+def graph_add_directed_cnots(instr, g):
     circuit = instr.circuit
     edge_labels = {}
     cys = []
     czs = []
 
-    # print(circuit)
     for i in range(len(circuit)):
         for sym, qudits, _ in circuit.items(tick=i):
-            if sym == 'CNOT' or sym == 'CZ' or sym == 'CY':
-                G.add_edges_from(qudits)
+            if sym in {"CNOT", "CZ", "CY"}:
+                g.add_edges_from(qudits)
                 for e in qudits:
                     edge_labels[e] = str(i)
 
-                if sym == 'CZ':
+                if sym == "CZ":
                     czs.append(qudits)
-                elif sym == 'CY':
+                elif sym == "CY":
                     cys.append(qudits)
 
     return edge_labels, czs, cys
 
 
 def mapset(mapping, oldset):
-    """
-    Applies a mapping to a set.
+    """Applies a mapping to a set.
 
     Args:
+    ----
         mapping:
         oldset (set):
 
     Returns:
+    -------
 
     """
     newset = set()
 
     for e in oldset:
         newset.add(mapping[e])
 
     return newset
 
 
 class NoMap:
-    """
-    Default Mapping: item -> item.
-    """
+    """Default Mapping: item -> item."""
 
-    def __init__(self):
+    def __init__(self) -> None:
         pass
 
     def __getitem__(self, item):
         return item
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/qecc_parent_class.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/qecc_parent_class.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,250 +7,236 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Contains the parent classes for QECCs, logical gates, and logical instructions.
-"""
-from .plot import plot_qecc
+"""Contains the parent classes for QECCs, logical gates, and logical instructions."""
 from pecos.circuit_converters.checks2circuit import Check2Circuits
+from pecos.qeccs.plot import plot_qecc
 
 
-class QECC(object):
-    """
-    Parent class for QECCs.
+class QECC:
+    """Parent class for QECCs.
 
     A QECC's role is to output circuits for logical gates. Logical gates are a collection of logical instructions.
     Logical instructions might be called multiple times. To save time and memory, logical instructions are saved to
     the QECC instance.
 
     Warnings:
+    --------
         Do not change the value of ``params`` once set during initialization.
     """
 
-    def __init__(self, **qecc_params):
-
+    def __init__(self, **qecc_params) -> None:
         # Give name for others classes to identify this code
         # --------------------------------------------------
         self.name = None  # Name that identifies to other what QECC this is.
 
         # QECC parameters:
         # ----------------
         self.qecc_params = qecc_params  # The QECC's parameters such as distance.
 
-        # [[N, K, D]]
         # D
         self.distance = None
         # K
         self.num_logical_qudits = None
 
         # Number of Qudits and Syndromes
         # ------------------------------
         # N
         self.num_data_qudits = None
 
-        # self.num_syndromes = None  # Number of syndromes outputted
         self.num_ancilla_qudits = None  # Total number of ancillas (usually == num_syndromes but not necessarily)
         # Number of qubits (num_qudits) is set as an attribute below.
 
         # Sets of qudit ids
         # -----------------
-        self.qudit_set = set([])  # Set of qudit ids used internally in the QECC
-        self.data_qudit_set = set([])
-        self.ancilla_qudit_set = set([])
+        self.qudit_set = set()  # Set of qudit ids used internally in the QECC
+        self.data_qudit_set = set()
+        self.ancilla_qudit_set = set()
 
         self.layout = {}  # A dictionary of qudit id => (x, y, ...)
         self.position2qudit = {}
         self.lattice_dimensions = {}  # Dimensions of the physical layout
         self.sides = {}  # Describes the geometry of the qecc so decoders can understand the QECC's shape
 
         self.sym2gate_class = {}  # symbol => logical gate class
         self.sym2instruction_class = {}  # symbol => logical instruction class
 
-        # self.circuit_compiler = None
-        self.circuit_compiler = qecc_params.get('circuit_compiler', Check2Circuits())
+        self.circuit_compiler = qecc_params.get("circuit_compiler", Check2Circuits())
 
         # logical gates and instructions are stored in the QECC for reference
-        # self.stored_instructions = {}  # Stored instruction instances. instr symbol => set of instr instances
-        # self.stored_gates = {}  # gate symbol -> set of gate instances
 
         self.instr_set = set()  # Instances of instructions that have been created.
         self.gate_set = set()  # Instances of gates that have been created.
 
         # Mapping
         # -------
         # Maps qudit id to new qudit id.
-        self.mapping = self.qecc_params.get('mapping', NoMap())
+        self.mapping = self.qecc_params.get("mapping", NoMap())
 
     @property
     def num_qudits(self):
         return self.num_data_qudits + self.num_ancilla_qudits
 
     @property
     def available_gates(self):
         return list(self.sym2gate_class.keys())
 
     @property
     def available_instructions(self):
         return list(self.sym2instruction_class.keys())
 
     def plot(self, figsize=(9, 9)):
-        """
-        Default plotter of the QECC.
+        """Default plotter of the QECC.
 
         Args:
+        ----
             figsize(tuple of int):
 
         Returns:
+        -------
 
         """
-
         plot_qecc(self, figsize)
 
     def gate(self, symbol, **gate_params):
         """Returns a logical gate object.
 
         Args:
+        ----
             symbol(str):
             **gate_params:
 
         Returns:
+        -------
 
         """
-
         # Recognize special symbol prefix
-        if symbol.startswith('ideal '):
+        if symbol.startswith("ideal "):
             # An ideal logical gate is one that has no errors and all random outcomes are forced to be zero.
-            gate_params['error_free'] = True
-            gate_params['forced_outcome'] = False
-            symbol = symbol.replace('ideal ', '')
+            gate_params["error_free"] = True
+            gate_params["forced_outcome"] = False
+            symbol = symbol.replace("ideal ", "")
 
         gotten_gate = self._retrieve_element(symbol, gate_params, self.gate_set)
 
         # If None are found create a new one
         if gotten_gate is None:
-
             gotten_gate = self.sym2gate_class[symbol](self, symbol, **gate_params)
             self.gate_set.add(gotten_gate)
 
             # Create logical instructions
             # ---------------------------
             for instr_symbol in gotten_gate.instr_symbols:
-
                 instr = self.instruction(instr_symbol, **gate_params)
                 gotten_gate.circuits.append(instr.circuit)
                 gotten_gate.instr_instances.append(instr)
 
         return gotten_gate
 
     def instruction(self, symbol, **instr_params):
-        """
-        Gets logical instruction given a string and parameters.
+        """Gets logical instruction given a string and parameters.
 
         Args:
+        ----
             symbol(str):
             **gate_params(dict):
 
         Returns(LogicalInstruction):
 
         """
-
         gotten_instr = self._retrieve_element(symbol, instr_params, self.instr_set)
 
         # If no instruction has been found corresponding to the symbol:
         if gotten_instr is None:
-
             instr_class = self.sym2instruction_class[symbol]
 
             gotten_instr = instr_class(self, symbol, **instr_params)
             self.instr_set.add(gotten_instr)
 
         return gotten_instr
 
     @staticmethod
     def _retrieve_element(symbol, params, element_set):
-        """
-        Retrieve an element from a set.
+        """Retrieve an element from a set.
 
         Args:
+        ----
             symbol(str):
             gate_params(dict):
             element_set(set):
 
         Returns:
+        -------
 
         """
         gotten_element = None
         for element in element_set:
             if params == element.params and symbol == element.symbol:
                 gotten_element = element
                 break
 
         return gotten_element
 
     def _data_id_iter(self):
-        """
-        Assigns qudit ids. Also, records qudit id in the sets self.
+        """Assigns qudit ids. Also, records qudit id in the sets self.
 
         Returns:
+        -------
 
         """
-
         while True:
             qudit_id = max(self.qudit_set, default=-1) + 1
             self.qudit_set.add(qudit_id)
             self.data_qudit_set.add(qudit_id)
 
             if len(self.data_qudit_set) > self.num_data_qudits:
-                raise Exception('Number of data qudits requested exceeds number expected.')
+                msg = "Number of data qudits requested exceeds number expected."
+                raise Exception(msg)
 
             yield qudit_id
 
     def _ancilla_id_iter(self):
-        """
-        Assigns qudit ids. Also, records qudit id in the sets self.
+        """Assigns qudit ids. Also, records qudit id in the sets self.
 
         Returns:
+        -------
 
         """
         last_ancilla_id = None
 
         while True:
-
             if len(self.ancilla_qudit_set) == self.num_ancilla_qudits:
-                print('Requesting more qudits then expected assuming last ancilla id.')
+                print("Requesting more qudits then expected assuming last ancilla id.")
                 yield last_ancilla_id
             else:
                 qudit_id = max(self.qudit_set, default=-1) + 1
                 last_ancilla_id = qudit_id
                 self.qudit_set.add(qudit_id)
                 self.ancilla_qudit_set.add(qudit_id)
 
                 yield qudit_id
 
     def _add_node(self, x, y, iter_ids):
-
         nid = next(iter_ids)
 
         self.layout[nid] = (x, y)
         self.position2qudit[(x, y)] = nid
 
     def __eq__(self, other):
         return (self.name, self.qecc_params) == (other.name, other.qecc_params)
 
     def __ne__(self, other):
-        return not(self == other)
+        return not (self == other)
 
 
-class NoMap(object):
-    """
-    Default Mapping: item -> item.
-    """
+class NoMap:
+    """Default Mapping: item -> item."""
 
-    def __init__(self):
+    def __init__(self) -> None:
         pass
 
     def __getitem__(self, item):
         return item
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_4444/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_4444/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_4444/instructions.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_4444/instructions.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,43 +7,41 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ..instruction_parent_class import LogicalInstruction
-from ...circuits.quantum_circuit import QuantumCircuit
-from ..helper_functions import pos2qudit
+from pecos.circuits.quantum_circuit import QuantumCircuit
+from pecos.qeccs.helper_functions import pos2qudit
+from pecos.qeccs.instruction_parent_class import LogicalInstruction
 
 
 class InstrSynExtraction(LogicalInstruction):
-    """
-    Instruction for a round of syndrome extraction.
+    """Instruction for a round of syndrome extraction.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
-        self.symbol = 'instr_syn_extract'
+        self.symbol = "instr_syn_extract"
 
-        self.init_ticks = params.get('init_ticks', 0)
-        self.meas_ticks = params.get('meas_ticks', 7)
-        self.data_ticks = params.get('data_ticks', [2, 4, 3, 5])
+        self.init_ticks = params.get("init_ticks", 0)
+        self.meas_ticks = params.get("meas_ticks", 7)
+        self.data_ticks = params.get("data_ticks", [2, 4, 3, 5])
 
         self.abstract_circuit = QuantumCircuit(track_qudits=False, **params)
 
         self.data_qudit_set = self.qecc.data_qudit_set
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
 
-        self.ancilla_x_check = set([])
-        self.ancilla_z_check = set([])
+        self.ancilla_x_check = set()
+        self.ancilla_z_check = set()
 
         # Go through the ancillas and grab the data qubits that are on either side of it.
         layout = qecc.layout  # qudit_id => (x, y)
 
         self.pos2qudit = pos2qudit(layout)
 
         for q, (x, y) in layout.items():
@@ -53,243 +51,249 @@
 
             elif x % 2 == 0 and y % 2 == 1:
                 # Z ancilla
                 self._create_z_check(q, x, y)
 
         # Determine the logical operations
         # --------------------------------
-        z_qudits = set(qecc.sides['top'])
-        x_qudits = set(qecc.sides['left'])
+        z_qudits = set(qecc.sides["top"])
+        x_qudits = set(qecc.sides["left"])
 
         logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': QuantumCircuit([{'X': x_qudits}]), 'Z': QuantumCircuit([{'Z': z_qudits}])},
+            {"X": QuantumCircuit([{"X": x_qudits}]), "Z": QuantumCircuit([{"Z": z_qudits}])},
         ]
 
         self.initial_logical_ops = logical_ops
 
         logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': QuantumCircuit([{'X': x_qudits}]), 'Z': QuantumCircuit([{'Z': z_qudits}])},
+            {"X": QuantumCircuit([{"X": x_qudits}]), "Z": QuantumCircuit([{"Z": z_qudits}])},
         ]
 
         self.final_logical_ops = logical_ops
 
         self.logical_signs = None
         self.logical_stabilizers = None
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
 
     def _create_x_check(self, ancilla, x, y):
-        """
-        Creates X-checks for circuit_extended.
-        """
-
+        """Creates X-checks for circuit_extended."""
         # register the x syndrome ancillas
         self.ancilla_x_check.add(ancilla)
 
         # get where the position of where the data qubits should be relative to the ancilla
         data_pos = self._data_pos_x_check(x, y)
 
         # Get the actual, available data-qubits and their ticks that correspond to the possible data qubit positions
-        datas, my_data_ticks = self._find_data(position_to_qudit=self.pos2qudit, positions=data_pos,
-                                               # ticks=self.x_ticks)
-                                               ticks=self.data_ticks)
+        datas, my_data_ticks = self._find_data(
+            position_to_qudit=self.pos2qudit,
+            positions=data_pos,
+            # ticks=self.x_ticks)
+            ticks=self.data_ticks,
+        )
 
         # Now add the check to the extended circuit
         locations = set(datas)
         locations.add(ancilla)
-        self.abstract_circuit.append('X check', locations=locations, datas=datas, ancillas=ancilla,
-                                     ancilla_ticks=self.init_ticks, data_ticks=my_data_ticks,
-                                     meas_ticks=self.meas_ticks)
+        self.abstract_circuit.append(
+            "X check",
+            locations=locations,
+            datas=datas,
+            ancillas=ancilla,
+            ancilla_ticks=self.init_ticks,
+            data_ticks=my_data_ticks,
+            meas_ticks=self.meas_ticks,
+        )
 
     def _create_z_check(self, ancilla, x, y):
-        """
-        Creates Z-checks for circuit_extended.
-        """
-
+        """Creates Z-checks for circuit_extended."""
         # register the z syndrome ancillas
         self.ancilla_z_check.add(ancilla)
 
         # get where the position of where the data qubits should be relative to the ancilla
         data_pos = self._data_pos_z_check(x, y)
         # Get the actual, available data-qubits and their ticks that correspond to the possible data qubit positions
-        datas, my_data_ticks = self._find_data(position_to_qudit=self.pos2qudit, positions=data_pos,
-                                               # ticks=self.z_ticks)
-                                               ticks=self.data_ticks)
+        datas, my_data_ticks = self._find_data(
+            position_to_qudit=self.pos2qudit,
+            positions=data_pos,
+            # ticks=self.z_ticks)
+            ticks=self.data_ticks,
+        )
 
         # Now add the check to the extended circuit
         locations = set(datas)
         locations.add(ancilla)
-        self.abstract_circuit.append('Z check', locations=locations, datas=datas, ancillas=ancilla,
-                                     ancilla_ticks=self.init_ticks, data_ticks=my_data_ticks,
-                                     meas_ticks=self.meas_ticks)
+        self.abstract_circuit.append(
+            "Z check",
+            locations=locations,
+            datas=datas,
+            ancillas=ancilla,
+            ancilla_ticks=self.init_ticks,
+            data_ticks=my_data_ticks,
+            meas_ticks=self.meas_ticks,
+        )
 
     @staticmethod
     def _find_data(position_to_qudit, positions, ticks):
+        """From the positions given for possible data qudits, add the qudits and their corresponding ticks for each
+        qudit that does exist.
         """
-        From the positions given for possible data qudits, add the qudits and their corresponding ticks for each qudit
-        that does exist.
-        """
-
         data_list = []
         tick_list = []
 
         for i, p in enumerate(positions):
             data = position_to_qudit.get(p, None)
             if data is not None:
                 data_list.append(data)
                 tick_list.append(ticks[i])
 
         return data_list, tick_list
 
     @staticmethod
     def _data_pos_z_check(x, y):
-        """
-        Determines the position of data qudits in a Z check in order of ticks.
+        """Determines the position of data qudits in a Z check in order of ticks.
 
         Check direction:   1  |  2
                               |
                            ---+---
                               |
                            3  |  4
 
 
         """
-        data_pos = [
+        return [
             (x - 1, y),
             (x, y + 1),
             (x, y - 1),
-            (x + 1, y)
+            (x + 1, y),
         ]
 
-        return data_pos
-
     @staticmethod
     def _data_pos_x_check(x, y):
-        """
-        Determines the position of data qudits in a Z check in order of ticks.
+        """Determines the position of data qudits in a Z check in order of ticks.
 
         Check direction:   1  |  3
                               |
                            ---+---
                               |
                            2  |  4
         """
-        data_pos = [
+        return [
             (x - 1, y),
             (x, y - 1),
             (x, y + 1),
-            (x + 1, y)
+            (x + 1, y),
         ]
 
-        return data_pos
-
 
 class InstrInitZero(LogicalInstruction):
-    """
-    Instruction for initializing a logical zero.
+    """Instruction for initializing a logical zero.
 
     It is just like syndrome extraction except the data qubits are initialized in the zero state at tick = 0.
 
     `ideal_meas` == True will cause the measurements to be replace with ideal measurements.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
-        self.symbol = 'instr_init_zero'
+        self.symbol = "instr_init_zero"
 
         self.data_qudit_set = self.qecc.data_qudit_set
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
 
         # This is basically syndrome extraction round where all the data qubits are initialized to zero.
-        syn_ext = qecc.instruction('instr_syn_extract', **params)
+        syn_ext = qecc.instruction("instr_syn_extract", **params)
 
         # Make a shallow copy of the abstract circuits.
         self.abstract_circuit = syn_ext.abstract_circuit.copy()
         self.abstract_circuit.metadata.update(params)
 
         self.ancilla_x_check = syn_ext.ancilla_x_check
         self.ancilla_z_check = syn_ext.ancilla_z_check
 
         data_qudits = syn_ext.data_qudit_set
-        self.abstract_circuit.append('init |0>', locations=data_qudits, tick=0)
+        self.abstract_circuit.append("init |0>", locations=data_qudits, tick=0)
 
         self.initial_logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': None, 'Z': None},  # None => can be anything
+            {"X": None, "Z": None},  # None => can be anything
         ]
 
         # Special for state initialization:
         # ---------------------------------
         # list of tuples of logical check and delogical stabilizer for each logical qudit.
         self.final_logical_ops = [
-            {'Z': QuantumCircuit([{'Z': set(qecc.sides['top'])}]), 'X': QuantumCircuit([{'X': set(qecc.sides['left'])}])}
+            {
+                "Z": QuantumCircuit([{"Z": set(qecc.sides["top"])}]),
+                "X": QuantumCircuit([{"X": set(qecc.sides["left"])}]),
+            },
         ]
 
         # List of corresponding logical sign. (The logical sign if the instruction is preformed ideally.)
         self.logical_signs = [0]
-        self.logical_stabilizers = ['Z']
+        self.logical_stabilizers = ["Z"]
         # ---------------------------------
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
 
 
 class InstrInitPlus(LogicalInstruction):
-    """
-    Instruction for initializing a logical plus.
+    """Instruction for initializing a logical plus.
 
     It is just like syndrome extraction except the data qubits are initialized in the plus state at tick = 0.
 
     `ideal_meas` == True will cause the measurements to be replace with ideal measurements.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
-        self.symbol = 'instr_init_plus'
+        self.symbol = "instr_init_plus"
 
         self.data_qudit_set = self.qecc.data_qudit_set
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
 
         # This is basically syndrome extraction round where all the data qubits are initialized to zero.
-        syn_ext = qecc.instruction('instr_syn_extract', **params)
+        syn_ext = qecc.instruction("instr_syn_extract", **params)
 
         # Make a shallow copy of the abstract circuits.
         self.abstract_circuit = syn_ext.abstract_circuit.copy()
         self.abstract_circuit.metadata.update(params)
 
         self.ancilla_x_check = syn_ext.ancilla_x_check
         self.ancilla_z_check = syn_ext.ancilla_z_check
 
         data_qudits = syn_ext.data_qudit_set
-        self.abstract_circuit.append('init |0>', locations=data_qudits, tick=0)
-        self.abstract_circuit.append('H', locations=data_qudits, tick=1)
+        self.abstract_circuit.append("init |0>", locations=data_qudits, tick=0)
+        self.abstract_circuit.append("H", locations=data_qudits, tick=1)
 
         self.initial_logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': None, 'Z': None},  # None => can be anything
+            {"X": None, "Z": None},  # None => can be anything
         ]
 
         # Special for state initialization:
         # ---------------------------------
         # list of tuples of logical check and delogical stabilizer for each logical qudit.
         self.final_logical_ops = [
-            {'X': QuantumCircuit([{'X': set(qecc.sides['left'])}]), 'Z': QuantumCircuit([{'Z': set(qecc.sides['top'])}])}
+            {
+                "X": QuantumCircuit([{"X": set(qecc.sides["left"])}]),
+                "Z": QuantumCircuit([{"Z": set(qecc.sides["top"])}]),
+            },
         ]
 
         # List of corresponding logical sign. (The logical sign if the instruction is preformed ideally.)
         self.logical_signs = [0]
-        self.logical_stabilizers = ['X']
+        self.logical_stabilizers = ["X"]
         # ---------------------------------
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_4444/surface_4444.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_4444/surface_4444.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,59 +1,52 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-    repetition_z
-    ~~~~~~~~~~~~
+"""repetition_z
+~~~~~~~~~~~~.
 
-    Generates circuits for the repetition code in the Z-Basis.
+Generates circuits for the repetition code in the Z-Basis.
 """
-from ..qecc_parent_class import QECC
 from pecos.circuit_converters.checks2circuit import Check2Circuits
-from .instructions import InstrSynExtraction, InstrInitZero, InstrInitPlus
-from .gates import GateIdentity, GateInitZero, GateInitPlus
+from pecos.qeccs.qecc_parent_class import QECC
+from pecos.qeccs.surface_4444.gates import GateIdentity, GateInitPlus, GateInitZero
+from pecos.qeccs.surface_4444.instructions import InstrInitPlus, InstrInitZero, InstrSynExtraction
 
 
 class Surface4444(QECC):
-    """
-    Non-medial Surface code on 4.4.4.4 lattice.
-    """
-
-    def __init__(self, distance=None, height=None, width=None, **qecc_params):
-        """
+    """Non-medial Surface code on 4.4.4.4 lattice."""
 
-        Args:
+    def __init__(self, distance=None, height=None, width=None, **qecc_params) -> None:
+        """Args:
+        ----
             distance: The distance of the code. If specified a square code of height and width equaled to the distance
             will be returned.
             height: The height of the code block. This is the size of the minimum logical X.
             width: The width of the code block. This is the size of the minimum logical Z.
             **qecc_params:
         """
-
-        qecc_params['distance'] = distance
-        qecc_params['height'] = height
-        qecc_params['width'] = width
+        qecc_params["distance"] = distance
+        qecc_params["height"] = height
+        qecc_params["width"] = width
 
         super().__init__(**qecc_params)
 
         # Give name for others classes to identify this code
         # --------------------------------------------------
-        self.name = '4.4.4.4 Surface Code'
+        self.name = "4.4.4.4 Surface Code"
 
         # QECC parameters:
         # ----------------
         self.qecc_params = qecc_params
 
         # Create dictionaries to associate symbols to gate and instruction classes.
         self.sym2gate_class, self.sym2instruction_class = self._set_symbols()
@@ -71,19 +64,18 @@
         # number of syndrome bits
         self.num_syndromes = self.num_data_qudits - self.num_logical_qudits
 
         # --------------------------------------------------------------------------------------------------------------
         # Determine number of ancillas to reserve given the check circuit implementation and, perhaps, the logical
         # gate circuits implemented by this class.
         # --------------------------------------------------------------------------------------------------------------
-        self.circuit_compiler = qecc_params.get('circuit_compiler', Check2Circuits())
+        self.circuit_compiler = qecc_params.get("circuit_compiler", Check2Circuits())
         self.num_ancilla_qudits = self.circuit_compiler.get_num_ancillas(self.num_syndromes)
 
         # Total number of qudits.
-        # self.num_qudits = self.num_data_qudits + self.num_ancilla_qudits
         # self.qudit_set, self.data_qudit_set, self.ancilla_qudit_set will be determined when creating the layout.
 
         # Determine QECC geometry
         # -----------------------
         self.lattice_width = None
         self.lattice_height = None
         self.lattice_dimensions = {}
@@ -92,141 +84,134 @@
 
         # Create side information
         # Allows other classes (e.g., decoders) to understand the orientation of the code
         self.sides = self._determine_sides()
 
     @staticmethod
     def _set_symbols():
-
         # gate and instruction symbol bindings
         # ------------------------------------
         # gate symbol => gate class
         sym2gate_class = {
-            'I': GateIdentity,
-            'init |0>': GateInitZero,
-            'init |+>': GateInitPlus,
+            "I": GateIdentity,
+            "init |0>": GateInitZero,
+            "init |+>": GateInitPlus,
         }
 
         # instruction symbol => instr. class
         sym2instruction_class = {
-            'instr_syn_extract': InstrSynExtraction,
-            'instr_init_zero': InstrInitZero,
-            'instr_init_plus': InstrInitPlus,
+            "instr_syn_extract": InstrSynExtraction,
+            "instr_init_zero": InstrInitZero,
+            "instr_init_plus": InstrInitPlus,
         }
 
         return sym2gate_class, sym2instruction_class
 
     def _get_distance(self):
-        """
-        Check and set the distance
+        """Check and set the distance
         :return:
         """
-
         params = self.qecc_params
 
-        distance = params.get('distance')
-        width = params.get('width')
-        height = params.get('height')
-        
+        distance = params.get("distance")
+        width = params.get("width")
+        height = params.get("height")
+
         if width is not None and height is not None:
-            
             if distance is not None:
-                raise Exception('The distance should not be specified if the height and width are.')
+                msg = "The distance should not be specified if the height and width are."
+                raise Exception(msg)
 
             distance = min(width, height)
 
         elif distance is not None:
-            
             if width is not None or height is not None:
-                raise Exception('If the distance is specified then neither the height or the width should be.')
-            
+                msg = "If the distance is specified then neither the height or the width should be."
+                raise Exception(msg)
+
             width = height = distance
 
         else:
-            raise Exception('Either distance or both height and width should be specified.')
+            msg = "Either distance or both height and width should be specified."
+            raise Exception(msg)
+
+        self.qecc_params["distance"] = distance
+        self.qecc_params["height"] = height
+        self.qecc_params["width"] = width
 
-        self.qecc_params['distance'] = distance
-        self.qecc_params['height'] = height
-        self.qecc_params['width'] = width
-            
         return distance, height, width
 
     def _data_id_iter(self):
-        """
-        Assigns qudit ids. Also, records qudit id in the sets self.
+        """Assigns qudit ids. Also, records qudit id in the sets self.
 
         Returns:
+        -------
 
         """
-
         while True:
             qudit_id = max(self.qudit_set, default=-1) + 1
             self.qudit_set.add(qudit_id)
             self.data_qudit_set.add(qudit_id)
 
             if len(self.data_qudit_set) > self.num_data_qudits:
-                raise Exception('Number of data qudits requested exceeds number expected.')
+                msg = "Number of data qudits requested exceeds number expected."
+                raise Exception(msg)
 
             yield qudit_id
 
     def _ancilla_id_iter(self):
-        """
-        Assigns qudit ids. Also, records qudit id in the sets self.
+        """Assigns qudit ids. Also, records qudit id in the sets self.
 
         Returns:
+        -------
 
         """
         last_ancilla_id = None
 
         while True:
-
             if len(self.ancilla_qudit_set) == self.num_ancilla_qudits:
-                print('Requesting more qudits then expected assuming last ancilla id.')
+                print("Requesting more qudits then expected assuming last ancilla id.")
                 yield last_ancilla_id
             else:
                 qudit_id = max(self.qudit_set, default=-1) + 1
                 last_ancilla_id = qudit_id
                 self.qudit_set.add(qudit_id)
                 self.ancilla_qudit_set.add(qudit_id)
 
                 yield qudit_id
 
     def _add_node(self, x, y, iter_ids):
-
         nid = next(iter_ids)
 
         self.layout[nid] = (x, y)
         self.position_to_qubit[(x, y)] = nid
 
     def _generate_layout(self):
-        """
-        Creates the layout dictionary which describes the location of the qubits in the code.
+        """Creates the layout dictionary which describes the location of the qubits in the code.
 
         :param qudit_ids:
         :return:
         """
-
         height = self.height
         width = self.width
         lattice_height = 2 * (height - 1)
         lattice_width = 2 * (width - 1)
         self.lattice_height = lattice_height
         self.lattice_width = lattice_width
         data_ids = self._data_id_iter()
         ancilla_ids = self._ancilla_id_iter()
 
         self.lattice_dimensions = {
-            'width': lattice_width,
-            'height': lattice_width
+            "width": lattice_width,
+            "height": lattice_width,
         }
 
         # Determine the position of things
         for y in range(lattice_height + 1):
             for x in range(lattice_width + 1):
-
                 if (x % 2 == 0 and y % 2 == 0) or (x % 2 == 1 and y % 2 == 1):
                     # Data
                     self._add_node(x, y, data_ids)
 
                 elif x % 2 == 1 and y % 2 == 0:
                     # X ancilla
                     self._add_node(x, y, ancilla_ids)
@@ -234,43 +219,38 @@
                 elif x % 2 == 0 and y % 2 == 1:
                     # Z ancilla
                     self._add_node(x, y, ancilla_ids)
 
         return self.layout
 
     def _determine_sides(self):
-        """
-        Outputs a dictionary that describes the sides of the code.
+        """Outputs a dictionary that describes the sides of the code.
 
         The repetition code is essentially a line.
 
         d d d
          a a
 
         d = data
         a = ancilla
 
         :return:
         """
-
         width = self.lattice_width
         height = self.lattice_height
 
         # Logical X
         top_nodes = []
         right_nodes = []
         bottom_nodes = []
         left_nodes = []
 
-        # layout = self.layout
-
         # self.qubits_data is not set when this is called
 
         for d, (x, y) in self.layout.items():
-
             if x == 0 and y % 2 == 0:
                 left_nodes.append(d)
 
             if x == width and y % 2 == 0:
                 right_nodes.append(d)
 
             if y == 0 and x % 2 == 0:
@@ -280,15 +260,13 @@
                 top_nodes.append(d)
 
         top_nodes.sort()
         right_nodes.sort(reverse=True)
         bottom_nodes.sort(reverse=True)
         left_nodes.sort()
 
-        boundaries = {
-            'top': top_nodes,
-            'right': right_nodes,
-            'bottom': bottom_nodes,
-            'left': left_nodes
+        return {
+            "top": top_nodes,
+            "right": right_nodes,
+            "bottom": bottom_nodes,
+            "left": left_nodes,
         }
-
-        return boundaries
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_medial_4444/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_medial_4444/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_medial_4444/instructions.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_medial_4444/instructions.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,277 +7,264 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ..instruction_parent_class import LogicalInstruction
-from ...circuits.quantum_circuit import QuantumCircuit
-from ..helper_functions import pos2qudit
+from pecos.circuits.quantum_circuit import QuantumCircuit
+from pecos.qeccs.helper_functions import pos2qudit
+from pecos.qeccs.instruction_parent_class import LogicalInstruction
 
 
 class InstrSynExtraction(LogicalInstruction):
-    """
-    Instruction for a round of syndrome extraction.
+    """Instruction for a round of syndrome extraction.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
-        qecc_init_ticks = qecc.qecc_params.get('init_ticks', 0)
-        qecc_meas_ticks = qecc.qecc_params.get('meas_ticks', 7)
-        qecc_x_ticks = qecc.qecc_params.get('x_ticks', [2, 4, 3, 5])
-        qecc_z_ticks = qecc.qecc_params.get('z_ticks', [2, 4, 3, 5])
-
-        self.init_ticks = params.get('init_ticks', qecc_init_ticks)
-        self.meas_ticks = params.get('meas_ticks', qecc_meas_ticks)
-        self.x_ticks = params.get('x_ticks', qecc_x_ticks)
-        self.z_ticks = params.get('z_ticks', qecc_z_ticks)
+        qecc_init_ticks = qecc.qecc_params.get("init_ticks", 0)
+        qecc_meas_ticks = qecc.qecc_params.get("meas_ticks", 7)
+        qecc_x_ticks = qecc.qecc_params.get("x_ticks", [2, 4, 3, 5])
+        qecc_z_ticks = qecc.qecc_params.get("z_ticks", [2, 4, 3, 5])
+
+        self.init_ticks = params.get("init_ticks", qecc_init_ticks)
+        self.meas_ticks = params.get("meas_ticks", qecc_meas_ticks)
+        self.x_ticks = params.get("x_ticks", qecc_x_ticks)
+        self.z_ticks = params.get("z_ticks", qecc_z_ticks)
 
         self.abstract_circuit = QuantumCircuit(**params)
 
         self.data_qudit_set = self.qecc.data_qudit_set
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
 
-        self.ancilla_x_check = set([])
-        self.ancilla_z_check = set([])
+        self.ancilla_x_check = set()
+        self.ancilla_z_check = set()
 
         # Go through the ancillas and grab the data qubits that are on either side of it.
         layout = qecc.layout  # qudit_id => (x, y)
 
         self.pos2qudit = pos2qudit(layout)
 
         for q, (x, y) in layout.items():
             if x % 2 == 0 and y % 2 == 0:
-
                 # Ancilla
                 if x % 4 == y % 4:
                     # X check
                     self._create_x_check(q, x, y)
 
                 else:
                     # Z check
                     self._create_z_check(q, x, y)
 
         # Determine the logical operations
         # --------------------------------
-        z_qudits = set(qecc.sides['top'])
-        x_qudits = set(qecc.sides['left'])
+        z_qudits = set(qecc.sides["top"])
+        x_qudits = set(qecc.sides["left"])
 
         logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': QuantumCircuit([{'X': x_qudits}]), 'Z': QuantumCircuit([{'Z': z_qudits}])},
+            {"X": QuantumCircuit([{"X": x_qudits}]), "Z": QuantumCircuit([{"Z": z_qudits}])},
         ]
 
         self.initial_logical_ops = logical_ops
 
         logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': QuantumCircuit([{'X': x_qudits}]), 'Z': QuantumCircuit([{'Z': z_qudits}])},
+            {"X": QuantumCircuit([{"X": x_qudits}]), "Z": QuantumCircuit([{"Z": z_qudits}])},
         ]
 
         self.final_logical_ops = logical_ops
 
         self.logical_signs = None
         self.logical_stabilizers = None
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
 
         self._stabs_destabs = {}
 
     def _create_x_check(self, ancilla, x, y):
-        """
-        Creates X-checks for circuit_extended.
-        """
-
+        """Creates X-checks for circuit_extended."""
         # register the x syndrome ancillas
         self.ancilla_x_check.add(ancilla)
 
         # get where the position of where the data qubits should be relative to the ancilla
         data_pos = self._data_pos_x_check(x, y)
 
         # Get the actual, available data-qubits and their ticks that correspond to the possible data qubit positions
-        datas, my_data_ticks = self._find_data(position_to_qudit=self.pos2qudit, positions=data_pos,
-                                               ticks=self.x_ticks)
+        datas, my_data_ticks = self._find_data(position_to_qudit=self.pos2qudit, positions=data_pos, ticks=self.x_ticks)
 
         # Now add the check to the extended circuit
         locations = set(datas)
         locations.add(ancilla)
-        self.abstract_circuit.append('X check', locations=locations, datas=datas, ancillas=ancilla,
-                                     ancilla_ticks=self.init_ticks, data_ticks=my_data_ticks,
-                                     meas_ticks=self.meas_ticks)
+        self.abstract_circuit.append(
+            "X check",
+            locations=locations,
+            datas=datas,
+            ancillas=ancilla,
+            ancilla_ticks=self.init_ticks,
+            data_ticks=my_data_ticks,
+            meas_ticks=self.meas_ticks,
+        )
 
     def _create_z_check(self, ancilla, x, y):
-        """
-        Creates Z-checks for circuit_extended.
-        """
-
+        """Creates Z-checks for circuit_extended."""
         # register the z syndrome ancillas
         self.ancilla_z_check.add(ancilla)
 
         # get where the position of where the data qubits should be relative to the ancilla
         data_pos = self._data_pos_z_check(x, y)
         # Get the actual, available data-qubits and their ticks that correspond to the possible data qubit positions
-        datas, my_data_ticks = self._find_data(position_to_qudit=self.pos2qudit, positions=data_pos,
-                                               ticks=self.z_ticks)
+        datas, my_data_ticks = self._find_data(position_to_qudit=self.pos2qudit, positions=data_pos, ticks=self.z_ticks)
 
         # Now add the check to the extended circuit
         locations = set(datas)
         locations.add(ancilla)
-        self.abstract_circuit.append('Z check', locations=locations, datas=datas, ancillas=ancilla,
-                                     ancilla_ticks=self.init_ticks, data_ticks=my_data_ticks,
-                                     meas_ticks=self.meas_ticks)
+        self.abstract_circuit.append(
+            "Z check",
+            locations=locations,
+            datas=datas,
+            ancillas=ancilla,
+            ancilla_ticks=self.init_ticks,
+            data_ticks=my_data_ticks,
+            meas_ticks=self.meas_ticks,
+        )
 
     @staticmethod
     def _find_data(position_to_qudit, positions, ticks):
         """
         From the positions given for possible data qudits, add the qudits and their corresponding ticks for each qudit
         that does exist.
 
-        :param position_to_qudit:
-        :param positions:
-        :param ticks:
-        :return:
-        """
+        Args:
+            position_to_qudit:
+            positions:
+            ticks:
+
+        Returns:
 
+        """
         data_list = []
         tick_list = []
 
         for i, p in enumerate(positions):
             data = position_to_qudit.get(p, None)
             if data is not None:
                 data_list.append(data)
                 tick_list.append(ticks[i])
 
         return data_list, tick_list
 
     @staticmethod
     def _data_pos_z_check(x, y):
-        """
-        Determines the position of data qudits in a Z check in order of ticks.
+        """Determines the position of data qudits in a Z check in order of ticks.
 
         Check direction:   1  |  2
                               |
                            ---+---
                               |
                            3  |  4
 
 
         """
-
-        data_pos = [
+        return [
             (x - 1, y + 1),
             (x + 1, y + 1),
             (x - 1, y - 1),
-            (x + 1, y - 1)
+            (x + 1, y - 1),
         ]
 
-        return data_pos
-
     @staticmethod
     def _data_pos_x_check(x, y):
-        """
-        Determines the position of data qudits in a Z check in order of ticks.
+        """Determines the position of data qudits in a Z check in order of ticks.
 
         Check direction:   1  |  3
                               |
                            ---+---
                               |
                            2  |  4
         """
-
-        data_pos = [
+        return [
             (x - 1, y + 1),
             (x - 1, y - 1),
             (x + 1, y + 1),
-            (x + 1, y - 1)
+            (x + 1, y - 1),
         ]
 
-        return data_pos
-
     @property
     def stabs_destabs(self):
-
         if self._stabs_destabs:
             return self._stabs_destabs
 
         if self.qecc.height != self.qecc.width:
-            raise Exception('This currently only works for square code blocks.')
+            msg = "This currently only works for square code blocks."
+            raise Exception(msg)
 
-        # instr = self.instruction('instr_syn_extract')
         instr = self
 
         stabs_row_x = []
         stabs_row_z = []
         destabs_row_x = []
         destabs_row_z = []
 
         for a in self.ancilla_qudit_set:
             stabs_row_z.append({a})
-            stabs_row_x.append(set([]))
+            stabs_row_x.append(set())
             destabs_row_x.append({a})
-            destabs_row_z.append(set([]))
+            destabs_row_z.append(set())
 
         xdestabs = self.generate_xdestabs()
         zdestabs = self.generate_zdestabs()
 
         # Creating stabilizers
         for check_type, _, params in instr.abstract_circuit.items():
-
-            if check_type == 'X check':
+            if check_type == "X check":
                 # Ancillas initialized in |0>
                 # Pauli X-type stabilizers
-                stabs_row_x.append(set(params['datas']))
-                stabs_row_z.append(set([]))
-                destabs_row_x.append(set([]))
-                destabs_row_z.append(zdestabs[params['ancillas']])
+                stabs_row_x.append(set(params["datas"]))
+                stabs_row_z.append(set())
+                destabs_row_x.append(set())
+                destabs_row_z.append(zdestabs[params["ancillas"]])
 
             else:
                 # Ancillas initialized in |0>
                 # Pauli Z-type stabilizers
-                stabs_row_z.append(set(params['datas']))
-                stabs_row_x.append(set([]))
-                destabs_row_z.append(set([]))
-                destabs_row_x.append(xdestabs[params['ancillas']])
+                stabs_row_z.append(set(params["datas"]))
+                stabs_row_x.append(set())
+                destabs_row_z.append(set())
+                destabs_row_x.append(xdestabs[params["ancillas"]])
 
         output_dict = {
-            'stabs_x': stabs_row_x,
-            'stabs_z': stabs_row_z,
-            'destabs_x': destabs_row_x,
-            'destabs_z': destabs_row_z,
+            "stabs_x": stabs_row_x,
+            "stabs_z": stabs_row_z,
+            "destabs_x": destabs_row_x,
+            "destabs_z": destabs_row_z,
         }
 
         self._stabs_destabs = output_dict
 
         return output_dict
 
     def generate_xdestabs(self):
-
         distance = self.qecc.distance
 
         # x-type destabilizers
 
         xdestabs_temp = []
         # going alone the bottom
-        if distance % 2 == 0:
-            b = 1
-        else:
-            b = 2
+        b = 1 if distance % 2 == 0 else 2
 
         for x in range(b, distance, 2):
-
             temp = []
             y = distance - 1
-            for j in range(0, distance):
-
+            for j in range(distance):
                 new_point = (x + j, y - j)
 
                 if new_point[1] <= 0:
                     break
 
                 if new_point[0] > distance - 1:
                     break
@@ -288,39 +275,37 @@
 
         # ----------------
         xdestabs = []
         for ds in xdestabs_temp:
             for i in range(len(ds)):
                 temp = []
                 for j in range(i + 1):
-                    # print('-', i, j)
                     temp.append(ds[j])
                 xdestabs.append(temp)
         # -----------------
 
         # ladder climb
         ladder = []
         x = 0
         for y in range(distance - 1, 0, -1):
             ladder.append((x, y))
 
         for i in range(len(ladder)):
-            xdestabs.append(ladder[:i + 1])
+            xdestabs.append(ladder[: i + 1])
 
         ladder_points = []
         for i in range((distance + 1) % 2, distance - 1, 2):
             ladder_points.append(i)
 
         ladder_temp = []
         for i in ladder_points:
-            temp = list(ladder[:i + 1])
+            temp = list(ladder[: i + 1])
             x, y = ladder[i]
 
             for j in range(1, distance):
-
                 if j != 1:
                     temp = list(ladder_temp[-1])
                 new_point = (x + j, y - j)
 
                 if new_point[1] <= 0:
                     break
 
@@ -332,15 +317,15 @@
 
         xdestabs.extend(ladder_temp)
 
         set_destabs = {}
         relayout = {v: k for k, v in self.qecc.layout.items()}
 
         for d in xdestabs:
-            row = set([])
+            row = set()
 
             # Find the associated ancilla location
             x, y = d[-1]
             a = relayout[(2 * x + 1 + 1, 2 * y + 1 - 1)]
 
             if a in self.ancilla_x_check:
                 a = relayout[(2 * x - 1 + 1, 2 * y + 1 - 1)]
@@ -348,76 +333,67 @@
             for x, y in d:
                 row.add(relayout[(2 * x + 1, 2 * y + 1)])
             set_destabs[a] = set(row)
 
         return set_destabs
 
     def generate_zdestabs(self):
-
         distance = self.qecc.distance
 
         # x-type destabilizers
 
         zdestabs_temp = []
         # going alone the bottom
-        if distance % 2 == 0:
-            b = 2
-        else:
-            b = 1
+        b = 2 if distance % 2 == 0 else 1
 
         for y in range(b, distance, 2):
-
             temp = []
             x = distance - 1
-            for j in range(0, distance):
-
+            for j in range(distance):
                 new_point = (x - j, y + j)
 
                 if new_point[0] <= 0:
                     break
 
                 if new_point[1] > distance - 1:
                     break
 
                 temp.append(new_point)
 
-                # print(x, y)
             zdestabs_temp.append(temp)
 
         # ----------------
         zdestabs = []
         for ds in zdestabs_temp:
             for i in range(len(ds)):
                 temp = []
                 for j in range(i + 1):
-                    # print('-', i, j)
                     temp.append(ds[j])
                 zdestabs.append(temp)
         # -----------------
 
         # ladder climb
         ladder = []
         y = 0
         for x in range(distance - 1, 0, -1):
             ladder.append((x, y))
 
         for i in range(len(ladder)):
-            zdestabs.append(ladder[:i + 1])
+            zdestabs.append(ladder[: i + 1])
 
         ladder_points = []
         for i in range(distance % 2, distance - 1, 2):
             ladder_points.append(i)
 
         ladder_temp = []
         for i in ladder_points:
-            temp = list(ladder[:i + 1])
+            temp = list(ladder[: i + 1])
             x, y = ladder[i]
 
             for j in range(1, distance):
-
                 if j != 1:
                     temp = list(ladder_temp[-1])
                 new_point = (x - j, y + j)
 
                 if new_point[0] <= 0:
                     break
 
@@ -429,15 +405,15 @@
 
         zdestabs.extend(ladder_temp)
 
         set_destabs = {}
         relayout = {v: k for k, v in self.qecc.layout.items()}
 
         for d in zdestabs:
-            row = set([])
+            row = set()
 
             # Find the associated ancilla location
             x, y = d[-1]
             a = relayout[(2 * x + 1 - 1, 2 * y + 1 + 1)]
 
             if a in self.ancilla_z_check:
                 a = relayout[(2 * x + 1 - 1, 2 * y + 1 - 1)]
@@ -446,162 +422,161 @@
                 row.add(relayout[(2 * x + 1, 2 * y + 1)])
             set_destabs[a] = row
 
         return set_destabs
 
 
 class InstrInitZero(LogicalInstruction):
-    """
-    Instruction for initializing a logical zero.
+    """Instruction for initializing a logical zero.
 
     It is just like syndrome extraction except the data qubits are initialized in the zero state at tick = 0.
 
     `ideal_meas` == True will cause the measurements to be replace with ideal measurements.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
-        self.symbol = 'instr_init_zero'
+        self.symbol = "instr_init_zero"
 
         self.data_qudit_set = self.qecc.data_qudit_set
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
 
         # This is basically syndrome extraction round where all the data qubits are initialized to zero.
-        syn_ext = qecc.instruction('instr_syn_extract', **params)
+        syn_ext = qecc.instruction("instr_syn_extract", **params)
 
         # Make a shallow copy of the abstract circuits.
         self.abstract_circuit = syn_ext.abstract_circuit.copy()
         self.abstract_circuit.params.update(params)
 
         self.ancilla_x_check = syn_ext.ancilla_x_check
         self.ancilla_z_check = syn_ext.ancilla_z_check
 
         data_qudits = syn_ext.data_qudit_set
-        self.abstract_circuit.append('init |0>', locations=data_qudits, tick=0)
+        self.abstract_circuit.append("init |0>", locations=data_qudits, tick=0)
 
         self.initial_logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': None, 'Z': None},  # None => can be anything
+            {"X": None, "Z": None},  # None => can be anything
         ]
 
         # Special for state initialization:
         # ---------------------------------
         # list of tuples of logical check and delogical stabilizer for each logical qudit.
         self.final_logical_ops = [
-            {'Z': QuantumCircuit([{'Z': set(qecc.sides['top'])}]), 'X': QuantumCircuit([{'X': set(qecc.sides['left'])}])}
+            {
+                "Z": QuantumCircuit([{"Z": set(qecc.sides["top"])}]),
+                "X": QuantumCircuit([{"X": set(qecc.sides["left"])}]),
+            },
         ]
 
         # List of corresponding logical sign. (The logical sign if the instruction is preformed ideally.)
         self.logical_signs = [0]
-        self.logical_stabilizers = ['Z']
+        self.logical_stabilizers = ["Z"]
         # ---------------------------------
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
 
         self._stabs_destabs = {}
 
     @property
     def stabs_destabs(self):
-
         if self._stabs_destabs:
             return self._stabs_destabs
 
         params = self.params
-        syn_ext = self.qecc.instruction('instr_syn_extract', **params)
+        syn_ext = self.qecc.instruction("instr_syn_extract", **params)
 
         for name, rows in syn_ext.stabs_destabs.items():
             self._stabs_destabs[name] = []
             for row in rows:
                 self._stabs_destabs[name].append(set(row))
 
         # |0> -> logical Z is a stabilizer
-        self._stabs_destabs['stabs_z'].append(set(self.qecc.sides['top']))
-        self._stabs_destabs['stabs_x'].append(set([]))
-        self._stabs_destabs['destabs_x'].append(set(self.qecc.sides['left']))
-        self._stabs_destabs['destabs_z'].append(set([]))
+        self._stabs_destabs["stabs_z"].append(set(self.qecc.sides["top"]))
+        self._stabs_destabs["stabs_x"].append(set())
+        self._stabs_destabs["destabs_x"].append(set(self.qecc.sides["left"]))
+        self._stabs_destabs["destabs_z"].append(set())
 
         return self._stabs_destabs
 
 
 class InstrInitPlus(LogicalInstruction):
-    """
-    Instruction for initializing a logical plus.
+    """Instruction for initializing a logical plus.
 
     It is just like syndrome extraction except the data qubits are initialized in the plus state at tick = 0.
 
     `ideal_meas` == True will cause the measurements to be replace with ideal measurements.
 
     Parent class sets self.qecc.
     """
 
-    def __init__(self, qecc, symbol, **params):
-
+    def __init__(self, qecc, symbol, **params) -> None:
         super().__init__(qecc, symbol, **params)
 
-        self.symbol = 'instr_init_plus'
+        self.symbol = "instr_init_plus"
 
         self.data_qudit_set = self.qecc.data_qudit_set
         self.ancilla_qudit_set = self.qecc.ancilla_qudit_set
 
         # This is basically syndrome extraction round where all the data qubits are initialized to plus.
-        syn_ext = qecc.instruction('instr_syn_extract', **params)
+        syn_ext = qecc.instruction("instr_syn_extract", **params)
 
         # Make a shallow copy of the abstract circuits.
         self.abstract_circuit = syn_ext.abstract_circuit.copy()
         self.abstract_circuit.params.update(params)
 
         self.ancilla_x_check = syn_ext.ancilla_x_check
         self.ancilla_z_check = syn_ext.ancilla_z_check
 
         data_qudits = syn_ext.data_qudit_set
-        # self.abstract_circuit.append('init |+>', qudits=data_qudits, tick=0)
-        self.abstract_circuit.append('init |0>', locations=data_qudits, tick=0)
-        self.abstract_circuit.append('H', locations=data_qudits, tick=1)
+        self.abstract_circuit.append("init |0>", locations=data_qudits, tick=0)
+        self.abstract_circuit.append("H", locations=data_qudits, tick=1)
 
         self.initial_logical_ops = [  # Each element in the list corresponds to a logical qubit
             # The keys label the type of logical operator
-            {'X': None, 'Z': None},  # None => can be anything
+            {"X": None, "Z": None},  # None => can be anything
         ]
 
         # Special for state initialization:
         # ---------------------------------
         # list of tuples of logical check and delogical stabilizer for each logical qudit.
         self.final_logical_ops = [
-            {'X': QuantumCircuit([{'X': set(qecc.sides['left'])}]), 'Z': QuantumCircuit([{'Z': set(qecc.sides['top'])}])}
+            {
+                "X": QuantumCircuit([{"X": set(qecc.sides["left"])}]),
+                "Z": QuantumCircuit([{"Z": set(qecc.sides["top"])}]),
+            },
         ]
 
         # List of corresponding logical sign. (The logical sign if the instruction is preformed ideally.)
         self.logical_signs = [0]
-        self.logical_stabilizers = ['X']
+        self.logical_stabilizers = ["X"]
         # ---------------------------------
 
         # Must be called at the end of initiation.
         self._compile_circuit(self.abstract_circuit)
 
         self._stabs_destabs = {}
 
     @property
     def stabs_destabs(self):
-
         if self._stabs_destabs:
             return self._stabs_destabs
 
         params = self.params
-        syn_ext = self.qecc.instruction('instr_syn_extract', **params)
+        syn_ext = self.qecc.instruction("instr_syn_extract", **params)
 
         for name, rows in syn_ext.stabs_destabs.items():
             self._stabs_destabs[name] = []
             for row in rows:
                 self._stabs_destabs[name].append(set(row))
 
         # |0> -> logical Z is a stabilizer
-        self._stabs_destabs['stabs_x'].append(set(self.qecc.sides['left']))
-        self._stabs_destabs['stabs_z'].append(set([]))
-        self._stabs_destabs['destabs_z'].append(set(self.qecc.sides['top']))
-        self._stabs_destabs['stabs_x'].append(set([]))
+        self._stabs_destabs["stabs_x"].append(set(self.qecc.sides["left"]))
+        self._stabs_destabs["stabs_z"].append(set())
+        self._stabs_destabs["destabs_z"].append(set(self.qecc.sides["top"]))
+        self._stabs_destabs["stabs_x"].append(set())
 
         return self._stabs_destabs
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/qeccs/surface_medial_4444/surface_medial_4444.py` & `quantum_pecos-0.6.0.dev1/python/pecos/qeccs/surface_medial_4444/surface_medial_4444.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,61 +1,54 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-    repetition_z
-    ~~~~~~~~~~~~
+"""repetition_z
+~~~~~~~~~~~~.
 
-    Generates circuits for the repetition code in the Z-Basis.
+Generates circuits for the repetition code in the Z-Basis.
 """
-from ..qecc_parent_class import QECC
 from pecos.circuit_converters.checks2circuit import Check2Circuits
-from .instructions import InstrSynExtraction, InstrInitZero, InstrInitPlus
-from .gates import GateIdentity, GateInitZero, GateInitPlus
+from pecos.qeccs.qecc_parent_class import QECC
+from pecos.qeccs.surface_medial_4444.gates import GateIdentity, GateInitPlus, GateInitZero
+from pecos.qeccs.surface_medial_4444.instructions import InstrInitPlus, InstrInitZero, InstrSynExtraction
 
 
 class SurfaceMedial4444(QECC):
-    """
-    Medial Surface code on 4.4.4.4 lattice.
-    """
-
-    def __init__(self, distance=None, height=None, width=None, **qecc_params):
-        """
+    """Medial Surface code on 4.4.4.4 lattice."""
 
-        Args:
+    def __init__(self, distance=None, height=None, width=None, **qecc_params) -> None:
+        """Args:
+        ----
             distance: The distance of the code. If specified a square code of height and width equaled to the distance
             will be returned.
             height: The height of the code block. This is the size of the minimum logical X.
             width: The width of the code block. This is the size of the minimum logical Z.
             **qecc_params:
         """
-
-        qecc_params['distance'] = distance
-        qecc_params['height'] = height
-        qecc_params['width'] = width
+        qecc_params["distance"] = distance
+        qecc_params["height"] = height
+        qecc_params["width"] = width
 
         super().__init__(**qecc_params)
 
-        self.rotated = qecc_params.get('rotated', False)
+        self.rotated = qecc_params.get("rotated", False)
 
         # Give name for others classes to identify this code
         # --------------------------------------------------
-        self.name = 'Medial 4.4.4.4 Surface Code'
+        self.name = "Medial 4.4.4.4 Surface Code"
 
         # QECC parameters:
         # ----------------
         self.qecc_params = qecc_params
 
         # Create dictionaries to associate symbols to gate and instruction classes.
         self.sym2gate_class, self.sym2instruction_class = self._set_symbols()
@@ -73,19 +66,18 @@
         # number of syndrome bits
         self.num_syndromes = self.num_data_qudits - self.num_logical_qudits
 
         # --------------------------------------------------------------------------------------------------------------
         # Determine number of ancillas to reserve given the check circuit implementation and, perhaps, the logical
         # gate circuits implemented by this class.
         # --------------------------------------------------------------------------------------------------------------
-        self.circuit_compiler = qecc_params.get('circuit_compiler', Check2Circuits())
+        self.circuit_compiler = qecc_params.get("circuit_compiler", Check2Circuits())
         self.num_ancilla_qudits = self.circuit_compiler.get_num_ancillas(self.num_syndromes)
 
         # Total number of qudits.
-        # self.num_qudits = self.num_data_qudits + self.num_ancilla_qudits
         # self.qudit_set, self.data_qudit_set, self.ancilla_qudit_set will be determined when creating the layout.
 
         # Determine QECC geometry
         # -----------------------
         self.lattice_width = None
         self.lattice_height = None
         self.lattice_dimensions = {}
@@ -94,99 +86,91 @@
 
         # Create side information
         # Allows other classes (e.g., decoders) to understand the orientation of the code
         self.sides = self._determine_sides()
 
     @staticmethod
     def _set_symbols():
-
         # gate and instruction symbol bindings
         # ------------------------------------
         # gate symbol => gate class
         sym2gate_class = {
-            'I': GateIdentity,
-            'init |0>': GateInitZero,
-            'init |+>': GateInitPlus,
+            "I": GateIdentity,
+            "init |0>": GateInitZero,
+            "init |+>": GateInitPlus,
         }
 
         # instruction symbol => instr. class
         sym2instruction_class = {
-            'instr_syn_extract': InstrSynExtraction,
-            'instr_init_zero': InstrInitZero,
-            'instr_init_plus': InstrInitPlus,
+            "instr_syn_extract": InstrSynExtraction,
+            "instr_init_zero": InstrInitZero,
+            "instr_init_plus": InstrInitPlus,
         }
 
         return sym2gate_class, sym2instruction_class
 
     def _get_distance(self):
-        """
-        Sets the distances based on the `qecc_params` `distance`, `height`, and `width`. 
-        
+        """Sets the distances based on the `qecc_params` `distance`, `height`, and `width`.
+
         This will modify the `gate_params`.
         """
-        
         params = self.qecc_params
 
-        distance = params.get('distance')
-        width = params.get('width')
-        height = params.get('height')
+        distance = params.get("distance")
+        width = params.get("width")
+        height = params.get("height")
 
         if width is not None and height is not None:
-
             if distance is not None:
-                raise Exception('The distance should not be specified if the height and width are.')
+                msg = "The distance should not be specified if the height and width are."
+                raise Exception(msg)
 
             distance = min(width, height)
 
         elif distance is not None:
-
             if width is not None or height is not None:
-                raise Exception('If the distance is specified then neither the height or the width should be.')
+                msg = "If the distance is specified then neither the height or the width should be."
+                raise Exception(msg)
 
             width = height = distance
 
         else:
-            raise Exception('Either distance or both height and width should be specified.')
-        
-        self.qecc_params['distance'] = distance
-        self.qecc_params['height'] = height
-        self.qecc_params['width'] = width
+            msg = "Either distance or both height and width should be specified."
+            raise Exception(msg)
+
+        self.qecc_params["distance"] = distance
+        self.qecc_params["height"] = height
+        self.qecc_params["width"] = width
 
         return distance, height, width
 
     def _generate_layout(self):
-        """
-        Creates the layout dictionary which describes the location of the qubits in the code.
+        """Creates the layout dictionary which describes the location of the qubits in the code.
 
         :param qudit_ids:
         :return:
         """
-
         height = self.height
         width = self.width
         lattice_height = 2 * height
         lattice_width = 2 * width
         self.lattice_height = lattice_height
         self.lattice_width = lattice_width
         data_ids = self._data_id_iter()
         ancilla_ids = self._ancilla_id_iter()
 
         self.lattice_dimensions = {
-            'width': 2 * width,
-            'height': 2 * height
+            "width": 2 * width,
+            "height": 2 * height,
         }
 
-        if self.rotated:
-            xy_iter = self._rotated_orientaition()
-        else:
-            xy_iter = self._norm_orientaition()
+        xy_iter = self._rotated_orientaition() if self.rotated else self._norm_orientaition()
 
         # Determine the position of things
         for x, y in xy_iter:
-
             if 0 < x < lattice_width and 0 < y < lattice_height:
                 # Interior (no digons)
 
                 if x % 2 == 1 and y % 2 == 1:  # That is, both coordinates are odd...
                     # Data
 
                     self._add_node(x, y, data_ids)
@@ -205,27 +189,25 @@
                     if x != 0 and x % 4 == 0:
                         self._add_node(x, y, ancilla_ids)
 
                 elif x == 0:
                     # Left column
                     # X checks
 
-                    if (y-2) % 4 == 0:
+                    if (y - 2) % 4 == 0:
                         self._add_node(x, y, ancilla_ids)
 
                 if y == lattice_height:
                     # Bottom: X checks
 
                     if height % 2 == 0:
-
                         if x != 0 and x % 4 == 0:
                             self._add_node(x, y, ancilla_ids)
 
                     else:
-
                         if (x - 2) % 4 == 0:
                             self._add_node(x, y, ancilla_ids)
 
                 elif x == lattice_width:
                     # Right column
                     # X checks
 
@@ -245,43 +227,38 @@
 
     def _rotated_orientaition(self):
         for x in range(self.lattice_width + 1):
             for y in range(self.lattice_height + 1):
                 yield x, y
 
     def _determine_sides(self):
-        """
-        Outputs a dictionary that describes the sides of the code.
+        """Outputs a dictionary that describes the sides of the code.
 
         The repetition code is essentially a line.
 
         d d d
          a a
 
         d = data
         a = ancilla
 
         :return:
         """
-
         width = self.lattice_width
         height = self.lattice_height
 
         # Logical X
         top_nodes = []
         right_nodes = []
         bottom_nodes = []
         left_nodes = []
 
-        # layout = self.layout
-
         # self.qubits_data is not set when this is called
 
         for d, (x, y) in self.layout.items():
-
             if x == 1 and y % 2 == 1:
                 left_nodes.append(d)
 
             if x == width - 1 and y % 2 == 1:
                 right_nodes.append(d)
 
             if y == 1 and x % 2 == 1:
@@ -296,15 +273,13 @@
         left_nodes.sort()
 
         top_nodes = [self.mapping[i] for i in top_nodes]
         right_nodes = [self.mapping[i] for i in right_nodes]
         bottom_nodes = [self.mapping[i] for i in bottom_nodes]
         left_nodes = [self.mapping[i] for i in left_nodes]
 
-        boundaries = {
-            'top': top_nodes,
-            'right': right_nodes,
-            'bottom': bottom_nodes,
-            'left': left_nodes
+        return {
+            "top": top_nodes,
+            "right": right_nodes,
+            "bottom": bottom_nodes,
+            "left": left_nodes,
         }
-
-        return boundaries
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/reps/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/op_processors/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,12 +1,14 @@
-# Copyright 2023 The PECOS Developers
+# Copyright 2022 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .pypmir import PyPMIR
+from __future__ import annotations
+
+from pecos.circuits.hyqc.hyqc import HyQC
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/block_types.py` & `quantum_pecos-0.6.0.dev1/python/pecos/machines/machine_abc.py`

 * *Files 19% similar despite different names*

```diff
@@ -5,42 +5,42 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import List, Optional
+from __future__ import annotations
 
-from .op_types import COp
+import abc
 
 
-class Block:
-    """General block type"""
-
-    def __init__(self, metadata: Optional[dict] = None):
+class Machine(metaclass=abc.ABCMeta):
+    def __init__(
+        self,
+        machine_params: dict | None = None,
+        num_qubits: int | None = None,
+        metadata: dict | None = None,
+        pos: dict | None = None,
+    ) -> None:
+        self.machine_params = machine_params
+        if self.machine_params is not None:
+            self.machine_params = dict(self.machine_params)
+        self.num_qubits = num_qubits
         self.metadata = metadata
+        self.pos = pos
 
-
-class SeqBlock(Block):
-    """A generic sequence block"""
-
-    def __init__(self,
-                 ops: list,
-                 metadata: Optional[dict] = None) -> None:
-
-        super().__init__(metadata=metadata)
-        self.ops = ops
-
-
-class IfBlock(Block):
-    """If/else block"""
-
-    def __init__(self,
-                 condition: "COp",
-                 true_branch: List["COp"],
-                 false_branch: Optional[list] = None,
-                 metadata: Optional[dict] = None):
-        super().__init__(metadata=metadata)
-        self.condition = condition
-        self.true_branch = true_branch
-        self.false_branch = false_branch
+    @abc.abstractmethod
+    def reset(self) -> None:
+        """Reset state to initialization state."""
+
+    @abc.abstractmethod
+    def init(self, num_qubits: int | None = None) -> None:
+        pass
+
+    @abc.abstractmethod
+    def shot_reinit(self) -> None:
+        """Run all code needed at the beginning of each shot, e.g., resetting state."""
+
+    @abc.abstractmethod
+    def process(self, op_buffer: list) -> list:
+        pass
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/data_types.py` & `quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/data_types.py`

 * *Files 19% similar despite different names*

```diff
@@ -5,64 +5,56 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import List, Optional, Union
+from __future__ import annotations
 
+from pecos.reps.pypmir.instr_type import Instr
 
-class Data:
 
-    def __init__(self, metadata: Optional[dict] = None):
-        self.metadata = metadata
+class Data(Instr):
+    """General data type."""
 
 
 class DefineVar(Data):
-
-    def __init__(self,
-                 data_type: Union[str, type],
-                 variable: str,
-                 metadata: Optional[dict] = None):
+    def __init__(self, data_type: str | type, variable: str, metadata: dict | None = None) -> None:
         super().__init__(metadata=metadata)
         self.data_type = data_type
         self.variable = variable
 
 
 class CVarDefine(DefineVar):
-
-    def __init__(self,
-                 data_type: Union[str, type],
-                 variable: str,
-                 cvar_id: int,
-                 size: int,
-                 metadata: Optional[dict] = None):
-
+    def __init__(
+        self,
+        data_type: str | type,
+        variable: str,
+        cvar_id: int,
+        size: int,
+        metadata: dict | None = None,
+    ) -> None:
         super().__init__(data_type=data_type, variable=variable, metadata=metadata)
         self.size = size
         self.cvar_id = cvar_id
 
 
 class QVarDefine(DefineVar):
-
-    def __init__(self,
-                 data_type: Union[str, type],
-                 variable: str,
-                 size: int,
-                 qubit_ids: List[int],
-                 metadata: Optional[dict] = None):
-
+    def __init__(
+        self,
+        data_type: str | type,
+        variable: str,
+        size: int,
+        qubit_ids: list[int],
+        metadata: dict | None = None,
+    ) -> None:
         super().__init__(data_type=data_type, variable=variable, metadata=metadata)
         self.size = size
         self.qubit_ids = qubit_ids
 
 
 class ExportVar(Data):
-
-    def __init__(self,
-                 variables: List[str],
-                 to: Optional[List[str]] = None,
-                 metadata: Optional[dict] = None):
+    def __init__(self, variables: list[str], to: list[str] | None = None, metadata: dict | None = None) -> None:
         super().__init__(metadata=metadata)
         self.variables = variables
         self.to = to
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/op_types.py` & `quantum_pecos-0.6.0.dev1/python/pecos/slr/slr.py`

 * *Files 23% similar despite different names*

```diff
@@ -5,72 +5,56 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Optional
 
+from pecos import __version__
+from pecos.slr.block import Block
 
-class Op:
 
-    def __init__(self,
-                 name: str,
-                 args: Optional[list] = None,
-                 returns: Optional[list] = None,
-                 metadata: Optional[dict] = None) -> None:
-        self.name = name
-        self.args = args
-        self.returns = returns
-        self.metadata = metadata
+class Main(Block):
+    """
+    A simple representation for Hybrid Quantum and Classical (HyQC) programs.
 
+    This serves as the entry point for the program.
+    """
 
-class QOp(Op):
-    """Quantum operation"""
+    def __init__(self, *args, vargs=None, ops=None):
+        super().__init__(*args, ops=ops, vargs=vargs)
+        self.num_qubits = None
 
-    def __init__(self,
-                 name: str,
-                 args: list,
-                 returns: Optional[list] = None,
-                 metadata: Optional[dict] = None):
-        super().__init__(
-            name=name,
-            args=args,
-            returns=returns,
-            metadata=metadata
-        )
+    def get_var(self, sym: str):
+        """Returns a variable object whose name matches the string provided."""
+        return self.vars.get(sym)
 
+    def qasm(self, include="hqslib1.inc", header=None):
+        def stamp_version(qasm):
+            qasm.append(f"// Generated using: PECOS version {__version__}")
 
-class COp(Op):
-    """Classical operation"""
+        qasm = []
+        if header is not None:
+            qasm.append(header)
+            stamp_version(qasm)
+        else:
+            qasm.append("OPENQASM 2.0;")
+            if include is not None:
+                qasm.append(f'include "{include}";')
 
-    def __init__(self,
-                 name: str,
-                 args: list,
-                 returns: Optional[list] = None,
-                 metadata: Optional[dict] = None):
-        super().__init__(
-            name=name,
-            args=args,
-            returns=returns,
-            metadata=metadata
-        )
+            stamp_version(qasm)
 
+            for v in self.vars.vars:
+                qasm.append(v.qasm())
 
-class FFCall(COp):
-    pass
+        for op in self.ops:
+            qm = op.qasm()
+            if qm is not None:
+                qasm.append(qm)
 
+        qasm = "\n".join(qasm)
 
-class MOp(Op):
-    """Machine operation"""
-    pass
+        return qasm
 
 
-class EMOp(Op):
-    """Error model operation"""
-    pass
-
-
-class SOp(Op):
-    """Simulation model"""
-    pass
+class CFunc: ...
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/reps/pypmir/types.py` & `quantum_pecos-0.6.0.dev1/python/pecos/reps/pypmir/types.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,10 +5,13 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from . import block_types as block
-from . import data_types as data
-from . import op_types as opt
+# ruff: noqa: F401
+
+from pecos.reps.pypmir import block_types as block
+from pecos.reps.pypmir import data_types as data
+from pecos.reps.pypmir import instr_type as instr
+from pecos.reps.pypmir import op_types as opt
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,9 +4,7 @@
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
-
-from .custatevec.state import CuStateVec
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuconn.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuconn.py`

 * *Files 18% similar despite different names*

```diff
@@ -8,10 +8,10 @@
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 import os
 import sys
 
-cupath = os.path.abspath(os.path.join(os.path.dirname(__file__), 'cuquantum_wrapper', 'build', 'bin'))
+cupath = os.path.abspath(os.path.join(os.path.dirname(__file__), "cuquantum_wrapper", "build", "bin"))
 sys.path.append(cupath)
 import cuquantum_wrapper as cq
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/reps/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -4,9 +4,7 @@
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
-
-# Initial author: Tyson Lawrence
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/extern/pybind11/tests/conftest.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/state.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,200 +1,159 @@
-"""pytest configuration
+# Copyright 2018 The PECOS Developers
+# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
+# DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
+#
+# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+# the License.You may obtain a copy of the License at
+#
+#     https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations under the License.
 
-Extends output capture as needed by pybind11: ignore constructors, optional unordered lines.
-Adds docstring and exceptions message sanitizers.
-"""
-
-import contextlib
-import difflib
-import gc
-import re
-import textwrap
-
-import pytest
-
-# Early diagnostic for failed imports
-import pybind11_tests  # noqa: F401
-
-_long_marker = re.compile(r"([0-9])L")
-_hexadecimal = re.compile(r"0x[0-9a-fA-F]+")
-
-# Avoid collecting Python3 only files
-collect_ignore = []
+"""A simple wrapper for the ProjectQ simulator.
 
+Compatibility checked for: ProjectQ version 0.5.1
+"""
 
-def _strip_and_dedent(s):
-    """For triple-quote strings"""
-    return textwrap.dedent(s.lstrip("\n").rstrip())
+from __future__ import annotations
 
+import contextlib
+from typing import TYPE_CHECKING
 
-def _split_and_sort(s):
-    """For output which does not require specific line order"""
-    return sorted(_strip_and_dedent(s).splitlines())
+import numpy as np
+from projectq import MainEngine
+from projectq.ops import All, Measure
 
+from pecos.simulators.gate_syms import alt_symbols
+from pecos.simulators.projectq import bindings
+from pecos.simulators.projectq.helper import MakeFunc
+from pecos.simulators.projectq.logical_sign import find_logical_signs
+from pecos.simulators.sim_class_types import StateVector
 
-def _make_explanation(a, b):
-    """Explanation for a failed assert -- the a and b arguments are List[str]"""
-    return ["--- actual / +++ expected"] + [
-        line.strip("\n") for line in difflib.ndiff(a, b)
-    ]
+if TYPE_CHECKING:
+    from pecos.circuits import QuantumCircuit
 
 
-class Output:
-    """Basic output post-processing and comparison"""
+class ProjectQSim(StateVector):
+    """Initializes the stabilizer state.
 
-    def __init__(self, string):
-        self.string = string
-        self.explanation = []
+    Args:
+    ----
+        num_qubits (int): Number of qubits being represented.
 
-    def __str__(self):
-        return self.string
+    Returns:
+    -------
 
-    def __eq__(self, other):
-        # Ignore constructor/destructor output which is prefixed with "###"
-        a = [
-            line
-            for line in self.string.strip().splitlines()
-            if not line.startswith("###")
-        ]
-        b = _strip_and_dedent(other).splitlines()
-        if a == b:
-            return True
-        else:
-            self.explanation = _make_explanation(a, b)
-            return False
+    """
 
+    def __init__(self, num_qubits) -> None:
+        if not isinstance(num_qubits, int):
+            msg = f"`num_qubits` should be of type `int.` but got type: {type(num_qubits)} "
+            raise TypeError(msg)
 
-class Unordered(Output):
-    """Custom comparison for output without strict line ordering"""
+        super().__init__()
 
-    def __eq__(self, other):
-        a = _split_and_sort(self.string)
-        b = _split_and_sort(other)
-        if a == b:
-            return True
-        else:
-            self.explanation = _make_explanation(a, b)
-            return False
+        self.bindings = bindings.gate_dict
+        for k, v in alt_symbols.items():
+            if v in self.bindings:
+                self.bindings[k] = self.bindings[v]
 
+        self.num_qubits = num_qubits
+        self.eng = MainEngine()
 
-class Capture:
-    def __init__(self, capfd):
-        self.capfd = capfd
-        self.out = ""
-        self.err = ""
+        self.qureg = self.eng.allocate_qureg(num_qubits)
+        self.qs = list(self.qureg)
+        self.qids = dict(enumerate(self.qs))
+        self.gate_dict = {}
 
-    def __enter__(self):
-        self.capfd.readouterr()
+    def reset(self):
+        """Reset the quantum state to all 0 for another run without reinitializing."""
+        self.eng.flush()
+        amps = [0] * 2**self.num_qubits
+        amps[0] = 1
+        self.eng.backend.set_wavefunction(amps, self.qureg)
         return self
 
-    def __exit__(self, *args):
-        self.out, self.err = self.capfd.readouterr()
-
-    def __eq__(self, other):
-        a = Output(self.out)
-        b = other
-        if a == b:
-            return True
+    def logical_sign(self, logical_op: QuantumCircuit) -> int:
+        """Args:
+        ----
+            logical_op:
+
+        Returns:
+        -------
+
+        """
+        return find_logical_signs(self, logical_op)
+
+    def add_gate(self, symbol: str, gate_obj, *, make_func: bool = True):
+        """Adds a new gate on the fly to this Simulator.
+
+        Args:
+        ----
+            symbol:
+            gate_obj:
+            make_func:
+
+        Returns:
+        -------
+
+        """
+        if symbol in self.gate_dict:
+            print("WARNING: Can not add gate as the symbol has already been taken.")
         else:
-            self.explanation = a.explanation
-            return False
-
-    def __str__(self):
-        return self.out
-
-    def __contains__(self, item):
-        return item in self.out
-
-    @property
-    def unordered(self):
-        return Unordered(self.out)
-
-    @property
-    def stderr(self):
-        return Output(self.err)
-
-
-@pytest.fixture
-def capture(capsys):
-    """Extended `capsys` with context manager and custom equality operators"""
-    return Capture(capsys)
-
-
-class SanitizedString:
-    def __init__(self, sanitizer):
-        self.sanitizer = sanitizer
-        self.string = ""
-        self.explanation = []
+            if make_func:
+                self.gate_dict[symbol] = MakeFunc(gate_obj).func
+            else:
+                self.gate_dict[symbol] = gate_obj
+
+    def get_probs(self, key_basis=None):
+        self.eng.flush()
+
+        if key_basis:
+            probs_dict = {}
+            for b in key_basis:
+                b = b[::-1]
+                p = self.eng.backend.get_probability(b, self.qureg)
+                b = b[::-1]
+                probs_dict[b] = p
+            return probs_dict
 
-    def __call__(self, thing):
-        self.string = self.sanitizer(thing)
-        return self
-
-    def __eq__(self, other):
-        a = self.string
-        b = _strip_and_dedent(other)
-        if a == b:
-            return True
         else:
-            self.explanation = _make_explanation(a.splitlines(), b.splitlines())
-            return False
-
-
-def _sanitize_general(s):
-    s = s.strip()
-    s = s.replace("pybind11_tests.", "m.")
-    s = _long_marker.sub(r"\1", s)
-    return s
-
-
-def _sanitize_docstring(thing):
-    s = thing.__doc__
-    s = _sanitize_general(s)
-    return s
-
-
-@pytest.fixture
-def doc():
-    """Sanitize docstrings and add custom failure explanation"""
-    return SanitizedString(_sanitize_docstring)
-
-
-def _sanitize_message(thing):
-    s = str(thing)
-    s = _sanitize_general(s)
-    s = _hexadecimal.sub("0", s)
-    return s
-
-
-@pytest.fixture
-def msg():
-    """Sanitize messages and add custom failure explanation"""
-    return SanitizedString(_sanitize_message)
-
-
-# noinspection PyUnusedLocal
-def pytest_assertrepr_compare(op, left, right):
-    """Hook to insert custom failure explanation"""
-    if hasattr(left, "explanation"):
-        return left.explanation
-
-
-@contextlib.contextmanager
-def suppress(exception):
-    """Suppress the desired exception"""
-    try:
-        yield
-    except exception:
-        pass
-
-
-def gc_collect():
-    """Run the garbage collector twice (needed when running
-    reference counting tests with PyPy)"""
-    gc.collect()
-    gc.collect()
+            probs_dict = {}
+            for b in range(np.power(2, self.num_qubits)):
+                b = format(b, f"0{self.num_qubits}b")
+                p = self.eng.backend.get_probability(b, self.qureg)
+                b = b[::-1]
+                probs_dict[b] = p
+
+            return probs_dict
+
+    def get_amps(self, key_basis=None):
+        self.eng.flush()
+
+        if key_basis:
+            amps_dict = {}
+            for b in key_basis:
+                b = b[::-1]
+                p = self.eng.backend.get_amplitude(b, self.qureg)
+                b = b[::-1]
+                amps_dict[b] = p
+            return amps_dict
 
+        else:
+            amp_dict = {}
+            for b in range(np.power(2, self.num_qubits)):
+                b = format(b, f"0{self.num_qubits}b")
+                a = self.eng.backend.get_amplitude(b, self.qureg)
+                b = b[::-1]
+                amp_dict[b] = a
+
+            return amp_dict
+
+    def __del__(self) -> None:
+        self.eng.flush()
+        All(Measure) | self.qureg  # Requirement by ProjectQ...
 
-def pytest_configure():
-    pytest.suppress = suppress
-    pytest.gc_collect = gc_collect
+        with contextlib.suppress(KeyError):
+            self.eng.flush(deallocate_qubits=True)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/cuquantum_wrapper/test/test_python_bindings.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/cuquantum_wrapper/test/test_python_bindings.py`

 * *Files 5% similar despite different names*

```diff
@@ -15,35 +15,34 @@
 import os
 import sys
 import unittest
 
 import numpy as np
 from numpy.testing import assert_array_equal, assert_allclose
 
-sys.path.append('./build/bin') 
-sys.path.append('../build/bin') 
+sys.path.append("./build/bin")
+sys.path.append("../build/bin")
 import cuquantum_wrapper as cq
 
 
 class TestPythonBindings(unittest.TestCase):
-
     def test_bell_state(self):
-        """ Test Bell state """ 
+        """Test Bell state"""
 
         # Create a workspace
         ws = cq.CuStatevecWorkspace()
 
         # Initialize a zero state on th device
         sv = cq.StateVector(2)
         sv.init_on_device()
 
         # Since we initialized on the device, we need to read back to check
         sv.read_from_device()
         v = sv.get()
-        v_expected = np.array( [1, 0, 0, 0], dtype=complex)
+        v_expected = np.array([1, 0, 0, 0], dtype=complex)
         assert_array_equal(v, v_expected)
 
         # Create gates, copy to device, apply to target qubits, and free
         h = cq.Hadamard()
         cnot = cq.CX()
         h.copy_to_device()
         cnot.copy_to_device()
@@ -51,23 +50,23 @@
         cnot.apply(sv, ws, [0], [1], False)
         h.free_on_device()
         cnot.free_on_device()
 
         # Read final state
         sv.read_from_device()
         v = sv.get()
-        S2 = 1/np.sqrt(2)
-        v_expected = np.array( [S2, 0, 0, S2], dtype=complex)
+        S2 = 1 / np.sqrt(2)
+        v_expected = np.array([S2, 0, 0, S2], dtype=complex)
         assert_allclose(v, v_expected)
 
         # Reset back to zero state
         sv.reset(ws)
         sv.read_from_device()
         v = sv.get()
-        v_expected = np.array( [1, 0, 0, 0], dtype=complex)
+        v_expected = np.array([1, 0, 0, 0], dtype=complex)
         assert_array_equal(v, v_expected)
 
     def test_tq_gates(self):
         """Test TQ gates not already tested work."""
         # Create a workspace
         ws = cq.CuStatevecWorkspace()
 
@@ -82,68 +81,68 @@
         sqrtzz.copy_to_device()
         rzz.apply(sv, ws, [0], [1], False)
         sqrtzz.apply(sv, ws, [0], [1], False)
         rzz.free_on_device()
         sqrtzz.free_on_device()
 
     def test_measure_channels(self):
-        """ Test batch measure """ 
+        """Test batch measure"""
         # Create a workspace
         ws = cq.CuStatevecWorkspace()
-        
+
         # Create the input (to be measured) state vector
         v = np.array(
-            [0, 0+0.1j, 0.1+0.1j, 0.1+0.2j, 0.2+0.2j, 0.3+0.3j, 0.3+0.4j, 0.4+0.5j], 
-            dtype=complex)
+            [0, 0 + 0.1j, 0.1 + 0.1j, 0.1 + 0.2j, 0.2 + 0.2j, 0.3 + 0.3j, 0.3 + 0.4j, 0.4 + 0.5j], dtype=complex
+        )
         sv = cq.StateVector(v)
 
         sv.copy_to_device()
 
         # Batch measure the qubits (all of them)
         bit_order = [2, 1, 0]
         randnum = 0.5
         collapse = True
 
-        res = sv.batch_measure(ws, bit_order, randnum, collapse);
+        res = sv.batch_measure(ws, bit_order, randnum, collapse)
 
         sv.read_from_device()
         sv.free_on_device()
 
         # Get the final state as a numpy array
         v = sv.get()
 
         # Expected state vector and results
-        res_expected = [1,1,0]
-        v_expected = np.array( [0, 0, 0, 0, 0, 0, 0.6+0.8j, 0], dtype=complex)
+        res_expected = [1, 1, 0]
+        v_expected = np.array([0, 0, 0, 0, 0, 0, 0.6 + 0.8j, 0], dtype=complex)
 
         # Check
         assert_array_equal(v, v_expected)
         self.assertEqual(res, res_expected)
 
     def test_quantum_volume(self):
-        """ Test quantum volume... not a real test """
+        """Test quantum volume... not a real test"""
 
         num_qubits = 4
 
         # Create the workspace
         ws = cq.CuStatevecWorkspace()
 
         # Initialize the state vector to the zero state on the device
         sv = cq.StateVector(num_qubits)
         sv.init_on_device()
 
         # Create and run the QV sim
         qv = cq.QuantumVolume(num_qubits)
         qv.copy_to_device()
-        qv.apply(sv,ws)
+        qv.apply(sv, ws)
         qv.free_on_device()
 
         # Get probabilities out
         probs = sv.get_probabilities(ws)
 
         # Read the final state and free
         sv.read_from_device()
         sv.free_on_device()
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     unittest.main()
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,10 +1,13 @@
-# Copyright 2022 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
+
+from pecos.simulators.custatevec import bindings
+from pecos.simulators.custatevec.state import CuStateVec
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/bindings.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/bindings.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/gates_init.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/gates_meas.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,22 +6,13 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 import numpy as np
-from .gates_sq import X
 
 
-def init_zero(state, location, **params):
-    result = state.statevec.batch_measure(state.workspace, [location], np.random.uniform(), True)
-
-    if result == [1]:
-        X(state, location)
-
-
-def init_one(state, location, **params):
-    result = state.statevec.batch_measure(state.workspace, [location], np.random.uniform(), True)
-
-    if result == [0]:
-        X(state, location)
+def Measure(state, location, **params):
+    rn = np.random.uniform()
+    meas = state.statevec.batch_measure(state.workspace, [location], rn, True)
+    return meas[0]
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/gates_meas.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cointoss/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,13 @@
-# Copyright 2022 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-import numpy as np
-
-
-def Measure(state, location, **params):
-    rn = np.random.uniform()
-    meas = state.statevec.batch_measure(state.workspace, [location], rn, True)
-    return meas[0]
+from pecos.simulators.cointoss import bindings
+from pecos.simulators.cointoss.state import CoinToss
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/gates_sq.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/gates_sq.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,18 +10,15 @@
 # specific language governing permissions and limitations under the License.
 
 from typing import Tuple, Any
 from numpy import pi
 from ..cuconn import cq
 
 
-def U1q(state,
-        qubit: int,
-        angles: Tuple[float, float],
-        **params: Any) -> None:
+def U1q(state, qubit: int, angles: Tuple[float, float], **params: Any) -> None:
     """
     U1q(theta, phi) = RZ(phi-pi/2)*RY(theta)*RZ(-phi+pi/2)
 
     Args:
         state:
         qubit:
         angles:
@@ -35,115 +32,102 @@
     g = cq.U1q(theta, phi)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [qubit], False)
     g.free_on_device()
 
 
 def RX(state, location, **params):
-
-    angle = params['angle']
+    angle = params["angle"]
     g = cq.Rx(angle)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def RY(state, location, **params):
-
-    angle = params['angle']
+    angle = params["angle"]
     g = cq.Ry(angle)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def RZ(state, location, **params):
-
-    angle = params['angle']
+    angle = params["angle"]
     g = cq.Rz(angle)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def I(state, location, **params):
     pass
 
 
 def X(state, location, **params):
-
     g = cq.PauliX()
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def Y(state, location, **params):
-
     g = cq.PauliY()
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def Z(state, location, **params):
-
     g = cq.PauliZ()
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def H(state, location, **params):
-
     g = cq.Hadamard()
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def Q(state, location, **params):
-
-    g = cq.Rx(pi/2)
+    g = cq.Rx(pi / 2)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def Qd(state, location, **params):
-
-    g = cq.Rx(-pi/2)
+    g = cq.Rx(-pi / 2)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def R(state, location, **params):
-
-    g = cq.Ry(pi/2)
+    g = cq.Ry(pi / 2)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def Rd(state, location, **params):
-
-    g = cq.Ry(-pi/2)
+    g = cq.Ry(-pi / 2)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def S(state, location, **params):
-
-    g = cq.Rz(pi/2)
+    g = cq.Rz(pi / 2)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
 
 
 def Sd(state, location, **params):
-
-    g = cq.Rz(-pi/2)
+    g = cq.Rz(-pi / 2)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], [location], False)
     g.free_on_device()
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/gates_tq.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/gates_tq.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,30 +9,27 @@
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from ..cuconn import cq
 
 
 def CX(state, location, **params):
-
     qc, qt = location
     g = cq.PauliX()
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [qc], [qt], False)
     g.free_on_device()
 
 
 def SqrtZZ(state, location, **params):
-
     g = cq.SqrtZZ()
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], location, False)
     g.free_on_device()
 
 
 def RZZ(state, location, **params):
-
-    angle = params['angle']
+    angle = params["angle"]
     g = cq.RZZ(angle)
     g.copy_to_device()
     g.apply(state.statevec, state.workspace, [], location, False)
     g.free_on_device()
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cuquantum/custatevec/state.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cuquantum_old/custatevec/state.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,26 +7,25 @@
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from . import bindings
 from ..cuconn import cq
+
 try:
     from typing import Self
 except:
     from typing_extensions import Self
 
 
 class CuStateVec:
-
     def __init__(self, num_qubits: int) -> None:
-
         if not isinstance(num_qubits, int):
-            raise Exception('``num_qubits`` should be of type ``int.``')
+            raise Exception("``num_qubits`` should be of type ``int.``")
 
         self.num_qubits = num_qubits
         self.workspace = cq.CuStatevecWorkspace()
         self.statevec = cq.StateVector(num_qubits)
         self.statevec.init_on_device()
         self.workspace_gates = []
 
@@ -41,15 +40,14 @@
         """Reset the quantum state for another run without reinitializing."""
         self.statevec.free_on_device()
         self.statevec.init_on_device()
 
         return self
 
     def __del__(self):
-
         wqs = list(self.workspace_gates)
         for g in wqs:
             g.free_on_device()
             self.workspace_gates.remove(g)
 
         self.statevec.free_on_device()
         del self.statevec
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,8 +7,8 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .cysparsesim import SparseSim
+from pecos.simulators.cysparsesim.cysparsesim import SparseSim
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/setup.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/setup.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,66 +7,65 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Setup
-=====
+"""Setup
+=====.
 
 The setup file for the Cython wrapped C++ version of SparseSim.
 
 Notes:
+-----
     Use the following to compile from command line:
     python setup.py build_ext --inplace
+
 """
-# import numpy as np
-import os
+import contextlib
 import shutil
 from distutils.core import setup
 from distutils.extension import Extension
+from pathlib import Path
+
 from Cython.Build import cythonize
 
 # Delete previous build folder
-current_location = os.path.dirname(os.path.abspath(__file__))
-try:
-    shutil.rmtree(os.path.join(current_location, 'build'))
-except FileNotFoundError:
-    pass
+current_location = Path.parent(Path.resolve(__file__))
+with contextlib.suppress(FileNotFoundError):
+    shutil.rmtree(Path(current_location / "build"))
 
 # compiler_flags = ["-std=c++11", "-Wall", "-fPIC", "-O2", "-O3", "-c", ]
-compiler_flags = ["-std=c++11", "-W3", "-fPIC", "-O2", "-O3", "-c", ]
+compiler_flags = ["-std=c++11", "-W3", "-fPIC", "-O2", "-O3", "-c"]
 
 ext_modules = [
-    Extension('cysparsesim',
-              sources=[
-                  "src/cysparsesim.pyx",
-                  "src/sparsesim.cpp",
-                  "src/logical_sign.py",
-              ],
-              language='c++',
-              extra_compile_args=compiler_flags,
-              include_dirs=['./src'],
-              # include_dirs=[np.get_include()],
-              ),
+    Extension(
+        "cysparsesim",
+        sources=[
+            "src/cysparsesim.pyx",
+            "src/sparsesim.cpp",
+            "src/logical_sign.py",
+        ],
+        language="c++",
+        extra_compile_args=compiler_flags,
+        include_dirs=["./src"],
+        # include_dirs=[np.get_include()],
+    ),
 ]
 
 
 for e in ext_modules:
     e.cython_directives = {
-        'boundscheck': False,
-        'wraparound': False,
+        "boundscheck": False,
+        "wraparound": False,
     }
 
 
 setup(
     name="state",
     ext_modules=cythonize(ext_modules, build_dir="build", language_level=3),
-    script_args=['build_ext'],
+    script_args=["build_ext"],
     options={
-        'build_ext': {'inplace': True},
-    }
-
+        "build_ext": {"inplace": True},
+    },
 )
-
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/src/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/src/__init__.py`

 * *Files identical despite different names*

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim/src/logical_sign.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim/src/logical_sign.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,84 +7,84 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Functions:
+"""Functions:
 
 find_logical_signs
 logical_flip
 """
 
 
 def find_logical_signs(state, logical_circuit, delogical_circuit=None):
-    """
-    Find the sign of the logical operator.
+    """Find the sign of the logical operator.
 
     Args:
+    ----
         state:
         logical_circuit (QuantumCircuit):
         delogical_circuit (QuantumCircuit):
 
     Returns:
+    -------
 
     """
     if len(logical_circuit) != 1:
-        raise Exception('Logical operators are expected to only have one tick.')
+        msg = "Logical operators are expected to only have one tick."
+        raise Exception(msg)
 
     stabs = state.stabs
     destabs = state.destabs
 
-    logical_xs = set([])
-    logical_zs = set([])
+    logical_xs = set()
+    logical_zs = set()
 
     for symbol, gate_locations, _ in logical_circuit.items():
-
-        if symbol == 'X':
+        if symbol == "X":
             logical_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             logical_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             logical_xs.update(gate_locations)
             logical_zs.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
     if delogical_circuit:  # Check the relationship between logical operator and delogical operator.
-
         if len(delogical_circuit) != 1:
-            raise Exception('Delogical operators are expected to only have one tick.')
+            msg = "Delogical operators are expected to only have one tick."
+            raise Exception(msg)
 
-        delogical_xs = set([])
-        delogical_zs = set([])
+        delogical_xs = set()
+        delogical_zs = set()
 
         for symbol, gate_locations, _ in delogical_circuit.items():
-
-            if symbol == 'X':
+            if symbol == "X":
                 delogical_xs.update(gate_locations)
-            elif symbol == 'Z':
+            elif symbol == "Z":
                 delogical_zs.update(gate_locations)
-            elif symbol == 'Y':
+            elif symbol == "Y":
                 delogical_xs.update(gate_locations)
                 delogical_zs.update(gate_locations)
             else:
                 raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
         # Make sure the logical and delogical anti-commute
 
         anticom_x = len(logical_xs & delogical_zs) % 2  # Number of common elements modulo 2
         anticom_z = len(logical_zs & delogical_xs) % 2  # Number of common elements modulo 2
 
         if not ((anticom_x + anticom_z) % 2):
-            print('logical Xs: %s logical Zs: %s' % (logical_xs, logical_zs))
-            print('delogical Xs: %s delogical Zs: %s' % (delogical_xs, delogical_zs))
-            raise Exception("Logical and delogical operators supplied do not anti-commute!")
+            print(f"logical Xs: {logical_xs} logical Zs: {logical_zs}")
+            print(f"delogical Xs: {delogical_xs} delogical Zs: {delogical_zs}")
+            msg = "Logical and delogical operators supplied do not anti-commute!"
+            raise Exception(msg)
 
     # We want the supplied logical operator to be in the stabilizer group and
     #  the supplied delogical to not be in the stabilizers (we want it to end up being the logical op's destabilizer)
 
     # The following two function calls are wasteful because we will need some of what they discover... such as all the
     #  stabilizers that have destabilizers that anti-commute with the logical operator...
     #  But it is assumed that the user is not calling this function that often... so we can be wasteful...
@@ -92,41 +92,40 @@
     # Check logical is a stabilizer (we want to remove it from the stabilizers)
 
     # Find the anti-commuting destabilizers => stabilizers to give the logical operator
     # --------------------------
     build_stabs = set()
 
     for q in logical_xs:  # For qubits that have Xs in for the logical operator...
-        build_stabs ^= destabs['col_z'][q]  # Add in stabilizers that anti-commute for the logical operator's Xs
+        build_stabs ^= destabs["col_z"][q]  # Add in stabilizers that anti-commute for the logical operator's Xs
 
     for q in logical_zs:
-        build_stabs ^= destabs['col_x'][q]  # Add in stabilizers that anti-commute for the logical operator's Zs
+        build_stabs ^= destabs["col_x"][q]  # Add in stabilizers that anti-commute for the logical operator's Zs
 
     # If a stabilizer anticommutes an even number of times for the X and/or Z Paulis... it will not appear due to ^=
 
     # Confirm that the stabilizers chosen give the logical operator. If not... return with a failure = 1
     # --------------------------
     test_x = set()
     test_z = set()
 
     for stab in build_stabs:
-        test_x ^= stabs['row_x'][stab]
-        test_z ^= stabs['row_z'][stab]
+        test_x ^= stabs["row_x"][stab]
+        test_z ^= stabs["row_z"][stab]
 
     # Compare with logical operator
     test_x ^= logical_xs
     test_z ^= logical_zs
 
     if len(test_x) != 0 or len(test_z) != 0:
         # for stab in build_stabs:
-        #    print('stab ... ', stab)
 
-        print(('Logical op: xs - %s and zs - %s' % (logical_xs, logical_zs)))
-        raise Exception('Failure due to not finding logical op! x... %s z... %s' %
-                        (str(test_x ^ logical_xs), str(test_z ^ logical_zs)))
+        print(f"Logical op: xs - {logical_xs} and zs - {logical_zs}")
+        msg = f"Failure due to not finding logical op! x... {str(test_x ^ logical_xs)} z... {str(test_z ^ logical_zs)}"
+        raise Exception(msg)
 
     # Get the sign of the logical operator
     # --------------------------
 
     # First, the minus sign
     logical_minus = len(build_stabs & stabs.signs_minus)
 
@@ -153,11 +152,11 @@
         logical_i = 0
         logical_minus += 1
     elif logical_i == 3:  # num_is %4 = 3 => -i => logical_i = 1, logical_minus += 1
         logical_i = 1
         logical_minus += 1
 
     if logical_i != 0:
-        raise Exception('Logical operator has an imaginary sign... Not allowed if logical state is stabilized '
-                        'by logical op!')
+        msg = "Logical operator has an imaginary sign... Not allowed if logical state is stabilized by logical op!"
+        raise Exception(msg)
 
     return logical_minus
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_col/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuit_converters/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,17 @@
-# Copyright 2018 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from .cysparsesim import State
+"""This name space contains classes and functions for converting circuit data-structures into other circuit
+data-structures.
+"""
+
+from pecos.circuit_converters.std2chs import std2chs
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_col/setup.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/setup.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,56 +7,55 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Setup
-=====
+"""Setup
+=====.
 
 The setup file for the Cython wrapped C++ version of SparseSim.
 
 Notes:
+-----
     Use the following to compile from command line:
     python setup.py build_ext --inplace
+
 """
-# import numpy as np
-import os
+import contextlib
 import shutil
 from distutils.core import setup
 from distutils.extension import Extension
+from pathlib import Path
+
 from Cython.Build import cythonize
 
 # Delete previous build folder
-current_location = os.path.dirname(os.path.abspath(__file__))
-try:
-    shutil.rmtree(os.path.join(current_location, 'build'))
-except FileNotFoundError:
-    pass
+current_location = Path.parent(Path.resolve(__file__))
+with contextlib.suppress(FileNotFoundError):
+    shutil.rmtree(Path(current_location / "build"))
 
-compiler_flags = ["-std=c++11", "-Wall", "-fPIC", "-O2", "-O3", "-c", ]
+compiler_flags = ["-std=c++11", "-Wall", "-fPIC", "-O2", "-O3", "-c"]
 
 ext_modules = [
-    Extension('cysparsesim',
-              sources=["src/cysparsesim.pyx", "src/sparsesim.cpp"],
-              language='c++',
-              extra_compile_args=compiler_flags,
-              include_dirs=['./src'],
-              # include_dirs=[np.get_include()],
-              ),
+    Extension(
+        "cysparsesim",
+        sources=["src/cysparsesim.pyx", "src/sparsesim.cpp"],
+        language="c++",
+        extra_compile_args=compiler_flags,
+        include_dirs=["./src"],
+        # include_dirs=[np.get_include()],
+    ),
 ]
 
 
 for e in ext_modules:
-    e.cython_directives = {'boundscheck': False, 'wraparound': False}
+    e.cython_directives = {"boundscheck": False, "wraparound": False}
 
 
 setup(
     name="state",
     ext_modules=cythonize(ext_modules, build_dir="build"),
-    script_args=['build_ext'],
-    options={'build_ext': {'inplace': True}}
-
+    script_args=["build_ext"],
+    options={"build_ext": {"inplace": True}},
 )
-
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_col/src/logical_sign.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/src/logical_sign.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,82 +7,81 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Functions:
+"""Functions:
 
 find_logical_signs
 logical_flip
 """
 
 
 def find_logical_signs(state, logical_circuit, delogical_circuit):
-    """
-    Find the sign of the logical operator.
+    """Find the sign of the logical operator.
 
     Args:
+    ----
         state:
         logical_circuit:
         delogical_circuit:
 
     Returns:
+    -------
 
     """
-
     if len(logical_circuit) != 1 or len(delogical_circuit) != 1:
-        raise Exception('Logical operators are expected to only have one tick.')
+        msg = "Logical operators are expected to only have one tick."
+        raise Exception(msg)
 
     stabs = state.stabs
     destabs = state.destabs
     signs_minus = state.signs_minus
     signs_i = state.signs_i
 
-    logical_xs = set([])
-    logical_zs = set([])
+    logical_xs = set()
+    logical_zs = set()
 
-    delogical_xs = set([])
-    delogical_zs = set([])
+    delogical_xs = set()
+    delogical_zs = set()
 
     for symbol, gate_locations in logical_circuit.items(params=False):
-
-        if symbol == 'X':
+        if symbol == "X":
             logical_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             logical_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             logical_xs.update(gate_locations)
             logical_zs.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
     for symbol, gate_locations in delogical_circuit.items(params=False):
-
-        if symbol == 'X':
+        if symbol == "X":
             delogical_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             delogical_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             delogical_xs.update(gate_locations)
             delogical_zs.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
     # Make sure the logical and delogical anti-commute
 
     anticom_x = len(logical_xs & delogical_zs) % 2  # Number of common elements modulo 2
     anticom_z = len(logical_zs & delogical_xs) % 2  # Number of common elements modulo 2
 
     if not ((anticom_x + anticom_z) % 2):
-        print('logical Xs: %s logical Zs: %s' % (logical_xs, logical_zs))
-        print('delogical Xs: %s delogical Zs: %s' % (delogical_xs, delogical_zs))
-        raise Exception("Logical and delogical operators supplied do not anti-commute!")
+        print(f"logical Xs: {logical_xs} logical Zs: {logical_zs}")
+        print(f"delogical Xs: {delogical_xs} delogical Zs: {delogical_zs}")
+        msg = "Logical and delogical operators supplied do not anti-commute!"
+        raise Exception(msg)
 
     # We want the supplied logical operator to be in the stabilizer group and
     #  the supplied delogical to not be in the stabilizers (we want it to end up being the logical op's destabilizer)
 
     # The following two function calls are wasteful because we will need some of what they discover... such as all the
     #  stabilizers that have destabilizers that anti-commute with the logical operator...
     #  But it is assumed that the user is not calling this function that often... so we can be wasteful...
@@ -90,41 +89,40 @@
     # Check logical is a stabilizer (we want to remove it from the stabilizers)
 
     # Find the anti-commuting destabilizers => stabilizers to give the logical operator
     # --------------------------
     build_stabs = set()
 
     for q in logical_xs:  # For qubits that have Xs in for the logical operator...
-        build_stabs ^= destabs['col_z'][q]  # Add in stabilizers that anti-commute for the logical operator's Xs
+        build_stabs ^= destabs["col_z"][q]  # Add in stabilizers that anti-commute for the logical operator's Xs
 
     for q in logical_zs:
-        build_stabs ^= destabs['col_x'][q]  # Add in stabilizers that anti-commute for the logical operator's Zs
+        build_stabs ^= destabs["col_x"][q]  # Add in stabilizers that anti-commute for the logical operator's Zs
 
     # If a stabilizer anticommutes an even number of times for the X and/or Z Paulis... it will not appear due to ^=
 
     # Confirm that the stabilizers chosen give the logical operator. If not... return with a failure = 1
     # --------------------------
     test_x = set()
     test_z = set()
 
     for stab in build_stabs:
-        test_x ^= stabs['row_x'][stab]
-        test_z ^= stabs['row_z'][stab]
+        test_x ^= stabs["row_x"][stab]
+        test_z ^= stabs["row_z"][stab]
 
     # Compare with logical operator
     test_x ^= logical_xs
     test_z ^= logical_zs
 
     if len(test_x) != 0 or len(test_z) != 0:
         # for stab in build_stabs:
-        #    print('stab ... ', stab)
 
-        print(('Logical op: xs - %s and zs - %s' % (logical_xs, logical_zs)))
-        raise Exception('Failure due to not finding logical op! x... %s z... %s' %
-                        (str(test_x ^ logical_xs), str(test_z ^ logical_zs)))
+        print(f"Logical op: xs - {logical_xs} and zs - {logical_zs}")
+        msg = f"Failure due to not finding logical op! x... {str(test_x ^ logical_xs)} z... {str(test_z ^ logical_zs)}"
+        raise Exception(msg)
 
     # Get the sign of the logical operator
     # --------------------------
 
     # First, the minus sign
     logical_minus = len(build_stabs & signs_minus)
 
@@ -151,14 +149,11 @@
         logical_i = 0
         logical_minus += 1
     elif logical_i == 3:  # num_is %4 = 3 => -i => logical_i = 1, logical_minus += 1
         logical_i = 1
         logical_minus += 1
 
     if logical_i != 0:
-        raise Exception('Logical operator has an imaginary sign... Not allowed if logical state is stabilized '
-                        'by logical op!')
+        msg = "Logical operator has an imaginary sign... Not allowed if logical state is stabilized by logical op!"
+        raise Exception(msg)
 
     return logical_minus
-
-
-
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_row/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_col/src/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,14 +1,11 @@
-# Copyright 2018 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
-
-from .cysparsesim import State
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_row/setup.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/setup.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,56 +7,55 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Setup
-=====
+"""Setup
+=====.
 
 The setup file for the Cython wrapped C++ version of SparseSim.
 
 Notes:
+-----
     Use the following to compile from command line:
     python setup.py build_ext --inplace
+
 """
-# import numpy as np
-import os
+import contextlib
 import shutil
 from distutils.core import setup
 from distutils.extension import Extension
+from pathlib import Path
+
 from Cython.Build import cythonize
 
 # Delete previous build folder
-current_location = os.path.dirname(os.path.abspath(__file__))
-try:
-    shutil.rmtree(os.path.join(current_location, 'build'))
-except FileNotFoundError:
-    pass
+current_location = Path.parent(Path.resolve(__file__))
+with contextlib.suppress(FileNotFoundError):
+    shutil.rmtree(Path(current_location / "build"))
 
-compiler_flags = ["-std=c++11", "-Wall", "-fPIC", "-O2", "-O3", "-c", ]
+compiler_flags = ["-std=c++11", "-Wall", "-fPIC", "-O2", "-O3", "-c"]
 
 ext_modules = [
-    Extension('cysparsesim',
-              sources=["src/cysparsesim.pyx", "src/sparsesim.cpp"],
-              language='c++',
-              extra_compile_args=compiler_flags,
-              include_dirs=['./src'],
-              # include_dirs=[np.get_include()],
-              ),
+    Extension(
+        "cysparsesim",
+        sources=["src/cysparsesim.pyx", "src/sparsesim.cpp"],
+        language="c++",
+        extra_compile_args=compiler_flags,
+        include_dirs=["./src"],
+        # include_dirs=[np.get_include()],
+    ),
 ]
 
 
 for e in ext_modules:
-    e.cython_directives = {'boundscheck': False, 'wraparound': False}
+    e.cython_directives = {"boundscheck": False, "wraparound": False}
 
 
 setup(
     name="state",
     ext_modules=cythonize(ext_modules, build_dir="build"),
-    script_args=['build_ext'],
-    options={'build_ext': {'inplace': True}}
-
+    script_args=["build_ext"],
+    options={"build_ext": {"inplace": True}},
 )
-
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/cysparsesim_row/src/logical_sign.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/cysparsesim_row/src/logical_sign.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,82 +7,81 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Functions:
+"""Functions:
 
 find_logical_signs
 logical_flip
 """
 
 
 def find_logical_signs(state, logical_circuit, delogical_circuit):
-    """
-    Find the sign of the logical operator.
+    """Find the sign of the logical operator.
 
     Args:
+    ----
         state:
         logical_circuit:
         delogical_circuit:
 
     Returns:
+    -------
 
     """
-
     if len(logical_circuit) != 1 or len(delogical_circuit) != 1:
-        raise Exception('Logical operators are expected to only have one tick.')
+        msg = "Logical operators are expected to only have one tick."
+        raise Exception(msg)
 
     stabs = state.stabs
     destabs = state.destabs
     signs_minus = state.signs_minus
     signs_i = state.signs_i
 
-    logical_xs = set([])
-    logical_zs = set([])
+    logical_xs = set()
+    logical_zs = set()
 
-    delogical_xs = set([])
-    delogical_zs = set([])
+    delogical_xs = set()
+    delogical_zs = set()
 
     for symbol, gate_locations in logical_circuit.items(params=False):
-
-        if symbol == 'X':
+        if symbol == "X":
             logical_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             logical_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             logical_xs.update(gate_locations)
             logical_zs.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
     for symbol, gate_locations in delogical_circuit.items(params=False):
-
-        if symbol == 'X':
+        if symbol == "X":
             delogical_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             delogical_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             delogical_xs.update(gate_locations)
             delogical_zs.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
     # Make sure the logical and delogical anti-commute
 
     anticom_x = len(logical_xs & delogical_zs) % 2  # Number of common elements modulo 2
     anticom_z = len(logical_zs & delogical_xs) % 2  # Number of common elements modulo 2
 
     if not ((anticom_x + anticom_z) % 2):
-        print('logical Xs: %s logical Zs: %s' % (logical_xs, logical_zs))
-        print('delogical Xs: %s delogical Zs: %s' % (delogical_xs, delogical_zs))
-        raise Exception("Logical and delogical operators supplied do not anti-commute!")
+        print(f"logical Xs: {logical_xs} logical Zs: {logical_zs}")
+        print(f"delogical Xs: {delogical_xs} delogical Zs: {delogical_zs}")
+        msg = "Logical and delogical operators supplied do not anti-commute!"
+        raise Exception(msg)
 
     # We want the supplied logical operator to be in the stabilizer group and
     #  the supplied delogical to not be in the stabilizers (we want it to end up being the logical op's destabilizer)
 
     # The following two function calls are wasteful because we will need some of what they discover... such as all the
     #  stabilizers that have destabilizers that anti-commute with the logical operator...
     #  But it is assumed that the user is not calling this function that often... so we can be wasteful...
@@ -90,41 +89,40 @@
     # Check logical is a stabilizer (we want to remove it from the stabilizers)
 
     # Find the anti-commuting destabilizers => stabilizers to give the logical operator
     # --------------------------
     build_stabs = set()
 
     for q in logical_xs:  # For qubits that have Xs in for the logical operator...
-        build_stabs ^= destabs['col_z'][q]  # Add in stabilizers that anti-commute for the logical operator's Xs
+        build_stabs ^= destabs["col_z"][q]  # Add in stabilizers that anti-commute for the logical operator's Xs
 
     for q in logical_zs:
-        build_stabs ^= destabs['col_x'][q]  # Add in stabilizers that anti-commute for the logical operator's Zs
+        build_stabs ^= destabs["col_x"][q]  # Add in stabilizers that anti-commute for the logical operator's Zs
 
     # If a stabilizer anticommutes an even number of times for the X and/or Z Paulis... it will not appear due to ^=
 
     # Confirm that the stabilizers chosen give the logical operator. If not... return with a failure = 1
     # --------------------------
     test_x = set()
     test_z = set()
 
     for stab in build_stabs:
-        test_x ^= stabs['row_x'][stab]
-        test_z ^= stabs['row_z'][stab]
+        test_x ^= stabs["row_x"][stab]
+        test_z ^= stabs["row_z"][stab]
 
     # Compare with logical operator
     test_x ^= logical_xs
     test_z ^= logical_zs
 
     if len(test_x) != 0 or len(test_z) != 0:
         # for stab in build_stabs:
-        #    print('stab ... ', stab)
 
-        print(('Logical op: xs - %s and zs - %s' % (logical_xs, logical_zs)))
-        raise Exception('Failure due to not finding logical op! x... %s z... %s' %
-                        (str(test_x ^ logical_xs), str(test_z ^ logical_zs)))
+        print(f"Logical op: xs - {logical_xs} and zs - {logical_zs}")
+        msg = f"Failure due to not finding logical op! x... {str(test_x ^ logical_xs)} z... {str(test_z ^ logical_zs)}"
+        raise Exception(msg)
 
     # Get the sign of the logical operator
     # --------------------------
 
     # First, the minus sign
     logical_minus = len(build_stabs & signs_minus)
 
@@ -151,14 +149,11 @@
         logical_i = 0
         logical_minus += 1
     elif logical_i == 3:  # num_is %4 = 3 => -i => logical_i = 1, logical_minus += 1
         logical_i = 1
         logical_minus += 1
 
     if logical_i != 0:
-        raise Exception('Logical operator has an imaginary sign... Not allowed if logical state is stabilized '
-                        'by logical op!')
+        msg = "Logical operator has an imaginary sign... Not allowed if logical state is stabilized by logical op!"
+        raise Exception(msg)
 
     return logical_minus
-
-
-
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/parent_sim_classes.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/parent_sim_classes.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,79 +1,70 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Any, Union, Tuple, Set
+from __future__ import annotations
 
+from typing import Any
 
-class Simulator(object):
-    """
-    A parent class to provide standard methods for simulators.
-    """
 
-    def __init__(self):
-        self.bindings = {}
+class Simulator:
+    """A parent class to provide standard methods for simulators."""
 
-    def run_gate(self,
-                 symbol: str,
-                 locations: Union[Set[int], Set[Tuple[int, ...]]],
-                 **params: Any):
-        """
+    def __init__(self) -> None:
+        self.bindings = {}
 
-        Args:
+    def run_gate(self, symbol: str, locations: set[int] | set[tuple[int, ...]], **params: Any):
+        """Args:
+        ----
             symbol:
             locations:
             **params:
 
         Returns:
+        -------
 
         """
-
         output = {}
 
-        if params.get('simulate_gate', True):
-
+        if params.get("simulate_gate", True) and locations:
             for location in locations:
+                if params.get("angles") and len(params["angles"]) == 1:
+                    params.update({"angle": params["angles"][0]})
                 results = self.bindings[symbol](self, location, **params)
 
                 # TODO: get params var value ... -> result = {'sym':, 'index':, 'result': result, 'qubit': location}
 
                 if results:
                     output[location] = results
 
         return output
 
-    def run_circuit(self,
-                    circuit,
-                    removed_locations=None):
-        """
-
-        Args:
+    def run_circuit(self, circuit, removed_locations=None):
+        """Args:
+        ----
             circuit (QuantumCircuit): A circuit instance or object with an appropriate items() generator.
             removed_locations:
 
         Returns (list): If output is True then the circuit output is returned. Note that this output format may differ
         from what a ``circuit_runner`` will return for the same method named ``run_circuit``.
 
         """
-
         # TODO: removed_locations doesn't make sense except if circuit is tick_circuit
         # because can't say not to do gates for particular ticks....
 
         if removed_locations is None:
-            removed_locations = set([])
+            removed_locations = set()
 
         results = {}
         for symbol, locations, params in circuit.items():
             gate_results = self.run_gate(symbol, locations - removed_locations, **params)
             results.update(gate_results)
 
         return results
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from . import bindings
-
-from .state import PauliFaultProp
+from pecos.simulators.paulifaultprop import bindings
+from pecos.simulators.paulifaultprop.state import PauliFaultProp
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/bindings.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/bindings.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,93 +1,79 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Specifies the symbol and function for each gate
-"""
-from . import gates_init, gates_one_qubit, gates_two_qubit, gates_meas
+"""Specifies the symbol and function for each gate."""
+from pecos.simulators.paulifaultprop import gates_init, gates_meas, gates_one_qubit, gates_two_qubit
 
 gate_dict = {
     # Initialization
     # ==============
     # just removes errors:
-    'init |0>': gates_init.init,
-    'init |1>': gates_init.init,
-    'init |+>': gates_init.init,
-    'init |->': gates_init.init,
-    'init |+i>': gates_init.init,
-    'init |-i>': gates_init.init,
-
+    "init |0>": gates_init.init,
+    "init |1>": gates_init.init,
+    "init |+>": gates_init.init,
+    "init |->": gates_init.init,
+    "init |+i>": gates_init.init,
+    "init |-i>": gates_init.init,
     # One-qubit Cliffords
     # ===================
-
     # Paulis
-    'I': gates_one_qubit.I,
-    'X': gates_one_qubit.X,
-    'Y': gates_one_qubit.Y,
-    'Z': gates_one_qubit.Z,
-
+    "I": gates_one_qubit.Identity,
+    "X": gates_one_qubit.X,
+    "Y": gates_one_qubit.Y,
+    "Z": gates_one_qubit.Z,
     # Square root of Paulis
-    'SX': gates_one_qubit.SX,
-    'SXdg': gates_one_qubit.SXdg,
-    'SY': gates_one_qubit.SY,
-    'SYdg': gates_one_qubit.SYdg,
-    'SZ': gates_one_qubit.SZ,
-    'SZdg': gates_one_qubit.SZdg,
-
+    "SX": gates_one_qubit.SX,
+    "SXdg": gates_one_qubit.SXdg,
+    "SY": gates_one_qubit.SY,
+    "SYdg": gates_one_qubit.SYdg,
+    "SZ": gates_one_qubit.SZ,
+    "SZdg": gates_one_qubit.SZdg,
     # Hadamard-like
-    'H': gates_one_qubit.H,
-    'H2': gates_one_qubit.H2,
-    'H3': gates_one_qubit.H3,
-    'H4': gates_one_qubit.H4,
-    'H5': gates_one_qubit.H5,
-    'H6': gates_one_qubit.H6,
-
+    "H": gates_one_qubit.H,
+    "H2": gates_one_qubit.H2,
+    "H3": gates_one_qubit.H3,
+    "H4": gates_one_qubit.H4,
+    "H5": gates_one_qubit.H5,
+    "H6": gates_one_qubit.H6,
     # Face rotations
-    'F': gates_one_qubit.F,    # +y+x
-    'Fdg': gates_one_qubit.Fdg,  # +z+y
-    'F2': gates_one_qubit.F2,    # -z+y
-    'F2dg': gates_one_qubit.F2dg,  # -y-x
-    'F3': gates_one_qubit.F3,    # +y-x
-    'F3dg': gates_one_qubit.F3dg,  # -z-y
-    'F4': gates_one_qubit.F4,    # +z-y
-    'F4dg': gates_one_qubit.F4dg,  # -y-z
-
+    "F": gates_one_qubit.F,  # +y+x
+    "Fdg": gates_one_qubit.Fdg,  # +z+y
+    "F2": gates_one_qubit.F2,  # -z+y
+    "F2dg": gates_one_qubit.F2dg,  # -y-x
+    "F3": gates_one_qubit.F3,  # +y-x
+    "F3dg": gates_one_qubit.F3dg,  # -z-y
+    "F4": gates_one_qubit.F4,  # +z-y
+    "F4dg": gates_one_qubit.F4dg,  # -y-z
     # Two-qubit operations
     # ====================
-    'CX': gates_two_qubit.CX,
-    'CZ': gates_two_qubit.CZ,
-    'CY': gates_two_qubit.CY,
-    'SWAP': gates_two_qubit.SWAP,
-    'G': gates_two_qubit.G2,
-    'G2': gates_two_qubit.G2,
-    'II': gates_two_qubit.II,
-
-    # MlmerSrensen gates
-    'SqrtXX': gates_two_qubit.SXX,  # \equiv e^{+i (\pi /4)} * e^{-i (\pi /4) XX } == R(XX, pi/2)
-    'SqrtZZ': gates_two_qubit.SZZ,
-    'MS': gates_two_qubit.SXX,
-    'MSXX': gates_two_qubit.SXX,
-
+    "CX": gates_two_qubit.CX,
+    "CZ": gates_two_qubit.CZ,
+    "CY": gates_two_qubit.CY,
+    "SWAP": gates_two_qubit.SWAP,
+    "G": gates_two_qubit.G2,
+    "G2": gates_two_qubit.G2,
+    "II": gates_two_qubit.II,
+    # Mlmer-Srensen gates
+    "SqrtXX": gates_two_qubit.SXX,  # \equiv e^{+i (\pi /4)} * e^{-i (\pi /4) XX } == R(XX, pi/2)
+    "SqrtZZ": gates_two_qubit.SZZ,
+    "MS": gates_two_qubit.SXX,
+    "MSXX": gates_two_qubit.SXX,
     # Measurements
     # ============
-    'measure X': gates_meas.meas_x,
-    'measure Y': gates_meas.meas_y,
-    'measure Z': gates_meas.meas_z,
-
+    "measure X": gates_meas.meas_x,
+    "measure Y": gates_meas.meas_y,
+    "measure Z": gates_meas.meas_z,
     # Measure general operators (here... just some Pauli)
-    'measure': gates_meas.meas_pauli,
-    'check': gates_meas.meas_pauli,  # TODO: all simulators should have this... and should measure as general as possible
-
-    'force output': gates_meas.force_output,
-
+    "measure": gates_meas.meas_pauli,
+    "check": gates_meas.meas_pauli,
+    # TODO: all simulators should have this... and should measure as general as possible
+    "force output": gates_meas.force_output,
 }
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/gates_init.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/custatevec/gates_init.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,31 +1,28 @@
-# -*- coding: utf-8 -*-
-
-# Copyright 2018 The PECOS Developers
+# Copyright 2023 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from typing import Any
 
-def init(state,
-         qubit: int,
-         **params: Any) -> None:
-    """
+from pecos.simulators.custatevec.gates_meas import meas_z
+from pecos.simulators.custatevec.gates_one_qubit import X
 
-    Args:
-        state:
-        qubit:
 
-    Returns:
+def init_zero(state, qubit: int, **params: Any) -> None:
+    """Initialise or reset the qubit to state |0>
 
+    Args:
+        state: An instance of CuStateVec
+        qubit: The index of the qubit to be initialised
     """
+    result = meas_z(state, qubit)
 
-    state.faults['X'].discard(qubit)
-    state.faults['Y'].discard(qubit)
-    state.faults['Z'].discard(qubit)
+    if result:
+        X(state, qubit)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/gates_meas.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/gates_meas.py`

 * *Files 13% similar despite different names*

```diff
@@ -5,122 +5,118 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Any, Union, Tuple
+from __future__ import annotations
 
+from typing import Any
 
-def meas_x(state,
-           qubit: int,
-           **params: Any) -> int:
-    """
-    Measurement in the X basis.
+
+def meas_x(state, qubit: int, **params: Any) -> int:
+    """Measurement in the X basis.
 
     Args:
+    ----
         state:
         qubit:
         **params:
 
     Returns:
+    -------
 
     """
-
-    if qubit in state.faults['Z'] or qubit in state.faults['Y']:
+    if qubit in state.faults["Z"] or qubit in state.faults["Y"]:
         return 1
     else:
         return 0
 
 
-def meas_z(state,
-           qubit: int,
-           **params: Any) -> int:
-    """
-    Measurement in the Z basis.
+def meas_z(state, qubit: int, **params: Any) -> int:
+    """Measurement in the Z basis.
 
     Args:
+    ----
         state:
         qubit:
         **params:
 
     Returns:
+    -------
 
     """
-
-    if qubit in state.faults['X'] or qubit in state.faults['Y']:
+    if qubit in state.faults["X"] or qubit in state.faults["Y"]:
         return 1
     else:
         return 0
 
 
-def meas_y(state,
-           qubit: int,
-           **params: Any):
-    """
-    Measurement in the Y basis.
+def meas_y(state, qubit: int, **params: Any):
+    """Measurement in the Y basis.
 
     Args:
+    ----
         state:
         qubit:
         **params:
 
     Returns:
+    -------
 
     """
-    if qubit in state.faults['X'] or qubit in state.faults['Z']:
+    if qubit in state.faults["X"] or qubit in state.faults["Z"]:
         return 1
     else:
         return 0
 
 
-def meas_pauli(state,
-               qubits: Union[int, Tuple[int, ...]],
-               **params: Any) -> int:
+def meas_pauli(state, qubits: int | tuple[int, ...], **params: Any) -> int:
+    pauli = params["Pauli"]
 
-    pauli = params['Pauli']
+    if isinstance(qubits, int) and pauli not in ["X", "Y", "Z"]:
+        msg = "Pauli for a single qubit measurement must be 'X', 'Y' or 'Z'!"
+        raise Exception(msg)
 
-    if isinstance(qubits, int) and pauli not in ['X', 'Y', 'Z']:
-        raise Exception('Pauli for a single qubit measurement must be \'X\', \'Y\' or \'Z\'!')
-
-    if pauli in ['X', 'Y', 'Z']:
+    if pauli in ["X", "Y", "Z"]:
         pauli = pauli * len(qubits)
     else:
         if len(pauli) == len(qubits) + 1:
             # last qubit is considered the syndrome ancilla
             qubits = qubits[:-1]
         elif len(pauli) != len(qubits):
-            raise Exception('The Pauli operator needs to be the size of the qubits it is acting on or a single type.')
+            msg = "The Pauli operator needs to be the size of the qubits it is acting on or a single type."
+            raise Exception(msg)
 
     meas = 0
 
     for q, p in zip(qubits, pauli):
-        if p == 'X':
+        if p == "X":
             meas += meas_x(state, q)
-        elif p == 'Z':
+        elif p == "Z":
             meas += meas_z(state, q)
-        elif p == 'Y':
+        elif p == "Y":
             meas += meas_y(state, q)
         else:
-            raise Exception('Pauli symbol not supported!')
+            msg = "Pauli symbol not supported!"
+            raise Exception(msg)
 
     return meas % 2
 
 
-def force_output(state,
-                 qubit: int,
-                 forced_output: int = -1) -> int:
-    """
-    Outputs value.
+def force_output(state, qubit: int, forced_output: int = -1) -> int:
+    """Outputs value.
 
     Used for error generators to generate outputs when replacing measurements.
 
     Args:
+    ----
         state:
         qubit:
         forced_output:
 
     Returns:
+    -------
 
     """
     return forced_output
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/gates_one_qubit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/gates_one_qubit.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,651 +1,655 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import List, Tuple, Any
-
-from .state import PauliFaultProp
+from typing import TYPE_CHECKING, Any
 
+if TYPE_CHECKING:
+    from pecos.simulators.paulifaultprop.state import PauliFaultProp
 
-def switch(state,
-           switch_list: List[Tuple[str, str]],
-           qubit: int) -> None:
 
+def switch(state, switch_list: list[tuple[str, str]], qubit: int) -> None:
     for symbol_init, symbol_final in switch_list:
         if qubit in state.faults[symbol_init]:
             state.faults[symbol_init].remove(qubit)
             state.faults[symbol_final].add(qubit)
             break
 
 
-def I(state: 'PauliFaultProp',
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Identity does nothing.
+def Identity(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Identity does nothing.
 
     X -> X
     Z -> Z
     Y -> Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-    pass
 
 
-def X(state: 'PauliFaultProp',
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Pauli X
+def X(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Pauli X.
 
     X -> X
     Z -> -Z
     Y -> -Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['Z'] or qubit in state.faults['Y']):
+    if state.track_sign and (qubit in state.faults["Z"] or qubit in state.faults["Y"]):
         state.flip_sign()
 
 
-def Y(state: 'PauliFaultProp',
-      qubit: int,
-      **params: Any) -> None:
-    """
-    X -> -X
+def Y(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """X -> -X
     Z -> -Z
-    Y -> Y
+    Y -> Y.
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['X'] or qubit in state.faults['Z']):
+    if state.track_sign and (qubit in state.faults["X"] or qubit in state.faults["Z"]):
         state.flip_sign()
 
 
-def Z(state: 'PauliFaultProp',
-      qubit: int,
-      **params: Any) -> None:
-    """
-    X -> -X
+def Z(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """X -> -X
     Z -> Z
-    Y -> -Y
+    Y -> -Y.
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['X'] or qubit in state.faults['Y']):
+    if state.track_sign and (qubit in state.faults["X"] or qubit in state.faults["Y"]):
         state.flip_sign()
 
 
-def SX(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Square root of X.
+def SX(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Square root of X.
 
     X -> X
     Z -> -Y
     Y -> Z
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['Z']:
+    if state.track_sign and qubit in state.faults["Z"]:
         state.flip_sign()
 
-    switch(state, [
-        ('Z', 'Y'),
-        ('Y', 'Z')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("Z", "Y"),
+            ("Y", "Z"),
+        ],
+        qubit,
+    )
 
 
-def SXdg(state: 'PauliFaultProp',
-         qubit: int,
-         **params: Any) -> None:
-    """
-    Hermitian conjugate of the square root of X.
+def SXdg(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hermitian conjugate of the square root of X.
 
     X -> X
     Z -> Y
     Y -> -Z
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['Y']:
+    if state.track_sign and qubit in state.faults["Y"]:
         state.flip_sign()
 
-    switch(state, [
-        ('Z', 'Y'),
-        ('Y', 'Z')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("Z", "Y"),
+            ("Y", "Z"),
+        ],
+        qubit,
+    )
 
 
-def SY(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Square root of Y.
+def SY(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Square root of Y.
 
     X -> -Z
     Z -> X
     Y -> Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['X']:
+    if state.track_sign and qubit in state.faults["X"]:
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Z'),
-        ('Z', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Z"),
+            ("Z", "X"),
+        ],
+        qubit,
+    )
 
 
-def SYdg(state: 'PauliFaultProp',
-         qubit: int,
-         **params: Any) -> None:
-    """
-    Hermitian conjugate of the square root of Y.
+def SYdg(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hermitian conjugate of the square root of Y.
 
     X -> Z
     Z -> -X
     Y -> Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['Z']:
+    if state.track_sign and qubit in state.faults["Z"]:
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Z'),
-        ('Z', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Z"),
+            ("Z", "X"),
+        ],
+        qubit,
+    )
 
 
-def SZ(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Square root of Z.
+def SZ(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Square root of Z.
 
     X -> Y
     Z -> Z
     Y -> -X
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['Y']:
+    if state.track_sign and qubit in state.faults["Y"]:
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Y'),
-        ('Y', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Y"),
+            ("Y", "X"),
+        ],
+        qubit,
+    )
 
 
-def SZdg(state: 'PauliFaultProp',
-         qubit: int,
-         **params: Any) -> None:
-    """
-    Hermitian conjugate of the square root of Z.
+def SZdg(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hermitian conjugate of the square root of Z.
 
     X -> -Y
     Z -> Z
     Y -> X
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['X']:
+    if state.track_sign and qubit in state.faults["X"]:
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Y'),
-        ('Y', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Y"),
+            ("Y", "X"),
+        ],
+        qubit,
+    )
 
 
-def H(state: 'PauliFaultProp',
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Hadamard gate.
+def H(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hadamard gate.
 
     X -> Z
     Z -> X
     Y -> -Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['Y']:
+    if state.track_sign and qubit in state.faults["Y"]:
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Z'),
-        ('Z', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Z"),
+            ("Z", "X"),
+        ],
+        qubit,
+    )
 
 
-def H2(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Hadamard-like rotation
+def H2(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hadamard-like rotation.
 
     X -> -Z
     Z -> -X
     Y -> -Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
     if state.track_sign:
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Z'),
-        ('Z', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Z"),
+            ("Z", "X"),
+        ],
+        qubit,
+    )
 
 
-def H3(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Hadamard-like rotation
+def H3(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hadamard-like rotation.
 
     X -> Y
     Z -> -Z
     Y -> X
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['Z']:
+    if state.track_sign and qubit in state.faults["Z"]:
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Y'),
-        ('Y', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Y"),
+            ("Y", "X"),
+        ],
+        qubit,
+    )
 
 
-def H4(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Hadamard-like rotation
+def H4(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hadamard-like rotation.
 
     X -> -Y
     Z -> -Z
     Y -> -X
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
     if state.track_sign:
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Y'),
-        ('Y', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Y"),
+            ("Y", "X"),
+        ],
+        qubit,
+    )
 
 
-def H5(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Hadamard-like rotation
+def H5(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hadamard-like rotation.
 
     X -> -X
     Z -> Y
     Y -> Z
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and qubit in state.faults['X']:
+    if state.track_sign and qubit in state.faults["X"]:
         state.flip_sign()
 
-    switch(state, [
-        ('Z', 'Y'),
-        ('Y', 'Z')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("Z", "Y"),
+            ("Y", "Z"),
+        ],
+        qubit,
+    )
 
 
-def H6(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Hadamard-like rotation
+def H6(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Hadamard-like rotation.
 
     X -> -X
     Z -> -Y
     Y -> -Z
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
     if state.track_sign:
         state.flip_sign()
 
-    switch(state, [
-        ('Z', 'Y'),
-        ('Y', 'Z')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("Z", "Y"),
+            ("Y", "Z"),
+        ],
+        qubit,
+    )
 
 
-def F(state: 'PauliFaultProp',
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Face rotation
+def F(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Face rotation.
 
     X -> Y
     Z -> X
     Y -> Z
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    switch(state, [
-        ('X', 'Y'),
-        ('Z', 'X'),
-        ('Y', 'Z')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Y"),
+            ("Z", "X"),
+            ("Y", "Z"),
+        ],
+        qubit,
+    )
 
 
-def F2(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Face rotation
+def F2(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Face rotation.
 
     X -> -Z
     Z -> Y
     Y -> -X
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['X'] or qubit in state.faults['Y']):
+    if state.track_sign and (qubit in state.faults["X"] or qubit in state.faults["Y"]):
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Z'),
-        ('Z', 'Y'),
-        ('Y', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Z"),
+            ("Z", "Y"),
+            ("Y", "X"),
+        ],
+        qubit,
+    )
 
 
-def F3(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Face rotation
+def F3(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Face rotation.
 
     X -> Y
     Z -> -X
     Y -> -Z
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['Z'] or qubit in state.faults['Y']):
+    if state.track_sign and (qubit in state.faults["Z"] or qubit in state.faults["Y"]):
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Y'),
-        ('Z', 'X'),
-        ('Y', 'Z')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Y"),
+            ("Z", "X"),
+            ("Y", "Z"),
+        ],
+        qubit,
+    )
 
 
-def F4(state: 'PauliFaultProp',
-       qubit: int,
-       **params: Any) -> None:
-    """
-    Face rotation
+def F4(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Face rotation.
 
     X -> Z
     Z -> -Y
     Y -> -X
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['Z'] or qubit in state.faults['Y']):
+    if state.track_sign and (qubit in state.faults["Z"] or qubit in state.faults["Y"]):
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Z'),
-        ('Z', 'Y'),
-        ('Y', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Z"),
+            ("Z", "Y"),
+            ("Y", "X"),
+        ],
+        qubit,
+    )
 
 
-def Fdg(state: 'PauliFaultProp',
-        qubit: int,
-        **params: Any) -> None:
-    """
-    Face rotation
+def Fdg(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Face rotation.
 
     X -> Z
     Z -> Y
     Y -> X
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
+    switch(
+        state,
+        [
+            ("X", "Z"),
+            ("Z", "Y"),
+            ("Y", "X"),
+        ],
+        qubit,
+    )
 
-    switch(state, [
-        ('X', 'Z'),
-        ('Z', 'Y'),
-        ('Y', 'X')
-    ], qubit)
 
-
-def F2dg(state: 'PauliFaultProp',
-         qubit: int,
-         **params: Any) -> None:
-    """
-    Face rotation
+def F2dg(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Face rotation.
 
     X -> -Y
     Z -> -X
     Y -> Z
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['X'] or qubit in state.faults['Z']):
+    if state.track_sign and (qubit in state.faults["X"] or qubit in state.faults["Z"]):
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Y'),
-        ('Z', 'X'),
-        ('Y', 'Z')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Y"),
+            ("Z", "X"),
+            ("Y", "Z"),
+        ],
+        qubit,
+    )
 
 
-def F3dg(state: 'PauliFaultProp',
-         qubit: int,
-         **params: Any) -> None:
-    """
-    Face rotation
+def F3dg(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Face rotation.
 
     X -> -Z
     Z -> -Y
     Y -> X
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['X'] or qubit in state.faults['Z']):
+    if state.track_sign and (qubit in state.faults["X"] or qubit in state.faults["Z"]):
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Z'),
-        ('Z', 'Y'),
-        ('Y', 'X')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Z"),
+            ("Z", "Y"),
+            ("Y", "X"),
+        ],
+        qubit,
+    )
 
 
-def F4dg(state: 'PauliFaultProp',
-         qubit: int,
-         **params: Any) -> None:
-    """
-    Face rotation
+def F4dg(state: "PauliFaultProp", qubit: int, **params: Any) -> None:
+    """Face rotation.
 
     X -> -Y
     Z -> X
     Y -> -Z
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
-    if state.track_sign and (qubit in state.faults['X'] or qubit in state.faults['Y']):
+    if state.track_sign and (qubit in state.faults["X"] or qubit in state.faults["Y"]):
         state.flip_sign()
 
-    switch(state, [
-        ('X', 'Y'),
-        ('Z', 'X'),
-        ('Y', 'Z')
-    ], qubit)
+    switch(
+        state,
+        [
+            ("X", "Y"),
+            ("Z", "X"),
+            ("Y", "Z"),
+        ],
+        qubit,
+    )
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/gates_two_qubit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/gates_two_qubit.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,22 +5,21 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Tuple, Any
-from .gates_one_qubit import H, SZ, SZdg, SX, SY, SYdg, X
+from typing import Any
 
+from pecos.simulators.paulifaultprop.gates_one_qubit import SX, SY, SZ, H, SYdg, SZdg, X
 
-def CX(state,
-       qubits: Tuple[int, int]) -> None:
-    """
-    Applies the controlled-X gate.
+
+def CX(state, qubits: tuple[int, int]) -> None:
+    """Applies the controlled-X gate.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     XI -> XX
@@ -42,93 +41,81 @@
     IX -> IX
     IZ -> ZZ
     IY -> ZY
 
     """
     q1, q2 = qubits
 
-    if state.track_sign and (q1 in state.faults['Y'] and q2 in state.faults['Y']):
+    if state.track_sign and (q1 in state.faults["Y"] and q2 in state.faults["Y"]):
         state.flip_sign()
 
-    if q1 in state.faults['X']:
-
-        if q2 in state.faults['X']:  # XX
-            state.faults['X'].remove(q2)
+    if q1 in state.faults["X"]:
+        if q2 in state.faults["X"]:  # XX
+            state.faults["X"].remove(q2)
             # XX -> XI
 
-        elif q2 in state.faults['Z']:  # XZ
-            state.faults['X'].remove(q1)
-            state.faults['Z'].remove(q2)
-            state.faults['Y'].add(q1)
-            state.faults['Y'].add(q2)
+        elif q2 in state.faults["Z"]:  # XZ
+            state.faults["X"].remove(q1)
+            state.faults["Z"].remove(q2)
+            state.faults["Y"].add(q1)
+            state.faults["Y"].add(q2)
             # XZ -> -YY
 
-        elif q2 in state.faults['Y']:  # XY
-            state.faults['X'].remove(q1)
-            state.faults['Y'].remove(q2)
-            state.faults['Y'].add(q1)
-            state.faults['Z'].add(q2)
+        elif q2 in state.faults["Y"]:  # XY
+            state.faults["X"].remove(q1)
+            state.faults["Y"].remove(q2)
+            state.faults["Y"].add(q1)
+            state.faults["Z"].add(q2)
             # XY -> YZ
 
         else:  # XI
-            state.faults['X'].add(q2)
+            state.faults["X"].add(q2)
             # XI -> XX
 
-    elif q1 in state.faults['Z']:
-
-        if q2 in state.faults['Z']:  # ZZ
-            state.faults['Z'].remove(q1)
-            # ZZ -> IZ
-
-        elif q2 in state.faults['Y']:  # ZY
-            state.faults['Z'].remove(q1)
-            # ZY -> IY
-
-    elif q1 in state.faults['Y']:
-
-        if q2 in state.faults['X']:  # YX
-            state.faults['X'].remove(q2)
+    elif q1 in state.faults["Z"]:
+        # ZZ -> IZ
+        # ZY -> IY
+        if q2 in state.faults["Z"] or q2 in state.faults["Y"]:
+            state.faults["Z"].remove(q1)
+
+    elif q1 in state.faults["Y"]:
+        if q2 in state.faults["X"]:  # YX
+            state.faults["X"].remove(q2)
             # YX -> YI
 
-        elif q2 in state.faults['Z']:  # YZ
-            state.faults['Y'].remove(q1)
-            state.faults['Z'].remove(q2)
-            state.faults['X'].add(q1)
-            state.faults['Y'].add(q2)
+        elif q2 in state.faults["Z"]:  # YZ
+            state.faults["Y"].remove(q1)
+            state.faults["Z"].remove(q2)
+            state.faults["X"].add(q1)
+            state.faults["Y"].add(q2)
             # YZ -> XY
 
-        elif q2 in state.faults['Y']:  # YY
-            state.faults['Y'].remove(q1)
-            state.faults['Y'].remove(q2)
-            state.faults['X'].add(q1)
-            state.faults['Z'].add(q2)
+        elif q2 in state.faults["Y"]:  # YY
+            state.faults["Y"].remove(q1)
+            state.faults["Y"].remove(q2)
+            state.faults["X"].add(q1)
+            state.faults["Z"].add(q2)
             # YY -> -XZ
 
         else:  # YI
-            state.faults['X'].add(q2)
+            state.faults["X"].add(q2)
             # YI -> YX
 
     else:
+        # IZ -> ZZ
+        # IY -> ZY
+        if q2 in state.faults["Z"] or q2 in state.faults["Y"]:  # IY
+            state.faults["Z"].add(q1)
 
-        if q2 in state.faults['Z']:  # IZ
-            state.faults['Z'].add(q1)
-            # IZ -> ZZ
-
-        elif q2 in state.faults['Y']:  # IY
-            state.faults['Z'].add(q1)
-            # IY -> ZY
-
-    if state.track_sign and (q1 in state.faults['Y'] and q2 in state.faults['Y']):
+    if state.track_sign and (q1 in state.faults["Y"] and q2 in state.faults["Y"]):
         state.flip_sign()
 
 
-def CZ(state,
-       qubits: Tuple[int, int]) -> None:
-    """
-    Applies the controlled-Z gate.
+def CZ(state, qubits: tuple[int, int]) -> None:
+    """Applies the controlled-Z gate.
 
     II -> II
     XI -> XZ
     ZI -> ZI
     YI -> YZ
     IX -> ZX
     IZ -> IZ
@@ -145,24 +132,21 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     H(state, qubits[1])
     CX(state, qubits)
     H(state, qubits[1])
 
 
-def CY(state,
-       qubits: Tuple[int, int]) -> None:
-    """
-    Applies the controlled-Y gate.
+def CY(state, qubits: tuple[int, int]) -> None:
+    """Applies the controlled-Y gate.
 
     II -> II
     XI -> XZ
     ZI -> ZI
     YI -> YZ
     IX -> ZX
     IZ -> IZ
@@ -179,77 +163,63 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     SZ(state, qubits[1])
     CX(state, qubits)
     SZ(state, qubits[1])
 
 
-def SWAP(state,
-         qubits: Tuple[int, int]) -> None:
-    """
-    Applies a SWAP gate.
+def SWAP(state, qubits: tuple[int, int]) -> None:
+    """Applies a SWAP gate.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     q1, q2 = qubits
 
     CX(state, (q1, q2))
     CX(state, (q2, q1))
     CX(state, (q1, q2))
 
 
-def G2(state,
-       qubits: Tuple[int, int]) -> None:
-    """
-    Applies a CZ.H(1).H(2).CZ
+def G2(state, qubits: tuple[int, int]) -> None:
+    """Applies a CZ.H(1).H(2).CZ.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     CZ(state, qubits)
     H(state, qubits[0])
     H(state, qubits[1])
     CZ(state, qubits)
 
 
-def II(state,
-       qubits: Tuple[int, int],
-       **params) -> None:
-    """
-    Two qubit identity.
+def II(state, qubits: tuple[int, int], **params) -> None:
+    """Two qubit identity.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-    pass
 
 
-def SXX(state,
-        qubits: Tuple[int, int],
-        **params) -> None:
-    """
-    Applies a square root of XX rotation to generators
+def SXX(state, qubits: tuple[int, int], **params) -> None:
+    """Applies a square root of XX rotation to generators.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
@@ -257,107 +227,96 @@
     SX(state, qubit1)  # Sqrt X
     SX(state, qubit2)  # Sqrt X
     SYdg(state, qubit1)  # (Sqrt Y)^\dagger
     CX(state, qubits)  # CNOT
     SY(state, qubit1)  # Sqrt Y
 
 
-def SXXdg(state,
-          qubits: Tuple[int, int],
-          **params) -> None:
-    """
-    Applies a square root of XX rotation to generators
+def SXXdg(state, qubits: tuple[int, int], **params) -> None:
+    """Applies a square root of XX rotation to generators.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
     qubit1, qubit2 = qubits
     X(state, qubit1)
     X(state, qubit2)
     SXX(state, qubits)
 
-def SYY(state,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    r"""
-    Sqrt of YY == (rZ,rZ).SqrtXX.(rZd,rZd)
+
+def SYY(state, qubits: tuple[int, int], **params: Any) -> None:
+    r"""Sqrt of YY == (rZ,rZ).SqrtXX.(rZd,rZd).
 
     XI -> -ZY
     IX -> -YZ
     ZI -> XY
     IZ -> YX
 
     TODO: verify implementation!
 
     Args:
+    ----
         state:
         qubits:
 
     Returns:
+    -------
 
     """
     qubit1, qubit2 = qubits
     SZdg(state, qubit1)  # rZd
     SZdg(state, qubit2)  # rZd
     SXX(state, qubits)
     SZ(state, qubit1)  # rZ
     SZ(state, qubit2)  # rZ
 
 
-def SYYdg(state,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    """
-    Adjoint of SYY
+def SYYdg(state, qubits: tuple[int, int], **params: Any) -> None:
+    """Adjoint of SYY.
 
     Args:
+    ----
         state:
         qubits:
         **params:
 
     Returns:
+    -------
 
     """
-
     qubit1, qubit2 = qubits
     SZdg(state, qubit1)
     SZdg(state, qubit2)
     SXXdg(state, qubits)
     SZ(state, qubit1)
     SZ(state, qubit2)
 
 
-def SZZ(state,
-        qubits: Tuple[int, int],
-        **params) -> None:
-    """
-        Applies a square root of ZZ rotation to generators
+def SZZ(state, qubits: tuple[int, int], **params) -> None:
+    """Applies a square root of ZZ rotation to generators.
 
-        state (SparseSim): Instance representing the stabilizer state.
-        qubit (int): Integer that indexes the qubit being acted on.
+    state (SparseSim): Instance representing the stabilizer state.
+    qubit (int): Integer that indexes the qubit being acted on.
     """
     qubit1, qubit2 = qubits
     SYdg(state, qubit1)  # rYd
     SYdg(state, qubit2)  # rYd
     SXX(state, qubits)
     SY(state, qubit1)  # rY
     SY(state, qubit2)  # rY
 
 
-def SZZdg(state,
-        qubits: Tuple[int, int],
-        **params) -> None:
-    """
-        Applies an adjoint of square root of ZZ rotation to generators
+def SZZdg(state, qubits: tuple[int, int], **params) -> None:
+    """Applies an adjoint of square root of ZZ rotation to generators.
 
-        state (SparseSim): Instance representing the stabilizer state.
-        qubit (int): Integer that indexes the qubit being acted on.
+    state (SparseSim): Instance representing the stabilizer state.
+    qubit (int): Integer that indexes the qubit being acted on.
     """
     qubit1, qubit2 = qubits
     SYdg(state, qubit1)  # rYd
     SYdg(state, qubit2)  # rYd
     SXXdg(state, qubits)
     SY(state, qubit1)  # rY
     SY(state, qubit2)  # rY
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/logical_sign.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/logical_sign.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,46 +5,46 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from ...circuits import QuantumCircuit
+from pecos.circuits import QuantumCircuit
 
 
-def find_logical_signs(state,
-                       logical_circuit: QuantumCircuit) -> int:
-    """
-    Find the sign of the logical operator.
+def find_logical_signs(state, logical_circuit: QuantumCircuit) -> int:
+    """Find the sign of the logical operator.
 
     Args:
+    ----
         state:
         logical_circuit:
 
     Returns:
+    -------
 
     """
     if len(logical_circuit) != 1:
-        raise Exception('Logical operators are expected to only have one tick.')
+        msg = "Logical operators are expected to only have one tick."
+        raise Exception(msg)
 
-    logical_xs = set([])
-    logical_zs = set([])
+    logical_xs = set()
+    logical_zs = set()
 
     for symbol, gate_locations, _ in logical_circuit.items():
-
-        if symbol == 'X':
+        if symbol == "X":
             logical_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             logical_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             logical_xs.update(gate_locations)
             logical_zs.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
-    anticom = len(state.faults['X'] & logical_zs)
-    anticom += len(state.faults['Y'] & logical_zs)
-    anticom += len(state.faults['Y'] & logical_xs)
-    anticom += len(state.faults['Z'] & logical_xs)
+    anticom = len(state.faults["X"] & logical_zs)
+    anticom += len(state.faults["Y"] & logical_zs)
+    anticom += len(state.faults["Y"] & logical_xs)
+    anticom += len(state.faults["Z"] & logical_xs)
 
     return anticom % 2
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/paulifaultprop/state.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/paulifaultprop/state.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,60 +1,61 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Set, Tuple, Union
-from ..sim_class_types import PauliPropagation
-from . import bindings
-from .logical_sign import find_logical_signs
-from ...circuits import QuantumCircuit
-from ...circuits.quantum_circuit import ParamGateCollection
-from ..gate_syms import alt_symbols
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from pecos.simulators.gate_syms import alt_symbols
+from pecos.simulators.paulifaultprop import bindings
+from pecos.simulators.paulifaultprop.logical_sign import find_logical_signs
+from pecos.simulators.sim_class_types import PauliPropagation
+
+if TYPE_CHECKING:
+    from pecos.circuits import QuantumCircuit
+    from pecos.circuits.quantum_circuit import ParamGateCollection
 
 
 class PauliFaultProp(PauliPropagation):
-    r"""
-    A simulator that evolves Pauli faults through Clifford circuits.
+    r"""A simulator that evolves Pauli faults through Clifford circuits.
 
     The unitary evolution of a Pauli follows :math:`PC = CP' \Leftrightarrow P' = C^{\dagger} P C`, where :math:`P` and
     :math:`P'` are Pauli operators and :math:`C` is a Clifford operator.
 
     Attributes:
+    ----------
         num_qubits(int): Number of qubits.
         faults (Dict[str, Set[int]]):
         bindings (Dict[str, Callable]):
 
     """
 
-    def __init__(self, num_qubits: int, track_sign: bool = False) -> None:
-        """
-
-        Args:
+    def __init__(self, *, num_qubits: int, track_sign: bool = False) -> None:
+        """Args:
+        ----
             num_qubits (int):
 
         Returns: None
 
         """
-
         super().__init__()
 
         self.num_qubits = num_qubits
         self.faults = {
-            'X': set(),
-            'Y': set(),
-            'Z': set(),
+            "X": set(),
+            "Y": set(),
+            "Z": set(),
         }
         # Here we will encode Y as the qubit id in faults_x and faults_z
 
         self.track_sign = track_sign
         self.sign = 0
         self.img = 0
 
@@ -64,247 +65,240 @@
                 self.bindings[k] = self.bindings[v]
 
     def flip_sign(self):
         self.sign += 1
         self.sign %= 2
 
     def flip_img(self, num_is):
-
         self.img += num_is
         self.img %= 4
 
-        if self.img == 2 or self.img == 3:
+        if self.img in {2, 3}:
             self.flip_sign()
 
         self.img %= 2
 
     def logical_sign(self, logical_op: QuantumCircuit) -> int:
-        """
-        Find the sign of a logical operator, which is equivalent to determining if the faults commute (sign == 0) or
+        """Find the sign of a logical operator, which is equivalent to determining if the faults commute (sign == 0) or
         anticommute (sign == 1) with the logical operator.
 
         That is, compare the commutation of `logical_op` with `faults.`
 
         Args:
+        ----
             logical_op (QuantumCircuit): Quantum circuit representing a logical operator.
 
         Returns: int - sign.
 
         """
         return find_logical_signs(self, logical_op)
 
-    def run_circuit(self,
-                    circuit: ParamGateCollection,
-                    removed_locations: Union[Set[int], Set[Tuple[int, ...]], None] = None,
-                    apply_faults: bool = False):
-        """
-        Used to apply a quantum circuit to a state, whether the circuit represents an fault or ideal circuit.
+    def run_circuit(
+        self,
+        circuit: ParamGateCollection,
+        removed_locations: set[int] | (set[tuple[int, ...]] | None) = None,
+        *,
+        apply_faults: bool = False,
+    ):
+        """Used to apply a quantum circuit to a state, whether the circuit represents an fault or ideal circuit.
 
         Args:
+        ----
             circuit: A class representing a circuit. # TODO: Shouldn't this also include QuantumCircuit
             removed_locations : A set of qudit locations that correspond to
                 ideal gates that should be removed.
             apply_faults: Whether to apply the `circuit` as a Pauli fault (True) or as a Clifford to update the
                 faults (False).
 
         Returns: None
 
         """
+        circuit_type = circuit.metadata.get("circuit_type")
 
-        circuit_type = circuit.metadata.get('circuit_type')
-
-        if circuit_type == 'faults' or circuit_type == 'recovery':
+        if circuit_type in {"faults", "recovery"}:
             self.add_faults(circuit)
+            return None
         else:
-            if self.faults['X'] or self.faults['Y'] or self.faults['Z']:
+            if self.faults["X"] or self.faults["Y"] or self.faults["Z"]:
                 # Only apply gates if there are faults to act on
                 return super().run_circuit(circuit, removed_locations)
+            return None
 
             # need to return output?
 
-    def add_faults(self, circuit: Union[QuantumCircuit, ParamGateCollection], minus = False) -> None:
-        """
-        A methods to add faults to the state.
+    def add_faults(self, circuit: QuantumCircuit | ParamGateCollection, *, minus=False) -> None:
+        """A methods to add faults to the state.
 
         Args:
+        ----
             circuit (Union[QuantumCircuit, ParamGateCollection]): A quantum circuit representing Pauli faults.
 
         Returns: None
 
         """
-
         if self.track_sign and minus:
             self.flip_sign()
 
         for elem in circuit.items():
             if len(elem) == 2:
                 symbol, locations = elem
             else:
                 symbol, locations, _ = elem
 
-            if symbol in ['X', 'Y', 'Z']:
-
-                if symbol == 'X':
-
+            if symbol in ["X", "Y", "Z"]:
+                if symbol == "X":
                     # X.I = X
                     # X.X = I
                     # X.Y = iZ
                     # X.Z = -iY
 
-                    yoverlap = self.faults['Y'] & locations
-                    zoverlap = self.faults['Z'] & locations
+                    yoverlap = self.faults["Y"] & locations
+                    zoverlap = self.faults["Z"] & locations
 
-                    self.faults['Y'] -= yoverlap
-                    self.faults['Z'] -= zoverlap
+                    self.faults["Y"] -= yoverlap
+                    self.faults["Z"] -= zoverlap
 
-                    self.faults['Y'] ^= zoverlap
-                    self.faults['Z'] ^= yoverlap
+                    self.faults["Y"] ^= zoverlap
+                    self.faults["Z"] ^= yoverlap
 
-                    self.faults['X'] ^= locations - yoverlap - zoverlap
+                    self.faults["X"] ^= locations - yoverlap - zoverlap
 
                     if self.track_sign:
-
                         if yoverlap:
                             # X.Y = i Z
                             self.flip_img(len(yoverlap))
 
                         if zoverlap:
                             # X.Z = -i Y
                             self.flip_img(len(zoverlap))
 
                             if len(zoverlap) % 2:
                                 self.flip_sign()
 
-                elif symbol == 'Z':
-
+                elif symbol == "Z":
                     # Z.I = Z
                     # Z.X = iY
                     # Z.Y = -iX
                     # Z.Z = I
 
-                    xoverlap = self.faults['X'] & locations
-                    yoverlap = self.faults['Y'] & locations
+                    xoverlap = self.faults["X"] & locations
+                    yoverlap = self.faults["Y"] & locations
 
-                    self.faults['X'] -= xoverlap
-                    self.faults['Y'] -= yoverlap
+                    self.faults["X"] -= xoverlap
+                    self.faults["Y"] -= yoverlap
 
-                    self.faults['X'] ^= yoverlap
-                    self.faults['Y'] ^= xoverlap
+                    self.faults["X"] ^= yoverlap
+                    self.faults["Y"] ^= xoverlap
 
-                    self.faults['Z'] ^= locations - xoverlap - yoverlap
+                    self.faults["Z"] ^= locations - xoverlap - yoverlap
 
                     if self.track_sign:
                         if xoverlap:
                             # Z.X = i Y
                             self.flip_img(len(xoverlap))
 
                         if yoverlap:
                             # Z.Y = -i X
                             self.flip_img(len(yoverlap))
 
                             if len(yoverlap) % 2:
                                 self.flip_sign()
 
                 else:
-
                     # Y.I = Y
                     # Y.X = -iZ
                     # Y.Y = I
                     # Y.Z = iX
 
-                    xoverlap = self.faults['X'] & locations
-                    zoverlap = self.faults['Z'] & locations
+                    xoverlap = self.faults["X"] & locations
+                    zoverlap = self.faults["Z"] & locations
 
-                    self.faults['X'] -= xoverlap
-                    self.faults['Z'] -= zoverlap
+                    self.faults["X"] -= xoverlap
+                    self.faults["Z"] -= zoverlap
 
-                    self.faults['X'] ^= zoverlap
-                    self.faults['Z'] ^= xoverlap
+                    self.faults["X"] ^= zoverlap
+                    self.faults["Z"] ^= xoverlap
 
-                    self.faults['Y'] ^= locations - xoverlap - zoverlap
+                    self.faults["Y"] ^= locations - xoverlap - zoverlap
 
                     if self.track_sign:
                         if zoverlap:
                             # Y Z = i X
                             self.flip_img(len(zoverlap))
 
                         if xoverlap:
                             # Y X = -i Z
                             self.flip_img(len(xoverlap))
 
                             if len(xoverlap) % 2:
                                 self.flip_sign()
 
             else:
-                raise Exception(f'Got {symbol}. Can only handle Pauli errors.')
+                msg = f"Got {symbol}. Can only handle Pauli errors."
+                raise Exception(msg)
 
     def get_str(self):
-
         fault_dict = self.faults
 
-        if self.sign:
-            pstr = '-'
-        else:
-            pstr = '+'
+        pstr = "-" if self.sign else "+"
 
         for q in range(self.num_qubits):
-            if q in fault_dict.get('X', set()):
-                pstr += 'X'
-            elif q in fault_dict.get('Y', set()):
-                pstr += 'Y'
-            elif q in fault_dict.get('Z', set()):
-                pstr += 'Z'
+            if q in fault_dict.get("X", set()):
+                pstr += "X"
+            elif q in fault_dict.get("Y", set()):
+                pstr += "Y"
+            elif q in fault_dict.get("Z", set()):
+                pstr += "Z"
             else:
-                pstr += 'I'
+                pstr += "I"
         return pstr
 
-    def fault_str_sign(self, strip=False):
+    def fault_str_sign(self, *, strip=False):
         fault_str = []
 
         if self.sign:
-            fault_str.append('-')
+            fault_str.append("-")
         else:
-            fault_str.append('+')
+            fault_str.append("+")
 
         if self.img:
-            fault_str.append('i')
+            fault_str.append("i")
         else:
-            fault_str.append(' ')
+            fault_str.append(" ")
 
-        fault_str = ''.join(fault_str)
+        fault_str = "".join(fault_str)
 
         if strip:
             fault_str = fault_str.strip()
 
         return fault_str
 
     def fault_str_operator(self):
         fault_str = []
 
         for q in range(self.num_qubits):
-            if q in self.faults['X']:
-                fault_str.append('X')
+            if q in self.faults["X"]:
+                fault_str.append("X")
 
-            elif q in self.faults['Y']:
-                fault_str.append('Y')
+            elif q in self.faults["Y"]:
+                fault_str.append("Y")
 
-            elif q in self.faults['Z']:
-                fault_str.append('Z')
+            elif q in self.faults["Z"]:
+                fault_str.append("Z")
 
             else:
-                fault_str.append('I')
+                fault_str.append("I")
 
-        return ''.join(fault_str)
+        return "".join(fault_str)
 
     def fault_string(self):
-
-        return f'{self.fault_str_sign()}{self.fault_str_operator()}'
+        return f"{self.fault_str_sign()}{self.fault_str_operator()}"
 
     def fault_wt(self):
-        wt = len(self.faults['X'])
-        wt += len(self.faults['Y'])
-        wt += len(self.faults['Z'])
+        wt = len(self.faults["X"])
+        wt += len(self.faults["Y"])
+        wt += len(self.faults["Z"])
 
         return wt
 
-    def __str__(self):
-        return '{\'X\': %s, \'Y\': %s, \'Z\': %s}' % (self.faults['X'], self.faults['Y'], self.faults['Z'])
+    def __str__(self) -> str:
+        return "{{'X': {}, 'Y': {}, 'Z': {}}}".format(self.faults["X"], self.faults["Y"], self.faults["Z"])
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/decoders/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,10 +6,9 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from . import bindings
-
-from .state import ProjectQSim
+from pecos.decoders.dummy_decoder.dummy_decoder import DummyDecoder
+from pecos.decoders.mwpm2d.mwpm2d import MWPM2D
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/bindings.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/bindings.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,113 +7,99 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-import projectq.ops as ops
-from .helper import MakeFunc
-from . import gates_init, gates_one_qubit, gates_two_qubit, gates_meas
+from projectq import ops
+
+from pecos.simulators.projectq import gates_init, gates_meas, gates_one_qubit, gates_two_qubit
+from pecos.simulators.projectq.helper import MakeFunc
 
 # Note: More ProjectQ gates can be added by updating the wrapper's `gate_dict` attribute.
 
 # Note: Multiqubit gates are usually in all caps.
 
 
 gate_dict = {
     # ProjectQ specific:
-    'T': MakeFunc(ops.T).func,  # fourth root of Z
-    'Tdg': MakeFunc(ops.Tdag).func,  # fourth root of Z dagger
-    'SSWAP': MakeFunc(ops.SqrtSwap).func,
-    'Entangle': MakeFunc(ops.Entangle).func,  # H on first qubit and CNOT to all others...
-
-    'RX': gates_one_qubit.RX,  # Rotation about X (takes angle arg)
-    'RY': gates_one_qubit.RY,  # Rotation about Y (takes angle arg)
-    'RZ': gates_one_qubit.RZ,  # Rotation about Z (takes angle arg)
-
-    'R1XY': gates_one_qubit.R1XY,
-
-    'PhaseRot': MakeFunc(ops.R, angle=True).func,  # Phase-shift: Same as Rz but with a 1 in upper left of matrix.
-    'TOFFOLI': MakeFunc(ops.Toffoli).func,
-
-    'CRZ': MakeFunc(ops.CRz, angle=True).func,  # Controlled-Rz gate
-    'CRX': MakeFunc(ops.C(ops.Rx, 1), angle=True).func,  # Controlled-Rx
-    'CRY': MakeFunc(ops.C(ops.Ry, 1), angle=True).func,  # Controlled-Ry
-
-    'RXX': gates_two_qubit.RXX,
-    'RYY': gates_two_qubit.RYY,
-    'RZZ': gates_two_qubit.RZZ,
-    'R2XXYYZZ': gates_two_qubit.R2XXYYZZ,
-
+    "T": MakeFunc(ops.T).func,  # fourth root of Z
+    "Tdg": MakeFunc(ops.Tdag).func,  # fourth root of Z dagger
+    "SSWAP": MakeFunc(ops.SqrtSwap).func,
+    "Entangle": MakeFunc(ops.Entangle).func,  # H on first qubit and CNOT to all others...
+    "RX": gates_one_qubit.RX,  # Rotation about X (takes angle arg)
+    "RY": gates_one_qubit.RY,  # Rotation about Y (takes angle arg)
+    "RZ": gates_one_qubit.RZ,  # Rotation about Z (takes angle arg)
+    "R1XY": gates_one_qubit.R1XY,
+    "PhaseRot": MakeFunc(ops.R, angle=True).func,  # Phase-shift: Same as Rz but with a 1 in upper left of matrix.
+    "TOFFOLI": MakeFunc(ops.Toffoli).func,
+    "CRZ": MakeFunc(ops.CRz, angle=True).func,  # Controlled-Rz gate
+    "CRX": MakeFunc(ops.C(ops.Rx, 1), angle=True).func,  # Controlled-Rx
+    "CRY": MakeFunc(ops.C(ops.Ry, 1), angle=True).func,  # Controlled-Ry
+    "RXX": gates_two_qubit.RXX,
+    "RYY": gates_two_qubit.RYY,
+    "RZZ": gates_two_qubit.RZZ,
+    "R2XXYYZZ": gates_two_qubit.R2XXYYZZ,
     # Initialization
     # ==============
-    'Init +Z': gates_init.init_zero,  # Init by measuring (if entangle => random outcome
-    'Init -Z': gates_init.init_one,  # Init by measuring (if entangle => random outcome
-    'Init +X': gates_init.init_plus,  # Init by measuring (if entangle => random outcome
-    'Init -X': gates_init.init_minus,  # Init by measuring (if entangle => random outcome
-    'Init +Y': gates_init.init_plusi,  # Init by measuring (if entangle => random outcome
-    'Init -Y': gates_init.init_minusi,  # Init by measuring (if entangle => random outcome
-
-    'leak': gates_init.init_zero,
-    'leak |0>': gates_init.init_zero,
-    'leak |1>': gates_init.init_one,
-    'unleak |0>': gates_init.init_zero,
-    'unleak |1>': gates_init.init_one,
-
+    "Init +Z": gates_init.init_zero,  # Init by measuring (if entangle => random outcome
+    "Init -Z": gates_init.init_one,  # Init by measuring (if entangle => random outcome
+    "Init +X": gates_init.init_plus,  # Init by measuring (if entangle => random outcome
+    "Init -X": gates_init.init_minus,  # Init by measuring (if entangle => random outcome
+    "Init +Y": gates_init.init_plusi,  # Init by measuring (if entangle => random outcome
+    "Init -Y": gates_init.init_minusi,  # Init by measuring (if entangle => random outcome
+    "leak": gates_init.init_zero,
+    "leak |0>": gates_init.init_zero,
+    "leak |1>": gates_init.init_one,
+    "unleak |0>": gates_init.init_zero,
+    "unleak |1>": gates_init.init_one,
     # one-qubit operations
     # ====================
-
     # Paulis    # x->, z->
-    'I': gates_one_qubit.I,  # +x+z
-    'X': gates_one_qubit.X,  # +x-z
-    'Y': gates_one_qubit.Y,  # -x-z
-    'Z': gates_one_qubit.Z,  # -x+z
-
+    "I": gates_one_qubit.Identity,  # +x+z
+    "X": gates_one_qubit.X,  # +x-z
+    "Y": gates_one_qubit.Y,  # -x-z
+    "Z": gates_one_qubit.Z,  # -x+z
     # Square root of Paulis
-    'SX': gates_one_qubit.SX,    # +x-y  sqrt of X
-    'SXdg': gates_one_qubit.SXdg,  # +x+y sqrt of X dagger
-    'SY': gates_one_qubit.SY,    # -z+x sqrt of Y
-    'SYdg': gates_one_qubit.SYdg,  # +z-x sqrt of Y dagger
-    'SZ': gates_one_qubit.SZ,    # +y+z sqrt of Z
-    'SZdg': gates_one_qubit.SZdg,  # -y+z sqrt of Z dagger
-
+    "SX": gates_one_qubit.SX,  # +x-y  sqrt of X
+    "SXdg": gates_one_qubit.SXdg,  # +x+y sqrt of X dagger
+    "SY": gates_one_qubit.SY,  # -z+x sqrt of Y
+    "SYdg": gates_one_qubit.SYdg,  # +z-x sqrt of Y dagger
+    "SZ": gates_one_qubit.SZ,  # +y+z sqrt of Z
+    "SZdg": gates_one_qubit.SZdg,  # -y+z sqrt of Z dagger
     # Hadamard-like
-    'H': gates_one_qubit.H,
-    'H2': gates_one_qubit.H2,
-    'H3': gates_one_qubit.H3,
-    'H4': gates_one_qubit.H4,
-    'H5': gates_one_qubit.H5,
-    'H6': gates_one_qubit.H6,
-
+    "H": gates_one_qubit.H,
+    "H2": gates_one_qubit.H2,
+    "H3": gates_one_qubit.H3,
+    "H4": gates_one_qubit.H4,
+    "H5": gates_one_qubit.H5,
+    "H6": gates_one_qubit.H6,
     # Face rotations
-    'F': gates_one_qubit.F,    # +y+x
-    'Fdg': gates_one_qubit.Fdg,  # +z+y
-    'F2': gates_one_qubit.F2,    # -z+y
-    'F2dg': gates_one_qubit.F2dg,  # -y-x
-    'F3': gates_one_qubit.F3,    # +y-x
-    'F3dg': gates_one_qubit.F3dg,  # -z-y
-    'F4': gates_one_qubit.F4,    # +z-y
-    'F4dg': gates_one_qubit.F4dg,  # -y-z
-
+    "F": gates_one_qubit.F,  # +y+x
+    "Fdg": gates_one_qubit.Fdg,  # +z+y
+    "F2": gates_one_qubit.F2,  # -z+y
+    "F2dg": gates_one_qubit.F2dg,  # -y-x
+    "F3": gates_one_qubit.F3,  # +y-x
+    "F3dg": gates_one_qubit.F3dg,  # -z-y
+    "F4": gates_one_qubit.F4,  # +z-y
+    "F4dg": gates_one_qubit.F4dg,  # -y-z
     # two-qubit operations
     # ====================
-    'CX': gates_two_qubit.CNOT,
-    'CY': gates_two_qubit.CY,
-    'CZ': gates_two_qubit.CZ,
-    'SWAP': gates_two_qubit.SWAP,
-    'G': gates_two_qubit.G2,
-    'G2': gates_two_qubit.G2,
-    'II': gates_two_qubit.II,
-
-    # MlmerSrensen gates
-    'SXX': gates_two_qubit.SXX,  # \equiv e^{+i (\pi /4)} * e^{-i (\pi /4) XX } == R(XX, pi/2)
-    'SYY': gates_two_qubit.SYY,
-    'SZZ': gates_two_qubit.SZZ,
-
+    "CX": gates_two_qubit.CNOT,
+    "CY": gates_two_qubit.CY,
+    "CZ": gates_two_qubit.CZ,
+    "SWAP": gates_two_qubit.SWAP,
+    "G": gates_two_qubit.G2,
+    "G2": gates_two_qubit.G2,
+    "II": gates_two_qubit.II,
+    # Mlmer-Srensen gates
+    "SXX": gates_two_qubit.SXX,  # \equiv e^{+i (\pi /4)} * e^{-i (\pi /4) XX } == R(XX, pi/2)
+    "SYY": gates_two_qubit.SYY,
+    "SZZ": gates_two_qubit.SZZ,
     # Measurements
     # ============
-    'Measure +X': gates_meas.meas_x,  # no random_output (force outcome) !
-    'Measure +Y': gates_meas.meas_y,  # no random_output (force outcome) !
-    'Measure +Z': gates_meas.meas_z,  # no random_output (force outcome) !
-    'force output': gates_meas.force_output,
+    "Measure +X": gates_meas.meas_x,  # no random_output (force outcome) !
+    "Measure +Y": gates_meas.meas_y,  # no random_output (force outcome) !
+    "Measure +Z": gates_meas.meas_z,  # no random_output (force outcome) !
+    "force output": gates_meas.force_output,
 }
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/gates_init.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/gates_init.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,105 +9,85 @@
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from typing import Any
 
-from .gates_one_qubit import H2, H5, H6, X, H
-from .gates_meas import meas_z
+from pecos.simulators.projectq.gates_meas import meas_z
+from pecos.simulators.projectq.gates_one_qubit import H2, H5, H6, H, X
 
 
-def init_zero(state,
-              qubit,
-              **params: Any):
-    """
-
-    Args:
+def init_zero(state, qubit, **params: Any):
+    """Args:
+    ----
         state:
         qubit:
 
     Returns:
+    -------
 
     """
     result = meas_z(state, qubit)
 
     if result:
         X(state, qubit)
 
 
-def init_one(state,
-             qubit,
-             **params: Any):
-    """
-    Initialize qubit in state |1>.
+def init_one(state, qubit, **params: Any):
+    """Initialize qubit in state |1>.
 
     :param state:
     :param qubit:
     :return:
     """
-
     init_zero(state, qubit)
     X(state, qubit)
 
 
-def init_plus(state,
-              qubit,
-              **params: Any):
-    """
-    Initialize qubit in state |+>.
+def init_plus(state, qubit, **params: Any):
+    """Initialize qubit in state |+>.
 
     :param gens:
     :param qubit:
     :return:
     """
-
     init_zero(state, qubit)
     H(state, qubit)
 
 
-def init_minus(state,
-               qubit,
-               **params: Any):
-    """
-    Initialize qubit in state |->
+def init_minus(state, qubit, **params: Any):
+    """Initialize qubit in state |->.
 
     :param gens:
     :param qubit:
     :return:
     """
-
     init_zero(state, qubit)
     H2(state, qubit)
 
 
-def init_plusi(state,
-               qubit,
-               **params: Any):
-    """
-    Initialize qubit in state |+i>
+def init_plusi(state, qubit, **params: Any):
+    """Initialize qubit in state |+i>.
 
     :param gens:
     :param qubit:
     :return:
     """
-
     init_zero(state, qubit)
     H5(state, qubit)
 
 
-def init_minusi(state,
-                qubit,
-                **params: Any):
-    """
-    Initialize qubit in state |-i>
+def init_minusi(state, qubit, **params: Any):
+    """Initialize qubit in state |-i>.
 
     Args:
+    ----
         state:
         qubit:
 
     Returns:
+    -------
 
     """
-
     init_zero(state, qubit)
     H6(state, qubit)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/gates_meas.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/gates_meas.py`

 * *Files 23% similar despite different names*

```diff
@@ -10,110 +10,97 @@
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from typing import Any
 
 from projectq.ops import Measure
-from .gates_one_qubit import H, H5, X
 
+from pecos.simulators.projectq.gates_one_qubit import H5, H
 
-def force_output(state,
-                 qubit,
-                 forced_output=-1,
-                 **params: Any):
-    """
-    Outputs value.
+
+def force_output(state, qubit, forced_output=-1, **params: Any):
+    """Outputs value.
 
     Used for error generators to generate outputs when replacing measurements.
 
     Args:
+    ----
         state:
         qubit:
         forced_output:
 
     Returns:
+    -------
 
     """
     return forced_output
 
 
-def meas_z(state,
-           qubit,
-           forced_outcome=-1,
-           **params: Any):
-    """
-    Measurement in the Z-basis.
+def meas_z(state, qubit, forced_outcome=-1, **params: Any):
+    """Measurement in the Z-basis.
 
     Args:
         state:
         qubit:
         forced_outcome:
+        **params:
 
     Returns:
 
     """
-
     q = state.qids[qubit]
 
     state.eng.flush()
 
-    if forced_outcome == 0 or forced_outcome == 1:
-
+    if forced_outcome in {0, 1}:
         # project the qubit to the desired state ("randomly" chooses the value `forced_outcome`)
         state.eng.backend.collapse_wavefunction([q], [forced_outcome])
         # Note: this will raise an error if the probability of collapsing to this state is close to 0.0
 
         return forced_outcome
 
     else:
-
         Measure | q
         state.eng.flush()
 
         return int(q)
 
 
-def meas_y(state,
-           qubit,
-           forced_outcome=-1,
-           **params: Any):
-    """
-    Measurement in the Y-basis.
+def meas_y(state, qubit, forced_outcome=-1, **params: Any):
+    """Measurement in the Y-basis.
 
     Args:
+    ----
         state:
         qubit:
         forced_outcome:
 
     Returns:
+    -------
 
     """
-
     H5(state, qubit)
     meas_outcome = meas_z(state, qubit, forced_outcome)
     H5(state, qubit)
 
     return meas_outcome
 
 
-def meas_x(state,
-           qubit,
-           forced_outcome=-1,
-           **params: Any):
-    """
-    Measurement in the X-basis.
+def meas_x(state, qubit, forced_outcome=-1, **params: Any):
+    """Measurement in the X-basis.
 
     Args:
+    ----
         state:
         qubit:
         forced_outcome:
 
     Returns:
+    -------
 
     """
-
     H(state, qubit)
     meas_outcome = meas_z(state, qubit, forced_outcome)
     H(state, qubit)
 
     return meas_outcome
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/gates_one_qubit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/gates_one_qubit.py`

 * *Files 25% similar despite different names*

```diff
@@ -7,338 +7,267 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Any, Tuple
+from __future__ import annotations
+
+from typing import Any
+
 import numpy as np
-import projectq.ops as ops
-from .helper import MakeFunc
+from projectq import ops
 
+from pecos.simulators.projectq.helper import MakeFunc
 
-def I(state,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Identity does nothing.
+
+def Identity(state, qubit: int, **params: Any) -> None:
+    """Identity does nothing.
 
     X -> X
 
     Z -> Z
 
     Y -> Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-    pass
 
 
-def X(state,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Pauli X
+def X(state, qubit: int, **params: Any) -> None:
+    """Pauli X.
 
     X -> X
 
     Z -> -Z
 
     Y -> -Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
     ops.X | state.qids[qubit]
 
 
-def Y(state,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    X -> -X
+def Y(state, qubit: int, **params: Any) -> None:
+    """X -> -X.
 
     Z -> -Z
 
     Y -> Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
     ops.Y | state.qids[qubit]
 
 
-def Z(state,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    X -> -X
+def Z(state, qubit: int, **params: Any) -> None:
+    """X -> -X.
 
     Z -> Z
 
     Y -> -Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
     ops.Z | state.qids[qubit]
 
 
 RX = MakeFunc(ops.Rx, angle=True).func  # Rotation about X (takes angle arg)
 RY = MakeFunc(ops.Ry, angle=True).func  # Rotation about Y (takes angle arg)
 RZ = MakeFunc(ops.Rz, angle=True).func  # Rotation about Z (takes angle arg)
 
 
-def R1XY(state,
-         qubit: int,
-         angles: Tuple[float, float],
-         **params: Any) -> None:
-    """
-    R1XY(theta, phi) = U1q(theta, phi) = RZ(phi-pi/2)*RY(theta)*RZ(-phi+pi/2)
+def R1XY(state, qubit: int, angles: tuple[float, float], **params: Any) -> None:
+    """R1XY(theta, phi) = U1q(theta, phi) = RZ(phi-pi/2)*RY(theta)*RZ(-phi+pi/2).
 
     Args:
+    ----
         state:
         qubit:
         angles:
         **params:
 
     Returns:
+    -------
 
     """
-
     theta = angles[0]
     phi = angles[1]
 
     RZ(state, qubit, angle=-phi + np.pi / 2)
     RY(state, qubit, angle=theta)
     RZ(state, qubit, angle=phi - np.pi / 2)
 
 
-def SX(state,
-       qubit: int,
-       **params: Any) -> None:
-    """Square-root of X gate class"""
-
-    RX(state, qubit, angle=np.pi/2)
-
-
-def SXdg(state,
-         qubit: int,
-         **params: Any) -> None:
-    """Adjoint of the square-root of X gate class"""
+def SX(state, qubit: int, **params: Any) -> None:
+    """Square-root of X gate class."""
+    RX(state, qubit, angle=np.pi / 2)
 
-    RX(state, qubit, angle=-np.pi/2)
 
+def SXdg(state, qubit: int, **params: Any) -> None:
+    """Adjoint of the square-root of X gate class."""
+    RX(state, qubit, angle=-np.pi / 2)
 
-def SY(state,
-       qubit: int,
-       **params: Any) -> None:
-    """Square-root of Y gate class"""
 
-    RY(state, qubit, angle=np.pi/2)
+def SY(state, qubit: int, **params: Any) -> None:
+    """Square-root of Y gate class."""
+    RY(state, qubit, angle=np.pi / 2)
 
 
-def SYdg(state,
-         qubit: int,
-         **params: Any) -> None:
-    """Adjoint of the square-root of Y gate class"""
+def SYdg(state, qubit: int, **params: Any) -> None:
+    """Adjoint of the square-root of Y gate class."""
+    RY(state, qubit, angle=-np.pi / 2)
 
-    RY(state, qubit, angle=-np.pi/2)
-
-
-def SZ(state,
-       qubit: int,
-       **params: Any) -> None:
-    """Square-root of Z gate class"""
 
+def SZ(state, qubit: int, **params: Any) -> None:
+    """Square-root of Z gate class."""
     ops.S | state.qids[qubit]
 
 
-def SZdg(state,
-         qubit: int,
-         **params: Any) -> None:
-    """Adjoint of the square-root of Z gate class"""
+def SZdg(state, qubit: int, **params: Any) -> None:
+    """Adjoint of the square-root of Z gate class."""
+    ops.Sdag | state.qids[qubit]
 
-    ops.Sdag  | state.qids[qubit]
 
-
-def H(state,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Square root of Z.
+def H(state, qubit: int, **params: Any) -> None:
+    """Square root of Z.
 
     X -> Z
 
     Z -> X
 
     Y -> -Y
 
     Args:
+    ----
         state (PauliFaultProp):  The class representing the Pauli fault state.
         qubit (int): An integer indexing the qubit being operated on.
 
     Returns: None
 
     """
-
     ops.H | state.qids[qubit]
 
 
-def H2(state,
-      qubit: int,
-      **params: Any) -> None:
+def H2(state, qubit: int, **params: Any) -> None:
     # @property
     # def matrix(self):
-    #     return 0.5 * np.matrix([[1 + 1j, -1 - 1j], [-1 - 1j, -1 - 1j]])
 
-    ops.Ry(np.pi/2) | state.qids[qubit]
+    ops.Ry(np.pi / 2) | state.qids[qubit]
     ops.Z | state.qids[qubit]
 
 
-def H3(state,
-      qubit: int,
-      **params: Any) -> None:
+def H3(state, qubit: int, **params: Any) -> None:
     # @property
     # def matrix(self):
-    #     return np.matrix([[0, 1], [1j, 0]])
 
     ops.S | state.qids[qubit]
     ops.Y | state.qids[qubit]
 
 
-def H4(state,
-      qubit: int,
-      **params: Any) -> None:
+def H4(state, qubit: int, **params: Any) -> None:
     # @property
     # def matrix(self):
-    #     return np.matrix([[0, 1j], [1, 0]])
 
     ops.S | state.qids[qubit]
     ops.X | state.qids[qubit]
 
 
-def H5(state,
-      qubit: int,
-      **params: Any) -> None:
+def H5(state, qubit: int, **params: Any) -> None:
     # @property
     # def matrix(self):
-    #     return 0.5 * np.matrix([[1+1j, 1-1j], [-1+1j, -1-1j]])
 
-    ops.Rx(np.pi/2) | state.qids[qubit]
+    ops.Rx(np.pi / 2) | state.qids[qubit]
     ops.Z | state.qids[qubit]
 
 
-def H6(state,
-      qubit: int,
-      **params: Any) -> None:
+def H6(state, qubit: int, **params: Any) -> None:
     # @property
     # def matrix(self):
-    #     return 0.5 * np.matrix([[-1-1j, 1-1j], [-1+1j, 1+1j]])
 
-    ops.Rx(np.pi/2) | state.qids[qubit]
+    ops.Rx(np.pi / 2) | state.qids[qubit]
     ops.Y | state.qids[qubit]
 
 
-def F(state,
-      qubit: int,
-      **params: Any) -> None:
-    """Face rotations of an octahedron #1"""
+def F(state, qubit: int, **params: Any) -> None:
+    """Face rotations of an octahedron #1."""
     # @property
     # def matrix(self):
-    #     return 0.5 * np.matrix([[1+1j, 1-1j], [1+1j, -1+1j]])
 
     ops.Rx(np.pi / 2) | state.qids[qubit]
     ops.Rz(np.pi / 2) | state.qids[qubit]
 
 
-def Fdg(state,
-        qubit: int,
-        **params: Any) -> None:
-    """Adjoint of face rotations of an octahedron #1"""
-
+def Fdg(state, qubit: int, **params: Any) -> None:
+    """Adjoint of face rotations of an octahedron #1."""
     ops.Rz(-np.pi / 2) | state.qids[qubit]
     ops.Rx(-np.pi / 2) | state.qids[qubit]
 
 
-def F2(state,
-      qubit: int,
-      **params: Any) -> None:
-    """Face rotations of an octahedron #2"""
+def F2(state, qubit: int, **params: Any) -> None:
+    """Face rotations of an octahedron #2."""
     # @property
     # def matrix(self):
-    #     return 0.5 * np.matrix([[1 - 1j, -1 + 1j], [1 + 1j, 1 + 1j]])
 
     ops.Rz(np.pi / 2) | state.qids[qubit]
     ops.Rx(-np.pi / 2) | state.qids[qubit]
 
 
-def F2dg(state,
-         qubit: int,
-         **params: Any) -> None:
-    """Adjoint of face rotations of an octahedron #2"""
-
-    ops.Rx(np.pi/2) | state.qids[qubit]
+def F2dg(state, qubit: int, **params: Any) -> None:
+    """Adjoint of face rotations of an octahedron #2."""
+    ops.Rx(np.pi / 2) | state.qids[qubit]
     ops.Rz(-np.pi / 2) | state.qids[qubit]
 
 
-def F3(state,
-      qubit: int,
-      **params: Any) -> None:
-    """Face rotations of an octahedron #3"""
+def F3(state, qubit: int, **params: Any) -> None:
+    """Face rotations of an octahedron #3."""
     # @property
     # def matrix(self):
-    #     return 0.5 * np.matrix([[1-1j, 1+1j], [-1+1j, 1+1j]])
 
-    ops.Rx(-np.pi/2) | state.qids[qubit]
+    ops.Rx(-np.pi / 2) | state.qids[qubit]
     ops.Rz(np.pi / 2) | state.qids[qubit]
 
 
-def F3dg(state,
-         qubit: int,
-         **params: Any) -> None:
-    """Adjoint of face rotations of an octahedron #3"""
-
+def F3dg(state, qubit: int, **params: Any) -> None:
+    """Adjoint of face rotations of an octahedron #3."""
     ops.Rz(-np.pi / 2) | state.qids[qubit]
     ops.Rx(np.pi / 2) | state.qids[qubit]
 
 
-def F4(state,
-      qubit: int,
-      **params: Any) -> None:
-    """Face rotations of an octahedron #4"""
+def F4(state, qubit: int, **params: Any) -> None:
+    """Face rotations of an octahedron #4."""
     # @property
     # def matrix(self):
-    #     return 0.5 * np.matrix([[1+1j, 1+1j], [1-1j, -1+1j]])
 
     ops.Rz(np.pi / 2) | state.qids[qubit]
     ops.Rx(np.pi / 2) | state.qids[qubit]
 
 
-def F4dg(state,
-         qubit: int,
-         **params: Any) -> None:
-    """Adjoint of face rotations of an octahedron #4"""
-
-    ops.Rx(-np.pi/2) | state.qids[qubit]
-    ops.Rz(-np.pi / 2) | state.qids[qubit]
+def F4dg(state, qubit: int, **params: Any) -> None:
+    """Adjoint of face rotations of an octahedron #4."""
+    ops.Rx(-np.pi / 2) | state.qids[qubit]
+    ops.Rz(-np.pi / 2) | state.qids[qubit]
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/gates_two_qubit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/gates_two_qubit.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,209 +7,164 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Tuple, Any
+from __future__ import annotations
+
+from typing import Any
+
 from numpy import pi
 from projectq import ops
-from .gates_one_qubit import H
+
+from pecos.simulators.projectq.gates_one_qubit import H
 
 
-def II(state,
-       qubits: Tuple[int, int],
-       **params: Any) -> None:
+def II(state, qubits: tuple[int, int], **params: Any) -> None:
     pass
 
 
-def G2(state,
-       qubits: Tuple[int, int],
-       **params: Any) -> None:
-    """
-    Applies a CZ.H(1).H(2).CZ
+def G2(state, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies a CZ.H(1).H(2).CZ.
 
     Returns:
+    -------
 
     """
-
     CZ(state, qubits)
     H(state, qubits[0])
     H(state, qubits[1])
     CZ(state, qubits)
 
 
-def CNOT(state,
-         qubits: Tuple[int, int],
-         **params: Any) -> None:
-
+def CNOT(state, qubits: tuple[int, int], **params: Any) -> None:
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
 
     ops.CNOT | (q1, q2)
 
 
-def CZ(state,
-       qubits: Tuple[int, int],
-       **params: Any) -> None:
-
+def CZ(state, qubits: tuple[int, int], **params: Any) -> None:
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
 
     ops.C(ops.Z) | (q1, q2)
 
 
-def CY(state,
-       qubits: Tuple[int, int],
-       **params: Any) -> None:
+def CY(state, qubits: tuple[int, int], **params: Any) -> None:
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
 
     ops.C(ops.Y) | (q1, q2)
 
 
-def SWAP(state,
-         qubits: Tuple[int, int],
-         **params: Any) -> None:
+def SWAP(state, qubits: tuple[int, int], **params: Any) -> None:
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
 
     ops.Swap | (q1, q2)
 
 
-def SXX(state,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    """
-    Square root of XX rotation to generators
+def SXX(state, qubits: tuple[int, int], **params: Any) -> None:
+    """Square root of XX rotation to generators.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
     """
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
-    ops.Rxx(pi/2) | (q1, q2)
+    ops.Rxx(pi / 2) | (q1, q2)
 
 
-def SXXdg(state,
-          qubits: Tuple[int, int],
-          **params: Any) -> None:
-    """
-    Adjoint of square root of XX rotation
+def SXXdg(state, qubits: tuple[int, int], **params: Any) -> None:
+    """Adjoint of square root of XX rotation.
 
     state: Instance representing the stabilizer state.
     qubit: Integer that indexes the qubit being acted on.
 
     Returns: None
     """
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
-    ops.Rxx(-pi/2) | (q1, q2)
+    ops.Rxx(-pi / 2) | (q1, q2)
 
 
-def SYY(state,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    """
-    Square root of YY rotation to generators
+def SYY(state, qubits: tuple[int, int], **params: Any) -> None:
+    """Square root of YY rotation to generators.
 
     state: Instance representing the stabilizer state.
     qubit: Integer that indexes the qubit being acted on.
 
     Returns: None
     """
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
-    ops.Ryy(pi/2) | (q1, q2)
+    ops.Ryy(pi / 2) | (q1, q2)
 
 
-def SYYdg(state,
-          qubits: Tuple[int, int],
-          **params: Any) -> None:
-    """
-    Adjoint of square root of YY rotation to generators
+def SYYdg(state, qubits: tuple[int, int], **params: Any) -> None:
+    """Adjoint of square root of YY rotation to generators.
 
     state: Instance representing the stabilizer state.
     qubit: Integer that indexes the qubit being acted on.
 
     Returns: None
     """
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
-    ops.Ryy(-pi/2) | (q1, q2)
+    ops.Ryy(-pi / 2) | (q1, q2)
 
 
-def SZZ(state,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    """
-    Applies a square root of ZZ rotation to generators
+def SZZ(state, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies a square root of ZZ rotation to generators.
 
     state: Instance representing the stabilizer state.
     qubit: Integer that indexes the qubit being acted on.
 
     Returns: None
     """
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
-    ops.Rzz(pi/2) | (q1, q2)
+    ops.Rzz(pi / 2) | (q1, q2)
 
 
-def SZZdg(state,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    """
-    Applies an adjoint of square root of ZZ rotation to generators
+def SZZdg(state, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies an adjoint of square root of ZZ rotation to generators.
 
     state: Instance representing the stabilizer state.
     qubit: Integer that indexes the qubit being acted on.
 
     Returns: None
     """
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
-    ops.Rzz(-pi/2) | (q1, q2)
+    ops.Rzz(-pi / 2) | (q1, q2)
 
 
-def RXX(state,
-        qubits,
-        angle=None,
-        **params: Any) -> None:
-
+def RXX(state, qubits, angle=None, **params: Any) -> None:
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
     ops.Rxx(angle) | (q1, q2)
 
 
-def RYY(state,
-        qubits,
-        angle=None,
-        **params: Any) -> None:
-
+def RYY(state, qubits, angle=None, **params: Any) -> None:
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
     ops.Ryy(angle) | (q1, q2)
 
 
-def RZZ(state,
-        qubits,
-        angle=None,
-        **params: Any) -> None:
-
+def RZZ(state, qubits, angle=None, **params: Any) -> None:
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
     ops.Rzz(angle) | (q1, q2)
 
 
-def R2XXYYZZ(state,
-             qubits,
-             angles=None,
-             **params: Any) -> None:
-
+def R2XXYYZZ(state, qubits, angles=None, **params: Any) -> None:
     q1 = state.qids[qubits[0]]
     q2 = state.qids[qubits[1]]
     ops.Rxx(angles[0]) | (q1, q2)
     ops.Ryy(angles[1]) | (q1, q2)
     ops.Rzz(angles[2]) | (q1, q2)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/helper.py` & `quantum_pecos-0.6.0.dev1/python/pecos/circuits/hyqc/vars.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,44 +1,37 @@
-# Copyright 2019 The PECOS Developers
+# Copyright 2022 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Any
+from __future__ import annotations
 
+from pecos.circuits.hyqc.fund import Expression
 
-class MakeFunc:
-    """
-    Converts ProjectQ gate to a function.
-    """
-    def __init__(self, gate, angle=False):
-        """
-
-        Args:
-            gate:
-        """
-
-        self.gate = gate
-        self.angle = angle
-
-    def func(self,
-             state,
-             qubits,
-             **params: Any):
-
-        if isinstance(qubits, int):
-            qs = state.qids[qubits]
-        else:
-            qs = []
-            for q in qubits:
-                qs.append(state.qids[q])
-
-        if self.angle:
-            self.gate(params['angle']) | qs
-        else:
-            self.gate | qs
+
+class Var(Expression):
+    """Type for variables."""
+
+    def __init__(self, symbol: str | None = None) -> None:
+        super().__init__()
+
+        self.symbol = symbol
+
+    def __repr__(self) -> str:
+        repr_str = self.__class__.__name__
+        if self.symbol is not None:
+            repr_str = f"{repr_str}:{self.symbol}"
+        return f"<{repr_str} at {hex(id(self))}>"
+
+
+class CVar(Var):
+    """Type for classical variables."""
+
+
+class QVar(Var):
+    """Type for quantum variables."""
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/logical_sign.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/projectq/logical_sign.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,65 +6,66 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from projectq.ops import QubitOperator
-from ...circuits import QuantumCircuit
 
+from pecos.circuits import QuantumCircuit
 
-def find_logical_signs(state,
-                       logical_circuit: QuantumCircuit,
-                       allow_float=False) -> int:
-    """
-    Find the sign of the logical operator.
+
+def find_logical_signs(state, logical_circuit: QuantumCircuit, allow_float=False) -> int:
+    """Find the sign of the logical operator.
 
     Args:
+    ----
         state:
         logical_circuit:
 
     Returns:
+    -------
 
     """
     if len(logical_circuit) != 1:
-        raise Exception('Logical operators are expected to only have one tick.')
+        msg = "Logical operators are expected to only have one tick."
+        raise Exception(msg)
 
-    logical_xs = set([])
-    logical_zs = set([])
+    logical_xs = set()
+    logical_zs = set()
 
     op_string = []
 
     for symbol, gate_locations, _ in logical_circuit.items():
-
-        if symbol == 'X':
+        if symbol == "X":
             logical_xs.update(gate_locations)
             for loc in gate_locations:
-                op_string.append('X%s' % loc)
-        elif symbol == 'Z':
+                op_string.append("X%s" % loc)
+        elif symbol == "Z":
             logical_zs.update(gate_locations)
             for loc in gate_locations:
-                op_string.append('Z%s' % loc)
-        elif symbol == 'Y':
+                op_string.append("Z%s" % loc)
+        elif symbol == "Y":
             logical_xs.update(gate_locations)
             logical_zs.update(gate_locations)
             for loc in gate_locations:
-                op_string.append('Y%s' % loc)
+                op_string.append("Y%s" % loc)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
-    op_string = ' '.join(op_string)
+    op_string = " ".join(op_string)
     state.eng.flush()
     result = state.eng.backend.get_expectation_value(QubitOperator(op_string), state.qureg)
 
     if not allow_float:
         result = round(result, 5)
         if result == -1:
             return 1
         elif result == 1:
             return 0
         else:
-            print('Operator being measured:', op_string)
-            print('RESULT FOUND:', result)
-            raise Exception('Unexpected result found!')
+            print("Operator being measured:", op_string)
+            print("RESULT FOUND:", result)
+            msg = "Unexpected result found!"
+            raise Exception(msg)
 
     return result
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/projectq/state.py` & `quantum_pecos-0.6.0.dev1/python/pecos/foreign_objects/wasmtime.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,161 +1,138 @@
-# Copyright 2018 The PECOS Developers
-# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
-# DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
+# Copyright 2022 The PECOS Developers
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-A simple wrapper for the ProjectQ simulator.
+from __future__ import annotations
 
-Compatibility checked for: ProjectQ version 0.5.1
-"""
+from pathlib import Path
+from threading import Event
+from typing import TYPE_CHECKING
 
-from ..sim_class_types import StateVector
-from ...circuits import QuantumCircuit
-from projectq import MainEngine
-from projectq.ops import All, Measure
-from . import bindings
-from .logical_sign import find_logical_signs
-from .helper import MakeFunc
-import numpy as np
+from wasmtime import Config, Engine, FuncType, Instance, Module, Store, Trap, TrapCode
 
-from ..gate_syms import alt_symbols
+from pecos.errors import MissingCCOPError, WasmRuntimeError
+from pecos.foreign_objects.foreign_object_abc import ForeignObject
+from pecos.foreign_objects.wasm_execution_timer_thread import (
+    WASM_EXECUTION_MAX_TICKS,
+    WASM_EXECUTION_TICK_LENGTH_S,
+    WasmExecutionTimerThread,
+)
 
+if TYPE_CHECKING:
+    from collections.abc import Sequence
 
-class ProjectQSim(StateVector):
-    """
-    Initializes the stabilizer state.
-
-    Args:
-        num_qubits (int): Number of qubits being represented.
 
-    Returns:
+class WasmtimeObj(ForeignObject):
+    """Wrapper class to create a wasmtime instance and access its functions.
 
+    For more info on using Wasmer, see: https://wasmerio.github.io/wasmer-python/api/wasmer/wasmer.html
     """
 
-    def __init__(self, num_qubits):
-
-        if not isinstance(num_qubits, int):
-            raise Exception('``num_qubits`` should be of type ``int.``')
-
-        super().__init__()
-
-        self.bindings = bindings.gate_dict
-        for k, v in alt_symbols.items():
-            if v in self.bindings:
-                self.bindings[k] = self.bindings[v]
-
-        self.num_qubits = num_qubits
-        self.eng = MainEngine()
-
-        self.qureg = self.eng.allocate_qureg(num_qubits)
-        self.qs = list(self.qureg)
-        self.qids = {i: q for i, q in enumerate(self.qs)}
-        self.gate_dict = {}
-
-    def reset(self):
-        """Reset the quantum state to all 0 for another run without reinitializing."""
-        self.eng.flush()
-        amps = [0] * 2**self.num_qubits
-        amps[0] = 1
-        self.eng.backend.set_wavefunction(amps, self.qureg)
-        return self
-
-    def logical_sign(self, logical_op: QuantumCircuit) -> int:
-        """
-
-        Args:
-            logical_op:
-
-        Returns:
-
-        """
-        return find_logical_signs(self, logical_op,)
-
-    def add_gate(self,
-                 symbol: str,
-                 gate_obj,
-                 make_func: bool = True):
-        """
-        Adds a new gate on the fly to this Simulator.
-
-        Args:
-            symbol:
-            gate_obj:
-            make_func:
-
-        Returns:
-
-        """
-
-        if symbol in self.gate_dict:
-            print('WARNING: Can not add gate as the symbol has already been taken.')
+    def __init__(self, file: str | bytes | Path) -> None:
+        if isinstance(file, (str, Path)):
+            with Path.open(Path(file), "rb") as f:
+                wasm_bytes = f.read()
         else:
-            if make_func:
-                self.gate_dict[symbol] = MakeFunc(gate_obj).func
-            else:
-                self.gate_dict[symbol] = gate_obj
+            wasm_bytes = file
 
-    def get_probs(self, key_basis=None):
-        self.eng.flush()
+        self.wasm_bytes = wasm_bytes
 
-        if key_basis:
-            probs_dict = {}
-            for b in key_basis:
-                b = b[::-1]
-                p =  self.eng.backend.get_probability(b, self.qureg)
-                b = b[::-1]
-                probs_dict[b] = p
-            return probs_dict
+        self.store = None
+        self.module = None
+        self.instance = None
+        self.func_names = None
+
+        self.spin_up_wasm()
+
+    def init(self) -> None:
+        """Initialize object before running a series of experiments."""
+        self.new_instance()
+        self.get_funcs()
+
+        if "init" not in self.get_funcs():
+            msg = "Missing `init()` from Wasm module."
+            raise Exception(msg)
+
+        self.exec("init", [])
+
+    def shot_reinit(self) -> None:
+        """Call before each shot to, e.g., reset variables."""
+        if "shot_reinit" in self.get_funcs():
+            self.exec("shot_reinit", [])
+
+    def new_instance(self) -> None:
+        """Reset object internal state."""
+        self.instance = Instance(self.store, self.module, [])
+
+    def spin_up_wasm(self) -> None:
+        config = Config()
+        config.epoch_interruption = True
+        engine = Engine(config)
+        self.store = Store(engine)
+        self.module = Module(self.store.engine, self.wasm_bytes)
+        self.stop_flag = Event()
+        self.inc_thread_handle = WasmExecutionTimerThread(self.stop_flag, self._increment_engine)
+        self.inc_thread_handle.start()
+        self.new_instance()
+
+    def get_funcs(self) -> list[str]:
+        if self.func_names is None:
+            fs = []
+            for f in self.module.exports:
+                if isinstance(f.type, FuncType):
+                    fs.append(str(f.name))
 
-        else:
-
-            probs_dict = {}
-            for b in range(0, np.power(2, self.num_qubits)):
-                b = format(b, f'0{self.num_qubits}b')
-                p = self.eng.backend.get_probability(b, self.qureg)
-                b = b[::-1]
-                probs_dict[b] = p
-
-            return probs_dict
-
-    def get_amps(self, key_basis=None):
-        self.eng.flush()
-
-        if key_basis:
-            amps_dict = {}
-            for b in key_basis:
-                b = b[::-1]
-                p =  self.eng.backend.get_amplitude(b, self.qureg)
-                b = b[::-1]
-                amps_dict[b] = p
-            return amps_dict
+            self.func_names = fs
 
-        else:
+        return self.func_names
 
-            amp_dict = {}
-            for b in range(0, np.power(2, self.num_qubits)):
-                b = format(b, f'0{self.num_qubits}b')
-                a = self.eng.backend.get_amplitude(b, self.qureg)
-                b = b[::-1]
-                amp_dict[b] = a
-
-            return amp_dict
-
-    def __del__(self):
-        self.eng.flush()
-        All(Measure) | self.qureg  # Requirement by ProjectQ...
+    def _increment_engine(self):
+        self.store.engine.increment_epoch()
 
+    def exec(self, func_name: str, args: Sequence) -> tuple:
         try:
-            self.eng.flush(deallocate_qubits=True)
-        except KeyError:
-            pass
+            func = self.instance.exports(self.store)[func_name]
+        except KeyError as e:
+            message = f"No method found with name {func_name} in WASM"
+            raise MissingCCOPError(message) from e
 
-        # super().__del__()
+        try:
+            self.store.engine.increment_epoch()
+            self.store.set_epoch_deadline(WASM_EXECUTION_MAX_TICKS)
+            output = func(self.store, *args)
+            return output  # noqa: TRY300
+        except Trap as t:
+            if t.trap_code is TrapCode.INTERRUPT:
+                message = (
+                    f"WASM error: WASM failed during run-time. Execution time of "
+                    f"function '{func_name}' exceeded maximum "
+                    f"{WASM_EXECUTION_MAX_TICKS * WASM_EXECUTION_TICK_LENGTH_S}s"
+                )
+            else:
+                message = (
+                    f"WASM error: WASM failed during run-time. Execution of "
+                    f"function '{func_name}' resulted in {t.trap_code}\n"
+                    f"{t.message}"
+                )
+            raise WasmRuntimeError(message) from t
+        except Exception as e:
+            message = f"Error during execution of function '{func_name}' with args {args}"
+            raise WasmRuntimeError(message) from e
+
+    def teardown(self) -> None:
+        self.stop_flag.set()
+        self.inc_thread_handle.join()
+
+    def to_dict(self) -> dict:
+        return {"fobj_class": WasmtimeObj, "wasm_bytes": self.wasm_bytes}
+
+    @staticmethod
+    def from_dict(wasmtime_dict: dict) -> WasmtimeObj:
+        return wasmtime_dict["fobj_class"](wasmtime_dict["wasm_bytes"])
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/quantum_simulator.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/quantum_simulator.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,62 +5,76 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import List, Optional, Union
+from __future__ import annotations
 
-from .projectq.state import ProjectQSim
-from .sparsesim.state import SparseSim
-from ..reps.pypmir.op_types import QOp
+from pecos.simulators.sparsesim.state import SparseSim
 
+try:
+    from pecos.simulators.projectq.state import ProjectQSim
+except ImportError:
+    ProjectQSim = None
+
+from pecos.reps.pypmir.op_types import QOp
 
-class QuantumSimulator:
 
-    def __init__(self,
-                 backend: Optional[Union[str, object]] = None) -> None:
+class QuantumSimulator:
+    def __init__(self, backend: str | object | None = None) -> None:
         self.num_qubits = None
         self.state = None
         self.backend = backend
 
     def reset(self):
         self.num_qubits = None
         self.state = None
 
     def init(self, num_qubits: int):
         self.num_qubits = num_qubits
 
         if isinstance(self.backend, str):
             if self.backend == "stabilizer":
                 self.state = SparseSim
+            elif self.backend == "state-vector":
+                self.state = ProjectQSim
+            else:
+                msg = f"simulator `{self.state}` not currently implemented!"
+                raise NotImplementedError(msg)
 
         if self.backend is None:
-            self.state = ProjectQSim
+            self.state = SparseSim
 
         self.state = self.state(num_qubits=num_qubits)
 
     def shot_reinit(self):
         """Run all code needed at the beginning of each shot, e.g., resetting state."""
         self.state.reset()
 
-    def run(self, qops: List[QOp]) -> list:
+    def run(self, qops: list[QOp]) -> list:
         """Given a list of quantum operations, run them, update the state, and return any measurement results that
-        are generated in the form {qid: result, ...}"""
-
+        are generated in the form {qid: result, ...}.
+        """
         meas = []
         for op in qops:
-            output = self.state.run_gate(op.name, op.args, **op.metadata)
-            if op.returns:
-                temp = {}
-                bitflips = op.metadata.get("bitflips")
-                for q, r in zip(op.args, op.returns):
-                    out = output.get(q, 0)
-                    if bitflips and q in bitflips:
-                        out ^= 1
-
-                    temp[tuple(r)] = out
-
-                meas.append(temp)
+            if op.metadata is None:
+                op.metadata = {}
+            if isinstance(op, QOp):
+                output = self.state.run_gate(op.sim_name, op.args, **op.metadata)
+                if op.returns:
+                    temp = {}
+                    bitflips = op.metadata.get("bitflips")
+                    for q, r in zip(op.args, op.returns):
+                        out = output.get(q, 0)
+                        if bitflips and q in bitflips:
+                            out ^= 1
+
+                        temp[tuple(r)] = out
+
+                    meas.append(temp)
+            else:
+                msg = f"Quantum simulators process type QOp but got type {type(op)}"
+                raise TypeError(msg)
 
         return meas
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/__init__.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,21 @@
-# -*- coding: utf-8 -*-
-
 # Copyright 2018 The PECOS Developers
 # Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract
 # DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.
 #
 # Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 # the License.You may obtain a copy of the License at
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-SparseStabSim
-=============
-
-This is a stabilizer simulation that takes advantage of the structure of LDPC codes; more precisely, it utilizes the 
+"""A stabilizer simulation that takes advantage of the structure of LDPC codes; more precisely, it utilizes the
 row and column-wise sparseness of stabilizer tableau.
 
 .. module:: __init__
    :synopsis: The init file for the package PECOS.
 
 .. moduleauthor:: Ciarn Ryan-Anderson <cryanan@sandia.gov; ciaranra@unm.edu>
 
@@ -31,16 +25,16 @@
 
 Revision history
 
 Date        Author  Comment
 ----------  ------  ----------------------------------------------------------------------------------------------------
 12/28/2014  CRA     File created.
 
-05/23/2017  CRA     The stabilizer simulation was separated from the entire QECC tool chain to allow others to more 
+05/23/2017  CRA     The stabilizer simulation was separated from the entire QECC tool chain to allow others to more
                     easily utilize the simulator on its own. The __init__ file has been reduced and modified for this
                     purpose.
 """
 
-from . import bindings
+from pecos.simulators.sparsesim import bindings
 
 # Class that represents the stabilizer state
-from .state import SparseSim
+from pecos.simulators.sparsesim.state import SparseSim
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/bindings.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/bindings.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,87 +7,77 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from . import cmd_one_qubit as q1
-from . import cmd_two_qubit as q2
-from . import cmd_init as qinit
-from . import cmd_meas as qmeas
+from pecos.simulators.sparsesim import cmd_init as qinit
+from pecos.simulators.sparsesim import cmd_meas as qmeas
+from pecos.simulators.sparsesim import cmd_one_qubit as q1
+from pecos.simulators.sparsesim import cmd_two_qubit as q2
 
 gate_dict = {
     # Initialization
     # ==============
-    'Init +Z': qinit.init_zero,
-    'Init -Z': qinit.init_one,
-    'Init +X': qinit.init_plus,
-    'Init -X': qinit.init_minus,
-    'Init +Y': qinit.init_plusi,
-    'Init -Y': qinit.init_minusi,
-
-    'leak': qinit.init_one,
-    'leak |0>': qinit.init_zero,
-    'leak |1>': qinit.init_one,
-    'unleak |0>': qinit.init_zero,
-    'unleak |1>': qinit.init_one,
-
+    "Init +Z": qinit.init_zero,
+    "Init -Z": qinit.init_one,
+    "Init +X": qinit.init_plus,
+    "Init -X": qinit.init_minus,
+    "Init +Y": qinit.init_plusi,
+    "Init -Y": qinit.init_minusi,
+    "leak": qinit.init_one,
+    "leak |0>": qinit.init_zero,
+    "leak |1>": qinit.init_one,
+    "unleak |0>": qinit.init_zero,
+    "unleak |1>": qinit.init_one,
     # circuit element symbol to function
-
     # one-qubit operations
     # ====================
-
     # Paulis    # x->, z->
-    'I': q1.I,  # +x+z == R(U, 0)
-    'X': q1.X,  # +x-z == R(X, pi)
-    'Y': q1.Y,  # -x-z == R(Y, pi)
-    'Z': q1.Z,  # -x+z == R(Z, pi)
-
+    "I": q1.Identity,  # +x+z == R(U, 0)
+    "X": q1.X,  # +x-z == R(X, pi)
+    "Y": q1.Y,  # -x-z == R(Y, pi)
+    "Z": q1.Z,  # -x+z == R(Z, pi)
     # Square root of Paulis
-    'SX': q1.SX,    # +x-y == R(X, pi/2)
-    'SXdg': q1.SXdg,  # +x+y == R(X, -pi/2)
-    'SY': q1.SY,    # -z+x == R(Y, pi/2)
-    'SYdg': q1.SYdg,  # +z-x == R(Y, -pi/2)
-    'SZ': q1.SZ,    # +y+z == R(Z, pi/2)
-    'SZdg': q1.SZdg,  # -y+z == R(Z, -pi/2)
-
+    "SX": q1.SX,  # +x-y == R(X, pi/2)
+    "SXdg": q1.SXdg,  # +x+y == R(X, -pi/2)
+    "SY": q1.SY,  # -z+x == R(Y, pi/2)
+    "SYdg": q1.SYdg,  # +z-x == R(Y, -pi/2)
+    "SZ": q1.SZ,  # +y+z == R(Z, pi/2)
+    "SZdg": q1.SZdg,  # -y+z == R(Z, -pi/2)
     # Hadamard-like
-    'H': q1.H,
-    'H2': q1.H2,
-    'H3': q1.H3,
-    'H4': q1.H4,
-    'H5': q1.H5,
-    'H6': q1.H6,
-
+    "H": q1.H,
+    "H2": q1.H2,
+    "H3": q1.H3,
+    "H4": q1.H4,
+    "H5": q1.H5,
+    "H6": q1.H6,
     # Face rotations
-    'F': q1.F,    # +y+x
-    'Fdg': q1.Fdg,  # +z+y
-    'F2': q1.F2,    # -z+y
-    'F2dg': q1.F2dg,  # -y-x
-    'F3': q1.F3,    # +y-x
-    'F3dg': q1.F3dg,  # -z-y
-    'F4': q1.F4,    # +z-y
-    'F4dg': q1.F4dg,  # -y-z
-
+    "F": q1.F,  # +y+x
+    "Fdg": q1.Fdg,  # +z+y
+    "F2": q1.F2,  # -z+y
+    "F2dg": q1.F2dg,  # -y-x
+    "F3": q1.F3,  # +y-x
+    "F3dg": q1.F3dg,  # -z-y
+    "F4": q1.F4,  # +z-y
+    "F4dg": q1.F4dg,  # -y-z
     # two-qubit operations
     # ====================
-    'CX': q2.CX,
-    'CY': q2.CY,
-    'CZ': q2.CZ,
-    'SWAP': q2.SWAP,
-    'G': q2.G2,
-    'G2': q2.G2,
-    'II': q2.II,
-
-    # MlmerSrensen gates
-    'SXX': q2.SXX,  # \equiv e^{+i (\pi /4)} * e^{-i (\pi /4) XX } == R(XX, pi/2)
-    'SYY': q2.SYY,
-    'SZZ': q2.SZZ,
-
+    "CX": q2.CX,
+    "CY": q2.CY,
+    "CZ": q2.CZ,
+    "SWAP": q2.SWAP,
+    "G": q2.G2,
+    "G2": q2.G2,
+    "II": q2.II,
+    # Mlmer-Srensen gates
+    "SXX": q2.SXX,  # \equiv e^{+i (\pi /4)} * e^{-i (\pi /4) XX } == R(XX, pi/2)
+    "SYY": q2.SYY,
+    "SZZ": q2.SZZ,
     # Measurements
     # ============
-    'Measure +X': qmeas.meas_x,
-    'Measure +Y': qmeas.meas_y,
-    'Measure +Z': qmeas.meas_z,
-    'force output': qmeas.force_output,
+    "Measure +X": qmeas.meas_x,
+    "Measure +Y": qmeas.meas_y,
+    "Measure +Z": qmeas.meas_z,
+    "force output": qmeas.force_output,
 }
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/cmd_init.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/cmd_init.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,119 +9,97 @@
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from typing import Any
 
-from .state import SparseSim
-from .cmd_meas import meas_z
-from .cmd_one_qubit import H, H2, H5, H6, X
+from pecos.simulators.sparsesim.cmd_meas import meas_z
+from pecos.simulators.sparsesim.cmd_one_qubit import H2, H5, H6, H, X
+from pecos.simulators.sparsesim.state import SparseSim
 
 
-def init_zero(state: SparseSim,
-              qubit: int,
-              **params: Any) -> None:
+def init_zero(state: SparseSim, qubit: int, **params: Any) -> None:
     """
 
     Args:
-        state (SparseSim): Instance representing the stabilizer state.
-        qubit (int): Integer that indexes the qubit being acted on.
+        state: Instance representing the stabilizer state.
+        qubit: Integer that indexes the qubit being acted on.
+        **params:
 
     Returns: None
 
     """
-
     # Measure in the Z basis. (If random outcome, force a 0 outcome).
     # If outcome is 1 apply an X.
-    if meas_z(state, qubit, 0):
+    if meas_z(state, qubit, forced_outcome=0):
         X(state, qubit)
 
 
-def init_one(state: SparseSim,
-             qubit: int,
-             **params: Any) -> None:
-    """
-    Initialize qubit in state |1>.
+def init_one(state: SparseSim, qubit: int, **params: Any) -> None:
+    """Initialize qubit in state |1>.
 
     Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
-    if not meas_z(state, qubit, 1):
+    if not meas_z(state, qubit, forced_outcome=1):
         X(state, qubit)
 
 
-def init_plus(state: SparseSim,
-              qubit: int,
-              **params: Any) -> None:
-    """
-    Initialize qubit in state |+>.
+def init_plus(state: SparseSim, qubit: int, **params: Any) -> None:
+    """Initialize qubit in state |+>.
 
     Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     init_zero(state, qubit)
     H(state, qubit)
 
 
-def init_minus(state: SparseSim,
-               qubit: int,
-               **params: Any) -> None:
-    """
-    Initialize qubit in state |->
+def init_minus(state: SparseSim, qubit: int, **params: Any) -> None:
+    """Initialize qubit in state |->.
 
     Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     init_zero(state, qubit)
     H2(state, qubit)
 
 
-def init_plusi(state: SparseSim,
-               qubit: int,
-               **params: Any) -> None:
-    """
-    Initialize qubit in state |+i>
+def init_plusi(state: SparseSim, qubit: int, **params: Any) -> None:
+    """Initialize qubit in state |+i>.
 
     Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     init_zero(state, qubit)
     H5(state, qubit)
 
 
-def init_minusi(state: SparseSim,
-                qubit: int,
-                **params: Any) -> None:
-    """
-    Initialize qubit in state |-i>
+def init_minusi(state: SparseSim, qubit: int, **params: Any) -> None:
+    """Initialize qubit in state |-i>.
 
     Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     init_zero(state, qubit)
     H6(state, qubit)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/cmd_meas.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/cmd_meas.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,181 +7,159 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Set, Any
+from typing import Any
+
 import numpy as np
-from .state import SparseSim
-from .cmd_one_qubit import H, H5
 
+from pecos.simulators.sparsesim.cmd_one_qubit import H5, H
+from pecos.simulators.sparsesim.state import SparseSim
 
-def meas_x(state: SparseSim,
-           qubit: int,
-           forced_outcome: int = -1,
-           collapse: bool = True,
-           **params: Any) -> int:
-    """
-    Measurement in the X basis.
+
+def meas_x(state: SparseSim, qubit: int, *, forced_outcome: int = -1, collapse: bool = True, **params) -> int:
+    """Measurement in the X basis.
 
     Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
         forced_outcome (int):  Integer that will be outputted by the measurement if the measurement is
             non-deterministic. If equal to -1, however, the outcome will be uniformly chosen from {0, 1}.
         collapse (bool): Whether state should be collapsed.
 
-    Returns: int
+    Returns:
+        Measurement outcome (0 or 1).
 
     """
-
     H(state, qubit)
 
-    meas_outcome = meas_z(state, qubit, forced_outcome, collapse)
+    meas_outcome = meas_z(state, qubit, forced_outcome=forced_outcome, collapse=collapse)
 
     H(state, qubit)
 
     return meas_outcome
 
 
-def meas_y(state: SparseSim,
-           qubit: int,
-           forced_outcome: int = -1,
-           collapse: bool = True,
-           **params: Any) -> int:
-    """
-    Measurement in the Y basis.
+def meas_y(state: SparseSim, qubit: int, *, forced_outcome: int = -1, collapse: bool = True, **params) -> int:
+    """Measurement in the Y basis.
 
     Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
         forced_outcome (int):  Integer that will be outputted by the measurement if the measurement is
             non-deterministic. If equal to -1, however, the outcome will be uniformly chosen from {0, 1}.
         collapse (bool): Whether to collapse the state if measurement is not already determined.
 
-    Returns: int
+    Returns:
+        Measurement outcome (0 or 1).
 
     """
-
     H5(state, qubit)
 
-    meas_outcome = meas_z(state, qubit, forced_outcome, collapse)
+    meas_outcome = meas_z(state, qubit, forced_outcome=forced_outcome, collapse=collapse)
 
     H5(state, qubit)
 
     return meas_outcome
 
 
-def meas_z(state: SparseSim,
-           qubit: int,
-           forced_outcome: int = -1,
-           collapse: bool = True,
-           **params: Any) -> int:
-    """
-
-    Args:
+def meas_z(state: SparseSim, qubit: int, *, forced_outcome: int = -1, collapse: bool = True, **params) -> int:
+    """Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
         forced_outcome (int):  Integer that will be outputted by the measurement if the measurement is
             non-deterministic. If equal to -1, however, the outcome will be uniformly chosen from {0, 1}.
         collapse (bool): Whether to collapse the state if measurement is not already determined.
 
-    Returns: int
+    Returns:
+        Measurement outcome (0 or 1).
 
     """
-
     # Determine if any stabilizer gens anti-commute with the Z measurement on the qubit
     # => Get the stabilizer generators that have Xs on the qubit we are measuring.
 
     # Choose an anti-commuting stabilizer to replace.
 
     stabs = state.stabs
     destabs = state.destabs
 
-    # stabs_test = deepcopy(gens)
-
     anticom_stabs_col = stabs.col_x[qubit]
     anticom_destabs_col = destabs.col_x[qubit]
 
     if len(anticom_stabs_col) == 0:  # No anti-commuting stabilizer => determined sign
-
         stabs_row_x = stabs.row_x
         stabs_row_z = stabs.row_z
 
         num_minuses = len(anticom_destabs_col & stabs.signs_minus)
         num_is = len(anticom_destabs_col & stabs.signs_i)
 
         # Sign correction due ZX -> -XZ
-        cumulative_x = set([])
+        cumulative_x = set()
         for row in anticom_destabs_col:
             num_minuses += len(stabs_row_z[row] & cumulative_x)
 
             # Update the row sum Paulis
             cumulative_x ^= stabs_row_x[row]
 
         if num_is % 4:  # Can only be 0 or 2
             num_minuses += 1
 
         meas_outcome = num_minuses % 2
 
     else:  # There is at least one anti-commuting stabilizer. => indetermined sign
-
         if collapse:
             return nondeterministic_meas(state, qubit, anticom_stabs_col, anticom_destabs_col, forced_outcome)
 
         else:
             if forced_outcome is not None:
-
-                if forced_outcome == 0 or forced_outcome == 1:
+                if forced_outcome in {0, 1}:
                     meas_outcome = forced_outcome
                 else:
-                    raise Exception('forced_outcome can only be 0 or 1 and not %s' % forced_outcome)
+                    raise Exception("forced_outcome can only be 0 or 1 and not %s" % forced_outcome)
             else:
                 meas_outcome = np.random.randint(2)
 
     return meas_outcome
 
 
-def nondeterministic_meas(state: SparseSim,
-                          qubit: int,
-                          anticom_stabs_col: Set[int],
-                          anticom_destabs_col: Set[int],
-                          forced_outcome: int) -> int:
-    """
-
-    Args:
+def nondeterministic_meas(
+    state: SparseSim,
+    qubit: int,
+    anticom_stabs_col: set[int],
+    anticom_destabs_col: set[int],
+    forced_outcome: int,
+) -> int:
+    """Args:
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
         anticom_stabs_col (Set[int]):
         anticom_destabs_col (Set[int]):
         forced_outcome (int):  Integer that will be outputted by the measurement if the measurement is
             non-deterministic. If equal to -1, however, the outcome will be uniformly chosen from {0, 1}.
 
     Returns:
+        Measurement outcome (0 or 1).
 
     """
-
     # Removing dots
     stabs_row_x = state.stabs.row_x
     stabs_row_z = state.stabs.row_z
     destabs_row_x = state.destabs.row_x
     destabs_row_z = state.destabs.row_z
     stabs_col_x = state.stabs.col_x
     stabs_col_z = state.stabs.col_z
     destabs_col_x = state.destabs.col_x
     destabs_col_z = state.destabs.col_z
 
     anticom_stabs_col = set(anticom_stabs_col)  # Stabilizers that anti-commute with the measurement
     anticom_destabs_col = set(anticom_destabs_col)  # Destabilizers that anti-commute
 
-    # removed_id = anticom_stabs_col.pop()
-    # anticom_destabs_col.discard(removed_id)
-
     smallest_wt = 2 * state.num_qubits + 2
     removed_id = None
 
     for stab_id in anticom_stabs_col:
         if len(stabs_row_x[stab_id]) + len(stabs_row_z[stab_id]) < smallest_wt:
             smallest_wt = len(stabs_row_x[stab_id]) + len(stabs_row_z[stab_id])
             removed_id = stab_id
@@ -216,15 +194,14 @@
         # Generators that are only in Z can just be added => i*1 = i
         state.stabs.signs_i |= gens_only_stabs
 
     # ----------------------------------------------------------------
     # Multiply anti-commuting stabs with removed stab.
     # ----------------------------------------------------------------
     for gen in anticom_stabs_col:
-
         # ZX -> -XZ sign correction
         num_minuses = len(removed_row_z & stabs_row_x[gen])
         if num_minuses % 2:  # An overall minus occurred when multiply by removed row.
             state.stabs.signs_minus ^= {gen}
 
         # row sum stabilizers
         stabs_row_x[gen] ^= removed_row_x
@@ -305,39 +282,34 @@
             meas_outcome = forced_outcome
         else:
             raise Exception('forced_outcome can only be 0 or 1 and not %s' % forced_outcome)
     else:
         meas_outcome = np.random.randint(2)
     """
 
-    if forced_outcome > -1:
-            meas_outcome = forced_outcome
-    else:
-        meas_outcome = np.random.randint(2)
+    meas_outcome = forced_outcome if forced_outcome > -1 else np.random.randint(2)
 
     # Use the random outcome as the sign of the replaced stabilizer
     if meas_outcome:
         state.stabs.signs_minus.add(removed_id)
     else:
         state.stabs.signs_minus.discard(removed_id)
 
     return meas_outcome
 
 
-def force_output(state: SparseSim,
-                 qubit: int,
-                 forced_output: int = -1,
-                 **params: Any) -> int:
-    """
-    Outputs value.
+def force_output(state: SparseSim, qubit: int, forced_output: int = -1, **params: Any) -> int:
+    """Outputs value.
 
     Used for error generators to generate outputs when replacing measurements.
 
     Args:
+    ----
         state (SparseSim): Instance representing the stabilizer state.
         qubit (int): Integer that indexes the qubit being acted on.
         forced_output (int): Integer that will be outputted.
 
-    Returns: int
+    Returns:
+        Measurement outcome that is force to be a particular value.
 
     """
     return forced_output
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/cmd_one_qubit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/cmd_one_qubit.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,37 +9,30 @@
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from typing import Any
 
-from .state import SparseSim
+from pecos.simulators.sparsesim.state import SparseSim
 
 
-def I(state: SparseSim,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Identity, which does nothing.
+def Identity(state: SparseSim, qubit: int, **params: Any) -> None:
+    """Identity, which does nothing.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-    pass
 
 
-def X(state: SparseSim,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    X
+def X(state: SparseSim, qubit: int, **params: Any) -> None:
+    """X
     Returns:
 
     X -> X
     Z -> -Z
     W -> -W
     Y -> -Y
     => If you have a Z component, add a -1.
@@ -55,76 +48,65 @@
     # Change the sign appropriately
 
     # Z -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_z[qubit]
 
 
-def Y(state: SparseSim,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Pauli Y.
+def Y(state: SparseSim, qubit: int, **params: Any) -> None:
+    """Pauli Y.
 
     X -> -X
     Z -> -Z
     W -> W
     Y -> Y
     => If you have an X or Z component but not both, add a -1.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X or Z (exclusive) -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] ^ stabs.col_z[qubit]
 
 
-def Z(state: SparseSim,
-      qubit: int,
-      **params: Any) -> None:
-    """
-    Z
+def Z(state: SparseSim, qubit: int, **params: Any) -> None:
+    """Z
     Returns:
 
     X -> -X
     Z -> Z
     W -> -W
     Y -> -Y
     => If you have a X component, add a -1.
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
-   """
-
+    """
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit]
 
 
-def SX(state: SparseSim,
-      qubit: int,
-      **params: Any) -> None:
-    r"""
-    Applies a Q rotation to stabilizers and destabilizers
+def SX(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Q rotation to stabilizers and destabilizers.
 
     Q = \sqrt{X} = HSH
 
     Q = Q
     X = Q^2
     Q^{\dagger} = Q^3
     I = Q^4
@@ -136,15 +118,14 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # Z -> -1
     # ---------------------
     stabs.signs_minus ^= stabs.col_z[qubit]
@@ -177,19 +158,16 @@
         # X += Z
         g.col_x[qubit] ^= g.col_z[qubit]
 
         for i in g.col_z[qubit]:
             g.row_x[i] ^= {qubit}
 
 
-def SXdg(state: SparseSim,
-         qubit: int,
-         **params: Any) -> None:
-    r"""
-    Applies a Q^{\dagger} rotation to stabilizers and destabilizers
+def SXdg(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Q^{\dagger} rotation to stabilizers and destabilizers.
 
     Qd = \sqrt{X}^{\dagger} = H S^{\dagger}H
 
     Q = Q
     X = Q^2
     Q^{\dagger} = Q^3
     I = Q^4
@@ -201,15 +179,14 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # Z -> i
     # ---------------------
 
@@ -232,28 +209,24 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_z
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Update column
         # X += Z
         g.col_x[qubit] ^= g.col_z[qubit]
 
         for i in g.col_z[qubit]:
             g.row_x[i] ^= {qubit}
 
 
-def SY(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a R rotation to stabilizers and destabilizers
+def SY(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a R rotation to stabilizers and destabilizers.
 
     R = \sqrt{XZ} = SQS^{\dagger}
 
     R = R
     XZ = R^2
     R^{\dagger} = R^3
     I = R^4
@@ -265,25 +238,23 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X not Z -> -1
     # ---------------------
     stabs.signs_minus ^= stabs.col_x[qubit] - stabs.col_z[qubit]
 
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         for i in xonly:
             g.row_x[i].discard(qubit)
@@ -293,19 +264,16 @@
             g.row_z[i].discard(qubit)
             g.row_x[i].add(qubit)
 
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
 
-def SYdg(state: SparseSim,
-         qubit: int,
-         **params: Any) -> None:
-    r"""
-    Applies a R rotation to stabilizers and destabilizers
+def SYdg(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a R rotation to stabilizers and destabilizers.
 
     R^{\dagger} = \sqrt{XZ} = SQ^{\dagger}S^{\dagger}
 
     R = R
     XZ = R^2
     R^{\dagger} = R^3
     I = R^4
@@ -317,27 +285,25 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # Z not X -> -1
     # ---------------------
     stabs.signs_minus ^= stabs.col_z[qubit] - stabs.col_x[qubit]
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         for i in xonly:
             g.row_x[i].discard(qubit)
@@ -347,19 +313,16 @@
             g.row_z[i].discard(qubit)
             g.row_x[i].add(qubit)
 
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
 
-def SZ(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a phase gate (S) rotation to stabilizers and destabilizers
+def SZ(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a phase gate (S) rotation to stabilizers and destabilizers.
 
     S = \sqrt{Z}
 
     This is P in CHP.
 
     S = S
     Z = S^2
@@ -387,29 +350,25 @@
     stabs.signs_minus ^= stabs.signs_i & stabs.col_x[qubit]
     # For each X add an i unless there is already an i there then delete it.
     stabs.signs_i ^= stabs.col_x[qubit]
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Update column
         # Z += X
         g.col_z[qubit] ^= g.col_x[qubit]
 
         # Update row
         for i in g.col_x[qubit]:
             g.row_z[i] ^= {qubit}
 
 
-def SZdg(state: SparseSim,
-         qubit: int,
-         **params: Any) -> None:
-    r"""
-    Applies a Hermitian adjoint phase gate (S^{\dagger}) rotation to stabilizers and destabilizers
+def SZdg(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Hermitian adjoint phase gate (S^{\dagger}) rotation to stabilizers and destabilizers.
 
     S = S
     Z = S^2
     S^{\dagger} = S^3
     I = S^4
 
     X -> -iW = -Y
@@ -419,15 +378,14 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X -> -1
     # ---------------------
     stabs.signs_minus ^= stabs.col_x[qubit]
@@ -451,28 +409,24 @@
 
     # Generators that are only in X can just be added => i*1 = i
     stabs.signs_i |= gens_only_x
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Update column
         # Z += X
         g.col_z[qubit] ^= g.col_x[qubit]
 
         for i in g.col_x[qubit]:
             g.row_z[i] ^= {qubit}
 
 
-def H(state: SparseSim,
-      qubit: int,
-      **params: Any) -> None:
-    r"""
-    Applies a Hadamard gate (H) rotation to stabilizers and destabilizers
+def H(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Hadamard gate (H) rotation to stabilizers and destabilizers.
 
     Same as H1 in some places in PECOS.
 
     X + Z
 
     X -> Z
     Z -> X
@@ -481,27 +435,25 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X and Z -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] & stabs.col_z[qubit]
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         for i in xonly:
             g.row_x[i].discard(qubit)
@@ -511,46 +463,41 @@
             g.row_z[i].discard(qubit)
             g.row_x[i].add(qubit)
 
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
 
-def H2(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a Hadamard gate (H4) rotation to stabilizers and destabilizers
+def H2(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Hadamard gate (H4) rotation to stabilizers and destabilizers.
 
     X - Z
 
     X -> -Z
     Z -> -X
     W -> -W
     Y -> -Y
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X or Z (inclusive) -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] | stabs.col_z[qubit]
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         for i in xonly:
             g.row_x[i].discard(qubit)
@@ -560,34 +507,30 @@
             g.row_z[i].discard(qubit)
             g.row_x[i].add(qubit)
 
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
 
-def H3(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a Hadamard gate (H3) rotation to stabilizers and destabilizers
+def H3(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Hadamard gate (H3) rotation to stabilizers and destabilizers.
 
     Y + X
 
     X -> iW = Y
     Z -> -Z
     W -> -iX
     Y -> X
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # Z -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_z[qubit]
@@ -613,43 +556,38 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_x
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Update column
         # X += Z
         g.col_z[qubit] ^= g.col_x[qubit]
 
         for i in g.col_x[qubit]:
             g.row_z[i] ^= {qubit}
 
 
-def H4(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a Hadamard gate (H6) rotation to stabilizers and destabilizers
+def H4(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Hadamard gate (H6) rotation to stabilizers and destabilizers.
 
     Y - X
 
     X -> -iW = -Y
     Z -> -Z
     W -> iX
     Y -> -X
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X or Z (exclusive) -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] ^ stabs.col_z[qubit]
@@ -675,37 +613,32 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_x
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Update column
         # X += Z
         g.col_z[qubit] ^= g.col_x[qubit]
 
         for i in g.col_x[qubit]:
             g.row_z[i] ^= {qubit}
 
 
-def H5(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a Hadamard gate (H2) rotation to stabilizers and destabilizers
+def H5(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Hadamard gate (H2) rotation to stabilizers and destabilizers.
 
     Z + Y
 
     X -> -X
     Z -> iW = Y
     W -> -iZ
     Y -> Z
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
     # If X apply -1
     # If Z apply i
 
     # X -> -1
@@ -741,34 +674,30 @@
         # X += Z
         g.col_x[qubit] ^= g.col_z[qubit]
 
         for i in g.col_z[qubit]:
             g.row_x[i] ^= {qubit}
 
 
-def H6(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a Hadamard gate (H5) rotation to stabilizers and destabilizers
+def H6(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a Hadamard gate (H5) rotation to stabilizers and destabilizers.
 
     Z - Y
 
     X -> -X
     Z -> -iW = -Y
     W -> iZ
     Y -> -Z
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X or Z (exclusive) -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] ^ stabs.col_z[qubit]
@@ -802,32 +731,28 @@
         # X += Z
         g.col_x[qubit] ^= g.col_z[qubit]
 
         for i in g.col_z[qubit]:
             g.row_x[i] ^= {qubit}
 
 
-def F(state: SparseSim,
-      qubit: int,
-      **params: Any) -> None:
-    r"""
-    Applies a rotation (F1) about a stabilizer octahedron face to stabilizers  and destabilizers
+def F(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a rotation (F1) about a stabilizer octahedron face to stabilizers  and destabilizers.
 
     X -> iW = Y
     Z -> X
     W -> -iZ
     Y -> Z
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # both X and Z -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] & stabs.col_z[qubit]
@@ -853,15 +778,14 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_x
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         xzshared = g.col_x[qubit] & g.col_z[qubit]
 
@@ -880,32 +804,28 @@
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
         # X += Z
         g.col_x[qubit] ^= g.col_z[qubit]
 
 
-def F2(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a rotation (F2) about a stabilizer octahedron face to stabilizers and destabilizers
+def F2(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a rotation (F2) about a stabilizer octahedron face to stabilizers and destabilizers.
 
     X -> -Z
     Z -> iW = Y
     W -> iX
     Y -> -X
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X not Z -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] - stabs.col_z[qubit]
@@ -931,15 +851,14 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_z
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         xzshared = g.col_x[qubit] & g.col_z[qubit]
 
@@ -958,32 +877,28 @@
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
         # Z += X
         g.col_z[qubit] ^= g.col_x[qubit]
 
 
-def F3(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a rotation (F3) about a stabilizer octahedron face to stabilizers and destabilizers
+def F3(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a rotation (F3) about a stabilizer octahedron face to stabilizers and destabilizers.
 
     X -> iW = Y
     Z -> -X
     W -> iZ
     Y -> -Z
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # Z not X -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_z[qubit] - stabs.col_x[qubit]
@@ -1009,15 +924,14 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_x
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         xzshared = g.col_x[qubit] & g.col_z[qubit]
 
@@ -1036,32 +950,28 @@
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
         # X += Z
         g.col_x[qubit] ^= g.col_z[qubit]
 
 
-def F4(state: SparseSim,
-       qubit: int,
-       **params: Any) -> None:
-    r"""
-    Applies a rotation (F4) about a stabilizer octahedron face to stabilizers and destabilizers
+def F4(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a rotation (F4) about a stabilizer octahedron face to stabilizers and destabilizers.
 
     X -> Z
     Z -> -iW = -Y
     W -> iX
     Y -> -X
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # Z not X -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_z[qubit] - stabs.col_x[qubit]
@@ -1087,15 +997,14 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_z
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         xzshared = g.col_x[qubit] & g.col_z[qubit]
 
@@ -1114,32 +1023,28 @@
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
         # Z += X
         g.col_z[qubit] ^= g.col_x[qubit]
 
 
-def Fdg(state: SparseSim,
-        qubit: int,
-        **params: Any) -> None:
-    r"""
-    Applies a rotation (F1^{\dagger}) about a stabilizer octahedron face to stabilizers and destabilizers
+def Fdg(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a rotation (F1^{\dagger}) about a stabilizer octahedron face to stabilizers and destabilizers.
 
     X -> Z
     Z -> iW = Y
     W -> -iX
     Y -> X
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X and Z -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] & stabs.col_z[qubit]
@@ -1165,15 +1070,14 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_z
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         xzshared = g.col_x[qubit] & g.col_z[qubit]
 
@@ -1192,32 +1096,28 @@
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
         # Z += X
         g.col_z[qubit] ^= g.col_x[qubit]
 
 
-def F2dg(state: SparseSim,
-         qubit: int,
-         **params: Any) -> None:
-    r"""
-    Applies a rotation (F2^{\dagger}) about a stabilizer octahedron face to stabilizers and destabilizers
+def F2dg(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a rotation (F2^{\dagger}) about a stabilizer octahedron face to stabilizers and destabilizers.
 
     X -> -iW = -Y
     Z -> -X
     W -> -iZ
     Y -> Z
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X or Z (inclusive) -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] | stabs.col_z[qubit]
@@ -1243,15 +1143,14 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_x
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         xzshared = g.col_x[qubit] & g.col_z[qubit]
 
@@ -1270,32 +1169,28 @@
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
         # X += Z
         g.col_x[qubit] ^= g.col_z[qubit]
 
 
-def F3dg(state: SparseSim,
-         qubit: int,
-         **params: Any) -> None:
-    r"""
-    Applies a rotation (F3^{\dagger}) about a stabilizer octahedron face to stabilizers and destabilizers
+def F3dg(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a rotation (F3^{\dagger}) about a stabilizer octahedron face to stabilizers and destabilizers.
 
     X -> -Z
     Z -> -iW = -Y
     W -> -iX
     Y -> X
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X or Z (inclusive) -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] | stabs.col_z[qubit]
@@ -1321,15 +1216,14 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_z
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         xzshared = g.col_x[qubit] & g.col_z[qubit]
 
@@ -1348,32 +1242,28 @@
         # Swap X and Z for cols
         g.col_x[qubit], g.col_z[qubit] = g.col_z[qubit], g.col_x[qubit]
 
         # Z += X
         g.col_z[qubit] ^= g.col_x[qubit]
 
 
-def F4dg(state: SparseSim,
-         qubit: int,
-         **params: Any) -> None:
-    r"""
-    Applies a rotation (F4^{\dagger}) about a stabilizer octahedron face to stabilizers and destabilizers
+def F4dg(state: SparseSim, qubit: int, **params: Any) -> None:
+    r"""Applies a rotation (F4^{\dagger}) about a stabilizer octahedron face to stabilizers and destabilizers.
 
     X -> -iW = -Y
     Z -> X
     W -> iZ
     Y -> -Z
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     stabs = state.stabs
 
     # Change the sign appropriately
 
     # X not Z -> -1
     # ----------
     stabs.signs_minus ^= stabs.col_x[qubit] - stabs.col_z[qubit]
@@ -1399,15 +1289,14 @@
 
     # Generators that are only in Z can just be added => i*1 = i
     stabs.signs_i |= gens_only_x
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Swap X and Z for rows
         xonly = g.col_x[qubit] - g.col_z[qubit]
 
         zonly = g.col_z[qubit] - g.col_x[qubit]
 
         xzshared = g.col_x[qubit] & g.col_z[qubit]
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/cmd_two_qubit.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/cmd_two_qubit.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,28 +7,25 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from typing import Tuple, Any
-from .state import SparseSim
-from .cmd_one_qubit import SX, SZ, SZdg, SY, SYdg, X
+from typing import Any
 
+from pecos.simulators.sparsesim.cmd_one_qubit import SX, SY, SZ, SYdg, SZdg, X
+from pecos.simulators.sparsesim.state import SparseSim
 
-def CX(state: SparseSim,
-         qubits: Tuple[int, int],
-         **params: Any) -> None:
-    """
 
-    XI -> XX
+def CX(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """XI -> XX
     IX -> IX
     ZI -> ZI
-    IZ -> ZZ
+    IZ -> ZZ.
 
 
     II -> II
     XI -> XX
     ZI -> ZI
     WI -> WX
     IX -> IX
@@ -63,15 +60,14 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     qubit1, qubit2 = qubits
 
     set_q1 = {qubit1}
     set_q2 = {qubit2}
 
     # Update Paulis
     # -------------------------------------------------------------------
@@ -89,19 +85,16 @@
         g.col_x[qubit2] ^= g.col_x[qubit1]
 
         # Update the Z column
         # Z1 += Z2
         g.col_z[qubit1] ^= g.col_z[qubit2]
 
 
-def CZ(state: SparseSim,
-       qubits: Tuple[int, int],
-       **params: Any) -> None:
-    """
-    Applies a Controlled-Z gate (CZ) rotation.
+def CZ(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies a Controlled-Z gate (CZ) rotation.
 
     This version is best for a large number of qubits (aboa ut >= 150)
 
     XI -> XZ
     IX -> ZX
     ZI -> ZI
     IZ -> IZ
@@ -142,26 +135,24 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     qubit1, qubit2 = qubits
 
     stabs = state.stabs
 
     # Change the sign appropriately
     stabs.signs_minus ^= stabs.col_x[qubit1] & stabs.col_x[qubit2]
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         old_z1_col = set(g.col_z[qubit1])
         old_z2_col = set(g.col_z[qubit2])
 
         # Update columns
 
         # Z1 += X2
         g.col_z[qubit1] ^= g.col_x[qubit2]
@@ -191,44 +182,37 @@
         for i in z1_removed:
             g.row_z[i].discard(qubit1)
 
         for i in z2_removed:
             g.row_z[i].discard(qubit2)
 
 
-def CY(state: SparseSim,
-       qubits: Tuple[int, int],
-       **params: Any) -> None:
-    """
-    Applies a Controlled-Y gate
+def CY(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies a Controlled-Y gate.
 
     XI -> XY
     IX -> ZX
     ZI -> ZI
     IZ -> ZZ
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     _, qubit2 = qubits
 
     SZ(state, qubit2)
     CX(state, qubits)
     SZdg(state, qubit2)
 
 
-def SWAP(state: SparseSim,
-         qubits: Tuple[int, int],
-         **params: Any) -> None:
-    """
-    Applies a SWAP gate to the generators
+def SWAP(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies a SWAP gate to the generators.
 
     XI -> IX
     IX -> XI
     ZI -> IX
     IZ -> XI
 
     II -> II
@@ -250,21 +234,19 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     qubit1, qubit2 = qubits
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # Update rows
 
         # Swap the Xs of qubit1 and qubit2 for rows
 
         # set of gens with Xs on qubit1 but not qubit2
         xin1 = g.col_x[qubit1] - g.col_x[qubit2]
 
@@ -306,19 +288,16 @@
         # Swap the Xs of qubit1 and qubit2 for cols
         g.col_x[qubit1], g.col_x[qubit2] = g.col_x[qubit2], g.col_x[qubit1]
 
         # Swap the Zs of qubit1 and qubit2 for cols
         g.col_z[qubit1], g.col_z[qubit2] = g.col_z[qubit2], g.col_z[qubit1]
 
 
-def G2(state: SparseSim,
-       qubits: Tuple[int, int],
-       **params: Any) -> None:
-    """
-    Applies a CZ.H(1).H(2).CZ to the generators
+def G2(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies a CZ.H(1).H(2).CZ to the generators.
 
     XI -> IX
     IX -> XI
     ZI -> XZ
     IZ -> ZX
 
     This gate has a Schmidt rank of 4
@@ -342,27 +321,25 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     qubit1, qubit2 = qubits
 
     stabs = state.stabs
 
     # Change the sign appropriately
     # sign += Z1*Z2
     stabs.signs_minus ^= stabs.col_z[qubit1] & stabs.col_z[qubit2]
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         # set of gens with Zs on qubit1 but not qubit2
         zin1 = g.col_z[qubit1] - g.col_z[qubit2]
 
         # set of gens with Zs on qubit2 but not qubit1
         zin2 = g.col_z[qubit2] - g.col_z[qubit1]
 
         old_x1_col = set(g.col_x[qubit1])
@@ -424,39 +401,32 @@
         for i in x2_removed:
             g.row_x[i].discard(qubit2)
 
         del x1_removed
         del x2_removed
 
 
-def II(state: SparseSim,
-       qubits: Tuple[int, int],
-       **params: Any) -> None:
-    """
-    Two qubit identity.
+def II(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """Two qubit identity.
 
     XI -> XI
     IX -> IX
     ZI -> ZI
     IZ -> IZ
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-    pass
 
 
-def SXX(state: SparseSim,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    """
-    Applies a square root of XX rotation to generators
+def SXX(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies a square root of XX rotation to generators.
 
     XI -> XI
     IX -> IX
     ZI -> -YX
     IZ -> -XY
 
     sign rule: if odd # of Zs -> -i
@@ -498,15 +468,14 @@
 
     state (SparseSim): Instance representing the stabilizer state.
     qubit (int): Integer that indexes the qubit being acted on.
 
     Returns: None
 
     """
-
     qubit1, qubit2 = qubits
 
     stabs = state.stabs
 
     # Change the sign appropriately
     oddzs = stabs.col_z[qubit1] ^ stabs.col_z[qubit2]
     stabs.signs_minus ^= oddzs
@@ -524,15 +493,14 @@
 
     # 1*i = i
     stabs.signs_i |= add_is
 
     # Update Paulis
     # -------------------------------------------------------------------
     for g in state.gens:
-
         old_x1_col = set(g.col_x[qubit1])
         old_x2_col = set(g.col_x[qubit2])
 
         # Add XX if odd number of Zs
         oddzs = g.col_z[qubit1] ^ g.col_z[qubit2]
 
         # Update columns
@@ -561,28 +529,23 @@
         for i in x1_removed:
             g.row_x[i].discard(qubit1)
 
         for i in x2_removed:
             g.row_x[i].discard(qubit2)
 
 
-def SXXdg(state: SparseSim,
-          qubits: Tuple[int, int],
-          **params: Any) -> None:
+def SXXdg(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
     qubit1, qubit2 = qubits
     X(state, qubit1)
     X(state, qubit2)
     SXX(state, qubits)
 
 
-def SqrtXX2(state: SparseSim,
-            qubits: Tuple[int, int],
-            **params: Any) -> None:
-    """
-    Applies a square root of XX rotation to generators
+def SqrtXX2(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """Applies a square root of XX rotation to generators.
 
     XI -> XI
     IX -> IX
     ZI -> -YX
     IZ -> -XY
 
     sign rule: if odd # of Zs -> -i
@@ -632,133 +595,126 @@
     SX(state, qubit1)  # Sqrt X
     SX(state, qubit2)  # Sqrt X
     SYdg(state, qubit1)  # (Sqrt Y)^\dagger
     CX(state, qubits)  # CNOT (why didn't I capitalized this?)
     SY(state, qubit1)  # Sqrt Y
 
 
-def SYY(state: SparseSim,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    r"""
-    Sqrt of YY == (rZ,rZ).SqrtXX.(rZd,rZd)
+def SYY(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    r"""Sqrt of YY == (rZ,rZ).SqrtXX.(rZd,rZd).
 
     XI -> -ZY
     IX -> -YZ
     ZI -> XY
     IZ -> YX
 
     TODO: verify implementation!
 
     Args:
+    ----
         state:
         qubits:
 
     Returns:
+    -------
 
     """
     qubit1, qubit2 = qubits
     SZdg(state, qubit1)  # rZd
     SZdg(state, qubit2)  # rZd
     SXX(state, qubits)
     SZ(state, qubit1)  # rZ
     SZ(state, qubit2)  # rZ
 
 
-def SYYdg(state: SparseSim,
-        qubits: Tuple[int, int],
-        **params: Any) -> None:
-    """
-    Adjoint of SYY
+def SYYdg(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    """Adjoint of SYY.
 
     Args:
+    ----
         state:
         qubits:
         **params:
 
     Returns:
+    -------
 
     """
-
     qubit1, qubit2 = qubits
     SZdg(state, qubit1)
     SZdg(state, qubit2)
     SXXdg(state, qubits)
     SZ(state, qubit1)
     SZ(state, qubit2)
 
 
-def SZZ(state: SparseSim,
-           qubits: Tuple[int, int],
-           **params: Any) -> None:
-    r"""
-    Sqrt of ZZ == (rY,rY).SqrtXX.(rYd,rYd)
+def SZZ(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    r"""Sqrt of ZZ == (rY,rY).SqrtXX.(rYd,rYd).
 
     XI -> YZ
     IX -> ZY
     ZI -> ZI
     IZ -> IZ
 
     Args:
+    ----
         state:
         qubits:
 
     Returns:
+    -------
 
     """
     qubit1, qubit2 = qubits
     SYdg(state, qubit1)  # rYd
     SYdg(state, qubit2)  # rYd
     SXX(state, qubits)
     SY(state, qubit1)  # rY
     SY(state, qubit2)  # rY
 
 
-def SZZdg(state: SparseSim,
-          qubits: Tuple[int, int],
-          **params: Any) -> None:
-    r"""
-    Adjoint of SZZ
+def SZZdg(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    r"""Adjoint of SZZ.
 
     Args:
+    ----
         state:
         qubits:
 
     Returns:
+    -------
 
     """
     qubit1, qubit2 = qubits
     SYdg(state, qubit1)  # rYd
     SYdg(state, qubit2)  # rYd
     SXXdg(state, qubits)
     SY(state, qubit1)  # rY
     SY(state, qubit2)  # rY
 
 
-def iSWAP(state: SparseSim,
-          qubits: Tuple[int, int],
-          **params: Any) -> None:
-    r"""
-    iSWAP = [[1,0,0,0],[0,0,i,0],[0,i,0,0],[0,0,0,i]]
+def iSWAP(state: SparseSim, qubits: tuple[int, int], **params: Any) -> None:
+    r"""ISWAP = [[1,0,0,0],[0,0,i,0],[0,i,0,0],[0,0,0,i]]
     = e^{i(XX+YY) \pi / 4}
-    = (II + i XX + i YY + ZZ)/2
+    = (II + i XX + i YY + ZZ)/2.
 
     XI -> YZ
     IX -> ZY
     ZI -> ZI
     IZ -> IZ
 
     TODO: verify implementation!
 
     Args:
+    ----
         state:
         qubits:
 
     Returns:
+    -------
 
     """
-
     qubit1, qubit2 = qubits
     SWAP(state, qubits)
     SZ(state, qubit1)
     SZ(state, qubit2)
     CZ(state, qubits)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/logical_sign.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/logical_sign.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,91 +7,96 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Functions:
+"""Functions:
 
 find_logical_signs
 logical_flip
 """
-from typing import Optional
-from ...circuits import QuantumCircuit
 
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from pecos.circuits import QuantumCircuit
 
-def find_logical_signs(state,
-                       logical_circuit: QuantumCircuit,
-                       delogical_circuit: Optional[QuantumCircuit] = None
-                       ) -> int:
-    """
-    Find the sign of the logical operator.
+
+def find_logical_signs(
+    state,
+    logical_circuit: QuantumCircuit,
+    delogical_circuit: QuantumCircuit | None = None,
+) -> int:
+    """Find the sign of the logical operator.
 
     Args:
+    ----
         state:
         logical_circuit:
 
     Returns:
+    -------
 
     """
-
     if len(logical_circuit) != 1:
-        raise Exception('Logical operators are expected to only have one tick.')
+        msg = "Logical operators are expected to only have one tick."
+        raise Exception(msg)
 
     stabs = state.stabs
     destabs = state.destabs
 
-    logical_xs = set([])
-    logical_zs = set([])
-    logical_ys = set([])
+    logical_xs = set()
+    logical_zs = set()
+    logical_ys = set()
 
     for symbol, gate_locations, _ in logical_circuit.items():
-
-        if symbol == 'X':
+        if symbol == "X":
             logical_xs.update(gate_locations)
-        elif symbol == 'Z':
+        elif symbol == "Z":
             logical_zs.update(gate_locations)
-        elif symbol == 'Y':
+        elif symbol == "Y":
             logical_xs.update(gate_locations)
             logical_zs.update(gate_locations)
             logical_ys.update(gate_locations)
         else:
             raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
     if delogical_circuit:  # Check the relationship between logical operator and delogical operator.
-
         if len(delogical_circuit) != 1:
-            raise Exception('Delogical operators are expected to only have one tick.')
+            msg = "Delogical operators are expected to only have one tick."
+            raise Exception(msg)
 
-        delogical_xs = set([])
-        delogical_zs = set([])
-        
-        for symbol, gate_locations, _ in delogical_circuit.items():
+        delogical_xs = set()
+        delogical_zs = set()
 
-            if symbol == 'X':
+        for symbol, gate_locations, _ in delogical_circuit.items():
+            if symbol == "X":
                 delogical_xs.update(gate_locations)
-            elif symbol == 'Z':
+            elif symbol == "Z":
                 delogical_zs.update(gate_locations)
-            elif symbol == 'Y':
+            elif symbol == "Y":
                 delogical_xs.update(gate_locations)
                 delogical_zs.update(gate_locations)
             else:
                 raise Exception('Can not currently handle logical operator with operator "%s"!' % symbol)
 
         # Make sure the logical and delogical anti-commute
 
         anticom_x = len(logical_xs & delogical_zs) % 2  # Number of common elements modulo 2
         anticom_z = len(logical_zs & delogical_xs) % 2  # Number of common elements modulo 2
 
         if not ((anticom_x + anticom_z) % 2):
-            print('logical Xs: %s logical Zs: %s' % (logical_xs, logical_zs))
-            print('delogical Xs: %s delogical Zs: %s' % (delogical_xs, delogical_zs))
-            raise Exception("Logical and delogical operators supplied do not anti-commute!")
+            print(f"logical Xs: {logical_xs} logical Zs: {logical_zs}")
+            print(f"delogical Xs: {delogical_xs} delogical Zs: {delogical_zs}")
+            msg = "Logical and delogical operators supplied do not anti-commute!"
+            raise Exception(msg)
 
     # We want the supplied logical operator to be in the stabilizer group and
     #  the supplied delogical to not be in the stabilizers (we want it to end up being the logical op's destabilizer)
 
     # The following two function calls are wasteful because we will need some of what they discover... such as all the
     #  stabilizers that have destabilizers that anti-commute with the logical operator...
     #  But it is assumed that the user is not calling this function that often... so we can be wasteful...
@@ -121,19 +126,18 @@
 
     # Compare with logical operator
     test_x ^= logical_xs
     test_z ^= logical_zs
 
     if len(test_x) != 0 or len(test_z) != 0:
         # for stab in build_stabs:
-        #    print('stab ... ', stab)
 
-        print(('Logical op: xs - %s and zs - %s' % (logical_xs, logical_zs)))
-        raise Exception('Failure due to not finding logical op! x... %s z... %s' %
-                        (str(test_x ^ logical_xs), str(test_z ^ logical_zs)))
+        print(f"Logical op: xs - {logical_xs} and zs - {logical_zs}")
+        msg = f"Failure due to not finding logical op! x... {str(test_x ^ logical_xs)} z... {str(test_z ^ logical_zs)}"
+        raise Exception(msg)
 
     # Get the sign of the logical operator
     # --------------------------
 
     """
     num_minuses = len(anticom_destabs_col & stabs.signs_minus)
     num_is = len(anticom_destabs_col & stabs.signs_i)
@@ -144,38 +148,38 @@
         num_minuses += len(stabs_row_z[row] & cumulative_x)
 
         # Update the row sum Paulis
         cumulative_x ^= stabs_row_x[row]
 
     if num_is % 4:  # Can only be 0 or 2
         num_minuses += 1
-        
+
     meas_outcome = num_minuses % 2
     """
 
     num_logical_is = len(logical_ys) % 2
 
     num_minuses = len(build_stabs & stabs.signs_minus)
     num_is = len(build_stabs & stabs.signs_i) - num_logical_is
 
     # Sign correction due ZX -> -XZ
-    cumulative_x = set([])
+    cumulative_x = set()
     for row in build_stabs:
         num_minuses += len(stabs.row_z[row] & cumulative_x)
         cumulative_x ^= stabs.row_x[row]
 
     if num_is % 4:  # Can only be 0 or 2
         num_minuses += 1
 
     if num_is % 2:
-        raise Exception('Final sign should not have an imaginary sign!')
+        msg = "Final sign should not have an imaginary sign!"
+        raise Exception(msg)
 
     logical_sign = num_minuses % 2
 
-
     """
     # First, get the minus signs in front of the stabilizers
     logical_minus = len(build_stabs & stabs.signs_minus)
 
     print('num stab minuses', logical_minus)
 
     # Second, see get the imaginary signs in front of the stabilizers
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/refactor.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/refactor.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,121 +7,105 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-Functions:
+"""Functions:
 
 find_logical_signs
 logical_flip
 """
 
-from typing import Set
-
 
-def find_stab(state,
-              xs: Set[int],
-              zs: Set[int]):
-    """
-    Find a stabilizer in the stabilizer group.
+def find_stab(state, xs: set[int], zs: set[int]):
+    """Find a stabilizer in the stabilizer group.
 
     Args:
+    ----
         state:
         xs:
         zs:
 
     Returns:
+    -------
 
     """
-
     stabs = state.stabs
     destabs = state.destabs
 
     # Find the destabilizer generators that anticommute with the stabilizer indicated by xs and zs.
 
     # First the destabilizer generators that could *possibly* anticommute:
-    possible_antidestabs = set([])
+    possible_antidestabs = set()
     for q in xs:
         possible_antidestabs.update(destabs.col_z[q])
 
     for q in zs:
         possible_antidestabs.update(destabs.col_x[q])
 
     # Now we will confirm if they anticommute or not.
-    antidestabs = set([])
+    antidestabs = set()
     for d in possible_antidestabs:
         if (len(xs & destabs.row_z[d]) + len(zs & destabs.row_x[d])) % 2 == 1:
             # They anticommute an odd number of times.
             antidestabs.add(d)
 
     # Now we will confirm that the supplied stabilizer is actually in the stabilizer group.
-    confirm_xs = set([])
-    confirm_zs = set([])
+    confirm_xs = set()
+    confirm_zs = set()
     for d in antidestabs:
         confirm_xs ^= stabs.row_x[d]
         confirm_zs ^= stabs.row_z[d]
 
     found = confirm_xs == xs and confirm_zs == zs
 
     return found, antidestabs
 
 
-def refactor(state,
-             xs,
-             zs,
-             choose=None,
-             prefer=None,
-             protected=None):
-    """
-    Find the sign of the logical operator.
+def refactor(state, xs, zs, choose=None, prefer=None, protected=None):
+    """Find the sign of the logical operator.
 
     Args:
+    ----
         state:
         xs:
         zs:
         choose (None, int): Order of stabilizer ids to choose from.
         prefer (None, set): Stabilizer ids that we should choose from.
         protected (None, set): Stabilizer ids not to choose from.
 
     Returns:
+    -------
 
     """
-
     stabs = state.stabs
     destabs = state.destabs
 
     # Determine if the pruposed stabilizer is in the stabilizer group
     found, gens = find_stab(state, xs, zs)
 
     new_stab = None
 
     if found:
         # Now update the generators so the supplied stabilizer is a stabilizer generator.
 
-        if protected:
-            available = gens - protected
-        else:
-            available = gens
+        available = gens - protected if protected else gens
 
         # Pick a stabilizer generator to become the requested stabilizer generator.
         if choose is None and prefer is None:
-
             new_stab = available.pop()
             gens.remove(new_stab)
 
         elif prefer is None:  # Choose indicates what order to be stab ids from.
-
             new_stab = sorted(available)[choose]
             gens.remove(new_stab)
 
         else:  # choose is not None and prefer is not None. =>
-
             for i in prefer:
                 if i in available:
                     new_stab = i
                     gens.remove(i)
                     break
             else:
                 if choose is not None:
@@ -129,25 +113,20 @@
                     gens.remove(new_stab)
                 else:
                     new_stab = available.pop()
                     gens.remove(new_stab)
 
             # What if everything is protected........
 
-        # state.print_stabs()
-
-        # print(new_stab)
-
         # Now for each stabilizer/destabilizer generator pair we need to do:
         # stab_new -> stab_new * stab
         # destab -> destab * destab_new
 
         # Stab update
         for g in gens:
-
             for q in stabs.row_x[g]:
                 stabs.col_x[q] ^= {new_stab}
 
             for q in stabs.row_z[g]:
                 stabs.col_z[q] ^= {new_stab}
 
             stabs.row_x[new_stab] ^= stabs.row_x[g]
@@ -157,15 +136,14 @@
         for q in destabs.row_x[new_stab]:
             destabs.col_x[q] ^= gens
 
         for q in destabs.row_z[new_stab]:
             destabs.col_z[q] ^= gens
 
         for g in gens:
-
             destabs.row_x[g] ^= destabs.row_x[new_stab]
             destabs.row_z[g] ^= destabs.row_z[new_stab]
 
         # Sign update
         gen_i = gens & stabs.signs_i
         gen_minus = gens & stabs.signs_minus
 
@@ -178,12 +156,8 @@
                 num_minus += 1
 
             stabs.signs_i ^= {new_stab}
 
         if num_minus % 2:
             stabs.signs_minus ^= {new_stab}
 
-        # print('...........')
-        # state.print_stabs()
-        # print('~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n')
-
     return found, new_stab
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/simulators/sparsesim/state.py` & `quantum_pecos-0.6.0.dev1/python/pecos/simulators/sparsesim/state.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,16 +7,15 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-"""
-:file: state_data_structure.py
+""":file: state_data_structure.py.
 
 A data structure to track stabilizer states for codes made up of qubits.
 
 This is based on CHP; however, sparsity is taken advantage of. LDPC codes tend to be are sparse both row-wise and
 column-wise.
 
 For the paper on CHP read: http://arxiv.org/abs/quant-ph/0406196
@@ -29,54 +28,61 @@
 
 Date        Author  Comment
 ----------  ------  ---------------------------------------------------------------------------------------------------
 02/24/2015  CRA     File created.
 
 03/30/2016  CRA     Separated data structure stuff from main file.
 
-05/24/2017  CRA     Simplified string outputs. Added the method ``gate`` to ``State`` to give an 
+05/24/2017  CRA     Simplified string outputs. Added the method ``gate`` to ``State`` to give an
 
 """
-from typing import Any, Union, Set, Tuple, List, Optional
-from ...circuits import QuantumCircuit
-from ..sim_class_types import Stabilizer
-from . import bindings
-from .logical_sign import find_logical_signs
-from .refactor import refactor as refactor_generators
-from .refactor import find_stab as find_stabilizer
-from ..gate_syms import alt_symbols
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Any
+
+from pecos.simulators.gate_syms import alt_symbols
+from pecos.simulators.sim_class_types import Stabilizer
+from pecos.simulators.sparsesim import bindings
+from pecos.simulators.sparsesim.logical_sign import find_logical_signs
+from pecos.simulators.sparsesim.refactor import find_stab as find_stabilizer
+from pecos.simulators.sparsesim.refactor import refactor as refactor_generators
+
+if TYPE_CHECKING:
+    from pecos.circuits import QuantumCircuit
 
 
 class SparseSim(Stabilizer):
-    """
-    Represents the stabilizer state.
+    """Represents the stabilizer state.
 
     Attributes:
+    ----------
         num_qubits (int):
         bindings (dict):
         stabs (Gens):
         destabs (Gens):
         gens (Tuple[Gens, Gens]):
     """
 
     def __init__(self, num_qubits: int) -> None:
-        """
-        Initializes the stabilizer state.
+        """Initializes the stabilizer state.
 
         Args:
+        ----
             num_qubits (int): Number of qubits being represented.
 
         Returns:
+        -------
 
         """
-
         super().__init__()
 
         if not isinstance(num_qubits, int):
-            raise Exception('``num_qubits`` should be of type ``int.``')
+            msg = f"`num_qubits` should be of type `int` but got type: {type(num_qubits)}"
+            raise TypeError(msg)
 
         self.num_qubits = num_qubits
 
         self.bindings = bindings.gate_dict
         for k, v in alt_symbols.items():
             if v in self.bindings:
                 self.bindings[k] = self.bindings[v]
@@ -91,512 +97,451 @@
     def reset(self):
         """Reset the quantum state for another run without reinitializing."""
         # Initialize all qubits in the zero state
         self.stabs.init_all_z()
         self.destabs.init_all_x()
         return self
 
-    def logical_sign(self,
-                     logical_op: QuantumCircuit,
-                     # delogical_op: Optional[QuantumCircuit] = None
-                     ) -> int:
-        """
-
-        Args:
+    def logical_sign(
+        self,
+        logical_op: QuantumCircuit,
+    ) -> int:
+        """Args:
+        ----
             logical_op:
 
         Returns:
+        -------
 
         """
-        return find_logical_signs(self, logical_op,
-                                  # delogical_op
-                                  )
-
-    def refactor(self,
-                 xs: Set[int],
-                 zs: Set[int],
-                 choose=None,
-                 prefer=None,
-                 protected=None):
+        return find_logical_signs(
+            self,
+            logical_op,
+            # delogical_op
+        )
 
+    def refactor(self, xs: set[int], zs: set[int], choose=None, prefer=None, protected=None):
         return refactor_generators(self, xs, zs, choose, prefer, protected)
 
-    def find_stab(self,
-                  xs: Set[int],
-                  zs: Set[int]):
-
+    def find_stab(self, xs: set[int], zs: set[int]):
         return find_stabilizer(self, xs, zs)
 
-    def run_direct(self,
-                   symbol: str,
-                   location: Set[Union[int, Tuple[int, ...]]],
-                   **gate_kwargs: Any):
+    def run_direct(self, symbol: str, location: set[int | tuple[int, ...]], **gate_kwargs: Any):
         self.bindings[symbol](self, location, **gate_kwargs)
 
     def copy(self):
-
         new = SparseSim(self.num_qubits)
 
         old_stabs = self.stabs
         old_destabs = self.destabs
 
         new_gens = (new.stabs, new.destabs)
 
         for i, gen in enumerate([old_stabs, old_destabs]):
-
             new_gen = new_gens[i]
 
             new_gen.signs_minus = set()
             new_gen.signs_i = set()
 
             new_gen.signs_minus.update(gen.signs_minus)
             new_gen.signs_i.update(gen.signs_i)
 
             for j in range(self.num_qubits):
-
                 new_gen.row_x[j] = set()
                 new_gen.row_z[j] = set()
                 new_gen.col_x[j] = set()
                 new_gen.col_z[j] = set()
 
                 new_gen.row_x[j].update(gen.row_x[j])
                 new_gen.row_z[j].update(gen.row_z[j])
                 new_gen.col_x[j].update(gen.col_x[j])
                 new_gen.col_z[j].update(gen.col_z[j])
 
     @staticmethod
-    def _pauli_sign(gen,
-                    i_gen: int) -> str:
-
+    def _pauli_sign(gen, i_gen: int) -> str:
         if i_gen in gen.signs_minus:
-            if i_gen in gen.signs_i:
-                sign = '-i'
-            else:
-                sign = ' -'
+            sign = "-i" if i_gen in gen.signs_i else " -"
         else:
-
-            if i_gen in gen.signs_i:
-                sign = ' i'
-            else:
-                sign = '  '
+            sign = " i" if i_gen in gen.signs_i else "  "
 
         return sign
 
-    def col_string(self,
-                   gen,
-                   num_qubits: Optional[int] = None,
-                   print_signs: bool = True,
-                   print_y: bool = False):
-        """
-        Prints out the stabilizers for the column-wise sparse representation.
+    def col_string(self, gen, num_qubits: int | None = None, *, print_signs: bool = True, print_y: bool = False):
+        """Prints out the stabilizers for the column-wise sparse representation.
 
         Args:
+        ----
             gen (Gens): A generator instance.
             num_qubits (Optional[int]): number of qubits.
             print_signs (bool): Whether to print the signs of the generators.
             print_y (bool):
 
         Returns:
+        -------
 
         """
-
         col_x = gen.col_x
         col_z = gen.col_z
 
         result = []
 
         if num_qubits is None:
             num_qubits = self.num_qubits
 
         for i_gen in range(num_qubits):
-
             stab_letters = []
 
             # ---- Signs ---- #
-            if print_signs:
-                sign = self._pauli_sign(gen, i_gen)
-            else:
-                sign = '  '
+            sign = self._pauli_sign(gen, i_gen) if print_signs else "  "
 
             stab_letters.append(sign)
 
             # ---- Paulis ---- #
             for qubit in range(num_qubits):
-
-                letter = 'U'
+                letter = "U"
 
                 if i_gen in col_x[qubit] and i_gen not in col_z[qubit]:
-                    letter = 'X'
+                    letter = "X"
 
                 elif i_gen not in col_x[qubit] and i_gen in col_z[qubit]:
-                    letter = 'Z'
+                    letter = "Z"
 
                 elif i_gen in col_x[qubit] and i_gen in col_z[qubit]:
-                    letter = 'W'
+                    letter = "W"
 
                 elif i_gen not in col_x[qubit] and i_gen not in col_z[qubit]:
-                    letter = 'I'
+                    letter = "I"
 
                 stab_letters.append(letter)
 
             if print_y:
                 num_minus_is = 0
                 for i, letter in enumerate(stab_letters):
-                    if letter == 'W':
-                        stab_letters[i] = 'Y'
+                    if letter == "W":
+                        stab_letters[i] = "Y"
                         num_minus_is += 1
 
                 if print_signs:
                     # 1, i, -1, -i  ... i
                     # 1, -i, -1, i
                     has_i = num_minus_is % 2
                     has_minus = int(num_minus_is % 4 == 1 or num_minus_is % 4 == 2)
 
-                    if sign == ' -':
+                    if sign == " -":
                         has_minus += 1
-                    elif sign == ' i':
+                    elif sign == " i":
                         has_i += 1
-                    elif sign == '-i':
+                    elif sign == "-i":
                         has_minus += 1
                         has_i += 1
 
                     has_i %= 2
                     has_minus %= 2
 
                     if has_i:
                         if has_minus:
-                            stab_letters[0] = '-i'
+                            stab_letters[0] = "-i"
                         else:
-                            stab_letters[0] = ' i'
+                            stab_letters[0] = " i"
                     else:
                         if has_minus:
-                            stab_letters[0] = ' -'
+                            stab_letters[0] = " -"
                         else:
-                            stab_letters[0] = '  '
+                            stab_letters[0] = "  "
 
-            # print(''.join(stab_letters))
-            result.append(''.join(stab_letters))
+            result.append("".join(stab_letters))
 
         return result
 
-    def print_stabs(self,
-                    verbose: bool = True,
-                    print_y: bool = True,
-                    print_destabs: bool = False):
-
+    def print_stabs(self, *, verbose: bool = True, print_y: bool = True, print_destabs: bool = False):
         str_s = self.print_tableau(self.stabs, verbose=verbose, print_y=print_y)
 
         if print_destabs:
             if verbose:
-                print('-------------------------------')
+                print("-------------------------------")
             str_d = self.print_tableau(self.destabs, verbose=verbose, print_signs=False, print_y=print_y)
 
             return str_s, str_d
 
         return str_s
 
-    def print_tableau(self,
-                      gen,
-                      verbose: bool = True,
-                      print_signs: bool = True,
-                      print_y: bool = True):
-        """
-        Prints out the stabilizers.
+    def print_tableau(self, gen, *, verbose: bool = True, print_signs: bool = True, print_y: bool = True):
+        """Prints out the stabilizers.
         :return:
         """
-
         col_str = self.col_string(gen, print_signs=print_signs, print_y=print_y)
         row_str = self.row_string(gen, print_signs=print_signs, print_y=print_y)
 
         if col_str != row_str:
-            print('col')
+            print("col")
             for line in col_str:
                 print(line)
 
-            print('\nrow')
+            print("\nrow")
             for line in row_str:
                 print(line)
 
-            raise Exception('Something bad happened! String representation of the row-wise vs column-wise '
-                            'stabilizers do not match!')
+            msg = (
+                "Something bad happened! String representation of the row-wise vs column-wise stabilizers "
+                "do not match!"
+            )
+            raise Exception(msg)
 
         if verbose:
             for line in col_str:
                 print(line)
 
         return col_str
 
-    def row_string(self,
-                   gen,
-                   num_qubits: Optional[int] = None,
-                   print_signs: bool = True,
-                   print_y: bool = False) -> List[str]:
-        """
-        Prints out the stabilizers for the row-wise sparse representation.
+    def row_string(
+        self,
+        gen,
+        num_qubits: int | None = None,
+        *,
+        print_signs: bool = True,
+        print_y: bool = False,
+    ) -> list[str]:
+        """Prints out the stabilizers for the row-wise sparse representation.
 
         Args:
-            gen (Gens): A generator instance.
-            num_qubits (int): number of qubits.
-            print_signs (bool): Whether to print the signs of the generators.
-            print_y (bool):
+            gen: A generator instance.
+            num_qubits: number of qubits.
+            print_signs: Whether to print the signs of the generators.
+            print_y:
 
         Returns:
 
         """
-
         row_x = gen.row_x
         row_z = gen.row_z
 
         result = []
 
         if num_qubits is None:
             num_qubits = gen.num_qubits
 
         for i_gen in range(num_qubits):
-
             stab_letters = []
 
             # ---- Signs ---- #
-            if print_signs:
-                sign = self._pauli_sign(gen, i_gen)
-            else:
-                sign = '  '
+            sign = self._pauli_sign(gen, i_gen) if print_signs else "  "
             stab_letters.append(sign)
 
             # ---- Paulis ---- #
             for qubit in range(num_qubits):
-
-                letter = 'U'
+                letter = "U"
 
                 if qubit in row_x[i_gen] and qubit not in row_z[i_gen]:
-                    letter = 'X'
+                    letter = "X"
 
                 elif qubit not in row_x[i_gen] and qubit in row_z[i_gen]:
-                    letter = 'Z'
+                    letter = "Z"
 
                 elif qubit in row_x[i_gen] and qubit in row_z[i_gen]:
-                    letter = 'W'
+                    letter = "W"
 
                 elif qubit not in row_x[i_gen] and qubit not in row_z[i_gen]:
-                    letter = 'I'
+                    letter = "I"
 
                 stab_letters.append(letter)
 
             if print_y:
                 num_minus_is = 0
                 for i, letter in enumerate(stab_letters):
-                    if letter == 'W':
-                        stab_letters[i] = 'Y'
+                    if letter == "W":
+                        stab_letters[i] = "Y"
                         num_minus_is += 1
 
                 if print_signs:
                     # 1, i, -1, -i  ... i
                     # 1, -i, -1, i
                     has_i = num_minus_is % 2
                     has_minus = int(num_minus_is % 4 == 1 or num_minus_is % 4 == 2)
 
-                    if sign == ' -':
+                    if sign == " -":
                         has_minus += 1
-                    elif sign == ' i':
+                    elif sign == " i":
                         has_i += 1
-                    elif sign == '-i':
+                    elif sign == "-i":
                         has_minus += 1
                         has_i += 1
 
                     has_i %= 2
                     has_minus %= 2
 
                     if has_i:
                         if has_minus:
-                            stab_letters[0] = '-i'
+                            stab_letters[0] = "-i"
                         else:
-                            stab_letters[0] = ' i'
+                            stab_letters[0] = " i"
                     else:
                         if has_minus:
-                            stab_letters[0] = ' -'
+                            stab_letters[0] = " -"
                         else:
-                            stab_letters[0] = '  '
+                            stab_letters[0] = "  "
 
-            # print(''.join(stab_letters))
-            result.append(''.join(stab_letters))
+            result.append("".join(stab_letters))
 
         return result
 
 
-class Gens(object):
-    """
-    This class is the data structure used for tracking stabilizer/destabilizer generators.
-    """
+class Gens:
+    """This class is the data structure used for tracking stabilizer/destabilizer generators."""
 
     def __init__(self, num_qubits: int) -> None:
-        """
-        :param num_qubits: Number of qubits to simulate.
-        """
-
+        """:param num_qubits: Number of qubits to simulate."""
         self.num_qubits = num_qubits
 
         self.col_x = [set() for _ in range(num_qubits)]
         self.col_z = [set() for _ in range(num_qubits)]
 
         self.row_x = [set() for _ in range(num_qubits)]
         self.row_z = [set() for _ in range(num_qubits)]
 
         self.signs_minus = set()
         self.signs_i = set()
 
     def init_all_z(self) -> None:
-        """
-        Used to initiate stabilizers to all Zs.
+        """Used to initiate stabilizers to all Zs.
 
         :return:
         :rtype:
         """
-
         self.signs_minus = set()
         self.signs_i = set()
 
         self.col_x = [set() for _ in range(self.num_qubits)]
         self.col_z = [{i} for i in range(self.num_qubits)]
 
         self.row_x = [set() for _ in range(self.num_qubits)]
         self.row_z = [{i} for i in range(self.num_qubits)]
 
     def init_all_x(self) -> None:
-        """
-        Used to initiate destabilizers to all Xs.
+        """Used to initiate destabilizers to all Xs.
 
         :return:
         :rtype:
         """
-
         self.signs_minus = set()
         self.signs_i = set()
 
         self.col_x = [{i} for i in range(self.num_qubits)]
         self.col_z = [set() for _ in range(self.num_qubits)]
 
         self.row_x = [{i} for i in range(self.num_qubits)]
         self.row_z = [set() for _ in range(self.num_qubits)]
 
     def _pauli_sign(self, i_gen: int) -> str:
-
         if i_gen in self.signs_minus:
-            if i_gen in self.signs_i:
-                sign = '-i'
-            else:
-                sign = ' -'
+            sign = "-i" if i_gen in self.signs_i else " -"
         else:
-
-            if i_gen in self.signs_i:
-                sign = ' i'
-            else:
-                sign = '  '
+            sign = " i" if i_gen in self.signs_i else "  "
 
         return sign
 
-    def col_string(self, num_qubits: Optional[int] = None) -> List[str]:
-        """
-        Prints out the stabilizers for the column-wise sparse representation.
+    def col_string(self, num_qubits: int | None = None) -> list[str]:
+        """Prints out the stabilizers for the column-wise sparse representation.
 
         :param num_qubits:
         :return:
         """
-
         result = []
 
         if num_qubits is None:
             num_qubits = self.num_qubits
 
         for i_gen in range(num_qubits):
-
             stab_letters = []
 
             # ---- Signs ---- #
             sign = self._pauli_sign(i_gen)
             stab_letters.append(sign)
 
             # ---- Paulis ---- #
             for qubit in range(num_qubits):
-
-                letter = 'U'
+                letter = "U"
 
                 if i_gen in self.col_x[qubit] and i_gen not in self.col_z[qubit]:
-                    letter = 'X'
+                    letter = "X"
 
                 elif i_gen not in self.col_x[qubit] and i_gen in self.col_z[qubit]:
-                    letter = 'Z'
+                    letter = "Z"
 
                 elif i_gen in self.col_x[qubit] and i_gen in self.col_z[qubit]:
-                    letter = 'W'
+                    letter = "W"
 
                 elif i_gen not in self.col_x[qubit] and i_gen not in self.col_z[qubit]:
-                    letter = 'I'
+                    letter = "I"
 
                 stab_letters.append(letter)
 
-            # print(''.join(stab_letters))
-            result.append(''.join(stab_letters))
+            result.append("".join(stab_letters))
 
         return result
 
-    def print_tableau(self, verbose: bool = True) -> List[str]:
-        """
-        Prints out the stabilizers.
-        :return:
-        """
+    def print_tableau(self, *, verbose: bool = True) -> list[str]:
+        """Prints out the stabilizers.
+
+        Args:
+            verbose:
+
+        Returns:
 
+        """
         col_str = self.col_string()
         row_str = self.row_string()
 
         if col_str != row_str:
-            raise Exception('Something bad happened! String representation of the row-wise vs column-wile '
-                            'spare stabilizers do not match!')
+            msg = (
+                "Something bad happened! String representation of the row-wise vs column-wile spare stabilizers "
+                "do not match!"
+            )
+            raise Exception(msg)
 
         if verbose:
             for line in col_str:
                 print(line)
 
         return col_str
 
-    def row_string(self, num_qubits: Optional[int] = None) -> List[str]:
-        """
-        Prints out the stabilizers for the row-wise sparse representation.
+    def row_string(self, num_qubits: int | None = None) -> list[str]:
+        """Prints out the stabilizers for the row-wise sparse representation.
 
-        :param num_qubits:
-        :return:
-        """
+        Args:
+            num_qubits:
+
+        Returns:
 
+        """
         result = []
 
         if num_qubits is None:
             num_qubits = self.num_qubits
 
         for i_gen in range(num_qubits):
-
             stab_letters = []
 
             # ---- Signs ---- #
             sign = self._pauli_sign(i_gen)
             stab_letters.append(sign)
 
             # ---- Paulis ---- #
             for qubit in range(num_qubits):
-
-                letter = 'U'
+                letter = "U"
 
                 if qubit in self.row_x[i_gen] and qubit not in self.row_z[i_gen]:
-                    letter = 'X'
+                    letter = "X"
 
                 elif qubit not in self.row_x[i_gen] and qubit in self.row_z[i_gen]:
-                    letter = 'Z'
+                    letter = "Z"
 
                 elif qubit in self.row_x[i_gen] and qubit in self.row_z[i_gen]:
-                    letter = 'W'
+                    letter = "W"
 
                 elif qubit not in self.row_x[i_gen] and qubit not in self.row_z[i_gen]:
-                    letter = 'I'
+                    letter = "I"
 
                 stab_letters.append(letter)
 
-            result.append(''.join(stab_letters))
+            result.append("".join(stab_letters))
 
         return result
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/tools/fault_tolerance_checks.py` & `quantum_pecos-0.6.0.dev1/python/pecos/tools/fault_tolerance_checks.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,39 +7,47 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-from itertools import product, combinations
 import itertools as it
+from itertools import combinations, product
+
 import numpy as np
-from ..simulators import pySparseSim
+
+from pecos.circuits import LogicalCircuit, QuantumCircuit
+from pecos.decoders import MWPM2D
 from pecos.engines.circuit_runners import Standard
-from ..circuits import QuantumCircuit, LogicalCircuit
-from ..misc.stabilizer_funcs import op_commutes, remove_stab, circ2set, find_stab
-from ..error_models.parent_class_error_gen import ErrorCircuits
-from ..decoders import MWPM2D
+from pecos.error_models.parent_class_error_gen import ErrorCircuits
+from pecos.misc.stabilizer_funcs import circ2set, find_stab, op_commutes, remove_stab
+from pecos.simulators import pySparseSim
 
 
 def powerset(iterable, bound=None):
-    """
-    Returns the power set of an iterable
-    """
+    """Returns the power set of an iterable."""
     powerlist = list(iterable)
     if bound is None:
         bound = len(powerlist)
-    return it.chain.from_iterable(it.combinations(powerlist, t) for t in range(bound+1))
+    return it.chain.from_iterable(it.combinations(powerlist, t) for t in range(bound + 1))
 
 
-def t_errors_check(qecc, logical_gate=None, syn_extract=None, decoder=None, t_weight=None, error_set=None,
-                   verbose=True, data_errors=True, ancilla_errors=False):
-    """
-    This checks that the exRec conditions for a fault-free error correction (EC) or logical gate (Ga) as described in
+def t_errors_check(
+    qecc,
+    logical_gate=None,
+    syn_extract=None,
+    decoder=None,
+    t_weight=None,
+    error_set=None,
+    verbose=True,
+    data_errors=True,
+    ancilla_errors=False,
+):
+    """This checks that the exRec conditions for a fault-free error correction (EC) or logical gate (Ga) as described in
     arXiv:quant-ph/0504218.
 
     For fault-free EC, weight <= t errors in produce no errors out.
 
     For fault-free Ga, weight <= t errors in produce weight <= errors out.
 
 
@@ -53,96 +61,89 @@
                      ------------------
     error wt <= t -> |Ga (fault free) | ->error wt <= t   => A following fault-free EC + Recovery will result in a state
                      ------------------
     with no logical fault.
 
 
     Args:
+    ----
         qecc:
         logical_gate(QuantumCircuit):
         syn_extract(QuantumCircuit):
         decoder:
         t_weight:
         error_set:
         verbose:
         data_errors:
         ancilla_errors:
 
     Returns:
+    -------
         tuple (bool, int): The bool is whether the check is passed. The int is the weight of error last checked. If the
         bool is True then int == t_weight. If bool == False, int == weight of error that caused a logical error.
 
     """
-
     qudit_set = set()
 
     if data_errors:
         qudit_set.update(qecc.data_qudit_set)
 
     if ancilla_errors:
         qudit_set.update(qecc.ancilla_qudit_set)
 
     if t_weight is None:
-        t_weight = np.floor((qecc.distance-1)/2)
+        t_weight = np.floor((qecc.distance - 1) / 2)
 
     if error_set is None:
-        error_set = {'X', 'Y', 'Z'}
+        error_set = {"X", "Y", "Z"}
 
     circ_sim = Standard()
 
     # init |0> circuit
-    initzero = LogicalCircuit(supress_warning=True)
-    initzero.append(qecc.gate('ideal init |0>'))
+    initzero = LogicalCircuit(suppress_warning=True)
+    initzero.append(qecc.gate("ideal init |0>"))
 
     # init |+> circuit
-    initplus = LogicalCircuit(supress_warning=True)
-    initplus.append(qecc.gate('ideal init |+>'))
+    initplus = LogicalCircuit(suppress_warning=True)
+    initplus.append(qecc.gate("ideal init |+>"))
 
     if syn_extract is not None and logical_gate is not None:
-        raise Exception('Both syn_extract and logical_gate cannot be set (not None).')
+        msg = "Both syn_extract and logical_gate cannot be set (not None)."
+        raise Exception(msg)
 
     if syn_extract is None:
         # Syndrome extraction
-        syn_extract = LogicalCircuit(supress_warning=True)
-        syn_extract.append(qecc.gate('I', num_syn_extract=1, forced_outcome=1))
+        syn_extract = LogicalCircuit(suppress_warning=True)
+        syn_extract.append(qecc.gate("I", num_syn_extract=1, forced_outcome=1))
 
-    if logical_gate is None:
-        logic = syn_extract
-    else:
-        logic = logical_gate
+    logic = syn_extract if logical_gate is None else logical_gate
 
-    logical_ops_zero = qecc.instruction('instr_init_zero').logical_stabs[0]
-    logical_ops_plus = qecc.instruction('instr_init_plus').logical_stabs[0]
+    logical_ops_zero = qecc.instruction("instr_init_zero").logical_stabs[0]
+    logical_ops_plus = qecc.instruction("instr_init_plus").logical_stabs[0]
 
     if decoder is None:
         decoder = MWPM2D(qecc)
 
     for qubit_comb in powerset(qudit_set):
-
         if len(qubit_comb) > t_weight:
             break
 
         error_combinations = product(error_set, repeat=len(qubit_comb))
 
         for error_comb in error_combinations:
-
-            # print('>', error_comb, qubit_comb)
             error_circ = QuantumCircuit(1)
             errors = ErrorCircuits()
 
             errors.simple_add(0, 0, 0, before_errors=error_circ)
 
             for e, q in zip(error_comb, qubit_comb):
-                # print(e, q)
                 error_circ.update(e, {q})
 
             state_zero = pySparseSim(qecc.num_qudits)
             state_plus = pySparseSim(qecc.num_qudits)
-            # state_zero = circ_sim.init(qecc.num_qudits)
-            # state_plus = circ_sim.init(qecc.num_qudits)
 
             circ_sim.run(state_zero, initzero)
             circ_sim.run(state_plus, initplus)
 
             output, _ = circ_sim.run(state_zero, logic, error_circuits=errors)
             circ_sim.run(state_plus, logic, error_circuits=errors)
 
@@ -152,42 +153,45 @@
                 # Recovery operation
                 recovery = decoder.decode(syn)
                 circ_sim.run(state_zero, recovery)
                 circ_sim.run(state_plus, recovery)
 
             sign_zero = state_zero.logical_sign(*logical_ops_zero)
             sign_plus = state_plus.logical_sign(*logical_ops_plus)
-            # sign_plus = 0
-            # sign_zero = 0
 
             if sign_zero or sign_plus:
                 if verbose:
                     print(errors)
                 return False, len(error_comb)
 
             if logical_gate is None:  # The following is only required for EC.
-
                 # Any remaining syndromes?
                 output, _ = circ_sim.run(state_zero, syn_extract)
-                # circ_sim.run(state_plus, syn_extract, error_circuits=errors)
                 syn = output.simplified(True)
 
                 if syn:
                     if verbose:
-                        print('syndromes = %s' % syn)
+                        print("syndromes = %s" % syn)
                         print(errors)
                     return False, len(error_comb)
 
     return True, int(t_weight)
 
 
-def fault_check(qecc, logical_gate=None, decoder=None, t_weight=None, error_set=None, verbose=True, data_errors=True,
-                ancilla_errors=False):
-    """
-    This checks that the exRec conditions for a faulty error correction (EC) or logical gate (Ga) as described in
+def fault_check(
+    qecc,
+    logical_gate=None,
+    decoder=None,
+    t_weight=None,
+    error_set=None,
+    verbose=True,
+    data_errors=True,
+    ancilla_errors=False,
+):
+    """This checks that the exRec conditions for a faulty error correction (EC) or logical gate (Ga) as described in
     arXiv:quant-ph/0504218.
 
     For fault-free EC, weight <= t errors in produce no errors out.
 
     For fault-free Ga, weight <= t errors in produce weight <= errors out.
 
 
@@ -201,90 +205,85 @@
                      ------------------
     error wt <= t -> |Ga (fault free) | ->error wt <= t   => A following fault-free EC + Recovery will result in a state
                      ------------------
     with no logical fault.
 
 
     Args:
+    ----
         qecc:
         logical_gate(QuantumCircuit):
         decoder:
         t_weight:
         error_set:
         verbose:
         data_errors:
         ancilla_errors:
 
     Returns:
+    -------
         tuple (bool, int): The bool is whether the check is passed. The int is the weight of error last checked. If the
         bool is True then int == t_weight. If bool == False, int == weight of error that caused a logical error.
 
     """
-
     qudit_set = set()
 
     if data_errors:
         qudit_set.update(qecc.data_qudit_set)
 
     if ancilla_errors:
         qudit_set.update(qecc.ancilla_qudit_set)
 
     if t_weight is None:
         t_weight = np.floor((qecc.distance - 1) / 2)
 
     if error_set is None:
-        error_set = {'X', 'Y', 'Z'}
+        error_set = {"X", "Y", "Z"}
 
     circ_sim = Standard()
 
     # init |0> circuit
-    initzero = LogicalCircuit(supress_warning=True)
-    initzero.append(qecc.gate('ideal init |0>'))
+    initzero = LogicalCircuit(suppress_warning=True)
+    initzero.append(qecc.gate("ideal init |0>"))
 
     # init |+> circuit
-    initplus = LogicalCircuit(supress_warning=True)
-    initplus.append(qecc.gate('ideal init |+>'))
+    initplus = LogicalCircuit(suppress_warning=True)
+    initplus.append(qecc.gate("ideal init |+>"))
 
     if logical_gate is None:
         # Syndrome extraction
-        syn_extract = LogicalCircuit(supress_warning=True)
-        syn_extract.append(qecc.gate('I', num_syn_extract=1, forced_outcome=1))
+        syn_extract = LogicalCircuit(suppress_warning=True)
+        syn_extract.append(qecc.gate("I", num_syn_extract=1, forced_outcome=1))
         logic = syn_extract
     else:
         logic = logical_gate
 
-    logical_ops_zero = qecc.instruction('instr_init_zero').logical_stabs[0]
-    logical_ops_plus = qecc.instruction('instr_init_plus').logical_stabs[0]
+    logical_ops_zero = qecc.instruction("instr_init_zero").logical_stabs[0]
+    logical_ops_plus = qecc.instruction("instr_init_plus").logical_stabs[0]
 
     if decoder is None:
         decoder = MWPM2D(qecc)
 
     for qubit_comb in powerset(qudit_set):
-
         if len(qubit_comb) > t_weight:
             break
 
         error_combinations = product(error_set, repeat=len(qubit_comb))
 
         for error_comb in error_combinations:
-
-            # print('>', error_comb, qubit_comb)
             error_circ = QuantumCircuit(1)
             errors = ErrorCircuits()
 
             errors.simple_add(0, 0, 0, before_errors=error_circ)
 
             for e, q in zip(error_comb, qubit_comb):
-                # print(e, q)
                 error_circ.update(e, {q})
 
             state_zero = pySparseSim(qecc.num_qudits)
             state_plus = pySparseSim(qecc.num_qudits)
-            # state_zero = circ_sim.init(qecc.num_qudits)
-            # state_plus = circ_sim.init(qecc.num_qudits)
 
             circ_sim.run(state_zero, initzero)
             circ_sim.run(state_plus, initplus)
 
             output, _ = circ_sim.run(state_zero, logic, error_circuits=errors)
             circ_sim.run(state_plus, logic, error_circuits=errors)
 
@@ -294,148 +293,139 @@
                 # Recovery operation
                 recovery = decoder.decode(syn)
                 circ_sim.run(state_zero, recovery)
                 circ_sim.run(state_plus, recovery)
 
             sign_zero = state_zero.logical_sign(*logical_ops_zero)
             sign_plus = state_plus.logical_sign(*logical_ops_plus)
-            # sign_plus = 0
-            # sign_zero = 0
 
             if sign_zero or sign_plus:
                 if verbose:
                     print(errors)
                 return False, len(error_comb)
 
     return True, int(t_weight)
 
 
 def distance_check(qecc, mode=None, dist_mode=None):
-    """
-    Determines the distance of the code by looking for the smallest logical errors.
+    """Determines the distance of the code by looking for the smallest logical errors.
 
     Args:
+    ----
         qecc:
         mode:
         dist_mode:
 
     Returns:
+    -------
         Tuple (bool, int). The bool is whether the check is passed. The int is the weight of error last checked. If the
         bool is True then int == t_weight. If bool == False, int == weight of error that caused a logical error.
 
     """
-
     qudit_set = qecc.data_qudit_set
 
     circ_sim = Standard()
     state = pySparseSim(qecc.num_qudits)
-    # state = circ_sim.init(qecc.num_qudits, simulator=state_sparse)
 
-    ideal_initlogic = LogicalCircuit(supress_warning=True)
-    ideal_initlogic.append(qecc.gate('ideal init |0>'))
+    ideal_initlogic = LogicalCircuit(suppress_warning=True)
+    ideal_initlogic.append(qecc.gate("ideal init |0>"))
 
     circ_sim.run(state, ideal_initlogic)
 
-    logical_op, delogical_op = qecc.instruction('instr_init_zero').logical_stabs[0]
+    logical_op, delogical_op = qecc.instruction("instr_init_zero").logical_stabs[0]
 
     destab_xs, destab_zs = circ2set(delogical_op.items(params=False))
     stab_xs, stab_zs = circ2set(logical_op.items(params=False))
 
     remove_stab(state, stab_xs, stab_zs, destab_xs, destab_zs)
 
     if dist_mode is None:
-
-        if mode == 'X' or mode == 'x':
-            print('x')
+        if mode in {"X", "x"}:
+            print("x")
             return dist_mode_x(state, qudit_set)
-        elif mode == 'Z' or mode == 'z':
-            print('z')
+        elif mode in {"Z", "z"}:
+            print("z")
             return dist_mode_z(state, qudit_set)
-        elif mode == 'power':
+        elif mode == "power":
             return dist_mode_powerset(state, qudit_set)
         else:
             return dist_mode_smallest(state, qudit_set)
 
     else:
         return dist_mode(state, qudit_set)
 
 
 def dist_mode_powerset(state, qudit_set):
-    """
-
-    Args:
+    """Args:
         state:
         qudit_set:
 
     Returns:
 
     """
-
     for x_errors in powerset(qudit_set):
         for z_errors in powerset(qudit_set):
             if op_commutes(x_errors, z_errors, state.stabs) and not find_stab(state, x_errors, z_errors):
-                return "Logical error found: Xs - %s Zs - %s" % (x_errors, z_errors)
+                return f"Logical error found: Xs - {x_errors} Zs - {z_errors}"
 
     return False
 
 
 def dist_mode_smallest(state, qudit_set):
-    """
-
-    Args:
+    """Args:
+    ----
         state:
         qudit_set:
 
     Returns:
+    -------
 
     """
-    for lenq in range(len(qudit_set)+1):
+    for lenq in range(len(qudit_set) + 1):
         for qs in combinations(qudit_set, lenq):
-            # stab_x = qs, stab_zs = qs
             if op_commutes(qs, qs, state.stabs) and not find_stab(state, qs, qs):
-                return "Logical error found: Xs - %s Zs - %s" % (qs, qs)
+                return f"Logical error found: Xs - {qs} Zs - {qs}"
 
             for qs2 in powerset(qudit_set, len(qs) - 1):
-
                 if op_commutes(qs2, qs, state.stabs) and not find_stab(state, qs2, qs):
-                    return "Logical error found: Xs - %s Zs - %s" % (qs2, qs)
+                    return f"Logical error found: Xs - {qs2} Zs - {qs}"
 
                 if op_commutes(qs, qs2, state.stabs) and not find_stab(state, qs, qs2):
-                    return "Logical error found: Xs - %s Zs - %s" % (qs, qs2)
+                    return f"Logical error found: Xs - {qs} Zs - {qs2}"
 
     return False
 
 
 def dist_mode_x(state, qudit_set):
-    """
-
-    Args:
+    """Args:
+    ----
         state:
         qudit_set:
 
     Returns:
+    -------
 
     """
     z_errors = ()
     for x_errors in powerset(qudit_set):
         if op_commutes(x_errors, z_errors, state.stabs) and not find_stab(state, x_errors, z_errors):
-            return "Logical error found: Xs - %s Zs - %s" % (x_errors, z_errors)
+            return f"Logical error found: Xs - {x_errors} Zs - {z_errors}"
 
     return False
 
 
 def dist_mode_z(state, qudit_set):
-    """
-
-    Args:
+    """Args:
+    ----
         state:
         qudit_set:
 
     Returns:
+    -------
 
     """
     x_errors = ()
     for z_errors in powerset(qudit_set):
         if op_commutes(x_errors, z_errors, state.stabs) and not find_stab(state, x_errors, z_errors):
-            return "Logical error found: Xs - %s Zs - %s" % (x_errors, z_errors)
+            return f"Logical error found: Xs - {x_errors} Zs - {z_errors}"
 
     return False
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/tools/pseudo_threshold_tools.py` & `quantum_pecos-0.6.0.dev1/python/pecos/tools/pseudo_threshold_tools.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,51 +7,68 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
-import numpy as np
-from scipy.optimize import curve_fit
-from scipy.optimize import brentq, newton
 import matplotlib.pyplot as plt
-from ..engines import circuit_runners
-from ..qeccs import Surface4444
-from ..decoders import MWPM2D
-from ..error_models import XModel
-from .threshold_tools import codecapacity_logical_rate, codecapacity_logical_rate2, codecapacity_logical_rate3
-from ..misc.threshold_curve import func
+import numpy as np
+from scipy.optimize import brentq, curve_fit, newton
 
+from pecos.decoders import MWPM2D
+from pecos.engines import circuit_runners
+from pecos.error_models import XModel
+from pecos.misc.threshold_curve import func
+from pecos.qeccs import Surface4444
+from pecos.tools.threshold_tools import (
+    codecapacity_logical_rate,
+    codecapacity_logical_rate2,
+    codecapacity_logical_rate3,
+)
+
+
+def pseudo_threshold_code_capacity(
+    ps,
+    distance,
+    runs,
+    qecc_class=None,
+    error_gen=None,
+    decoder_class=None,
+    verbose=True,
+    mode=1,
+    deg=2,
+    circuit_runner=None,
+    plotting=False,
+    basis=None,
+):
+    """Function that generates p_logical values given a list of physical errors (ps) and distance (ds).
 
-def pseudo_threshold_code_capacity(ps, distance, runs, qecc_class=None, error_gen=None, decoder_class=None,
-                                   verbose=True, mode=1, deg=2, circuit_runner=None, plotting=False, basis=None):
-    """
-    Function that generates p_logical values given a list of physical errors (ps) and distance (ds).
     Args:
+    ----
         ps:
         distance:
         runs:
         qecc_class:
         error_gen:
         decoder_class:
         verbose:
         mode:
         deg:
         circuit_runner:
 
     Returns:
+    -------
 
     """
-
     if circuit_runner is None:
         circuit_runner = circuit_runners.Standard()
 
     if error_gen is None:
-        error_gen = XModel(model_level='code_capacity')
+        error_gen = XModel(model_level="code_capacity")
 
     if qecc_class is None:
         qecc_class = Surface4444
 
     if decoder_class is None:
         decoder_class = MWPM2D
 
@@ -68,61 +85,65 @@
 
     plog = []
 
     qecc = qecc_class(distance=distance)
     decoder = decoder_class(qecc)
 
     for p in ps:
-
-        logical_error_rate, time = determine_rate(runs, qecc, distance, error_gen, error_params={'p': p},
-                                                  decoder=decoder, verbose=verbose, circuit_runner=circuit_runner,
-                                                  basis=basis)
+        logical_error_rate, time = determine_rate(
+            runs,
+            qecc,
+            distance,
+            error_gen,
+            error_params={"p": p},
+            decoder=decoder,
+            verbose=verbose,
+            circuit_runner=circuit_runner,
+            basis=basis,
+        )
         if verbose and time:
-            print('Runtime: %s s' % time)
+            print("Runtime: %s s" % time)
 
         if verbose:
-
-            print('----')
+            print("----")
 
         plog.append(logical_error_rate)
 
     plog = np.array(plog)
 
     if verbose:
-        print('ps=', ps)
-        print('plog=', plog)
+        print("ps=", ps)
+        print("plog=", plog)
 
     if plotting:
-
         find_polyfit(ps, plog, deg, verbose)
 
         plot(ps, plog, deg)
 
-    # return plist, dlist, plog, results
-    # return {'plist': plist, 'distance': distance, 'plog': plog, 'opt': popt, 'std': stdev, 'pseudo_threshold': pseudo_thr}
-    return {'ps': ps, 'distance': distance, 'plog': plog}
+    # return {'plist': plist, 'distance': distance, 'plog': plog, 'opt': popt, 'std': stdev,
+    # 'pseudo_threshold': pseudo_thr}
+    return {"ps": ps, "distance": distance, "plog": plog}
 
 
 def find_polyfit(ps, plog, deg, verbose=True):
-
     plist = np.array(ps)
 
     popt, pcov = np.polyfit(ps, plog, deg=deg, cov=True)
 
     var = np.diag(pcov)
     stdev = np.sqrt(var)
 
     if verbose:
-        print('params=', popt)
-        print('std=', stdev)
+        print("params=", popt)
+        print("std=", stdev)
 
     pseudo_thr = find_pseudo(plist, plog, deg)
 
     if verbose:
-        print('Pseudo-threshold: %s' % pseudo_thr)
+        print("Pseudo-threshold: %s" % pseudo_thr)
 
     return pseudo_thr, popt, pcov
 
 
 def find_uniscalefit(ps, plog, distance, p0=None, maxfev=1000000, verbose=True, **kwargs):
     plist = np.array(ps)
     dlist = ns2nsfit(distance, len(plist))
@@ -130,68 +151,71 @@
     popt, pcov = curve_fit(func, (plist, dlist), plog, p0, maxfev=maxfev, **kwargs)
 
     var = np.diag(pcov)
     stdev = np.sqrt(var)
 
     for v in var:
         if np.isnan(v):
-            raise Exception('Was not able to find a good fit. Suggestion: Use `p0` to specify parameter guess.')
+            msg = "Was not able to find a good fit. Suggestion: Use `p0` to specify parameter guess."
+            raise Exception(msg)
 
     pseudo_thr = popt[0]
     v0 = popt[1]
     pseudo_thr_std = stdev[0]
     v0_std = stdev[1]
 
     if verbose:
-        print('pseudo-threshold: %s +- %s (1 stdev)' % (pseudo_thr, pseudo_thr_std))
-        print('v0: %s +- %s (1 stdev)' % (v0, v0_std))
+        print(f"pseudo-threshold: {pseudo_thr} +- {pseudo_thr_std} (1 stdev)")
+        print(f"v0: {v0} +- {v0_std} (1 stdev)")
 
     return pseudo_thr, pseudo_thr_std, v0, v0_std, popt, pcov
 
 
 def ns2nsfit(ns, num):
-    """
-    Returns a list of distances or ps for performing fits.
+    """Returns a list of distances or ps for performing fits.
 
     If ds == 5 and num == 3:
         -> [5, 5, 5]
 
     If ds == [3, 5, 7] and num == 3:
         -> [3, 3, 3, 5, 5, 5, 7, 7, 7]
 
     Likewise for ps.
 
     Args:
+    ----
         ds:
         num:
 
     Returns:
+    -------
 
     """
     if isinstance(ns, int):
-        return [ns]*num
+        return [ns] * num
 
     else:
         new_list = []
 
         for i in ns:
-            new_list.extend([i]*num)
+            new_list.extend([i] * num)
         return new_list
 
 
 def find_pseudo(plist, plog, deg):
-    """
-    Determines the pseudo threshold from list of ps and plogs.
+    """Determines the pseudo threshold from list of ps and plogs.
 
     Args:
+    ----
         plist:
         plog:
         deg:
 
     Returns:
+    -------
         float: The value of the pseudo-threshold.
 
     """
     popt = np.polyfit(plist, plog, deg=deg)
     poly = np.poly1d(popt)
 
     def fnc(x):
@@ -202,63 +226,61 @@
     except ValueError:
         pseudo_thr = newton(fnc, 0.05)
 
     return pseudo_thr
 
 
 def plot(plist, plog, deg=2, figsize=(10, 10), p_start=None, p_end=None):
-    """
-
-    Args:
+    """Args:
+    ----
         plist:
         plog:
         deg(int): Degree of polynomial fit.
         figsize(tuple of int):
         axis_start(float): Where the x and y axes begin.
         axis_end(float): Where the x and y axes end.
 
     Returns:
+    -------
 
     """
-
     if p_start is None:
         p_start = min(plog) * 0.9
 
     if p_end is None:
         p_end = max(plog) * 1.1
 
-    psuedo_thr = find_pseudo(plist, plog, deg)
+    pseudo_thr = find_pseudo(plist, plog, deg)
 
     popt, _ = np.polyfit(plist, plog, deg, cov=True)  # C_z is estimated covariance matrix
 
     axis_start = p_start
     axis_end = p_end
 
     x = np.linspace(axis_start, axis_end, 1000)
 
     poly = np.poly1d(popt)
     yi = poly(x)
 
     # Do the plotting:
     fg, ax = plt.subplots(1, 1, figsize=figsize)
-    # ax.set_title("Polynomial Fit of Degree %s with Error of $\pm1\sigma$" % deg, size=20)
     ax.set_title("Pseudothreshold from Polynomial Fit of Degree %s" % deg, size=20)
 
-    ax.plot(x, yi, '-', )
-    ax.plot(plist, plog, 'ro')
-    ax.axis('tight')
+    ax.plot(x, yi, "-")
+    ax.plot(plist, plog, "ro")
+    ax.axis("tight")
 
     y = x
-    plt.plot(x, y, 'k-', alpha=.30)
+    plt.plot(x, y, "k-", alpha=0.30)
 
     ax.set_ylim(axis_start, axis_end)
     ax.set_xlim(axis_start, axis_end)
 
-    plt.xlabel('Physical error rate', size=18)
-    plt.ylabel('Logical error rate', size=18)
+    plt.xlabel("Physical error rate", size=18)
+    plt.ylabel("Logical error rate", size=18)
 
-    pth = psuedo_thr
-    plt.axvline(pth, color='green', linewidth=2, linestyle='dashed', label='Pseudo-threshold (%s)' % pth)
+    pth = pseudo_thr
+    plt.axvline(pth, color="green", linewidth=2, linestyle="dashed", label="Pseudo-threshold (%s)" % pth)
     plt.legend(fontsize=16)
 
     fg.canvas.draw()
     plt.show()
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/tools/random_circuit_speed.py` & `quantum_pecos-0.6.0.dev1/python/pecos/tools/random_circuit_speed.py`

 * *Files 20% similar despite different names*

```diff
@@ -8,76 +8,109 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 import numpy as np
-from ..circuits import QuantumCircuit
+
+from pecos.circuits import QuantumCircuit
 from pecos.engines.circuit_runners import TimingRunner
-from ..simulators import pySparseSim
+from pecos.simulators import pySparseSim
 
 
 def random_circuit_speed(state_sim, num_qubits, circuit_depth, trials=10000, gates=None, seed_start=0, converter=None):
-
     circuits = generate_circuits(num_qubits, circuit_depth, trials, gates, seed_start)
 
     times = []
     measurements = []
 
     circ_sim = TimingRunner()
     for qc in circuits:
-
         if converter is not None:
             qc = converter(qc)
 
-        # state = circ_sim.init(num_qubits, state_sim)
         state = pySparseSim(num_qubits)
         circ_sim.reset_time()
         meas = circ_sim.run(state, qc)
         times.append(circ_sim.total_time)
         measurements.append(meas)
 
     return times, measurements, circuits
 
 
 def generate_circuits(num_qubits, circuit_depth, trials=100000, gates=None, seed_start=0, iterate=False):
-
     if gates is None:
-
-        gates = ['I', 'X', 'Y', 'Z', 'S', 'Sd', 'Q', 'Qd', 'R', 'Rd',
-                 'H', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
-                 'H+z+x', 'H-z-x', 'H+y-z', 'H-y-z', 'H-x+y', 'H-x-y',
-                 'F1', 'F1d', 'F2', 'F2d', 'F3', 'F3d', 'F4', 'F4d',
-                 'CNOT', 'CZ', 'SWAP', 'G', 'II',
-                 'measure X', 'measure Y', 'measure Z',
-                 'init |+>', 'init |->', 'init |+i>', 'init |-i>', 'init |0>', 'init |1>', ]
+        gates = [
+            "I",
+            "X",
+            "Y",
+            "Z",
+            "S",
+            "Sd",
+            "Q",
+            "Qd",
+            "R",
+            "Rd",
+            "H",
+            "H1",
+            "H2",
+            "H3",
+            "H4",
+            "H5",
+            "H6",
+            "H+z+x",
+            "H-z-x",
+            "H+y-z",
+            "H-y-z",
+            "H-x+y",
+            "H-x-y",
+            "F1",
+            "F1d",
+            "F2",
+            "F2d",
+            "F3",
+            "F3d",
+            "F4",
+            "F4d",
+            "CNOT",
+            "CZ",
+            "SWAP",
+            "G",
+            "II",
+            "measure X",
+            "measure Y",
+            "measure Z",
+            "init |+>",
+            "init |->",
+            "init |+i>",
+            "init |-i>",
+            "init |0>",
+            "init |1>",
+        ]
 
     circuits = []
 
-    for seed in range(seed_start, seed_start+trials):
-
+    for seed in range(seed_start, seed_start + trials):
         np.random.seed(seed)
         circuit_elements = list(np.random.choice(gates, circuit_depth))
         qc = QuantumCircuit()
 
         for element in circuit_elements:
-
             params = {}
 
-            if element in {'CNOT', 'CZ', 'SWAP', 'G', 'II', 'CY'}:
+            if element in {"CNOT", "CZ", "SWAP", "G", "II", "CY"}:
                 q = get_qubits(num_qubits, 2)
-                # q = tuple(q)
                 q = (int(q[0]), int(q[1]))
 
             else:
                 q = int(get_qubits(num_qubits, 1))
 
-                if element in {'measure Z', 'measure X', 'measure Y'}:
-                    params = {'gate_kwargs': {'forced_outcome': 0}}
+                if element in {"measure Z", "measure X", "measure Y"}:
+                    params = {"gate_kwargs": {"forced_outcome": 0}}
 
             qc.append(element, {q}, **params)
 
         if iterate:
             yield qc
         else:
             circuits.append(qc)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/tools/stabilizer_verification.py` & `quantum_pecos-0.6.0.dev1/python/pecos/tools/stabilizer_verification.py`

 * *Files 11% similar despite different names*

```diff
@@ -8,39 +8,37 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
 from itertools import combinations, product
-from ..circuits import QuantumCircuit
-from .. import simulators
 
-# TODO: NEED TO ADD SIGN TRACKING TO DESTABILIZERS TO GET THE RIGHT SIGN FOR LOGICAL Xs
+from pecos import simulators
+from pecos.circuits import QuantumCircuit
 
+# TODO: NEED TO ADD SIGN TRACKING TO DESTABILIZERS TO GET THE RIGHT SIGN FOR LOGICAL Xs
 
-class VerifyStabilizers(object):
-    """
-    Used to define a stabilizer QECC.
-    """
 
-    def __init__(self):
+class VerifyStabilizers:
+    """Used to define a stabilizer QECC."""
 
+    def __init__(self) -> None:
         self.circ_sim = simulators.pySparseSim
 
         self.checks = []
         self.logical_zs = []
         self.logical_xs = []
         self.logical_zs_defined = []  # User chosen logical Zs TODO: ...
         self.logical_xs_defined = []  # User chosen logical Xs TODO: ...
         self.logical_zs_reference = {}
         self.logical_xs_reference = {}
 
-        self.data_qubits = set([])
-        self.ancilla_qubits = set([])
+        self.data_qubits = set()
+        self.ancilla_qubits = set()
         self.circuit = None
 
         self.check_row_x = None
         self.check_row_z = None
         self.check_col_x = None
         self.check_col_z = None
 
@@ -51,271 +49,266 @@
 
         # distance
         self.dist = None
 
         self.state = None
 
     def check(self, paulis, qubits):
-        """
-
-        Args:
+        """Args:
+        ----
             paulis(sequence of str):
             qubits(sequence of int):
 
         Returns: None
 
         """
-
         if not qubits:
-            raise Exception('No qubit ids given.')
+            msg = "No qubit ids given."
+            raise Exception(msg)
 
-        check_string = 'check('+str(paulis)+', '+str(qubits)+')'
+        check_string = "check(" + str(paulis) + ", " + str(qubits) + ")"
 
         if isinstance(paulis, str):
-            if paulis not in ['X', 'x', 'Y', 'y', 'Z', 'z']:
-                raise Exception('Paulis should be "X", "Y" or "Z"!')
+            if paulis not in ["X", "x", "Y", "y", "Z", "z"]:
+                msg = 'Paulis should be "X", "Y" or "Z"!'
+                raise Exception(msg)
 
             paulis_new = [paulis for _ in qubits]
             paulis = paulis_new
 
         if not isinstance(paulis, str) and len(paulis) != len(qubits):
-            raise Exception('Number of Paulis and qubits do not match!!!')
+            msg = "Number of Paulis and qubits do not match!!!"
+            raise Exception(msg)
 
         self.checks.append((paulis, qubits, check_string))
         self.data_qubits.update(qubits)
 
     def logicalz(self, paulis, qubits):
-        """
-        Used to define logical Z.
+        """Used to define logical Z.
 
         Args:
+        ----
             paulis:
             qubits:
 
         Returns:
+        -------
 
         """
-
         if not qubits:
-            raise Exception('No qubit ids given.')
+            msg = "No qubit ids given."
+            raise Exception(msg)
 
-        logical_string = 'check(' + str(paulis) + ', ' + str(qubits) + ')'
+        logical_string = "check(" + str(paulis) + ", " + str(qubits) + ")"
 
         if isinstance(paulis, str):
-            if paulis not in ['X', 'x', 'Y', 'y', 'Z', 'z']:
-                raise Exception('Paulis should be "X", "Y" or "Z"!')
+            if paulis not in ["X", "x", "Y", "y", "Z", "z"]:
+                msg = 'Paulis should be "X", "Y" or "Z"!'
+                raise Exception(msg)
 
             paulis_new = [paulis for _ in qubits]
             paulis = paulis_new
 
         if not isinstance(paulis, str) and len(paulis) != len(qubits):
-            raise Exception('Number of Paulis and qubits do not match!!!')
+            msg = "Number of Paulis and qubits do not match!!!"
+            raise Exception(msg)
 
         self.logical_zs.append((paulis, qubits, logical_string))
 
     def logicalx(self, paulis, qubits):
-        """
-        Used to define logical X.
+        """Used to define logical X.
 
         Args:
+        ----
             paulis:
             qubits:
 
         Returns:
+        -------
 
         """
-
         if not qubits:
-            raise Exception('No qubit ids given.')
+            msg = "No qubit ids given."
+            raise Exception(msg)
 
-        logical_string = 'check(' + str(paulis) + ', ' + str(qubits) + ')'
+        logical_string = "check(" + str(paulis) + ", " + str(qubits) + ")"
 
         if isinstance(paulis, str):
-            if paulis not in ['X', 'x', 'Y', 'y', 'Z', 'z']:
-                raise Exception('Paulis should be "X", "Y" or "Z"!')
+            if paulis not in ["X", "x", "Y", "y", "Z", "z"]:
+                msg = 'Paulis should be "X", "Y" or "Z"!'
+                raise Exception(msg)
 
             paulis_new = [paulis for _ in qubits]
             paulis = paulis_new
 
         if not isinstance(paulis, str) and len(paulis) != len(qubits):
-            raise Exception('Number of Paulis and qubits do not match!!!')
+            msg = "Number of Paulis and qubits do not match!!!"
+            raise Exception(msg)
 
         self.logical_xs.append((paulis, qubits, logical_string))
 
     def num_logical_qubits(self):
         return len(self.data_qubits) - len(self.checks)
 
     def generators(self, print_y=True, verbose=True):
-        """
-        Evaluates the stabilizer generators that have been supplied via the `check` method.
+        """Evaluates the stabilizer generators that have been supplied via the `check` method.
 
         Args:
+        ----
             print_y:
             verbose:
 
         Returns:
+        -------
 
         """
-
         if self.circuit is None:
-            raise Exception('Must compile circuits first!')
+            msg = "Must compile circuits first!"
+            raise Exception(msg)
 
         state = self.state
         z, x, stab_strings, destab_strings = self.get_info(state, print_y=print_y, verbose=verbose)
 
         return z, x, stab_strings, destab_strings
 
     def _check_all_labels(self):
-        """
-        This checks to see that all the consecutive qubit ids have been used and none are missing.
+        """This checks to see that all the consecutive qubit ids have been used and none are missing.
 
         Returns:
+        -------
 
         """
-
         qubit_labels = set()
 
         checks = self.checks
-        for _, check in enumerate(checks):
+        for check in checks:
             _, qs, _ = check
             qubit_labels.update(qs)
 
         largest_labels = max(qubit_labels)
-        labels_should_have = set(range(largest_labels+1))
+        labels_should_have = set(range(largest_labels + 1))
 
         dont_have = labels_should_have - qubit_labels
 
         if dont_have:
-            raise Exception('Qubit ids missing: %s' % dont_have)
-
-    def _check2rowcol(self):
-        """
-        Creates row and column matrices.
-
-        Returns:
+            raise Exception("Qubit ids missing: %s" % dont_have)
 
-        """
+    def _check2rowcol(self) -> None:
+        """Creates row and column matrices."""
         checks = self.checks
 
         num_checks = len(checks)
         row_x = [set() for _ in range(num_checks)]
         row_z = [set() for _ in range(num_checks)]
         col_x = [set() for _ in range(self.num_data_qubits)]
         col_z = [set() for _ in range(self.num_data_qubits)]
 
         for stab_id, check in enumerate(checks):
             ps, qs, _ = check
 
             for p, q in zip(ps, qs):
-
-                if p == 'X' or p == 'x':
+                if p in {"X", "x"}:
                     row_x[stab_id].add(q)
                     col_x[q].add(stab_id)
 
-                elif p == 'Z' or p == 'z':
+                elif p in {"Z", "z"}:
                     row_z[stab_id].add(q)
                     col_z[q].add(stab_id)
 
-                elif p == 'Y' or p == 'y':
+                elif p in {"Y", "y"}:
                     row_x[stab_id].add(q)
                     row_z[stab_id].add(q)
                     col_x[q].add(stab_id)
                     col_z[q].add(stab_id)
 
         self.check_row_x = row_x
         self.check_row_z = row_z
         self.check_col_x = col_x
         self.check_col_z = col_z
 
     def _check_commute(self):
-        """
-        Checks to see that all the stabilizer generators commute.
+        """Checks to see that all the stabilizer generators commute.
 
         Returns:
             Returns bool value if all the checks commute or not.
         """
-
         row_x = self.check_row_x
         row_z = self.check_row_z
         col_x = self.check_col_x
         col_z = self.check_col_z
 
-        # print(row_x, row_z, col_x, col_z)
-
         for stab_id in range(len(self.checks)):
-
             anti_zs = set()
             for q in row_x[stab_id]:
                 anti_zs ^= col_z[q]
 
             anti_xs = set()
             for q in row_z[stab_id]:
                 anti_xs ^= col_x[q]
 
             anti = anti_xs ^ anti_zs
             anti.discard(stab_id)
 
             if anti:
-                print('\nChecks anticommute!')
-                print('\nCheck:')
+                print("\nChecks anticommute!")
+                print("\nCheck:")
                 for s in anti:
-                    # print('Xs-%s Zs-%s' % (row_x[s], row_z[s]))
                     print(self.checks[s][2])
-                print('\nanticommutes with:')
-                # print('Xs-%s Zs-%s' % (row_x[stab_id], row_z[stab_id]))
+                print("\nanticommutes with:")
                 print(self.checks[stab_id][2])
 
-                raise Exception('Checks anticommute!')
+                msg = "Checks anticommute!"
+                raise Exception(msg)
         return True
 
     def compile(self):
-        """
-        Checks commutation relations and creates a circuit to measure the checks.
+        """Checks commutation relations and creates a circuit to measure the checks.
 
         Returns:
+        -------
 
         """
-
         if self.circuit:
-            raise Exception('Measurement encoding-circuit has already been compiled!')
+            msg = "Measurement encoding-circuit has already been compiled!"
+            raise Exception(msg)
 
         # Check the qubit ids
         self._check_all_labels()
 
         # Create row and column matrices.
         self._check2rowcol()
 
         # Checks that all the stabilizer generators (checks) commute.
         self._check_commute()
 
         # Create check circuits:
         # ----------------------
-        ancilla_qubits = set([])
+        ancilla_qubits = set()
         qc = QuantumCircuit()
 
         ancilla_id = sorted(self.data_qubits)[-1]
 
-        for (ps, qs, _) in self.checks:
+        for ps, qs, _ in self.checks:
             ancilla_id += 1
             ancilla_qubits.add(ancilla_id)
-            qc.append('init |+>', {ancilla_id})
+            qc.append("init |+>", {ancilla_id})
 
             for p, q in zip(ps, qs):
                 symbol = None
 
-                if p == 'X' or p == 'x':
-                    symbol = 'CNOT'
-                elif p == 'Z' or p == 'z':
-                    symbol = 'CZ'
-                elif p == 'Y' or p == 'y':
-                    symbol = 'CY'
+                if p in {"X", "x"}:
+                    symbol = "CNOT"
+                elif p in {"Z", "z"}:
+                    symbol = "CZ"
+                elif p in {"Y", "y"}:
+                    symbol = "CY"
 
                 qc.append(symbol, {(ancilla_id, q)})
 
-            qc.append('measure X', {ancilla_id}, random_outcome=0)
+            qc.append("measure X", {ancilla_id}, random_outcome=0)
 
         self.ancilla_qubits = ancilla_qubits
 
         self.circuit = qc
 
         # Run circuits
         # ------------
@@ -326,137 +319,130 @@
         self.get_info(state, verbose=False)
         self.state = state
 
         self._verify_checks()
         self._check_logical_commute()
 
     def _check_logical_commute(self):
-
         logical_z_col_x = [set() for _ in range(self.num_data_qubits)]
         logical_z_col_z = [set() for _ in range(self.num_data_qubits)]
         logical_z_row_x = [set() for _ in range(len(self.logical_zs))]
         logical_z_row_z = [set() for _ in range(len(self.logical_zs))]
 
         logical_x_col_x = [set() for _ in range(self.num_data_qubits)]
         logical_x_col_z = [set() for _ in range(self.num_data_qubits)]
         logical_x_row_x = [set() for _ in range(len(self.logical_xs))]
         logical_x_row_z = [set() for _ in range(len(self.logical_xs))]
 
         for i, (ps, qs, _) in enumerate(self.logical_zs):
             for p, q in zip(ps, qs):
-                if p == 'X' or p == 'Y':
+                if p in {"X", "Y"}:
                     logical_z_col_x[q].add(i)
                     logical_z_row_x[i].add(q)
 
-                if p == 'Z' or p == 'Y':
+                if p in {"Z", "Y"}:
                     logical_z_col_z[q].add(i)
                     logical_z_row_z[i].add(q)
 
         for i, (ps, qs, _) in enumerate(self.logical_xs):
             for p, q in zip(ps, qs):
-                if p == 'X' or p == 'Y':
+                if p in {"X", "Y"}:
                     logical_x_col_x[q].add(i)
                     logical_x_row_x[i].add(q)
 
-                if p == 'Z' or p == 'Y':
+                if p in {"Z", "Y"}:
                     logical_x_col_z[q].add(i)
                     logical_x_row_z[i].add(q)
 
-
         for s in range(len(self.logical_zs)):
             anti_zs = set()
             for q in logical_z_row_x[s]:
                 anti_zs ^= logical_z_col_z[q]
 
             anti_xs = set()
             for q in logical_z_row_z[s]:
                 anti_xs ^= logical_z_col_x[q]
 
             anti = anti_xs ^ anti_zs
             anti.discard(s)
 
             if anti:
-                print('\nLogical Zs anticommute!')
-                print('\nLogical Zs:')
+                print("\nLogical Zs anticommute!")
+                print("\nLogical Zs:")
                 for i in anti:
-                    # print('Xs-%s Zs-%s' % (row_x[s], row_z[s]))
                     print(self.logical_zs[i][2])
-                print('\nanticommutes with:')
-                # print('Xs-%s Zs-%s' % (row_x[stab_id], row_z[stab_id]))
+                print("\nanticommutes with:")
                 print(self.logical_zs[s][2])
 
-                raise Exception('Logical Zs anticommute!')
+                msg = "Logical Zs anticommute!"
+                raise Exception(msg)
 
         for s in range(len(self.logical_xs)):
             anti_zs = set()
             for q in logical_x_row_x[s]:
                 anti_zs ^= logical_x_col_z[q]
 
             anti_xs = set()
             for q in logical_x_row_z[s]:
                 anti_xs ^= logical_x_col_x[q]
 
             anti = anti_xs ^ anti_zs
             anti.discard(s)
 
             if anti:
-                print('\nLogical Xs anticommute!')
-                print('\nLogical Xs:')
+                print("\nLogical Xs anticommute!")
+                print("\nLogical Xs:")
                 for i in anti:
-                    # print('Xs-%s Zs-%s' % (row_x[s], row_z[s]))
                     print(self.logical_xs[i][2])
-                print('\nanticommutes with:')
-                # print('Xs-%s Zs-%s' % (row_x[stab_id], row_z[stab_id]))
+                print("\nanticommutes with:")
                 print(self.logical_xs[s][2])
 
-                raise Exception('Logical Xs anticommute!')
+                msg = "Logical Xs anticommute!"
+                raise Exception(msg)
 
         # So far checked that all the logical Zs and logical Xs commute with themselves...
         # - Next check that they commute with the stabilizers...
         # - Then find if the there are anti-commuting pairs of logical Zs and Xs
         # - Then search for the logical operators and refactor...
         # This step might require switching logical Xs and Zs... Might be a bit complicated... as we can modify
         # "logical Xs" with destabilizers and swap those... So need to do a search through all stabilizers and
         # destabilizers and then determine if the required multiplication is valid with fix stabiliziers and whatever
         # has been fixed for the logical operators...
 
     def _verify_checks(self):
-
         # Stabilizers:
         checks = []
 
         for strings, qids, _ in self.checks:
-
             check_dict = {}
-            for P, q in zip(strings, qids):
-                if P == 'X':
-                    qset = check_dict.setdefault('X', set())
-                elif P == 'Z':
-                    qset = check_dict.setdefault('Z', set())
+            for pauli, q in zip(strings, qids):
+                if pauli == "X":
+                    qset = check_dict.setdefault("X", set())
+                elif pauli == "Z":
+                    qset = check_dict.setdefault("Z", set())
                 else:
-                    qset = check_dict.setdefault('Y', set())
+                    qset = check_dict.setdefault("Y", set())
                 qset.add(q)
             checks.append(check_dict)
 
         checks2 = []
         for i in range(len(self.checks)):
-
             xs = self.check_row_x[i]
             zs = self.check_row_z[i]
 
             stab_dict = {}
 
             if xs - zs:
-                stab_dict['X'] = xs - zs
+                stab_dict["X"] = xs - zs
 
             if zs - xs:
-                stab_dict['Z'] = zs - xs
+                stab_dict["Z"] = zs - xs
 
             if xs & zs:
-                stab_dict['Y'] = xs & zs
+                stab_dict["Y"] = xs & zs
 
             checks2.append(stab_dict)
 
         if checks != checks2:
             print("WARNING: PECOS didn't refactor the stabilizers into the checks supplied!")
 
         return checks != checks2
@@ -470,62 +456,61 @@
         if self.dist is None:
             self.distance(verbose=verbose)
 
         # Stabilizers:
         checks = []
 
         for strings, qids, _ in self.checks:
-
             check_dict = {}
-            for P, q in zip(strings, qids):
-                if P == 'X':
-                    qset = check_dict.setdefault('X', set())
-                elif P == 'Z':
-                    qset = check_dict.setdefault('Z', set())
+            for pauli, q in zip(strings, qids):
+                if pauli == "X":
+                    qset = check_dict.setdefault("X", set())
+                elif pauli == "Z":
+                    qset = check_dict.setdefault("Z", set())
                 else:
-                    qset = check_dict.setdefault('Y', set())
+                    qset = check_dict.setdefault("Y", set())
                 qset.add(q)
             checks.append(check_dict)
 
         # Destabilizers:
         destabs = []
         for i in self.data_gens:
             destab_dict = {}
             for j in range(len(destab_strings[i]) - self.num_ancilla_qubits):
-                P = destab_strings[i][j]
-                if P == 'X':
-                    qset = destab_dict.setdefault('X', set())
-                elif P == 'Z':
-                    qset = destab_dict.setdefault('Z', set())
-                elif P == 'Y':
-                    qset = destab_dict.setdefault('Y', set())
+                pauli = destab_strings[i][j]
+                if pauli == "X":
+                    qset = destab_dict.setdefault("X", set())
+                elif pauli == "Z":
+                    qset = destab_dict.setdefault("Z", set())
+                elif pauli == "Y":
+                    qset = destab_dict.setdefault("Y", set())
                 else:
                     continue
-                qset.add(j-2)
+                qset.add(j - 2)
             destabs.append(destab_dict)
 
         output_dict = {
-            'num_datas': self.num_data_qubits,
-            'num_logical_qubits': self.num_logical_qubits(),
-            'distance': self.dist,
-            '[[n, k, d]]': "[[%s, %s, %s]]" % (self.num_data_qubits, self.num_logical_qubits(), self.dist),
-            'checks': checks,
-            'destabilizers': destabs,
-            'logical_xs': x,
-            'logical_zs': z,
+            "num_datas": self.num_data_qubits,
+            "num_logical_qubits": self.num_logical_qubits(),
+            "distance": self.dist,
+            "[[n, k, d]]": f"[[{self.num_data_qubits}, {self.num_logical_qubits()}, {self.dist}]]",
+            "checks": checks,
+            "destabilizers": destabs,
+            "logical_xs": x,
+            "logical_zs": z,
         }
 
         self.logical_xs_reference = {}
         self.logical_zs_reference = {}
 
         for i, xi in enumerate(x):
-            self.logical_xs_reference['X'+str(i)] = xi
+            self.logical_xs_reference["X" + str(i)] = xi
 
         for i, zi in enumerate(z):
-            self.logical_zs_reference['Z'+str(i)] = zi
+            self.logical_zs_reference["Z" + str(i)] = zi
 
         return output_dict
 
     @property
     def num_data_qubits(self):
         return len(self.data_qubits)
 
@@ -534,473 +519,453 @@
         return len(self.ancilla_qubits)
 
     @property
     def num_qubits(self):
         return len(self.data_qubits) + len(self.ancilla_qubits)
 
     def refactor(self, state):
-
         found_stab_ids = set()
 
         refactor_things = list(self.checks)
         refactor_things.extend(self.logical_zs)
         # TODO: NEED TO REFACTOR THE DESTABILIZER OF LOGICAL Z TO GET THE RIGHT LOGICAL X.....
-        # refactor_things.extend(self.logical_xs)
 
-        for (ps, qs, _) in refactor_things:
-            xs = set([])
-            zs = set([])
+        for ps, qs, _ in refactor_things:
+            xs = set()
+            zs = set()
 
             for p, q in zip(ps, qs):
-
-                if p == 'X' or p == 'x':
+                if p in {"X", "x"}:
                     xs.add(q)
-                elif p == 'Z' or p == 'z':
+                elif p in {"Z", "z"}:
                     zs.add(q)
-                elif p == 'Y' or p == 'y':
+                elif p in {"Y", "y"}:
                     xs.add(q)
                     zs.add(q)
 
-            #found, stab_id = state.refactor(xs, zs, choose=0, protected=found_stab_ids)
-
             try:
                 found, stab_id = state.refactor(xs, zs, choose=0, protected=found_stab_ids)
             except IndexError:
-                xonly = xs -zs
+                xonly = xs - zs
                 zonly = zs - xs
                 ys = xs & zs
-                raise Exception("IndexError.\nThe stabilizer {'X': %s, 'Y': %s, 'Z': %s} is likely redundant!" %
-                                (xonly, ys, zonly))
+                msg = f"IndexError.\nThe stabilizer {{'X': {xonly}, 'Y': {ys}, 'Z': {zonly}}} is likely redundant!"
+                raise Exception(msg) from IndexError
 
             found_stab_ids.add(stab_id)
 
             if not found:
-                raise Exception('Could not find check:', (ps, qs))
-
-            # print('Found Xs - %s, Zs - %s, id = %s' % (xs, zs, stab_id))
-            # state.print_stabs(verbose=True, print_y=True,  print_destabs=True)
+                msg = "Could not find check:"
+                raise Exception(msg, (ps, qs))
 
         for q in self.ancilla_qubits:
             found, stab_id = state.refactor({q}, set(), choose=-1, protected=found_stab_ids)
             found_stab_ids.add(stab_id)
 
             if not found:
-                raise Exception('Could not find ancilla %s' % q)
-
-            # print('Found Xs - %s, Zs - %s, id = %s' % ({q}, set(), stab_id))
-            # state.print_stabs(verbose=True, print_y=True,  print_destabs=True)
+                raise Exception("Could not find ancilla %s" % q)
 
     def get_check_ancilla(self):
         check_tuples = []
         ancilla_tuples = []
 
-        for (ps, qs, _) in self.checks:
-            xs = set([])
-            zs = set([])
+        for ps, qs, _ in self.checks:
+            xs = set()
+            zs = set()
 
             for p, q in zip(ps, qs):
-
-                if p == 'X' or p == 'x':
+                if p in {"X", "x"}:
                     xs.add(q)
-                elif p == 'Z' or p == 'z':
+                elif p in {"Z", "z"}:
                     zs.add(q)
-                elif p == 'Y' or p == 'y':
+                elif p in {"Y", "y"}:
                     xs.add(q)
                     zs.add(q)
 
             check_tuples.append((xs, zs))
 
         for q in self.ancilla_qubits:
-            ancilla_tuples.append(({q}, set([])))
+            ancilla_tuples.append(({q}, set()))
 
         return check_tuples, ancilla_tuples
 
     def get_info(self, state, stop_search=1000, verbose=True, print_y=False):
-
         if self.circuit is None:
-            return Exception('Must run `compile()` first!')
+            return Exception("Must run `compile()` first!")
 
         self.refactor(state)
-        stab_strs, destab_strs = state.print_stabs(verbose=False, print_y=print_y,  print_destabs=True)
+        stab_strs, destab_strs = state.print_stabs(verbose=False, print_y=print_y, print_destabs=True)
 
         num_ancillas = len(self.ancilla_qubits)
 
         num_logical = self.num_logical_qubits()
         num_checks = len(self.checks)
 
         if verbose:
-            print('Number of data qubits: %s' % self.num_data_qubits)
-            print('Number of checks: %s' % num_checks)
-            print('Number of logical qubits: %s' % num_logical)
+            print("Number of data qubits: %s" % self.num_data_qubits)
+            print("Number of checks: %s" % num_checks)
+            print("Number of logical qubits: %s" % num_logical)
 
         check_tuples, ancilla_tuples = self.get_check_ancilla()
         # determine the gen_id of the checks and logicals
         check_gens = []
         logical_gens = []
         ancilla_gens = []
 
-        # print(ancilla_tuples)
-
         missing_checks = list(check_tuples)
         missing_ancillas = list(ancilla_tuples)
         notmatched_gens = list(range(state.num_qubits))
 
         found_all = False
         search_count = 0
         while not found_all:
             if verbose:
-                print('----')
+                print("----")
             for g, gtuple in enumerate(zip(state.stabs.row_x, state.stabs.row_z)):
                 if gtuple in missing_checks:
                     missing_checks.remove(gtuple)
-                    # print(g)
-                    # print(gtuple)
                     try:
                         notmatched_gens.remove(g)
                     except ValueError:
-                        raise Exception('list.remove(x): x not in list.\nThe stabilizer %s is likely redundant!' %
-                                        str(gtuple))
+                        raise Exception(
+                            "list.remove(x): x not in list.\nThe stabilizer %s is likely redundant!" % str(gtuple),
+                        ) from ValueError
 
                     check_gens.append(g)
                 elif gtuple in missing_ancillas:
                     missing_ancillas.remove(gtuple)
                     notmatched_gens.remove(g)
                     ancilla_gens.append(g)
 
             if len(notmatched_gens) == num_logical:
                 logical_gens = notmatched_gens
                 found_all = True
             else:
                 for xs, zs in missing_checks:
                     state.refactor(xs, zs, choose=0, prefer=notmatched_gens)
-                state.print_stabs(verbose=False, print_y=print_y,  print_destabs=True)
+                state.print_stabs(verbose=False, print_y=print_y, print_destabs=True)
 
             if search_count == stop_search:
-                raise Exception('Can not refactor properly!')
+                msg = "Can not refactor properly!"
+                raise Exception(msg)
             else:
                 search_count += 1
 
         self.data_gens = set(check_gens)
         self.ancilla_gens = set(ancilla_gens)
         self.logical_gens = set(logical_gens)
 
         if verbose:
-
             if len(check_gens) != num_checks:
-                print('Found:', check_gens)
-                print('Want:', check_tuples)
-                raise Exception('Did not find the correct number of stabilizer generators. %s/%s' %
-                                (len(check_gens), num_checks))
+                print("Found:", check_gens)
+                print("Want:", check_tuples)
+                msg = f"Did not find the correct number of stabilizer generators. {len(check_gens)}/{num_checks}"
+                raise Exception(msg)
 
             if len(logical_gens) != num_logical:
-                print('Found:', logical_gens)
-                raise Exception('Did not find the correct number of logical generators. %s/%s' %
-                                (len(logical_gens), num_logical))
+                print("Found:", logical_gens)
+                msg = f"Did not find the correct number of logical generators. {len(logical_gens)}/{num_logical}"
+                raise Exception(msg)
 
-            print('\nStabilizer generators:')
+            print("\nStabilizer generators:")
             for gen in check_gens:
-                print(stab_strs[gen][:len(stab_strs[gen])-num_ancillas])
+                print(stab_strs[gen][: len(stab_strs[gen]) - num_ancillas])
 
-            print('\nDestabilizer generators:')
+            print("\nDestabilizer generators:")
             for gen in check_gens:
-                print(destab_strs[gen][:len(destab_strs[gen]) - num_ancillas])
+                print(destab_strs[gen][: len(destab_strs[gen]) - num_ancillas])
 
-            print('\nLogical operators:')
+            print("\nLogical operators:")
 
             for i, gen in enumerate(logical_gens):
-                print('\n. Logical Z #%s:' % str(i+1))
-                print(stab_strs[gen][:len(stab_strs[gen])-num_ancillas])
-                print('. Logical X #%s:' % str(i + 1))
-                print(destab_strs[gen][:len(destab_strs[gen]) - num_ancillas])
+                print("\n. Logical Z #%s:" % str(i + 1))
+                print(stab_strs[gen][: len(stab_strs[gen]) - num_ancillas])
+                print(". Logical X #%s:" % str(i + 1))
+                print(destab_strs[gen][: len(destab_strs[gen]) - num_ancillas])
 
         logical_z_strings = []
         logical_x_strings = []
 
-        for i, gen in enumerate(logical_gens):
-
-            z_string = stab_strs[gen][:len(stab_strs[gen]) - num_ancillas]
-            x_string = destab_strs[gen][:len(destab_strs[gen]) - num_ancillas]
+        for gen in logical_gens:
+            z_string = stab_strs[gen][: len(stab_strs[gen]) - num_ancillas]
+            x_string = destab_strs[gen][: len(destab_strs[gen]) - num_ancillas]
 
             check_dict = {}
-            for q, P in enumerate(z_string):
-                if P == 'X':
-                    qset = check_dict.setdefault('X', set())
-                elif P == 'Z':
-                    qset = check_dict.setdefault('Z', set())
-                elif P == 'Y':
-                    qset = check_dict.setdefault('Y', set())
+            for q, pauli in enumerate(z_string):
+                if pauli == "X":
+                    qset = check_dict.setdefault("X", set())
+                elif pauli == "Z":
+                    qset = check_dict.setdefault("Z", set())
+                elif pauli == "Y":
+                    qset = check_dict.setdefault("Y", set())
                 else:
                     continue
-                qset.add(q-2)
+                qset.add(q - 2)
             logical_z_strings.append(check_dict)
 
             check_dict = {}
-            for q, P in enumerate(x_string):
-                if P == 'X':
-                    qset = check_dict.setdefault('X', set())
-                elif P == 'Z':
-                    qset = check_dict.setdefault('Z', set())
-                elif P == 'Y':
-                    qset = check_dict.setdefault('Y', set())
+            for q, pauli in enumerate(x_string):
+                if pauli == "X":
+                    qset = check_dict.setdefault("X", set())
+                elif pauli == "Z":
+                    qset = check_dict.setdefault("Z", set())
+                elif pauli == "Y":
+                    qset = check_dict.setdefault("Y", set())
                 else:
                     continue
 
-                qset.add(q-2)
+                qset.add(q - 2)
             logical_x_strings.append(check_dict)
 
         return logical_z_strings, logical_x_strings, stab_strs, destab_strs
 
     def distance(self, css=False, verbose=True):
-        """
-        Checks the distance of the code.
+        """Checks the distance of the code.
 
         Returns:
+        -------
 
         """
-
         if self.circuit is None:
-            raise Exception('Must compile circuits first!')
+            msg = "Must compile circuits first!"
+            raise Exception(msg)
 
         qudit_set = self.data_qubits
 
         state = self.state
         found = self._dist_mode_smallest(state, qudit_set, css=css, verbose=verbose)
 
-        if verbose:
-            if found:
-                xs, zs = found
-                distance = len(xs | zs)
+        if verbose and found:
+            xs, zs = found
+            distance = len(xs | zs)
 
-                print('\nThis is a [[%s, %s, %s]] code.' % (self.num_data_qubits, self.num_logical_qubits(), distance))
+            print(f"\nThis is a [[{self.num_data_qubits}, {self.num_logical_qubits()}, {distance}]] code.")
 
         if not found:
-            print('No logical errors found... Checks might describe a stabilizer state.')
+            print("No logical errors found... Checks might describe a stabilizer state.")
+            return None
         else:
-
             xs, zs = found
             self.dist = len(xs | zs)
             return found
 
-    def _dist_mode_smallest(self, state, qudit_set, css=False, verbose=True, start_len=None, end_len=None,
-                            list_ops=False):
-        """
-        Determine if a logical error can be found by starting with the smallest weight errors
+    def _dist_mode_smallest(
+        self,
+        state,
+        qudit_set,
+        css=False,
+        verbose=True,
+        start_len=None,
+        end_len=None,
+        list_ops=False,
+    ):
+        """Determine if a logical error can be found by starting with the smallest weight errors.
 
         Args:
+        ----
             state:
             qudit_set:
 
         Returns:
+        -------
 
         """
-
         ops = []
 
         if start_len is None:
             start_len = 1
 
         if end_len is None:
             end_len = len(qudit_set)
 
-        for lenq in range(start_len, end_len+1):
-
+        for lenq in range(start_len, end_len + 1):
             if verbose:
-                print('Checking Paulis of weight %s...' % lenq)
+                print("Checking Paulis of weight %s..." % lenq)
 
             for xs, zs in self.gen_errors(qudit_set, lenq, lenq, css=css):
                 if self._is_logical_error(state, xs, zs):
                     if verbose:
-                        print("Logical operator found: Xs - %s Zs - %s" % (xs, zs))
+                        print(f"Logical operator found: Xs - {xs} Zs - {zs}")
 
                     if list_ops:
-                        ops.append({'X': xs, 'Z': zs})
+                        ops.append({"X": xs, "Z": zs})
                     else:
                         return xs, zs
 
         return ops
 
     def gen_errors(self, qubits, min_errors=1, max_errors=False, css=False):
-        """
-
-        Args:
+        """Args:
+        ----
             qubits (set of int):
             min_errors (int):
             max_errors (bool, int):
             css (bool):
 
         Returns:
+        -------
 
         """
-
-        paulis = ('X', 'Z', 'Y')
+        paulis = ("X", "Z", "Y")
 
         num_qubits = len(qubits)
 
         for i in range(min_errors, num_qubits + 1):
-
             if max_errors and i > max_errors:
                 break
 
-            xs = next(product(('X',), repeat=i))
-            zs = next(product(('Z',), repeat=i))
+            xs = next(product(("X",), repeat=i))
+            zs = next(product(("Z",), repeat=i))
 
             xzs = [xs, zs]
 
-            # print(xs)
-            # print(zs)
-
             for b in combinations(qubits, i):
-
                 for ps in xzs:
-
                     x_set = set()
                     z_set = set()
                     for p, q in zip(ps, b):
-                        if p == 'X':
+                        if p == "X":
                             x_set.add(q)
                         else:
                             z_set.add(q)
                     yield x_set, z_set
 
             if not css:
                 for a in product(paulis, repeat=i):
-                    if a == xs or a == zs:
+                    if a in (xs, zs):
                         continue
 
                     for b in combinations(qubits, i):
                         x_set = set()
                         z_set = set()
                         for p, q in zip(a, b):
-                            if p == 'X':
+                            if p == "X":
                                 x_set.add(q)
-                            elif p == 'Z':
+                            elif p == "Z":
                                 z_set.add(q)
                             else:
                                 x_set.add(q)
                                 z_set.add(q)
                         yield x_set, z_set
 
     def _is_logical_error(self, state, xs, zs):
-
         # A trivial error anticommutes with the checks. (Might or might not anticommute with the logical stabilizers)
         # A logical error commutes with the checks and is not a product of checks.
 
         # Does the error anticommute with the checks?
-        x_anticoms = set([])
-        z_anticoms = set([])
+        x_anticoms = set()
+        z_anticoms = set()
         for q in xs:
             x_anticoms ^= state.stabs.col_z[q]
 
         for q in zs:
             z_anticoms ^= state.stabs.col_x[q]
 
         anticoms = x_anticoms ^ z_anticoms
         anticom_logical_zs = self.logical_gens & anticoms
         anticoms -= self.logical_gens
 
         if anticoms:
             return False
-        else:
-
+        elif anticom_logical_zs:
             # So the error commutes with all the stabilizers
             # Did it anticommute with any logical Z operations? If so... It is a product of logical Xs!
             # (and possibly other things)
-            if anticom_logical_zs:
-                return True
-            else:
-                # Let's see if the error anticommuted with any logical X operators:
+            return True
+        else:
+            # Let's see if the error anticommuted with any logical X operators:
 
-                x_anticoms_destabs = set([])
-                z_anticoms_destabs = set([])
+            x_anticoms_destabs = set()
+            z_anticoms_destabs = set()
 
-                for q in xs:
-                    x_anticoms_destabs ^= state.destabs.col_z[q]
+            for q in xs:
+                x_anticoms_destabs ^= state.destabs.col_z[q]
 
-                for q in zs:
-                    z_anticoms_destabs ^= state.destabs.col_x[q]
+            for q in zs:
+                z_anticoms_destabs ^= state.destabs.col_x[q]
 
-                anticoms_destabs = x_anticoms_destabs ^ z_anticoms_destabs
-                anticom_logical_xs = self.logical_gens & anticoms_destabs
+            anticoms_destabs = x_anticoms_destabs ^ z_anticoms_destabs
+            anticom_logical_xs = self.logical_gens & anticoms_destabs
 
-                # The error is a product of logical Zs
-                return bool(anticom_logical_xs)
+            # The error is a product of logical Zs
+            return bool(anticom_logical_xs)
 
     def shortest_logicals(self, start_weight=None, delta=0, verbose=True, css=False):
-        """
-        Find the shortest logical op
+        """Find the shortest logical op
         Args:
             start_weight (int): Weight of operators to begin searching.
             delta (int): Method will look for all logical ops with weight =< minimum weight + `delta`.
 
         Returns:
+        -------
             Dictionary of logical ops...
 
         """
-
         # if not self.logical_xs_reference and not self.logical_zs_reference:
-        #    self.eval(verbose=False)
 
         if start_weight is None:
-            if self.dist is not None:
-                start_weight = self.dist
-            else:
-                start_weight = 1
+            start_weight = self.dist if self.dist is not None else 1
 
         end_weight = start_weight + delta
 
         if self.circuit is None:
-            raise Exception('Must compile circuits first!')
+            msg = "Must compile circuits first!"
+            raise Exception(msg)
 
         qudit_set = self.data_qubits
 
         if end_weight > len(qudit_set):
             end_weight = len(qudit_set)
 
         state = self.state
-        found = self._dist_mode_smallest(state, qudit_set, css=css, verbose=False, start_len=start_weight,
-                                         end_len=end_weight, list_ops=True)
+        found = self._dist_mode_smallest(
+            state,
+            qudit_set,
+            css=css,
+            verbose=False,
+            start_len=start_weight,
+            end_len=end_weight,
+            list_ops=True,
+        )
 
         xs_labels = sorted(self.logical_xs_reference.keys())
         zs_labels = sorted(self.logical_zs_reference.keys())
 
         oplist = []
 
         if found:
             for paulis in found:
-                # weight = len(paulis['X'] | paulis['Z'])
-
                 op_product = []
                 for xi, op_label in enumerate(xs_labels):
                     if self.op_anticommute(paulis, self.logical_xs_reference[op_label]):
                         op_product.append(zs_labels[xi])
 
                 for zi, op_label in enumerate(zs_labels):
                     if self.op_anticommute(paulis, self.logical_zs_reference[op_label]):
                         op_product.append(xs_labels[zi])
 
                 op_product = sorted(op_product)
 
-                oplist.append({'X': paulis['X'], 'Z': paulis['Z'], 'equiv_ops': tuple(op_product)})
+                oplist.append({"X": paulis["X"], "Z": paulis["Z"], "equiv_ops": tuple(op_product)})
 
         if verbose:
-
-            print('Reference Logical Operators:')
-            print('\nLogical Xs:')
+            print("Reference Logical Operators:")
+            print("\nLogical Xs:")
             for op_label in xs_labels:
                 op = self.logical_xs_reference[op_label]
                 print(op_label, op)
-            print('\nLogical Zs:')
+            print("\nLogical Zs:")
             for op_label in zs_labels:
                 op = self.logical_zs_reference[op_label]
                 print(op_label, op)
 
-            print('\nLogical Ops Found:\n')
+            print("\nLogical Ops Found:\n")
             for foundop in oplist:
-                print('X - %s Z - %s Equiv Ops - %s' % (foundop['X'], foundop['Z'], foundop['equiv_ops']))
+                print("X - {} Z - {} Equiv Ops - {}".format(foundop["X"], foundop["Z"], foundop["equiv_ops"]))
 
         return oplist, self.logical_xs_reference, self.logical_zs_reference
 
     @staticmethod
     def op_anticommute(op1, op2):
-
-        return bool((len(op1.get('X', set()) & op2.get('Z', set())) +
-                     len(op2.get('X', set()) & op1.get('Z', set()))) % 2)
+        return bool(
+            (len(op1.get("X", set()) & op2.get("Z", set())) + len(op2.get("X", set()) & op1.get("Z", set()))) % 2,
+        )
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/tools/threshold_tools.py` & `quantum_pecos-0.6.0.dev1/python/pecos/tools/threshold_tools.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,51 +7,70 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+import contextlib
+
 import numpy as np
-from ..simulators import pySparseSim
-from .. import circuits
-from ..engines import circuit_runners
-from ..qeccs import Surface4444
-from ..decoders import MWPM2D
-from ..error_models import XModel
-from ..misc.threshold_curve import threshold_fit as default_fit, func as default_func
 
+from pecos import circuits
+from pecos.decoders import MWPM2D
+from pecos.engines import circuit_runners
+from pecos.error_models import XModel
+from pecos.misc.threshold_curve import func as default_func
+from pecos.misc.threshold_curve import threshold_fit as default_fit
+from pecos.qeccs import Surface4444
+from pecos.simulators import pySparseSim
+
+
+def threshold_code_capacity(
+    qecc_class,
+    error_gen,
+    decoder_class,
+    ps,
+    ds,
+    runs,
+    verbose=False,
+    mode=1,
+    threshold_fit=None,
+    p0=None,
+    func=None,
+    circuit_runner=None,
+    basis=None,
+):
+    """Function that generates p_logical values given a list of physical errors (ps) and distance (ds).
 
-def threshold_code_capacity(qecc_class, error_gen, decoder_class, ps, ds, runs, verbose=False, mode=1,
-                            threshold_fit=None, p0=None, func=None, circuit_runner=None, basis=None):
-    """
-    Function that generates p_logical values given a list of physical errors (ps) and distance (ds).
     Args:
-        ps(list of float):
-        ds(list of int):
-        runs(int):
-        error_gen:
+    ----
         qecc_class:
+        error_gen:
         decoder_class:
+        ps:
+        ds:
+        runs:
         verbose:
         mode:
         threshold_fit:
         p0:
         func:
         circuit_runner:
+        basis:
 
     Returns:
+    -------
 
     """
-
     if circuit_runner is None:
         circuit_runner = circuit_runners.Standard()
 
     if error_gen is None:
-        error_gen = XModel(model_level='code_capacity')
+        error_gen = XModel(model_level="code_capacity")
 
     if qecc_class is None:
         qecc_class = Surface4444
 
     if decoder_class is None:
         decoder_class = MWPM2D
 
@@ -60,88 +79,107 @@
 
     if func is None:
         func = default_func
 
         if p0 is None:
             p0 = (0.1, 1.5, 1, 1, 1)
 
-    if basis not in [None, 'zero', 'plus', 'both']:
-        raise Exception('`basis` can only be "None", "zero", "plus", "both"!')
+    if basis not in [None, "zero", "plus", "both"]:
+        msg = '`basis` can only be "None", "zero", "plus", "both"!'
+        raise Exception(msg)
 
-    if mode == 1 and basis != 'both':
+    if mode == 1 and basis != "both":
         determine_rate = codecapacity_logical_rate
-    elif mode == 1 and basis == 'both':
+    elif mode == 1 and basis == "both":
         determine_rate = codecapacity_logical_rate2
     elif mode == 2:
         determine_rate = codecapacity_logical_rate3
     else:
         raise Exception('Mode "%s" is not handled!' % mode)
 
     plist = np.array(ps * len(ds))
 
+    """
     dlist = []
     for d in ds:
         for p in ps:
             dlist.append(d)
     dlist = np.array(dlist)
+    """
 
     plog = []
     for d in ds:
-
         qecc = qecc_class(distance=d)
         decoder = decoder_class(qecc)
 
         for p in ps:
-
-            logical_error_rate, time = determine_rate(runs, qecc, d, error_gen, error_params={'p': p}, decoder=decoder,
-                                                      verbose=verbose, circuit_runner=circuit_runner, basis=basis)
+            logical_error_rate, time = determine_rate(
+                runs,
+                qecc,
+                d,
+                error_gen,
+                error_params={"p": p},
+                decoder=decoder,
+                verbose=verbose,
+                circuit_runner=circuit_runner,
+                basis=basis,
+            )
             if verbose:
                 if time:
-                    print('Runtime: %s s' % time)
+                    print("Runtime: %s s" % time)
 
-                print('----')
+                print("----")
 
             plog.append(logical_error_rate)
 
     plog = np.array(plog)
 
-    # results = threshold_fit(plist, dlist, plog, func, p0)
+    return {"distances": ds, "ps_physical": plist, "p_logical": plog}
 
-    # return plist, dlist, plog, results
-    # return {'distances': ds, 'ps': ps, 'plog': plog, 'opt': results[0], 'std': results[1]}
-    return {'distances': ds, 'ps_physical': plist, 'p_logical': plog}
 
+def threshold_code_capacity_calc(
+    ps,
+    ds,
+    runs,
+    error_gen=None,
+    qecc_class=None,
+    decoder_class=None,
+    verbose=True,
+    mode=1,
+    threshold_fit=None,
+    p0=None,
+    func=None,
+    circuit_runner=None,
+):
+    """Function that generates p_logical values given a list of physical errors (ps) and distance (ds).
 
-def threshold_code_capacity_calc(ps, ds, runs, error_gen=None, qecc_class=None, decoder_class=None, verbose=True,
-                                 mode=1, threshold_fit=None, p0=None, func=None, circuit_runner=None):
-    """
-    Function that generates p_logical values given a list of physical errors (ps) and distance (ds).
     Args:
+    ----
         ps(list of float):
         ds(list of int):
         runs(int):
         error_gen:
         qecc_class:
         decoder_class:
         verbose:
         mode:
         threshold_fit:
         p0:
         func:
         circuit_runner:
 
     Returns:
+    -------
 
     """
-
     if circuit_runner is None:
         circuit_runner = circuit_runners.Standard()
 
     if error_gen is None:
-        error_gen = XModel(model_level='code_capacity')
+        error_gen = XModel(model_level="code_capacity")
 
     if qecc_class is None:
         qecc_class = Surface4444
 
     if decoder_class is None:
         decoder_class = MWPM2D
 
@@ -163,292 +201,302 @@
     else:
         raise Exception('Mode "%s" is not handled!' % mode)
 
     plist = np.array(ps * len(ds))
 
     dlist = []
     for d in ds:
-        for p in ps:
+        for _p in ps:
             dlist.append(d)
     dlist = np.array(dlist)
 
     plog = []
     for d in ds:
-
         qecc = qecc_class(distance=d)
         decoder = decoder_class(qecc)
 
         for p in ps:
-
-            logical_error_rate, time = determine_rate(runs, qecc, d, error_gen, error_params={'p': p}, decoder=decoder,
-                                                      verbose=verbose, circuit_runner=circuit_runner)
+            logical_error_rate, time = determine_rate(
+                runs,
+                qecc,
+                d,
+                error_gen,
+                error_params={"p": p},
+                decoder=decoder,
+                verbose=verbose,
+                circuit_runner=circuit_runner,
+            )
             if verbose:
                 if time:
-                    print('Runtime: %s s' % time)
+                    print("Runtime: %s s" % time)
 
-                print('----')
+                print("----")
 
             plog.append(logical_error_rate)
 
     plog = np.array(plog)
 
     results = threshold_fit(plist, dlist, plog, func, p0)
 
-    # return plist, dlist, plog, results
-    return {'plist': plist, 'dlist': dlist, 'plog': plog, 'opt': results[0], 'std': results[1]}
+    return {"plist": plist, "dlist": dlist, "plog": plog, "opt": results[0], "std": results[1]}
 
 
-def codecapacity_logical_rate(runs, qecc, distance, error_gen, error_params, decoder, seed=None, state_sim=None,
-                              verbose=True, circuit_runner=None, basis=None):
-    """
-    A tool for determining the code-capacity logical-error rate for syndrome extraction.
+def codecapacity_logical_rate(
+    runs,
+    qecc,
+    distance,
+    error_gen,
+    error_params,
+    decoder,
+    seed=None,
+    state_sim=None,
+    verbose=True,
+    circuit_runner=None,
+    basis=None,
+):
+    """A tool for determining the code-capacity logical-error rate for syndrome extraction.
 
     In this analysis only logical |0> is prepared and each run consists of an ideal logical |0> preparation followed by
     a single round of syndrome extraction. The error rate is determined by number of runs with logical failures divided
     by the total number of runs.
 
     Args:
+    ----
         runs: Number of runs to evaluate the logical error rate.
         qecc:
         distance:
         error_gen:
         error_params:
         decoder:
         seed:
         state_sim:
         verbose:
         circuit_runner:
 
     Returns:
+    -------
 
     """
-
-    p = error_params['p']
+    p = error_params["p"]
     total_time = 0.0
 
     # Circuit simulator
     if circuit_runner is None:
         circuit_runner = circuit_runners.TimingRunner(seed=seed)
-    # circ_sim = circuit_runners.Standard(seed=seed)
 
     # Syndrome extraction
-    syn_extract = circuits.LogicalCircuit(supress_warning=True)
-    syn_extract.append(qecc.gate('I', num_syn_extract=1))
+    syn_extract = circuits.LogicalCircuit(suppress_warning=True)
+    syn_extract.append(qecc.gate("I", num_syn_extract=1))
 
     # Choosing basis
-    if basis is None or basis == 'zero':
-        basis = '|0>'
-    elif basis == 'plus':
-        basis = '|+>'
+    if basis is None or basis == "zero":
+        basis = "|0>"
+    elif basis == "plus":
+        basis = "|+>"
     else:
-        raise Exception('Basis must be "zero", "plus", "None"!')
+        msg = 'Basis must be "zero", "plus", "None"!'
+        raise Exception(msg)
 
     # init circuit
-    initzero = circuits.LogicalCircuit(supress_warning=True)
-    instr_symbol = 'ideal init %s' % basis
+    initzero = circuits.LogicalCircuit(suppress_warning=True)
+    instr_symbol = "ideal init %s" % basis
     gate = qecc.gate(instr_symbol)
     initzero.append(gate)
 
-    # print(gate)
-    # print(initzero)
-
     logical_circ_dict = gate.final_instr().final_logical_ops
     logical_ops_sym = gate.final_instr().logical_stabilizers
 
     if len(logical_circ_dict) != 1:
-        raise Exception('This tool expects a code that stores one logical qubit.')
+        msg = "This tool expects a code that stores one logical qubit."
+        raise Exception(msg)
 
     logical_circ = logical_circ_dict[0][logical_ops_sym[0]]
 
     num_failure = 0
 
     for _ in range(runs):
         # State
         state = pySparseSim(qecc.num_qudits)
 
         # Create ideal logical |0>
         circuit_runner.run(state, initzero)
-        try:
+        with contextlib.suppress(AttributeError):
             total_time += circuit_runner.total_time
-        except AttributeError:
-            pass
 
         output, _ = circuit_runner.run(state, syn_extract, error_gen=error_gen, error_params=error_params)
-        try:
+        with contextlib.suppress(AttributeError):
             total_time += circuit_runner.total_time
-        except AttributeError:
-            pass
-
-        # syn = output.simplified(True)
 
         if output:
-
             # Recovery operation
             recovery = decoder.decode(output)
 
             # Apply recovery operation
             circuit_runner.run(state, recovery)
 
         sign = state.logical_sign(logical_circ)
 
         num_failure += sign
 
     logical_rate = float(num_failure) / float(runs)
 
     if verbose:
-        print('\ndistance = %s' % distance)
-        print('p = %s' % p)
-        print('runs = %s' % runs)
-
-        print('\nlogical error rate: %s' % logical_rate)
-        r = float(logical_rate)/float(p)
-        print('\nplog/p = %s' % r)
+        print("\ndistance = %s" % distance)
+        print("p = %s" % p)
+        print("runs = %s" % runs)
+
+        print("\nlogical error rate: %s" % logical_rate)
+        r = float(logical_rate) / float(p)
+        print("\nplog/p = %s" % r)
 
     return logical_rate, total_time
 
 
-def codecapacity_logical_rate2(runs, qecc, distance, error_gen, error_params, decoder, seed=None, state_sim=None,
-                               verbose=True, circuit_runner=None, basis=None):
-    """
-    A tool for determining the code-capacity logical-error rate for syndrome extraction.
+def codecapacity_logical_rate2(
+    runs,
+    qecc,
+    distance,
+    error_gen,
+    error_params,
+    decoder,
+    seed=None,
+    state_sim=None,
+    verbose=True,
+    circuit_runner=None,
+    basis=None,
+):
+    """A tool for determining the code-capacity logical-error rate for syndrome extraction.
 
     In this analysis only logical |0> is prepared and each run consists of an ideal logical |0> preparation followed by
     a single round of syndrome extraction. The error rate is determined by number of runs with logical failures divided
     by the total number of runs.
 
     Args:
+    ----
         runs: Number of runs to evaluate the logical error rate.
         qecc:
         distance:
         error_gen:
         error_params:
         decoder:
         seed:
         state_sim:
         verbose:
         circuit_runner:
 
     Returns:
+    -------
 
     """
-
-    p = error_params['p']
+    p = error_params["p"]
     total_time = 0.0
 
     # Circuit simulator
     if circuit_runner is None:
         circuit_runner = circuit_runners.TimingRunner(seed=seed)
 
     # Syndrome extraction
-    syn_extract = circuits.LogicalCircuit(supress_warning=True)
-    syn_extract.append(qecc.gate('I', num_syn_extract=1))
+    syn_extract = circuits.LogicalCircuit(suppress_warning=True)
+    syn_extract.append(qecc.gate("I", num_syn_extract=1))
 
     # init logical |0> circuit
-    initzero = circuits.LogicalCircuit(supress_warning=True)
-    initzero.append(qecc.gate('ideal init |0>'))
+    initzero = circuits.LogicalCircuit(suppress_warning=True)
+    initzero.append(qecc.gate("ideal init |0>"))
 
     # init logical |+> circuit
-    initplus = circuits.LogicalCircuit(supress_warning=True)
-    initplus.append(qecc.gate('ideal init |+>'))
+    initplus = circuits.LogicalCircuit(suppress_warning=True)
+    initplus.append(qecc.gate("ideal init |+>"))
 
-    logical_ops_zero = qecc.instruction('instr_init_zero').logical_stabs[0]['Z']
-    logical_ops_plus = qecc.instruction('instr_init_plus').logical_stabs[0]['X']
+    logical_ops_zero = qecc.instruction("instr_init_zero").logical_stabs[0]["Z"]
+    logical_ops_plus = qecc.instruction("instr_init_plus").logical_stabs[0]["X"]
 
     num_failure = 0
 
     for _ in range(runs):
         # States
         state0 = state_sim(qecc.num_qudits)
         state1 = state_sim(qecc.num_qudits)
 
-        # state0 = circuit_runner.init(qecc.num_qudits, simulator=state_sim)
-        # state1 = circuit_runner.init(qecc.num_qudits, simulator=state_sim)
-
         # Create ideal logical |0>
         circuit_runner.run(state0, initzero)
-        try:
+        with contextlib.suppress(AttributeError):
             total_time += circuit_runner.total_time
-        except AttributeError:
-            pass
 
         # Create ideal logical |+>
         circuit_runner.run(state1, initplus)
-        try:
+        with contextlib.suppress(AttributeError):
             total_time += circuit_runner.total_time
-        except AttributeError:
-            pass
 
-        output, error_circuits = circuit_runner.run(state0, syn_extract, error_gen=error_gen,
-                                                    error_params=error_params)
-        try:
+        output, error_circuits = circuit_runner.run(state0, syn_extract, error_gen=error_gen, error_params=error_params)
+        with contextlib.suppress(AttributeError):
             total_time += circuit_runner.total_time
-        except AttributeError:
-            pass
-
-        # syn = output.simplified(True)
 
         circuit_runner.run(state1, syn_extract, error_circuits=error_circuits)
-        try:
+        with contextlib.suppress(AttributeError):
             total_time += circuit_runner.total_time
-        except AttributeError:
-            pass
 
         if output:
-
             # Recovery operation
             recovery = decoder.decode(output)
 
             # Apply recovery operation
 
             circuit_runner.run(state0, recovery)
-            try:
+            with contextlib.suppress(AttributeError):
                 total_time += circuit_runner.total_time
-            except AttributeError:
-                pass
             circuit_runner.run(state1, recovery)
-            try:
+            with contextlib.suppress(AttributeError):
                 total_time += circuit_runner.total_time
-            except AttributeError:
-                pass
 
         sign0 = state0.logical_sign(logical_ops_zero)
         sign1 = state1.logical_sign(logical_ops_plus)
 
         if sign0 or sign1:
-
             num_failure += 1
 
     logical_rate = float(num_failure) / float(runs)
 
     if verbose:
-        print('\ndistance = %s' % distance)
-        print('p = %s' % p)
-        print('runs = %s' % runs)
-
-        print('\nlogical error rate: %s' % logical_rate)
-        r = float(logical_rate)/float(p)
-        print('\nplog/p = %s' % r)
-        # print('----')
+        print("\ndistance = %s" % distance)
+        print("p = %s" % p)
+        print("runs = %s" % runs)
+
+        print("\nlogical error rate: %s" % logical_rate)
+        r = float(logical_rate) / float(p)
+        print("\nplog/p = %s" % r)
 
     return logical_rate, total_time
 
 
-def codecapacity_logical_rate3(runs, qecc, distance, error_gen, error_params, decoder, seed=None, state_sim=None,
-                               max_syn_extract=1e7, circuit_runner=None, verbose=True, init_circuit=None,
-                               init_logical_ops=None, basis=None):
-    """
-    A tool for determining the code-capacity logical-error rate for syndrome extraction.
+def codecapacity_logical_rate3(
+    runs,
+    qecc,
+    distance,
+    error_gen,
+    error_params,
+    decoder,
+    seed=None,
+    state_sim=None,
+    max_syn_extract=1e7,
+    circuit_runner=None,
+    verbose=True,
+    init_circuit=None,
+    init_logical_ops=None,
+    basis=None,
+):
+    """A tool for determining the code-capacity logical-error rate for syndrome extraction.
 
     In this analysis only logical |0> is prepared and each run consists of an ideal logical |0> preparation followed by
     a single round of syndrome extraction. The error rate is determined by number of runs with logical failures divided
     by the total number of runs.
 
     !!! This version determines logical threshold from 1/avg(duration)
 
     Args:
+    ----
         runs: Number of runs to evaluate the logical error rate.
         qecc:
         distance:
         error_gen:
         error_params:
         decoder:
         seed:
@@ -456,131 +504,111 @@
         max_syn_extract:
         circuit_runner:
         verbose:
         init_circuit:
         init_logical_ops:
 
     Returns:
+    -------
 
     """
-
-    p = error_params['p']
+    p = error_params["p"]
     total_time = 0.0
 
     # Circuit simulator
     if circuit_runner is None:
         circuit_runner = circuit_runners.TimingRunner(seed=seed)
 
     if init_circuit is None:
         # init circuit
-        init_circuit = circuits.LogicalCircuit(supress_warning=True)
+        init_circuit = circuits.LogicalCircuit(suppress_warning=True)
 
         # Choosing basis
-        if basis is None or basis == 'zero':
-            basis = '|0>'
-        elif basis == 'plus':
-            basis = '|+>'
+        if basis is None or basis == "zero":
+            basis = "|0>"
+        elif basis == "plus":
+            basis = "|+>"
         else:
-            raise Exception('Basis must be "zero", "plus", "None"!')
+            msg = 'Basis must be "zero", "plus", "None"!'
+            raise Exception(msg)
 
-        gate = qecc.gate('ideal init %s' % basis)
+        gate = qecc.gate("ideal init %s" % basis)
         init_circuit.append(gate)
 
     if init_logical_ops is None:
-        # logical_ops = qecc.instruction('instr_syn_extract').final_logical_ops[0]
-        ## logical_ops = qecc.instruction('instr_init_zero').logical_stabs[0]
-
         if init_circuit is None:
-
-            gate = qecc.gate('ideal init %s' % basis)
+            gate = qecc.gate("ideal init %s" % basis)
 
             # if len(gate.final_logical_stabs()) != 1:
-            #    raise Exception('This tool expects a code that stores one logical qubit.')
-
-            # logical_ops = qecc.instruction('instr_syn_extract').final_logical_ops[0]
-            # logical_ops = gate.final_logical_stabs()[0]
-            # logical_ops_plus = qecc.instruction('instr_init_plus').logical_stabs[0]
 
             logical_circ_dict = gate.final_instr().final_logical_ops
             logical_ops_sym = gate.final_instr().logical_stabilizers
 
             if len(logical_circ_dict) != 1:
-                raise Exception('This tool expects a code that stores one logical qubit.')
+                msg = "This tool expects a code that stores one logical qubit."
+                raise Exception(msg)
 
             logical_ops = logical_circ_dict[0][logical_ops_sym[0]]
         else:
-            raise Exception('This case is not handled!')
+            msg = "This case is not handled!"
+            raise Exception(msg)
     else:
         logical_ops = init_logical_ops
 
     # Syndrome extraction
-    syn_extract = circuits.LogicalCircuit(supress_warning=True)
-    syn_extract.append(qecc.gate('I', num_syn_extract=1))
-
-    # logical_ops = qecc.instruction('instr_syn_extract').final_logical_ops[0]
+    syn_extract = circuits.LogicalCircuit(suppress_warning=True)
+    syn_extract.append(qecc.gate("I", num_syn_extract=1))
 
     run_durations = []
 
     for _ in range(runs):
-
         # State
         state = state_sim(qecc.num_qudits)
 
-        # state = circuit_runner.init(qecc.num_qudits, simulator=state_sim)
-
         # Create ideal logical |0>
         circuit_runner.run(state, init_circuit)
-        try:
+        with contextlib.suppress(AttributeError):
             total_time += circuit_runner.total_time
-        except AttributeError:
-            pass
-
-        for duration in range(max_syn_extract):
 
+        for _duration in range(max_syn_extract):
             # Run syndrome extraction
             output, _ = circuit_runner.run(state, syn_extract, error_gen=error_gen, error_params=error_params)
-            try:
+            with contextlib.suppress(AttributeError):
                 total_time += circuit_runner.total_time
-            except AttributeError:
-                pass
-
-            # syn = output.simplified(True)
 
             if output:
                 # Recovery operation
                 recovery = decoder.decode(output)
 
                 # Apply recovery operation
                 circuit_runner.run(state, recovery)
-                try:
+                with contextlib.suppress(AttributeError):
                     total_time += circuit_runner.total_time
-                except AttributeError:
-                    pass
 
             sign = state.logical_sign(logical_ops)
 
             if sign:
                 break
 
         else:
-            raise Exception('Max syndrome extraction (%s) met.' % max_syn_extract)
+            raise Exception("Max syndrome extraction (%s) met." % max_syn_extract)
 
-        run_durations.append(duration+1)  # duration + 1 == number of syndrome extractions.
+        run_durations.append(max_syn_extract)  # duration + 1 == number of syndrome extractions.
 
     if verbose:
-        print('\nTotal number of runs: %s' % sum(run_durations))
+        print("\nTotal number of runs: %s" % sum(run_durations))
 
     run_durations = np.array(run_durations)
     duration_mean = np.mean(run_durations)
 
     logical_rate = 1.0 / duration_mean
 
     if verbose:
-        print('\ndistance = %s' % distance)
-        print('p = %s' % p)
-        print('Number of failures = %s' % runs)
-
-        print('\nlogical error rate: %s' % logical_rate)
-        r = float(logical_rate)/float(p)
-        print('\nplog/p = %s' % r)
+        print("\ndistance = %s" % distance)
+        print("p = %s" % p)
+        print("Number of failures = %s" % runs)
+
+        print("\nlogical error rate: %s" % logical_rate)
+        r = float(logical_rate) / float(p)
+        print("\nplog/p = %s" % r)
 
     return logical_rate, total_time
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/tools/tool_anticommute.py` & `quantum_pecos-0.6.0.dev1/python/pecos/tools/tool_anticommute.py`

 * *Files 15% similar despite different names*

```diff
@@ -5,42 +5,45 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+
 def anticommute(qc1, qc2):
     x1 = set()
     y1 = set()
     z1 = set()
 
     x2 = set()
     y2 = set()
     z2 = set()
 
     for sym, qubits, _ in qc1.items():
-        if sym == 'X':
+        if sym == "X":
             x1 |= qubits
-        elif sym == 'Y':
+        elif sym == "Y":
             y1 |= qubits
-        elif sym == 'Z':
+        elif sym == "Z":
             z1 |= qubits
         else:
-            raise Exception('Waaa')
+            msg = "Waaa"
+            raise Exception(msg)
 
     for sym, qubits, _ in qc2.items():
-        if sym == 'X':
+        if sym == "X":
             x2 |= qubits
-        elif sym == 'Y':
+        elif sym == "Y":
             y2 |= qubits
-        elif sym == 'Z':
+        elif sym == "Z":
             z2 |= qubits
         else:
-            raise Exception('Waaa')
+            msg = "Waaa"
+            raise Exception(msg)
 
     anticom = len(x1 & z2)
     anticom += len(x1 & y2)
 
     anticom += len(y1 & z2)
     anticom += len(y1 & x2)
```

### Comparing `quantum-pecos-0.5.dev1/python/pecos/tools/tool_collection.py` & `quantum_pecos-0.6.0.dev1/python/pecos/tools/tool_collection.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,227 +7,212 @@
 #
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 # specific language governing permissions and limitations under the License.
 
+from __future__ import annotations
+
 from itertools import combinations, product
+
 import numpy as np
-from .. import circuits
-from ..circuits import QuantumCircuit
+
+from pecos import circuits
+from pecos.circuits import QuantumCircuit
 from pecos.engines.circuit_runners import Standard
-from ..simulators import pySparseSim
+from pecos.simulators import pySparseSim
 
 
-def fault_tolerance_check(QECC, decoder):
-    """
-    Checks that the decoder can correct all Pauli errors of weight up to floor(distance/2).
+def fault_tolerance_check(qecc, decoder):
+    """Checks that the decoder can correct all Pauli errors of weight up to floor(distance/2).
 
     Args:
+    ----
         QECC:
         decoder:
 
-    Returns:
+    Raises:
+    ------
+        Exception: If a fault that is supposed to be corrected is not.
 
     """
-
     # The logical circuits:
     # ---------------------
-    init_zero = circuits.LogicalCircuit(layout=QECC.layout)
-    init_zero.append(QECC.gate('ideal init |0>'))
+    init_zero = circuits.LogicalCircuit(layout=qecc.layout)
+    init_zero.append(qecc.gate("ideal init |0>"))
 
-    init_plus = circuits.LogicalCircuit(layout=QECC.layout)
-    init_plus.append(QECC.gate('ideal init |+>'))
+    init_plus = circuits.LogicalCircuit(layout=qecc.layout)
+    init_plus.append(qecc.gate("ideal init |+>"))
 
-    syn_extract = circuits.LogicalCircuit(layout=QECC.layout)
-    syn_extract.append(QECC.gate('I', num_syn_extract=1))
+    syn_extract = circuits.LogicalCircuit(layout=qecc.layout)
+    syn_extract.append(qecc.gate("I", num_syn_extract=1))
 
-    logical_ops = QECC.instruction('instr_syn_extract').final_logical_ops
-    logical_z = logical_ops[0]['Z']
-    # logical_x = logical_ops[0]['X']
+    logical_ops = qecc.instruction("instr_syn_extract").final_logical_ops
+    logical_z = logical_ops[0]["Z"]
 
-    num_qudits = QECC.num_qudits
-    data_qudits = QECC.data_qudit_set
-    qudits = QECC.qudit_set
+    num_qudits = qecc.num_qudits
+    data_qudits = qecc.data_qudit_set
+    qudits = qecc.qudit_set
 
-    t = int(np.floor((QECC.distance-1)*0.5))
+    t = int(np.floor((qecc.distance - 1) * 0.5))
 
     # circuit runner:
     circ_runner = Standard()
 
     # Check input errors
     for xs, zs in gen_pauli_errors(data_qudits, max_errors=t):
-        err = QuantumCircuit([{'X': xs, 'Z': zs}])
+        err = QuantumCircuit([{"X": xs, "Z": zs}])
         state = pySparseSim(num_qudits)
-        # state = circ_runner.init(num_qudits)
 
         sign = _apply_err(state, circ_runner, init_zero, syn_extract, err, decoder, logical_z)
 
         if sign:
-
-            raise Exception('Decoder failed to correct error: %s' % err)
+            raise Exception("Decoder failed to correct error: %s" % err)
 
         sign = _apply_err(state, circ_runner, init_zero, syn_extract, err, decoder, logical_z)
 
         if sign:
-            raise Exception('Decoder failed to correct error: %s' % err)
+            raise Exception("Decoder failed to correct error: %s" % err)
 
     # Check circuit errors
     # Need to apply errors amongst any combination of ticks and qubits
 
-    num_ticks = len(QECC.instruction('instr_syn_extract').circuit)
+    num_ticks = len(qecc.instruction("instr_syn_extract").circuit)
 
     spacetime = set(product(list(range(num_ticks)), qudits))
     for xs, zs in gen_pauli_errors(spacetime, max_errors=t):
         state = pySparseSim(num_qudits)
-        # state = circ_runner.init(num_qudits)
         xs = list(xs)
         zs = list(zs)
 
         err_dict = form_errors(xs, zs)
 
-        sign = _apply_err_spacetime(state, circ_runner, init_zero, syn_extract, err_dict, decoder, logical_z, QECC)
+        sign = _apply_err_spacetime(state, circ_runner, init_zero, err_dict, decoder, logical_z, qecc)
 
         if sign:
+            raise Exception("Decoder failed to correct error: %s" % str(spacetime))
 
-            raise Exception('Decoder failed to correct error: %s' % str(spacetime))
-
-        sign = _apply_err_spacetime(state, circ_runner, init_zero, syn_extract, err_dict, decoder, logical_z, QECC)
+        sign = _apply_err_spacetime(state, circ_runner, init_zero, err_dict, decoder, logical_z, qecc)
 
         if sign:
-            raise Exception('Decoder failed to correct error: %s' % str(spacetime))
+            raise Exception("Decoder failed to correct error: %s" % str(spacetime))
 
 
 def form_errors(xs, zs):
-
     errors = {}
     for t, q in xs:
-        xerr = errors.setdefault(t, {}).setdefault('X', set())
+        xerr = errors.setdefault(t, {}).setdefault("X", set())
         xerr.add(q)
 
     for t, q in zs:
-        zerr = errors.setdefault(t, {}).setdefault('Z', set())
+        zerr = errors.setdefault(t, {}).setdefault("Z", set())
         zerr.add(q)
 
     return errors
 
 
-def _apply_err_spacetime(state, circ_runner, init_circ, syn_circ, err_dict, decoder, logical_op, QECC):
+def _apply_err_spacetime(state, circ_runner, init_circ, err_dict, decoder, logical_op, qecc):
     circ_runner.run(state, init_circ)
 
-    syn_circ = QECC.instruction('instr_syn_extract', num_syn_extract=1)
+    syn_circ = qecc.instruction("instr_syn_extract", num_syn_extract=1)
     num_ticks = len(syn_circ.circuit)
 
     syn = set()
     for t in range(num_ticks):
-
-        xerrs = err_dict[t].get('X', set())
-        zerrs = err_dict[t].get('Z', set())
+        xerrs = err_dict[t].get("X", set())
+        zerrs = err_dict[t].get("Z", set())
 
         for gate_sym, locations, _ in syn_circ.circuit.items(tick=t):
-
-            if 'measure' in gate_sym and t in err_dict:
+            if "measure" in gate_sym and t in err_dict:
                 before_xerrs = locations & xerrs
                 if before_xerrs:
-                    state.run_gate('X', before_xerrs)
+                    state.run_gate("X", before_xerrs)
                     xerrs -= before_xerrs
 
                 before_zerrs = locations & zerrs
                 if before_zerrs:
-
                     zerrs -= before_zerrs
 
             output = state.run_gate(gate_sym, locations)
             syn.update(output.keys())
 
         if xerrs:
-            state.run_gate('X', xerrs)
+            state.run_gate("X", xerrs)
 
         if zerrs:
-            state.run_gate('Z', zerrs)
+            state.run_gate("Z", zerrs)
 
     if syn:
         recovery = decoder.decode(syn)
         circ_runner.run(state, recovery)
 
-    sign = state.logical_sign(logical_op)
-
-    return sign
+    return state.logical_sign(logical_op)
 
 
 def _apply_err(state, circ_runner, init_circ, syn_circ, error, decoder, logical_op):
-
     circ_runner.run(state, init_circ)
     circ_runner.run(state, error)
     output, _ = circ_runner.run(state, syn_circ)
     syn = output.simplified(True)
 
     if syn:
         recovery = decoder.decode(syn)
         circ_runner.run(state, recovery)
 
-    sign = state.logical_sign(logical_op)
-
-    return sign
+    return state.logical_sign(logical_op)
 
 
-def gen_pauli_errors(qubits, min_errors=1, max_errors=False, css=False):
-    """
-
-    Args:
-        qubits (set of int):
-        min_errors (int):
-        max_errors (bool, int):
-        css (bool):
+def gen_pauli_errors(qubits, *, min_errors: int = 1, max_errors: bool | int = False, css: bool = False):
+    """Args:
+    ----
+        qubits:
+        min_errors:
+        max_errors:
+        css:
 
     Returns:
+    -------
+        A generator that yields a set of Pauli faults.
 
     """
-
-    paulis = ('X', 'Z', 'Y')
+    paulis = ("X", "Z", "Y")
 
     num_qubits = len(qubits)
 
     for i in range(min_errors, num_qubits + 1):
-
         if max_errors and i > max_errors:
             break
 
-        xs = next(product(('X',), repeat=i))
-        zs = next(product(('Z',), repeat=i))
+        xs = next(product(("X",), repeat=i))
+        zs = next(product(("Z",), repeat=i))
 
         xzs = [xs, zs]
 
-        # print(xs)
-        # print(zs)
-
         for b in combinations(qubits, i):
-
             for ps in xzs:
-
                 x_set = set()
                 z_set = set()
                 for p, q in zip(ps, b):
-                    if p == 'X':
+                    if p == "X":
                         x_set.add(q)
                     else:
                         z_set.add(q)
                 yield x_set, z_set
 
         if not css:
             for a in product(paulis, repeat=i):
-                if a == xs or a == zs:
+                if a in (xs, zs):
                     continue
 
                 for b in combinations(qubits, i):
                     x_set = set()
                     z_set = set()
                     for p, q in zip(a, b):
-                        if p == 'X':
+                        if p == "X":
                             x_set.add(q)
-                        elif p == 'Z':
+                        elif p == "Z":
                             z_set.add(q)
                         else:
                             x_set.add(q)
                             z_set.add(q)
                     yield x_set, z_set
```

### Comparing `quantum-pecos-0.5.dev1/python/quantum_pecos.egg-info/PKG-INFO` & `quantum_pecos-0.6.0.dev1/python/quantum_pecos.egg-info/PKG-INFO`

 * *Files 19% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 Metadata-Version: 2.1
 Name: quantum-pecos
-Version: 0.5.dev1
-Summary: Performance Estimator of Codes On Surfaces (PECOS) is a package designed to facilitate the evaluation, study, and design of quantum error correction protocols as well as provde advanced hybrid compute execution models.
+Version: 0.6.0.dev1
+Summary: PECOS is a library/framework for the evaluation, study, and design of QEC protocols. It also provides the ability to study and evaluate the performance advanced hybrid quantum/classical compute execution models for NISQ algorithms and beyond.
 Author: The PECOS Developers
-Maintainer-email: Ciaran Ryan-Anderson <ciaran@pecos.io>
+Maintainer-email: Ciaran Ryan-Anderson <ciaran.ryan-anderson@quantinuum.com>
 License:                                  Apache License
                                    Version 2.0, January 2004
                                 http://www.apache.org/licenses/
         
            TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
         
            1. Definitions.
@@ -188,111 +188,207 @@
               replaced with your own identifying information. (Don't include
               the brackets!)  The text should be enclosed in the appropriate
               comment syntax for the file format. We also recommend that a
               file or class name and description of purpose be included on the
               same "printed page" as the copyright notice for easier
               identification within third-party archives.
         
-           
+        
            Copyright {yyyy} {name of copyright owner}
         
            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at
         
                http://www.apache.org/licenses/LICENSE-2.0
         
            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.
         
+Project-URL: documentation, https://quantum-pecos.readthedocs.io
+Project-URL: repository, https://github.com/PECOS-packages/PECOS
+Keywords: quantum,QEC,simulation,PECOS
 Classifier: Development Status :: 4 - Beta
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
 Classifier: Topic :: Scientific/Engineering :: Physics
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Classifier: Programming Language :: Python :: Implementation :: CPython
-Requires-Python: >=3.8
+Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: numpy>=1.15.0
-Requires-Dist: scipy>=1.1.0
-Requires-Dist: networkx<3,>=2.1.0
-Requires-Dist: matplotlib>=2.2.0
+Requires-Dist: phir~=0.3.0
+Requires-Dist: numpy<2.0,>=1.15.0
+Requires-Dist: scipy<2.0,>=1.1.0
+Requires-Dist: networkx<3.0,>=2.1.0
+Requires-Dist: matplotlib<4.0,>=2.2.0
 Provides-Extra: simulators
 Requires-Dist: cython; extra == "simulators"
 Requires-Dist: pybind11<3.0,>=2.2.3; extra == "simulators"
 Requires-Dist: projectq<0.9.0,>=0.5.0; extra == "simulators"
+Provides-Extra: cuda
+Requires-Dist: cuquantum-python>=23.6.0; extra == "cuda"
+Requires-Dist: cupy>=10.4.0; extra == "cuda"
+Provides-Extra: wasmtime
+Requires-Dist: wasmtime>=13.0; extra == "wasmtime"
 Provides-Extra: wasmer
 Requires-Dist: wasmer~=1.1.0; extra == "wasmer"
 Requires-Dist: wasmer_compiler_cranelift~=1.1.0; extra == "wasmer"
 Provides-Extra: visualization
 Requires-Dist: plotly~=5.9.0; extra == "visualization"
 Provides-Extra: tests
 Requires-Dist: pytest>=5.0.0; extra == "tests"
 Provides-Extra: all
 Requires-Dist: quantum-pecos[simulators]; extra == "all"
+Requires-Dist: quantum-pecos[wasmtime]; extra == "all"
 Requires-Dist: quantum-pecos[wasmer]; extra == "all"
 Requires-Dist: quantum-pecos[visualization]; extra == "all"
 Requires-Dist: quantum-pecos[tests]; extra == "all"
 
-![PECOS](docs/images/pecos_large_logo.png)
-=======================================
+# ![PECOS](branding/logo/pecos_logo_v2.png)
 
 [![PyPI version](https://badge.fury.io/py/quantum-pecos.svg)](https://badge.fury.io/py/quantum-pecos)
 [![Documentation Status](https://readthedocs.org/projects/quantum-pecos/badge/?version=latest)](https://quantum-pecos.readthedocs.io/en/latest/?badge=latest)
-[![Python Status](https://img.shields.io/badge/python-3.8%2C%203.9%2C%203.10%2C%203.11-brightgreen.svg)](https://img.shields.io/badge/python-3.8%2C%203.9%2C%203.10%2C%203.11-brightgreen.svg)
+[![Python versions](https://img.shields.io/badge/python-3.10%20%7C%203.11%20%7C%203.12-blue.svg)](https://img.shields.io/badge/python-3.9%2C%203.10%2C%203.11-blue.svg)
 [![Supported by Quantinuum](https://img.shields.io/badge/supported_by-Quantinuum-blue)](https://www.quantinuum.com/)
 
-Performance Estimator of Codes On Surfaces (PECOS) is a Python framework for studying, developing, and evaluating 
-quantum error-correction protocols as well as advance hybrid compute execution models for NISQ algorithms and beyond.
-
-PECOS aims to balance clarity, flexibility, and performance, with hopefully maximizing all three when possible.
-
-- Language: Python 3.8+ (with optional C and C++ extensions)
+**Performance Estimator of Codes On Surfaces (PECOS)** is a library/framework dedicated to the study, development, and
+evaluation of quantum error-correction protocols. It offers tools for the study and evaluation of hybrid
+quantum/classical compute execution models for NISQ algorithms and beyond.
+
+Initially conceived and developed in 2014 to verify lattice-surgery procedures presented in
+[arXiv:1407.5103](https://arxiv.org/abs/1407.5103) and released publicly in 2018, PECOS filled a significant gap in
+the QEC/QC tools available at that time. Over the years, it has grown into a framework for studying general QECCs and
+hybrid computation.
+
+With an emphasis on clarity, flexibility, and performance and catering to both QEC students and developers, PECOS is
+refined continually with these attributes in mind.
+
+## Features
+
+- Quantum Error-Correction Tools: Advanced tools for studying quantum error-correction protocols and error models.
+- Hybrid Quantum/Classical Execution: Evaluate advanced hybrid compute models, including support for classical compute,
+calls to Wasm VMs, conditional branching, and more.
+- Fast Simulation: Leverage the fast stabilizer-simulation algorithm.
+- Extensible: Add-ons and extensions support in C and C++ via Cython.
 
 ## Getting Started
 
-To get started, check out the documentation in the "docs" folder or find it online:
-
-https://quantum-pecos.readthedocs.io
+Explore the capabilities of PECOS by delving into the [official documentation](https://quantum-pecos.readthedocs.io).
 
 ## Versioning
 
-PECOS uses semantic versioning. However, until version 1.0.0, for the MAJOR.MINOR.BUG format, the role of MAJOR and 
-MINOR shifts down one. That is, going from version 0.1.0 to 0.2.0 can include API breaking.
+We follow semantic versioning principles. However, before version 1.0.0, the MAJOR.MINOR.BUG format sees the roles
+of MAJOR and MINOR shifted down a step. This means potential breaking changes might occur between MINOR increments, such
+as moving from versions 0.1.0 to 0.2.0.
 
 ## Latest Development
 
-See here for latest code in development:
-
-https://quantum-pecos.readthedocs.io/en/development/
+Stay updated with the latest developments on the
+[PECOS Development branch](https://quantum-pecos.readthedocs.io/en/development/).
 
 ## Installation
 
-Clone or download/unzip the version of PECOS you would like to use. Next, navigate to the root of the package 
-(where setup.py is located) and run:
-```
+1. Clone or download the desired version of PECOS.
+2. Navigate to the root directory, where `pyproject.toml` is located.
+3. Install using pip:
+
+```sh
 pip install .
 ```
 
-To install and continue to develop the version of PECOS located in the install folder, run the
- following instead:
+To install optional dependencies, such as for Wasm support or state vector simulations, see `pyproject.toml` for list of
+options. To install all optional dependencies use:
+
+```sh
+pip install .[all]
 ```
+
+Certain simulators have special requirements and are not installed by the command above. Installation instructions for these are provided [here](#simulators-with-special-requirements).
+
+For development, use (while including installation options as necessary):
+
+On Linux/Mac:
+
+```sh
+python -m venv .venv
+source .venv/bin/activate
+pip install -U pip setuptools
+pip install -r requirements.txt
+make metadeps
+pre-commit install
 pip install -e .
 ```
 
-## Uninstall
+On Windows:
 
-To uninstall run:
+```sh
+python -m venv .venv
+.\venv\Scripts\activate
+pip install -U pip setuptools
+pip install -r requirements.txt
+make metadeps
+pre-commit install
+pip install -e .
 ```
+
+See `Makefile` for other useful commands.
+
+Tests can be run using:
+
+```sh
+pytest tests
+```
+
+### Simulators with special requirements
+
+Certain simulators from `pecos.simulators` require external packages that are not installed by `pip install .[all]`.
+
+- `CuStateVec` requires a Linux machine with an NVIDIA GPU (see requirements [here](https://docs.nvidia.com/cuda/cuquantum/latest/getting_started/getting_started.html#dependencies-custatevec-label)). PECOS' dependencies are specified in the `[cuda]` section of `pyproject.toml` and can be installed via `pip install .[cuda]`. If installation is not successful, see alternative instructions [here](https://docs.nvidia.com/cuda/cuquantum/latest/getting_started/getting_started.html#installing-cuquantum).
+
+## Uninstall
+
+To uninstall:
+
+```sh
 pip uninstall quantum-pecos
 ```
 
+## Citing
+
+For publications utilizing PECOS, kindly cite PECOS such as:
+
+```bibtex
+@misc{pecos,
+ author={Ciaran Ryan-Anderson},
+ title={PECOS: Performance Estimator of Codes On Surfaces},
+ journal={GitHub},
+ howpublished={\url{https://github.com/PECOS-packages/PECOS}},
+ URL = {https://github.com/PECOS-packages/PECOS},
+ year={2018}
+}
+
+@phdthesis{crathesis,
+ author={Ciaran Ryan-Anderson},
+ school = {University of New Mexico},
+ title={Quantum Algorithms, Architecture, and Error Correction},
+ journal={arXiv:1812.04735},
+ year={2018}
+}
+```
+
+## License
+
+This project is licensed under the Apache-2.0 License - see the [LICENSE](./LICENSE) and [NOTICE](NOTICE) files for
+details.
+
 ## Supported by
 
-[<img src="https://assets-global.website-files.com/62b9d45fb3f64842a96c9686/6328d9f47889343caabf2639_Quantinuum%20Logo__horizontal%20blue.png" height="100">](https://www.quantinuum.com/)
+[![Quantinuum](./images/Quantinuum_(word_trademark).svg)](https://www.quantinuum.com/)
```

