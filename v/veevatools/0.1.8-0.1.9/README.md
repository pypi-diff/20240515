# Comparing `tmp/veevatools-0.1.8.tar.gz` & `tmp/veevatools-0.1.9.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "veevatools-0.1.8.tar", last modified: Fri Sep 15 02:18:49 2023, max compression
+gzip compressed data, was "veevatools-0.1.9.tar", last modified: Fri Jan 26 19:33:39 2024, max compression
```

## Comparing `veevatools-0.1.8.tar` & `veevatools-0.1.9.tar`

### file list

```diff
@@ -1,45 +1,45 @@
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.332161 veevatools-0.1.8/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      651 2023-08-24 05:23:19.000000 veevatools-0.1.8/LICENSE.txt
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)       37 2022-10-24 16:14:29.000000 veevatools-0.1.8/MANIFEST.in
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)     6397 2023-09-15 02:18:49.332309 veevatools-0.1.8/PKG-INFO
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)     6092 2023-09-08 15:25:59.000000 veevatools-0.1.8/README.md
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.309776 veevatools-0.1.8/salesforce/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)       72 2022-10-24 16:14:29.000000 veevatools-0.1.8/salesforce/__init__.py
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.312349 veevatools-0.1.8/salesforce/custom_exceptions/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      139 2022-10-24 16:14:29.000000 veevatools-0.1.8/salesforce/custom_exceptions/__init__.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)     3345 2022-10-24 16:14:29.000000 veevatools-0.1.8/salesforce/custom_exceptions/salesforce_exceptions.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      268 2022-10-24 16:14:29.000000 veevatools-0.1.8/salesforce/decorators.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)   115751 2023-09-01 02:56:08.000000 veevatools-0.1.8/salesforce/salesforce.py
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.315515 veevatools-0.1.8/salesforce/utilities/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      295 2022-10-24 16:14:29.000000 veevatools-0.1.8/salesforce/utilities/__init__.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      685 2022-10-24 16:14:29.000000 veevatools-0.1.8/salesforce/utilities/async_utils.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)     3827 2022-10-24 16:14:29.000000 veevatools-0.1.8/salesforce/utilities/df_utils.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)     2055 2023-05-03 02:20:42.000000 veevatools-0.1.8/salesforce/utilities/sf_query_processors.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      869 2023-09-15 02:18:49.332927 veevatools-0.1.8/setup.cfg
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)       37 2022-10-24 16:14:29.000000 veevatools-0.1.8/setup.py
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.316825 veevatools-0.1.8/utilities/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)       35 2023-08-18 01:10:34.000000 veevatools-0.1.8/utilities/__init__.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      685 2023-08-18 01:10:58.000000 veevatools-0.1.8/utilities/async_utils.py
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.320460 veevatools-0.1.8/veevanetwork/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)       40 2022-10-24 16:14:29.000000 veevatools-0.1.8/veevanetwork/__init__.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)        0 2022-10-24 16:14:29.000000 veevatools-0.1.8/veevanetwork/api.py
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.322534 veevatools-0.1.8/veevanetwork/custom_exceptions/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      145 2022-10-24 16:14:29.000000 veevatools-0.1.8/veevanetwork/custom_exceptions/__init__.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)     3793 2022-10-24 16:14:29.000000 veevatools-0.1.8/veevanetwork/custom_exceptions/veevanetwork_exceptions.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)   122066 2022-10-24 16:14:29.000000 veevatools-0.1.8/veevanetwork/network_api_v25.json
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)    80314 2023-08-17 05:27:04.000000 veevatools-0.1.8/veevanetwork/veevanetwork.py
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.323892 veevatools-0.1.8/veevanitro/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)       40 2023-08-24 05:26:43.000000 veevatools-0.1.8/veevanitro/__init__.py
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.325814 veevatools-0.1.8/veevanitro/nitro_utils/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      101 2023-08-22 15:37:06.000000 veevatools-0.1.8/veevanitro/nitro_utils/__init__.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      591 2023-08-22 15:10:57.000000 veevatools-0.1.8/veevanitro/nitro_utils/s3_utils.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)    64322 2023-08-24 05:30:26.000000 veevatools-0.1.8/veevanitro/veevanitro.py
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.328350 veevatools-0.1.8/veevatools.egg-info/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)     6397 2023-09-15 02:18:48.000000 veevatools-0.1.8/veevatools.egg-info/PKG-INFO
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      957 2023-09-15 02:18:49.000000 veevatools-0.1.8/veevatools.egg-info/SOURCES.txt
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)        1 2023-09-15 02:18:48.000000 veevatools-0.1.8/veevatools.egg-info/dependency_links.txt
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)      212 2023-09-15 02:18:49.000000 veevatools-0.1.8/veevatools.egg-info/requires.txt
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)       56 2023-09-15 02:18:49.000000 veevatools-0.1.8/veevatools.egg-info/top_level.txt
-drwxr-xr-x   0 michaelpay-mbpr16   (502) staff       (20)        0 2023-09-15 02:18:49.329480 veevatools-0.1.8/veevavault/
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)       36 2022-10-24 16:14:29.000000 veevatools-0.1.8/veevavault/__init__.py
--rw-r--r--   0 michaelpay-mbpr16   (502) staff       (20)   502355 2023-09-10 02:51:22.000000 veevatools-0.1.8/veevavault/veevavault.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.389310 veevatools-0.1.9/
+-rw-rw-rw-   0        0        0      658 2023-08-26 22:17:21.000000 veevatools-0.1.9/LICENSE.txt
+-rw-rw-rw-   0        0        0       38 2022-05-08 00:45:13.000000 veevatools-0.1.9/MANIFEST.in
+-rw-rw-rw-   0        0        0     6660 2024-01-26 19:33:39.389310 veevatools-0.1.9/PKG-INFO
+-rw-rw-rw-   0        0        0     6304 2023-10-17 17:09:00.000000 veevatools-0.1.9/README.md
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.368311 veevatools-0.1.9/salesforce/
+-rw-rw-rw-   0        0        0       73 2022-05-19 04:32:15.000000 veevatools-0.1.9/salesforce/__init__.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.370311 veevatools-0.1.9/salesforce/custom_exceptions/
+-rw-rw-rw-   0        0        0      142 2022-06-24 18:09:22.000000 veevatools-0.1.9/salesforce/custom_exceptions/__init__.py
+-rw-rw-rw-   0        0        0     3416 2022-05-16 20:22:53.000000 veevatools-0.1.9/salesforce/custom_exceptions/salesforce_exceptions.py
+-rw-rw-rw-   0        0        0      274 2022-05-19 04:43:58.000000 veevatools-0.1.9/salesforce/decorators.py
+-rw-rw-rw-   0        0        0   117770 2023-10-17 17:09:00.000000 veevatools-0.1.9/salesforce/salesforce.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.373309 veevatools-0.1.9/salesforce/utilities/
+-rw-rw-rw-   0        0        0      302 2022-09-01 00:09:33.000000 veevatools-0.1.9/salesforce/utilities/__init__.py
+-rw-rw-rw-   0        0        0      704 2022-06-30 05:29:51.000000 veevatools-0.1.9/salesforce/utilities/async_utils.py
+-rw-rw-rw-   0        0        0     3897 2022-06-28 03:58:32.000000 veevatools-0.1.9/salesforce/utilities/df_utils.py
+-rw-rw-rw-   0        0        0     2112 2023-03-09 15:52:01.000000 veevatools-0.1.9/salesforce/utilities/sf_query_processors.py
+-rw-rw-rw-   0        0        0      912 2024-01-26 19:33:39.390311 veevatools-0.1.9/setup.cfg
+-rw-rw-rw-   0        0        0       39 2022-05-07 03:46:02.000000 veevatools-0.1.9/setup.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.374311 veevatools-0.1.9/utilities/
+-rw-rw-rw-   0        0        0       35 2023-08-24 04:42:51.000000 veevatools-0.1.9/utilities/__init__.py
+-rw-rw-rw-   0        0        0      704 2023-08-24 04:42:51.000000 veevatools-0.1.9/utilities/async_utils.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.378313 veevatools-0.1.9/veevanetwork/
+-rw-rw-rw-   0        0        0       40 2022-06-08 00:43:06.000000 veevatools-0.1.9/veevanetwork/__init__.py
+-rw-rw-rw-   0        0        0        0 2022-06-16 04:00:20.000000 veevatools-0.1.9/veevanetwork/api.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.379310 veevatools-0.1.9/veevanetwork/custom_exceptions/
+-rw-rw-rw-   0        0        0      148 2022-06-23 17:12:46.000000 veevatools-0.1.9/veevanetwork/custom_exceptions/__init__.py
+-rw-rw-rw-   0        0        0     3870 2022-06-20 23:49:28.000000 veevatools-0.1.9/veevanetwork/custom_exceptions/veevanetwork_exceptions.py
+-rw-rw-rw-   0        0        0   122066 2022-06-16 02:54:23.000000 veevatools-0.1.9/veevanetwork/network_api_v25.json
+-rw-rw-rw-   0        0        0    81882 2023-08-01 17:54:29.000000 veevatools-0.1.9/veevanetwork/veevanetwork.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.381310 veevatools-0.1.9/veevanitro/
+-rw-rw-rw-   0        0        0       40 2023-08-26 22:17:21.000000 veevatools-0.1.9/veevanitro/__init__.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.382311 veevatools-0.1.9/veevanitro/nitro_utils/
+-rw-rw-rw-   0        0        0      104 2023-08-24 04:42:51.000000 veevatools-0.1.9/veevanitro/nitro_utils/__init__.py
+-rw-rw-rw-   0        0        0      610 2023-08-24 04:42:51.000000 veevatools-0.1.9/veevanitro/nitro_utils/s3_utils.py
+-rw-rw-rw-   0        0        0    65895 2023-08-26 22:17:21.000000 veevatools-0.1.9/veevanitro/veevanitro.py
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.386312 veevatools-0.1.9/veevatools.egg-info/
+-rw-rw-rw-   0        0        0     6660 2024-01-26 19:33:39.000000 veevatools-0.1.9/veevatools.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0      957 2024-01-26 19:33:39.000000 veevatools-0.1.9/veevatools.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-01-26 19:33:39.000000 veevatools-0.1.9/veevatools.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0      213 2024-01-26 19:33:39.000000 veevatools-0.1.9/veevatools.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       56 2024-01-26 19:33:39.000000 veevatools-0.1.9/veevatools.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2024-01-26 19:33:39.388314 veevatools-0.1.9/veevavault/
+-rw-rw-rw-   0        0        0       36 2022-06-08 00:45:04.000000 veevatools-0.1.9/veevavault/__init__.py
+-rw-rw-rw-   0        0        0   514554 2023-10-17 17:09:00.000000 veevatools-0.1.9/veevavault/veevavault.py
```

### Comparing `veevatools-0.1.8/LICENSE.txt` & `veevatools-0.1.9/LICENSE.txt`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-Copyright (c) 2023 Veeva Systems, Inc. All Rights Reserved
-
-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
-OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
+Copyright (c) 2023 Veeva Systems, Inc. All Rights Reserved
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
 IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

### Comparing `veevatools-0.1.8/README.md` & `veevatools-0.1.9/PKG-INFO`

 * *Files 23% similar despite different names*

```diff
@@ -1,212 +1,226 @@
-[![Downloads](https://pepy.tech/badge/veevatools)](https://pepy.tech/project/veevatools)
-
-# Introduction
-
-This python package is a set of Salesforce.com, Veeva Network, Veeva Vault, and Veeva Nitro libraries, scripts, and functions used to help expedite the development of Veeva Tools.
-<br/>
-<br/>
-
-# Installation / Requirements
-
-Ensure you have **at least Python version 3.10** installed.
-To Check your installation version, type the following commands in the terminal (MacOs) / command prompt (Windows):
-```
-python --version
-```
-To install python, go to https://www.python.org/ then navigate to the download page of your Operating System.
-
-![Screenshot 2022-06-24 140724](https://user-images.githubusercontent.com/59848012/175649491-0eafdef7-acd2-4631-85cb-f9dee8630b04.png)
-
-You will need to have Packager Installer for Python (pip) installed. To install pip, run the following command in the terminal (MacOs) / command prompt (Windows):
-
-```
-curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
-python3 get-pip.py
-```
-To install the Veeva Tools library:
-
-```
-pip install veevatools
-```
-To upgrade to the latest version of Veeva Tools library:
-```
-pip install veevatools --upgrade
-```
-
-# Overview
-
-The Veeva Tools package currently contains 3 major components:
-## Salesforce library
-
-### Authentication:
-
-```python
-from salesforce import Sf
-from pandas import pd
-sf = Sf()
-sf.authenticate(
-    sfUsername='yourname@salesforce.com',
-    sfPassword='password123',
-    sfOrgId='00D2C0000008jIK',
-    isSandbox= false
-    )
-```
-> Sidenote on Pandas DataFrames: <br/>
-Pandas DataFrame (pd) is used to prepare the data for import (i.e. create, update methods) and additional export methods such as pd.to_excel() in order to save the output into an Excel file.<br/>
-Additionally, Complex data manipuation (joins, merges, groupbys, filters)and data analytics (describe, statistical analysis) can all be performed using Pandas. <br />
-To learn more about Pandas DataFrames, go to the [Pandas documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)
-<br \>
-> Or just Google tutorials on Pandas DataFrames. 
-[This YouTube playlist by Corey Schafer](https://www.youtube.com/watch?v=ZyhVh-qRZPA&list=PL-osiE80TeTsWmV9i9c58mdDCSskIFdDS&ab_channel=CoreySchafer)
-provides an excellent starting point into the world of Pandas!
-
-<br/>
-
-### Data methods:
-The salesforce class (Sf) contains methods that can help you interact with data and metadata components:
-<br/>
-#### **Query**
-
-```python
-account_recordtypes = sf.query("SELECT Id, Name, SobjectType from RecordType WHERE SobjectType = 'Account'")]
-
-account_recordtypes
-```
-
-`Return -> pd.DataFrame():`
-|    |                 Id |                      Name | SobjectType |
-|---:|-------------------:|--------------------------:|------------:|
-|  0 | 012f4000001ArT3AAK |          Professional_vod |     Account |
-|  1 | 012f4000001ArT4AAK |           Institution_vod |     Account |
-|  2 | 012f4000001ArT5AAK |                   MCO_vod |     Account |
-|  3 | 012f4000001ArT6AAK |          Organization_vod |     Account |
-|  4 | 012f4000001ArWzAAK |              Hospital_vod |     Account |
-
-> Sidenote: <br />
-You can use any Pandas (pd) methods on the return value of the query output. For example <br/>```account_recordtypes.to_excel("Account RecordTypes.xlsx")``` <br/>
-Will save the results of the DataFrame into an Excel file.
-
-<br/>
-
-### **Create**
-```python
-## Takes a DataFrame of CRM records and creates records in CRM
-
-account_records = pd.DataFrame([{'FirstName': 'Test', 'LastName': 'Account'}, {'FirstName': 'Test2', 'LastName': 'Account2'}])
-
-result = sf.create('Account', account_records)
-
-result
-```
-`Return -> pd.DataFrame():`
-|   | success | created |                 Id |
-|--:|--------:|--------:|-------------------:|
-| 0 |    True |    True | 0010r00000tF7L1AAK |
-| 1 |    True |    True | 0010r00000tF7L2AAK |
-
-<br/>
-
-### Update
-```python
-### Takes a dataframe that contains at least the Id column
-### and any other column to be updated, for example, FirstName
-update_account_name = pd.DataFrame(
-    [{'FirstName': 'Updated', 'Id': '0010r00000tF7L1AAK'},
-     {'FirstName': 'Name', 'Id': '0010r00000tF7L2AAK'}]
-    )
-
-result = sf.update('Account', update_account_name)
-
-result
-```
-`Return -> pd.DataFrame()`
-|   | success | created |                 Id |
-|--:|--------:|--------:|-------------------:|
-| 0 |    True |   False | 0010r00000tF7L1AAK |
-| 1 |    True |   False | 0010r00000tF7L2AAK |
-<br/>
-
-### Upsert
-```python
-### Takes a dataframe that contains an external ID column
-### and any other column to be updated, for example, Name
-### if the external ID matches an existing record,
-### the account is updated, otherwise, a new record is created
-
-upsert_account = pd.DataFrame(
-    [{'NET_External_Id__c': '242977178138969088', 'Name': 'Updated Hospital Name'},
-     {'NET_External_Id__c': '555579769212255555', 'Name': 'Create New Hospital'}]
-    )
-
-result = sf.upsert(object_api='Account', external_id_field_api='NET_External_Id__c', record_dataframe=upsert_account)
-
-result
-```
-`Return -> pd.DataFrame()`
-|   | success | created |                 id |
-|--:|--------:|--------:|-------------------:|
-| 0 |    True |   False | 001f400000PKOrwAAH |
-| 1 |    True |    True | 0010r00000tF7stAAC |
-
-<br/>
-
-### Delete
-```python
-### Takes a dataframe that contains the Id column
-### deletes records listed based on their SFID.
-
-delete_account = pd.DataFrame([{'Id': '0010r00000tF7stAAC'}, {'Id': '001f400000PKOrwAAH'}])
-
-result = sf.delete(object_api='Account', record_dataframe=delete_account)
-
-result
-```
-`Return -> pd.DataFrame()`
-
-|   | success | created |                 Id |
-|--:|--------:|--------:|-------------------:|
-| 0 |    True |   False | 0010r00000tF7stAAC |
-| 1 |    True |   False | 001f400000PKOrwAAH |
-
-<br/>
-
-### Read Metadata
-```python
-###
-
-```
-<br/>
-
-### Create Metadata
-```python
-###
-
-```
-<br/>
-
-### Update Metadata
-```python
-###
-
-```
-<br/>
-
-### Rename Metadata
-```python
-###
-
-```
-<br/>
-
-### Delete Metadata
-```python
-###
-
-```
-<br/>
-
-### List MetaData
-```python
-###
-
-```
+Metadata-Version: 2.1
+Name: veevatools
+Version: 0.1.9
+Summary: Veeva tools library for accelerating Veeva Systems Internal Tools development
+Home-page: https://github.com/michaelpay
+Author: Michael Pay
+Author-email: monickenish@gmail.com
+License: UNKNOWN
+Platform: UNKNOWN
+Description-Content-Type: text/markdown
+License-File: LICENSE.txt
+
+[![Downloads](https://pepy.tech/badge/veevatools)](https://pepy.tech/project/veevatools)
+
+# Introduction
+
+This python package is a set of Salesforce.com, Veeva Network, Veeva Vault, and Veeva Nitro libraries, scripts, and functions used to help expedite the development of Veeva Tools.
+<br/>
+<br/>
+
+# Installation / Requirements
+
+Ensure you have **at least Python version 3.10** installed.
+To Check your installation version, type the following commands in the terminal (MacOs) / command prompt (Windows):
+```
+python --version
+```
+To install python, go to https://www.python.org/ then navigate to the download page of your Operating System.
+
+![Screenshot 2022-06-24 140724](https://user-images.githubusercontent.com/59848012/175649491-0eafdef7-acd2-4631-85cb-f9dee8630b04.png)
+
+You will need to have Packager Installer for Python (pip) installed. To install pip, run the following command in the terminal (MacOs) / command prompt (Windows):
+
+```
+curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
+python3 get-pip.py
+```
+To install the Veeva Tools library:
+
+```
+pip install veevatools
+```
+To upgrade to the latest version of Veeva Tools library:
+```
+pip install veevatools --upgrade
+```
+
+# Overview
+
+The Veeva Tools package currently contains 3 major components:
+## Salesforce library
+
+### Authentication:
+
+```python
+from salesforce import Sf
+from pandas import pd
+sf = Sf()
+sf.authenticate(
+    sfUsername='yourname@salesforce.com',
+    sfPassword='password123',
+    sfOrgId='00D2C0000008jIK',
+    isSandbox= false
+    )
+```
+> Sidenote on Pandas DataFrames: <br/>
+Pandas DataFrame (pd) is used to prepare the data for import (i.e. create, update methods) and additional export methods such as pd.to_excel() in order to save the output into an Excel file.<br/>
+Additionally, Complex data manipuation (joins, merges, groupbys, filters)and data analytics (describe, statistical analysis) can all be performed using Pandas. <br />
+To learn more about Pandas DataFrames, go to the [Pandas documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)
+<br \>
+> Or just Google tutorials on Pandas DataFrames. 
+[This YouTube playlist by Corey Schafer](https://www.youtube.com/watch?v=ZyhVh-qRZPA&list=PL-osiE80TeTsWmV9i9c58mdDCSskIFdDS&ab_channel=CoreySchafer)
+provides an excellent starting point into the world of Pandas!
+
+<br/>
+
+### Data methods:
+The salesforce class (Sf) contains methods that can help you interact with data and metadata components:
+<br/>
+#### **Query**
+
+```python
+account_recordtypes = sf.query("SELECT Id, Name, SobjectType from RecordType WHERE SobjectType = 'Account'")]
+
+account_recordtypes
+```
+
+`Return -> pd.DataFrame():`
+|    |                 Id |                      Name | SobjectType |
+|---:|-------------------:|--------------------------:|------------:|
+|  0 | 012f4000001ArT3AAK |          Professional_vod |     Account |
+|  1 | 012f4000001ArT4AAK |           Institution_vod |     Account |
+|  2 | 012f4000001ArT5AAK |                   MCO_vod |     Account |
+|  3 | 012f4000001ArT6AAK |          Organization_vod |     Account |
+|  4 | 012f4000001ArWzAAK |              Hospital_vod |     Account |
+
+> Sidenote: <br />
+You can use any Pandas (pd) methods on the return value of the query output. For example <br/>```account_recordtypes.to_excel("Account RecordTypes.xlsx")``` <br/>
+Will save the results of the DataFrame into an Excel file.
+
+<br/>
+
+### **Create**
+```python
+## Takes a DataFrame of CRM records and creates records in CRM
+
+account_records = pd.DataFrame([{'FirstName': 'Test', 'LastName': 'Account'}, {'FirstName': 'Test2', 'LastName': 'Account2'}])
+
+result = sf.create('Account', account_records)
+
+result
+```
+`Return -> pd.DataFrame():`
+|   | success | created |                 Id |
+|--:|--------:|--------:|-------------------:|
+| 0 |    True |    True | 0010r00000tF7L1AAK |
+| 1 |    True |    True | 0010r00000tF7L2AAK |
+
+<br/>
+
+### Update
+```python
+### Takes a dataframe that contains at least the Id column
+### and any other column to be updated, for example, FirstName
+update_account_name = pd.DataFrame(
+    [{'FirstName': 'Updated', 'Id': '0010r00000tF7L1AAK'},
+     {'FirstName': 'Name', 'Id': '0010r00000tF7L2AAK'}]
+    )
+
+result = sf.update('Account', update_account_name)
+
+result
+```
+`Return -> pd.DataFrame()`
+|   | success | created |                 Id |
+|--:|--------:|--------:|-------------------:|
+| 0 |    True |   False | 0010r00000tF7L1AAK |
+| 1 |    True |   False | 0010r00000tF7L2AAK |
+<br/>
+
+### Upsert
+```python
+### Takes a dataframe that contains an external ID column
+### and any other column to be updated, for example, Name
+### if the external ID matches an existing record,
+### the account is updated, otherwise, a new record is created
+
+upsert_account = pd.DataFrame(
+    [{'NET_External_Id__c': '242977178138969088', 'Name': 'Updated Hospital Name'},
+     {'NET_External_Id__c': '555579769212255555', 'Name': 'Create New Hospital'}]
+    )
+
+result = sf.upsert(object_api='Account', external_id_field_api='NET_External_Id__c', record_dataframe=upsert_account)
+
+result
+```
+`Return -> pd.DataFrame()`
+|   | success | created |                 id |
+|--:|--------:|--------:|-------------------:|
+| 0 |    True |   False | 001f400000PKOrwAAH |
+| 1 |    True |    True | 0010r00000tF7stAAC |
+
+<br/>
+
+### Delete
+```python
+### Takes a dataframe that contains the Id column
+### deletes records listed based on their SFID.
+
+delete_account = pd.DataFrame([{'Id': '0010r00000tF7stAAC'}, {'Id': '001f400000PKOrwAAH'}])
+
+result = sf.delete(object_api='Account', record_dataframe=delete_account)
+
+result
+```
+`Return -> pd.DataFrame()`
+
+|   | success | created |                 Id |
+|--:|--------:|--------:|-------------------:|
+| 0 |    True |   False | 0010r00000tF7stAAC |
+| 1 |    True |   False | 001f400000PKOrwAAH |
+
+<br/>
+
+### Read Metadata
+```python
+###
+
+```
+<br/>
+
+### Create Metadata
+```python
+###
+
+```
+<br/>
+
+### Update Metadata
+```python
+###
+
+```
+<br/>
+
+### Rename Metadata
+```python
+###
+
+```
+<br/>
+
+### Delete Metadata
+```python
+###
+
+```
+<br/>
+
+### List MetaData
+```python
+###
+
+```
+
+
```

### Comparing `veevatools-0.1.8/salesforce/custom_exceptions/salesforce_exceptions.py` & `veevatools-0.1.9/salesforce/custom_exceptions/salesforce_exceptions.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,71 +1,71 @@
-class RequiredValuesNotProvidedDuringCreate(Exception):
-    """Exception raised when the required values are not provided to the
-    salesforce.create() function.
-
-    Required Values:
-        object_api: str -- The Object API name of the table to be inserted to in Salesforce.
-        record_dataframe: pd.DataFrame() -- a DataFrame of the records to be inserted, including required fields are available
-    """
-
-    def __init__(self, message="Required parameters missing on create. An object_api and the record_dataframe must be provided"):
-        self.message = message
-        super().__init__(self.message)
-
-class RequiredValuesNotProvidedDuringDelete(Exception):
-    """Exception raised when the required values are not provided to the
-    salesforce.delete() function.
-
-    Required Values:
-        object_api: str -- The Object API name of the table to be upserted to in Salesforce.
-        record_dataframe: pd.DataFrame() -- a DataFrame of the records to be deleted. 
-            The provided DataFrame must contain the "Id" column (Case sensitive)
-
-    """
-
-    def __init__(self, message="Required parameters missing on delete. \
-        An object_api and the record_dataframe must be provided or the Id column missing in the provided dataframe."):
-        self.message = message
-        super().__init__(self.message)
-
-class RequiredValuesNotProvidedDuringUpdate(Exception):
-    """Exception raised when the required values are not provided to the
-    salesforce.update() function.
-
-    Required Values:
-        object_api: str -- The Object API name of the table to be updated to in Salesforce.
-        record_dataframe: pd.DataFrame() -- a DataFrame of the records to be updated. 
-            The provided DataFrame must contain the "Id" column (Case sensitive)
-
-    """
-
-    def __init__(self, message="Required parameters missing on update. \
-        An object_api and the record_dataframe must be provided or the Id column missing in the provided dataframe \
-            or dataframe column names do not match a valid Salesforce field API name."):
-        self.message = message
-        super().__init__(self.message)
-
-class RequiredValuesNotProvidedDuringUpsert(Exception):
-    """Exception raised when the required values are not provided to the
-    salesforce.upsert() function.
-
-    Required Values:
-        object_api: str -- The Object API name of the table to be upserted to in Salesforce.
-        record_dataframe: pd.DataFrame() -- a DataFrame of the records to be upserted. 
-            The provided DataFrame must contain the API name of an external ID column.
-
-    """
-
-    def __init__(self, message="Required parameters missing on upserted. \
-        An object_api and the record_dataframe must be provided or and external ID column missing in the provided dataframe \
-            or dataframe column names do not match a valid Salesforce field API name."):
-        self.message = message
-        super().__init__(self.message)
-
-class RequiredFieldMissingDuringCreate(Exception):
-    """Exception raised when the required fields are not provided to the
-    salesforce.create() function.
-    """
-    def __init__(self, message="Required fields missing on create. Check your Salesforce datamodel to ensure all required fields are provided"):
-        self.message = message
-        super().__init__(self.message)
-
+class RequiredValuesNotProvidedDuringCreate(Exception):
+    """Exception raised when the required values are not provided to the
+    salesforce.create() function.
+
+    Required Values:
+        object_api: str -- The Object API name of the table to be inserted to in Salesforce.
+        record_dataframe: pd.DataFrame() -- a DataFrame of the records to be inserted, including required fields are available
+    """
+
+    def __init__(self, message="Required parameters missing on create. An object_api and the record_dataframe must be provided"):
+        self.message = message
+        super().__init__(self.message)
+
+class RequiredValuesNotProvidedDuringDelete(Exception):
+    """Exception raised when the required values are not provided to the
+    salesforce.delete() function.
+
+    Required Values:
+        object_api: str -- The Object API name of the table to be upserted to in Salesforce.
+        record_dataframe: pd.DataFrame() -- a DataFrame of the records to be deleted. 
+            The provided DataFrame must contain the "Id" column (Case sensitive)
+
+    """
+
+    def __init__(self, message="Required parameters missing on delete. \
+        An object_api and the record_dataframe must be provided or the Id column missing in the provided dataframe."):
+        self.message = message
+        super().__init__(self.message)
+
+class RequiredValuesNotProvidedDuringUpdate(Exception):
+    """Exception raised when the required values are not provided to the
+    salesforce.update() function.
+
+    Required Values:
+        object_api: str -- The Object API name of the table to be updated to in Salesforce.
+        record_dataframe: pd.DataFrame() -- a DataFrame of the records to be updated. 
+            The provided DataFrame must contain the "Id" column (Case sensitive)
+
+    """
+
+    def __init__(self, message="Required parameters missing on update. \
+        An object_api and the record_dataframe must be provided or the Id column missing in the provided dataframe \
+            or dataframe column names do not match a valid Salesforce field API name."):
+        self.message = message
+        super().__init__(self.message)
+
+class RequiredValuesNotProvidedDuringUpsert(Exception):
+    """Exception raised when the required values are not provided to the
+    salesforce.upsert() function.
+
+    Required Values:
+        object_api: str -- The Object API name of the table to be upserted to in Salesforce.
+        record_dataframe: pd.DataFrame() -- a DataFrame of the records to be upserted. 
+            The provided DataFrame must contain the API name of an external ID column.
+
+    """
+
+    def __init__(self, message="Required parameters missing on upserted. \
+        An object_api and the record_dataframe must be provided or and external ID column missing in the provided dataframe \
+            or dataframe column names do not match a valid Salesforce field API name."):
+        self.message = message
+        super().__init__(self.message)
+
+class RequiredFieldMissingDuringCreate(Exception):
+    """Exception raised when the required fields are not provided to the
+    salesforce.create() function.
+    """
+    def __init__(self, message="Required fields missing on create. Check your Salesforce datamodel to ensure all required fields are provided"):
+        self.message = message
+        super().__init__(self.message)
+
```

### Comparing `veevatools-0.1.8/salesforce/salesforce.py` & `veevatools-0.1.9/salesforce/salesforce.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,2019 +1,2019 @@
-from sys import platform
-import numpy as np
-import pandas as pd
-import os
-from simple_salesforce import Salesforce
-from simple_salesforce import SalesforceLogin
-from salesforce_bulk import SalesforceBulk
-from sfdclib import SfdcSession
-from sfdclib import SfdcMetadataApi
-from sfdclib import SfdcToolingApi
-import re
-import time
-import json
-from salesforce_bulk.util import IteratorBytesIO
-import pandas as pd
-import requests
-import base64
-from typing import List, Tuple, Optional, Union, Type, Callable
-from collections import OrderedDict
-import sys
-import zeep
-import datetime
-import ast
-sys.path.append("..")
-try:
-    from custom_exceptions.salesforce_exceptions import *
-    from utilities.df_utils import *
-    from utilities.async_utils import *
-    from utilities.sf_query_processors import *
-    from decorators import *
-except:
-    from salesforce.custom_exceptions.salesforce_exceptions import *
-    from salesforce.utilities.df_utils import *
-    from salesforce.utilities.async_utils import *
-    from salesforce.utilities.sf_query_processors import *
-    from salesforce.decorators import *
-import asyncio
-from functools import wraps, partial
-from pandas import json_normalize
-
-
-
-
-class Sf:
-    _REGEX_PARSE_SOQL_FIELDS = "(?<=select)(.*?)(?<!, )(?=from)"
-    _REGEX_PARSE_SOQL_OBJECT = "(?<!, from )(?<=from )\w*"
-    
-    def __init__(self) -> None:
-        self.filename: str = None
-        self.os_platform: str = platform
-        self.credentials: pd.DataFrame = pd.DataFrame()
-        self.sfUsername: str = None
-        self.sfPassword: str = None
-        self.sfOrgId: str = ""
-        self.isSandbox: bool = None
-        self.session_id: str = None
-        self.instance: str = None
-        self.domain: str = None
-        self.security_token: str = ''
-        self.sf: Salesforce = None
-        self.bulk: SalesforceBulk = None
-        self.sfMeta: SfdcMetadataApi = None
-        self.tooling: SfdcToolingApi = None
-        self.api_version: str = 'v52.0'
-        self.record_count: dict = {}
-        self.record_count_caseinsensitive: dict = {}
-        self.debug: bool = False
-        self.veeva_common:dict = None
-        self.org_info:dict = None
-        self.sfdc_limits: dict = None
-    
-    def authenticate(self, sfUsername: Optional[str]=None, 
-                                sfPassword: Optional[str]=None, 
-                                sfOrgId: Optional[str]=None, 
-                                isSandbox: Optional[bool]=None, 
-                                session_id: Optional[str]=None, 
-                                instance: Optional[str]=None, 
-                                security_token: Optional[str] = None,
-                                domain: Optional[str] = None,
-                                if_return: Optional[bool] = False,
-                                *args, **kwargs) -> Optional[dict]:
-        """
-        Authenticates Salesforce and retrieves the auth token.
-
-        Dependencies:
-            from simple_salesforce import Salesforce
-            from simple_salesforce import SalesforceLogin
-            from salesforce_bulk import SalesforceBulk
-            from sfdclib import SfdcSession
-            from sfdclib import SfdcMetadataApi
-            from sfdclib import SfdcToolingApi
-        """
-        
-        sfUsername = self.sfUsername if sfUsername is None else sfUsername
-        sfPassword = self.sfPassword if sfPassword is None else sfPassword
-        sfOrgId = self.sfOrgId if sfOrgId is None else sfOrgId
-        isSandbox = self.isSandbox if isSandbox is None else isSandbox
-        session_id = self.session_id if session_id is None else session_id
-        instance = self.instance if instance is None else instance
-        security_token = self.security_token if security_token is None else security_token
-        domain = self.domain if domain is None else domain
-        
-        # If session ID already exists and instance URL is already populated,
-        # reauthenticate using existing session ID
-        if session_id is not None and instance is not None:
-            sf = Salesforce(session_id = session_id, instance = instance)
-            self.sf = sf
-            self.instance = instance
-            self.session_id = session_id
-        
-        # If username, password, org ID, and isSandbox flags are all provided,
-        # authenticate using provided credentials
-        elif sfUsername is not None and sfPassword is not None and sfOrgId is not None and isSandbox is not None:
-            
-            # SFDC Sandbox authentication
-            if isSandbox:
-                self.domain = 'test'
-                sf = Salesforce(password=sfPassword, 
-                                username=sfUsername, 
-                                organizationId=sfOrgId, 
-                                security_token = self.security_token,domain='test')
-                session_id, instance = SalesforceLogin(
-                username=sfUsername,
-                password=sfPassword,
-                security_token=self.security_token,
-                domain= self.domain)
-                self.session_id = session_id
-                self.instance = instance
-                self.sf = sf
-                self.sfUsername = sfUsername
-                self.sfPassword = sfPassword
-                self.load_org_info()
-                self.sfOrgId = self.org_info['Id'][0]
-                self.isSandbox = isSandbox
-                
-            else:
-                sf = Salesforce(password=sfPassword, 
-                                username=sfUsername, 
-                                organizationId=sfOrgId, 
-                                security_token=self.security_token)
-                session_id, instance = SalesforceLogin(
-                username=sfUsername,
-                password=sfPassword,
-                security_token=self.security_token)
-                self.session_id = session_id
-                self.instance = instance
-                self.sf = sf
-                self.sfUsername = sfUsername
-                self.sfPassword = sfPassword
-                self.load_org_info()
-                self.sfOrgId = self.org_info['Id'][0]
-                self.isSandbox = isSandbox
-                
-        else:
-            raise Exception('Either sfUsername, sfPassword, sfOrgId and isSandbox must be populated, OR session_id and instance must be populated.')
-
-        # Alternative way to authenticate using SFDC Bulk API
-        # bulk = SalesforceBulk(username=sfUsername, password=sfPassword, security_token='')
-        bulk = SalesforceBulk(sessionId = self.session_id, host = self.instance)
-        self.bulk = bulk
-        # SFDC Metadata API
-        sf_meta_instance = ""
-        if self.instance.__contains__("my.salesforce.com"):
-            sf_meta_instance = self.instance.replace("my.salesforce.com","my")
-        else:
-            sf_meta_instance = ".".join(self.instance.split(".")[:2])
-            
-        sfMeta = SfdcSession(session_id=self.session_id, instance=sf_meta_instance)
-        self.sfMeta = sfMeta
-        # Alternative way to authenticate using SFDC Metadata API
-        # sfMeta = SfdcSession(username=sfUsername,password=sfPassword,token='',is_sandbox=isSandbox)
-        sfMeta._api_version = "54.0"
-        tooling = SfdcToolingApi(sfMeta)
-        self.tooling = tooling
-        
-        self.api_version = 'v' + self.sf_api_call('/services/data')[-1]['version']
-        
-        for x in self.sf_api_call('/services/data/'+self.api_version+'/limits/recordCount')['sObjects']:
-            self.record_count[x['name']] = x['count']
-            self.record_count_caseinsensitive[x['name'].lower()] = x['count']
-        
-        self.sfdc_limits = self.parse_sf_limits(self.sf_api_call('/services/data/'+self.api_version+'/limits'))
-        
-        
-        if if_return:
-            return {'sf':sf, 
-                    'bulk':bulk, 
-                    'sfMeta': sfMeta, 
-                    'tooling':tooling, 
-                    'session_id':session_id, 
-                    'instance':instance, 
-                    'sfMeta_is_connected':sfMeta.is_connected(), 
-                    'bulk_api_sessionId':bulk.sessionId}
-
-    ### ----------------------------------------------------------------------------------------------------
-    ### Synchronous Data Functions
-    ### ----------------------------------------------------------------------------------------------------
-
-    def query(self, query: str, excludedFields: Optional[List] = [], *args) -> pd.DataFrame:
-        """
-        Using SFDC SOQL Syntax, and allowing for Relationships and group bys. 
-        
-        Arguments:
-            query (str): A Standard SFDC SOQL Query allowing for relationships (Owner.Name)
-                Asterisks(*) represents all queryable fields and can be used in conjunction
-                with other relationship fields. 
-                i.e. (Select *, Owner.Profile.Name, Owner.Name From Account)
-        
-        Returns:
-            Pandas Dataframe Object.
-        
-        Raises:
-            KeyError: Typically raised when 0 records exist for the object
-                
-            badfield: A self-correcting error that is raised when a field is unqueriable, i.e. Address Fields
-            
-            Exception: When relationship query contains more than 4 layers, an Exception is raised.
-            i.e. Parent_Account_vod__r.Owner.Profile.LastModifiedBy.Name (<- a 5 layer deep relationship is not supported)
-        
-        Example of Usage:
-            sf.query("Select *, Owner.Profile.Name From Account ORDER BY CreatedDate DESC LIMIT 100")
-            
-            return:
-            A Pandas Dataframe of the last created 100 account records, with all queriable fields included in the query and a relationship field.
-            
-        """
-        objectName = re.search(self._REGEX_PARSE_SOQL_OBJECT, query.lower()).group(0)
-        successful = False
-        
-        extracted_object = pd.DataFrame()
-        # replaces "*" in query with all fields on object
-        sfSchema = getattr(self.sf, objectName).describe().get('fields')
-
-        schemaDict = {}
-        for x in sfSchema:
-            schemaDict[x['name']] = x
-
-        while not successful:
-            try:
-                results = []
-                for field in schemaDict:
-                    if (schemaDict[field]['type'] != 'location' and 
-                        schemaDict[field]['type'] != 'address' and 
-                        schemaDict[field]['name'] not in excludedFields):
-                        results.append(field)
-                final_query = query.replace("*", ", ".join(results))                
-                query_response = self.sf.query_all(final_query)
-                # if the object has 0 records in Salesforce, return empty dataframe
-                if query_response['totalSize'] == 0:
-                    fields_preparsed = re.search(self._REGEX_PARSE_SOQL_FIELDS, query,  re.IGNORECASE).group(0).split(",")
-                    return pd.DataFrame(columns=fields_preparsed)
-                else:
-                    result = pd.DataFrame(query_response)['records']
-                    for _ in result:
-                        del _['attributes']
-                    successful = True
-            except KeyError:
-                if self.debug:
-                    print(objectName + ' skipped. (Potentially due to no records found.)')
-                    
-                return pd.DataFrame(columns=results)
-            except Exception as badfield:
-                field_exclusion = badfield.state_message[badfield.state_message.find("No such column '")+\
-                    16:badfield.state_message.find("No such column '")+16+\
-                        badfield.state_message[badfield.state_message.find("No such column '")+16:].find("'")]
-                excludedFields.append(field_exclusion)
-                print("Excluded unqueriable field: " + field_exclusion)
-                if query.find("*") == -1:
-                    raise Exception(f"Unqueriable field {field_exclusion} found in query.")
-                else:
-                    continue
-            
-            result = result.apply(lambda x: pd.Series(x)).copy()
-
-            relationship_fields_preparsed = re.search(self._REGEX_PARSE_SOQL_FIELDS, query,  re.IGNORECASE).group(0).split(",")
-            # relationship_fields_prepared Example:
-            # ['*',
-            #  ' Parent_Account_vod__r.Owner.Profile.Name',
-            #  ' Child_Account_vod__r.Owner.Profile.Name',
-            #  'Parent_Account_vod__r.Owner.Profile.Id ']
-
-            relational_fields = [{x.strip(): x.strip().split(".")} for x in relationship_fields_preparsed if "." in x]
-            # relationship_fields Example:
-            # [{'Parent_Account_vod__r.Owner.Profile.Name': ['Parent_Account_vod__r',
-            #    'Owner',
-            #    'Profile',
-            #    'Name']},
-            #  {'Child_Account_vod__r.Owner.Profile.Name': ['Child_Account_vod__r',
-            #    'Owner',
-            #    'Profile',
-            #    'Name']},
-            #  {'Parent_Account_vod__r.Owner.Profile.Id': ['Parent_Account_vod__r',
-            #    'Owner',
-            #    'Profile',
-            #    'Id']}]
-
-            columns_to_remove = set()
-            for x in relational_fields:
-                if len(list(x.values())[0]) > 4:
-                    raise Exception("Too Many Relationship Levels. The Query you have entered contains more than 4 levels deep and is not supported.")
-                elif len(list(x.values())[0]) == 4:
-                    result[list(x.keys())[0]] = result[list(x.keys())[0].split(".")[0]].\
-                        apply(lambda z: z[list(x.values())[0][1]][list(x.values())[0][2]][list(x.values())[0][3]])
-                    columns_to_remove.add(list(x.values())[0][0])
-                elif len(list(x.values())[0]) == 3:
-                    result[list(x.keys())[0]] = result[list(x.keys())[0].split(".")[0]].\
-                        apply(lambda z: z[list(x.values())[0][1]][list(x.values())[0][2]])
-                    columns_to_remove.add(list(x.values())[0][0])
-                elif len(list(x.values())[0]) == 2:
-                    result[list(x.keys())[0]] = result[list(x.keys())[0].split(".")[0]].\
-                        apply(lambda z: z[list(x.values())[0][1]])
-                    columns_to_remove.add(list(x.values())[0][0])
-            result.drop(columns_to_remove, axis=1, inplace=True)
-            result.replace(np.nan, None, inplace=True)        
-
-                
-        return result
-
-    def create(self, object_api: str=None, record_dataframe: pd.DataFrame = pd.DataFrame()) -> pd.DataFrame:
-        """
-        Function creates records within the Salesforce instance using bulk api.
-
-        Arguments:
-        object_api: str: API name of the Salesforce Object for which the records are to be created.
-
-        record_dataframe: pd.DataFrame: A pandas dataframe object containing all the required fields for a record.
-
-        Returns:
-        result: pd.DataFrame: A pandas dataframe with the following columns:
-            success: boolean: indicates whether the create request was successful
-            created: boolean: this value should always be False in a create request
-            id: object[str]: this value typically is None in a create request
-            statusCode: object[str] - Optional: the error code of the create operation if failed
-            message: object[str] - Optional: the error message of the create operation if failed
-            fields: object[List[str]] - Optional: the fields for which the error code and message applies to.
-
-        Raises:
-            RequiredValuesNotProvidedDuringUpdate
-        """
-        if (object_api is None) or (len(record_dataframe) == 0):
-            raise RequiredValuesNotProvidedDuringCreate()
-        else:
-            result = getattr(self.sf.bulk, object_api).insert(record_dataframe.to_dict('records'), batch_size=10000, use_serial=False)
-            result = pd.DataFrame(result)
-            result = unpack_column(result, "errors")
-
-        return pd.DataFrame(result.rename(columns={'id': 'Id'}))
-
-    def delete(self, object_api: str=None, record_dataframe: pd.DataFrame = pd.DataFrame()) -> pd.DataFrame:
-        """
-        Function deletes records within the Salesforce instance using bulk api.
-
-        Arguments:
-        object_api: str: API name of the Salesforce Object for which the records are to be deleted from.
-
-        record_dataframe: pd.DataFrame: A pandas dataframe object containing at least 1 column with an Id column (case sensitive)
-
-        Returns:
-        result: pd.DataFrame: A pandas dataframe with the following columns:
-            success: boolean: indicates whether the delete request was successful
-            created: boolean: this value should always be False in a delete request
-            id: object[str]: this value typically is None in a delete request
-            statusCode: object[str] - Optional: the error code of the delete operation if failed
-            message: object[str] - Optional: the error message of the delete operation if failed
-            fields: object[List[str]] - Optional: the fields for which the error code and message applies to.
-
-        Raises:
-            RequiredValuesNotProvidedDuringDelete
-        """
-        if (object_api is None) or (len(record_dataframe) == 0) or record_dataframe.columns.__contains__('Id') == False:
-            raise RequiredValuesNotProvidedDuringDelete()
-        else:
-            result = getattr(self.sf.bulk, object_api).delete(record_dataframe['Id'].to_frame().to_dict('records'))
-            result = pd.DataFrame(result)
-            result = unpack_column(result, "errors")
-
-        return pd.DataFrame(result.rename(columns={'id': 'Id'}))
-    
-    def update(self, object_api: str=None, record_dataframe: pd.DataFrame = pd.DataFrame()) -> pd.DataFrame:
-        """
-        Function updates records within the Salesforce instance using bulk api.
-
-        Arguments:
-        object_api: str: API name of the Salesforce Object for which the records are to be updated.
-
-        record_dataframe: pd.DataFrame: A pandas dataframe object containing at least 1 column with an Id column (case sensitive)
-            and additional columns matching the Salesforce field api names.
-
-        Returns:
-        result: pd.DataFrame: A pandas dataframe with the following columns:
-            success: boolean: indicates whether the update request was successful
-            created: boolean: this value should always be False in a update request
-            id: object[str]: this value typically is None in a update request
-            statusCode: object[str] - Optional: the error code of the update operation if failed
-            message: object[str] - Optional: the error message of the update operation if failed
-            fields: object[List[str]] - Optional: the fields for which the error code and message applies to.
-
-        Raises:
-            RequiredValuesNotProvidedDuringUpdate
-        """
-
-        field_metadata = self.field_describe([object_api],attributes=['name','type','updateable','compoundFieldName'])
-
-        if ((object_api is None) or 
-        (len(record_dataframe) == 0)):
-            raise RequiredValuesNotProvidedDuringUpdate(message="Object API and Record Dataframe are required, ensure your record dataframe has at least 1 row and 1 column with an Id column")
-        elif record_dataframe.columns.__contains__('Id') == False:
-            raise RequiredValuesNotProvidedDuringUpdate(message="Record Dataframe must have an Id column")
-        elif ~record_dataframe.columns.isin(field_metadata[object_api]).all():
-            # checks whether any of the columns in the dataframe passed in are not valid field API names
-            raise RequiredValuesNotProvidedDuringUpdate(message="One of the columns in the record dataframe is not a valid field for the object")
-        elif record_dataframe.columns.isin(field_metadata[(field_metadata['Updateable'] == False) & (field_metadata[object_api] != "Id")][object_api]).any():
-            # checks whether any of the columns in the dataframe passed in are not updateable
-            non_updatable_fields = list(set(record_dataframe.columns) - set(field_metadata[(field_metadata['Updateable'] == True) | (field_metadata[object_api] == "Id")][object_api]))
-            raise RequiredValuesNotProvidedDuringUpdate(message=f"The following fields are not updatable: {', '.join(non_updatable_fields)}")
-        elif record_dataframe.columns.isin(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_api]).any():
-            # checks whether any of the columns in the dataframe passed in are compound fields
-            compound_fields = list(set(record_dataframe.columns) & set(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_api]))
-            raise RequiredValuesNotProvidedDuringUpdate(message=f"The following fields are compound fields, which are not updatable: {', '.join(compound_fields)}")
-        # checks whether an reference (lookup/master-detail) field is included in the source dataframe
-        #  or ~record_dataframe.columns.isin(field_metadata[field_metadata['Type'] == 'reference'][object_api]).any()
-            
-        else:
-            record_dataframe.replace(np.nan, None, inplace=True)
-            result = getattr(self.sf.bulk, object_api).update(record_dataframe.to_dict('records'), batch_size=10000, use_serial=False)
-            result = pd.DataFrame(result)
-            result = unpack_column(result, "errors")
-
-        return pd.DataFrame(result.rename(columns={'id': 'Id'}))
-
-    def upsert(self, object_api: str=None, external_id_field_api: str="", record_dataframe: pd.DataFrame = pd.DataFrame()) -> pd.DataFrame:
-        """
-        Function upserts records within the Salesforce instance using bulk api.
-
-        Arguments:
-        object_api: str: API name of the Salesforce Object for which the records are to be upserted into.
-
-        external_id_field_api: str: API name of the external ID field used for the upsert operation.
-
-        record_dataframe: pd.DataFrame: A pandas dataframe object containing the External column (case sensitive)
-            and additional columns matching the Salesforce field api names.
-
-        Returns:
-        result: pd.DataFrame: A pandas dataframe with the following columns:
-            success: boolean: indicates whether the upsert request was successful
-            created: boolean: this value should always be False in a upsert request
-            id: object[str]: this value typically is None in a upsert request
-            statusCode: object[str] - Optional: the error code of the upsert operation if failed
-            message: object[str] - Optional: the error message of the upsert operation if failed
-            fields: object[List[str]] - Optional: the fields for which the error code and message applies to.
-
-        Raises:
-            RequiredValuesNotProvidedDuringUpsert
-            SalesforceMalformedRequest
-        """
-
-        field_metadata = self.field_describe([object_api], ['name', 'type', 'length','externalId','updateable','compoundFieldName'])
-            
-            
-        if ((object_api is None) or 
-        (len(record_dataframe) == 0)):
-            raise RequiredValuesNotProvidedDuringUpdate(message="Object API and Record Dataframe are required, ensure your record dataframe has at least 1 row and 1 column with an Id column")
-        elif ~record_dataframe.columns.isin(field_metadata[object_api]).all():
-            # checks whether any of the columns in the dataframe passed in are not valid field API names
-            raise RequiredValuesNotProvidedDuringUpdate(message="One of the columns in the record dataframe is not a valid field for the object")
-        elif external_id_field_api == "":
-            raise RequiredValuesNotProvidedDuringUpsert(message="External ID field API is required")
-        elif record_dataframe.columns.isin(field_metadata[(field_metadata['Updateable'] == False) & (field_metadata[object_api] != "Id")][object_api]).any():
-            # checks whether any of the columns in the dataframe passed in are not updateable
-            non_updatable_fields = list(set(record_dataframe.columns) - set(field_metadata[(field_metadata['Updateable'] == True) | (field_metadata[object_api] == "Id")][object_api]))
-            raise RequiredValuesNotProvidedDuringUpdate(message=f"The following fields are not updatable: {', '.join(non_updatable_fields)}")
-        elif record_dataframe.columns.isin(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_api]).any():
-            # checks whether any of the columns in the dataframe passed in are compound fields
-            compound_fields = list(set(record_dataframe.columns) & set(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_api]))
-            raise RequiredValuesNotProvidedDuringUpdate(message=f"The following fields are compound fields, which are not updatable: {', '.join(compound_fields)}")
-        else:
-            record_dataframe.replace(np.nan, None, inplace=True)
-            result = getattr(self.sf.bulk, object_api).upsert(record_dataframe.to_dict('records'), external_id_field_api, batch_size=10000, use_serial=False)
-            result = pd.DataFrame(result)
-            result = unpack_column(result, "errors")
-
-        return pd.DataFrame(result)
-
-    def extract_bulk(self, og_query: str, 
-                        excludedFields: Optional[List] = []) -> pd.DataFrame:
-        """
-        Uses a standard SOQL query to extract Salesforce Data and outputs a pandas dataframe
-        
-        Dependencies:
-            import re
-            import time
-            import json
-            from salesforce_bulk.util import IteratorBytesIO
-            import pandas as pd
-        
-        """
-        objectName = re.search(self._REGEX_PARSE_SOQL_OBJECT, og_query.lower()).group(0)
-        successful = False
-        
-        extracted_object = pd.DataFrame()
-        # replaces "*" in query with all fields on object
-        sfSchema = getattr(self.sf, objectName).describe().get('fields')
-
-        schemaDict = {}
-        for x in sfSchema:
-            schemaDict[x['name']] = x
-
-        while not successful:
-            try:
-                results = []
-                for field in schemaDict:
-                    if (schemaDict[field]['type'] != 'location' and 
-                        schemaDict[field]['type'] != 'address' and 
-                        schemaDict[field]['name'] not in excludedFields):
-                        results.append(field)
-                query = og_query.replace("*", ", ".join(results))
-                
-#                 # if the object has 0 records in Salesforce, return empty dataframe
-#                 if objectName not in self.record_count_caseinsensitive.keys():
-#                     return pd.DataFrame(columns=results)
-                    
-                job = self.bulk.create_query_job(objectName, contentType='JSON')
-                batch = self.bulk.query(job, query)
-                while not self.bulk.is_batch_done(batch):
-                    time.sleep(1)
-                sfdf = pd.DataFrame()
-                for result in self.bulk.get_all_results_for_query_batch(batch):
-                    result = json.load(IteratorBytesIO(result))
-                    sfdf = pd.concat([sfdf, pd.DataFrame(result)])
-
-                # drops attributes column in dataframe
-                sfdf.drop(columns="attributes", inplace = True)
-
-                # formats all datetime to the proper formatting
-                for column in sfdf:
-                    if schemaDict[column]['type'] == 'datetime':
-                        sfdf[column] = pd.to_datetime(sfdf[column], unit='ms')
-                    # if the column has a 'scale' or salesforce's decimal places, then turn the column into an int
-                    elif schemaDict[column]['type'] == 'double' and schemaDict[column]['scale'] == 0:
-                        sfdf[column] = pd.to_numeric(sfdf[column], downcast='integer')
-
-            #                         pd.to_datetime(sfdf[column], unit = 's')
-            #                         sfdf[column].apply(lambda x : datetime.fromtimestamp(int(x), tz).isoformat())
-            #                 sfdf.convert_dtypes()
-                # converts the output of the bulk query to text so that the unix timestamp displays property, and fills and empty values with the '' string.
-                sfdf = sfdf.fillna('').astype(str)
-                successful = True
-            except KeyError:
-                if self.debug:
-                    print(objectName + ' skipped. (Potentially due to no records found.)')
-                    
-                return pd.DataFrame(columns=results)
-            except Exception as badfield:
-                field_exclusion = badfield.state_message[badfield.state_message.find("No such column '")+\
-                    16:badfield.state_message.find("No such column '")+16+\
-                        badfield.state_message[badfield.state_message.find("No such column '")+16:].find("'")]
-                excludedFields.append(field_exclusion)
-                print("Excluded unqueriable field: " + field_exclusion)
-                if og_query.find("*") == -1:
-                    raise Exception(f"Unqueriable field {field_exclusion} found in query.")
-                else:
-                    continue
-        if self.debug:
-            print("Extracted " + objectName + " successfully!")
-        return sfdf
-    
-    def entity_access_query(self, entity_type):
-        # Retrieves information about which Profile or PermissionSet
-        # grants permission to which Setup Entity (i.e. ApexPage, ApexClass, TabSets, etc)
-        
-        entity_access = transform_sf_result_set_rec(self.sf.query_all(f"""
-        SELECT Id, Parent.Id, Parent.ProfileId, Parent.Profile.Name, Parent.Name,SetupEntityId,SetupEntityType FROM
-        SetupEntityAccess WHERE SetupEntityType = '{entity_type}'""")['records'])
-        # entity_access.drop(columns=['PermissionSet.Profile'], inplace=True)
-        return {entity_type: entity_access}
-
-    ### ----------------------------------------------------------------------------------------------------
-    ### Asynchronous Data Functions
-    ### ----------------------------------------------------------------------------------------------------
-
-    async def async_query(self, query, excludedFields: Optional[List] = []) -> pd.DataFrame:
-        async_query = async_wrap(self.query)
-        return await async_query(query, excludedFields)
-    
-    async def async_queries(self, queries: List[str]):
-        async_queries = async_wrap(self.sf.query_all)
-        result_list = await asyncio.gather(*[async_queries(query) for query in queries])
-        result_pd_list = [transform_sf_result_set_rec(result['records']) for result in result_list]
-        return result_pd_list
-
-
-    async def async_upsert(self, object_api, record_dataframe, external_id_field_api, batchsize=2000, *args, **kwargs):
-        async_upsert = async_wrap(self.upsert)
-        batches = len(record_dataframe) / batchsize
-        result_list = await asyncio.gather(*[async_upsert(object_api= object_api, record_dataframe=batch, external_id_field_api=external_id_field_api) for batch in np.array_split(record_dataframe, batches)])
-        return pd.concat(result_list).reset_index(drop=True)
-
-    async def async_update(self, object_api, record_dataframe, batchsize=2000, *args, **kwargs):
-        async_update = async_wrap(self.update)
-        batches = len(record_dataframe) / batchsize
-        result_list = await asyncio.gather(*[async_update(object_api= object_api, record_dataframe=batch) for batch in np.array_split(record_dataframe, batches)])
-        return pd.concat(result_list).reset_index(drop=True)
-
-    async def async_create(self, object_api, record_dataframe, batchsize=2000, *args, **kwargs):
-        async_create = async_wrap(self.create)
-        batches = len(record_dataframe) / batchsize
-        result_list = await asyncio.gather(*[async_create(object_api= object_api, record_dataframe=batch) for batch in np.array_split(record_dataframe, batches)])
-        return pd.concat(result_list).reset_index(drop=True)
-
-    async def async_delete(self, object_api, record_dataframe, batchsize=2000, *args, **kwargs):
-        async_delete = async_wrap(self.delete)
-        batches = len(record_dataframe) / batchsize
-        result_list = await asyncio.gather(*[async_delete(object_api= object_api, record_dataframe=batch) for batch in np.array_split(record_dataframe, batches)])
-        return pd.concat(result_list).reset_index(drop=True)
-    
-    async def async_get_user_password_status(self, user_ids: list[str]) -> dict:
-        async_sf_api_call = async_wrap(self.sf_api_call)
-        response = await asyncio.gather(*[async_sf_api_call(f'/services/data/{self.api_version}/sobjects/User/{user_id}/password', method='GET') for user_id in user_ids])
-        # Return a dict
-        response = {user_id: result for user_id, result in zip(user_ids, response)}
-        return response
-    
-    
-    
-    ### ----------------------------------------------------------------------------------------------------
-    ### Asynchronous Metadata Functions
-    ### ----------------------------------------------------------------------------------------------------
-    async def async_get_non_updatable_fields(self, object_name: str):
-        """
-        Returns a list of fields that cannot be updated.
-        """
-        async_field_describe =  async_wrap(self.field_describe)
-        field_metadata = await async_field_describe([object_name], attributes=['name','updateable'])
-        non_updatable_fields = list(field_metadata[field_metadata['Updateable'] == False][object_name])[1:]
-        return non_updatable_fields
-
-    async def async_get_compound_field_names(self, object_name: str, include_name_compound_fields: bool=False):
-        """
-        Returns a list of compound fields. By default "Name" compound field names are excluded.
-        To return a list of compound fields including "Name" fields, set include_name_compound_fields to True.
-
-        Compound field names are fields that are composed of multiple fields. These fields are not updatable directly via the API
-        and may cause errors if updated directly.
-        """
-        async_field_describe =  async_wrap(self.field_describe)
-        field_metadata = await async_field_describe([object_name], attributes=['name','compoundFieldName'])
-
-        if include_name_compound_fields:
-            compound_field_names = list(field_metadata[(~field_metadata['Compoundfieldname'].isnull())][object_name])
-        elif include_name_compound_fields==False:
-            compound_field_names = list(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_name])
-        else:
-            raise ValueError('include_name_compound_fields must be a boolean.')
-        return compound_field_names
-    
-    async def get_picklist_values_by_object_record_type(self, object: str):
-        object_record_type_ids = self.query(f"Select Id, Name From RecordType Where SobjectType = '{object}'").apply(lambda row: {"Id": row['Id'], "Name": row['Name']}, axis=1)
-        if len(object_record_type_ids) == 0:
-            object_record_type_ids = pd.Series([{"Id": "012000000000000AAA", "Name": "Master"}]).to_list()
-        else:
-            object_record_type_ids = object_record_type_ids.to_list()
-            
-        object_describe = self.sf_api_call(f"/services/data/{self.api_version}/ui-api/object-info/{object}")['fields']
-        controlling_fields = []
-        for field, values in object_describe.items():
-            controlling_fields.append({"Field": field, "Controlling Field": "" if values['controllingFields'] == [] else "; ".join(values['controllingFields'])})
-        controlling_fields = pd.DataFrame(controlling_fields)
-
-        def record_type_picklist_retriever(self, object, record_type_id, record_type_name):
-            result = []
-            picklist_metadata = self.sf_api_call(f"/services/data/{self.api_version}/ui-api/object-info/{object}/picklist-values/{record_type_id}")['picklistFieldValues']
-            if len(picklist_metadata) == 0:
-                return pd.DataFrame(columns=['attributes',
-                                    'label',
-                                    'validFor',
-                                    'value',
-                                    'Field_API',
-                                    'defaultValueLabel',
-                                    'defaultValueValue',
-                                    'Controlling Field',
-                                    'RecordTypeName',
-                                    'Object'])
-                
-            for key, value in picklist_metadata.items():
-                result.append({"Field_API": key, "controllerValues": value['controllerValues'], "defaultValue":  value['defaultValue'], "values": value['values']})
-            final_result_pd = json_normalize(result, ['values'], ['defaultValue', 'controllerValues', 'Field_API'])
-            ## Converts the validFor numerical codes i.e. [0,2] to it's corresponding text values by looking it up on the controllerValues column i.e. {'Web': 0, 'Phone Inquiry': 1, 'Partner Reference': 2 ... }
-            ## [0,2] -> ['Web', 'Partner Reference']
-            final_result_pd['validFor'] = final_result_pd.apply(lambda row: "\n".join([{v: k for k, v in row['controllerValues'].items()}[value] for value in row['validFor']]), axis=1)
-            final_result_pd.drop(columns=['controllerValues'], inplace=True)
-            
-            try:
-                final_result_pd[['defaultValueLabel', 'defaultValueValue']] = json_normalize(final_result_pd['defaultValue'])[['label','value']]
-            except:
-                final_result_pd[['defaultValueLabel', 'defaultValueValue']] = [np.nan, np.nan]
-            
-            final_result_pd.drop(columns=['defaultValue'], inplace=True)
-            final_result_pd = pd.merge(final_result_pd, controlling_fields, left_on='Field_API', right_on='Field', how='left').drop(columns=['Field']).copy()
-            final_result_pd['RecordTypeName'] = record_type_name
-            final_result_pd['Object'] = object
-            return final_result_pd
-
-        async_picklist_rt_retrieve = async_wrap(record_type_picklist_retriever)
-        results = pd.concat(await asyncio.gather(*[async_picklist_rt_retrieve(self, object, record_type_id['Id'], record_type_id['Name']) for record_type_id in object_record_type_ids]))
-        results = results[['Object', 'RecordTypeName', 'Field_API', 'Controlling Field', 'defaultValueLabel', 'defaultValueValue', 'label', 'value', 'validFor']]
-        return results
-
-
-    async def object_permission_bulk_check(self, objects: list, permissions: list ):
-        async_object_permission_check = async_wrap(self.object_permission_check)
-        result_list = await asyncio.gather(*[async_object_permission_check(object, permission ) for object in objects for permission in permissions])
-        # for result in result_list:
-        #     data = deep_merge_dictionaries(data, result)
-        result_list = [item for sublist in result_list for item in sublist]
-        return result_list
-
-    async def field_permission_bulk_check(self, objects: list, ) -> dict[str, pd.DataFrame]:
-        async_field_permission_check = async_wrap(self.field_permission_check)
-        result_list = await asyncio.gather(*[async_field_permission_check( object ) for object in objects])
-        # for result in result_list:
-        #     data = deep_merge_dictionaries(data, result)
-        profile_list = [item['profilePermissions'] for item in result_list]
-        permissionSet_list = [item['permissionSetPermissions'] for item in result_list]
-        result_dict = {'profilePermissions': pd.concat(profile_list), 'permissionSetPermissions': pd.concat(permissionSet_list)}
-        
-        return result_dict
-    
-    async def async_set_user_passwords(self, user_id_password_list_dict: dict) -> dict:
-        async_set_user_password = async_wrap(self.set_user_password)
-        results = await asyncio.gather(*[async_set_user_password(user_id, password) for user_id, password in user_id_password_list_dict.items()])
-        results = {result['user_id']: result['message'] for result in results}
-        return results
-
-    async def entity_access_bulk_query(self, entity_types: list):
-        async_entity_access_query = async_wrap(self.entity_access_query)
-        results = await asyncio.gather(*[async_entity_access_query(entity_type) for entity_type in entity_types])
-        merged_dict = {}
-        for result in results:
-            for key, value in result.items():
-                merged_dict[key] = value
-        return merged_dict
-
-    async def apex_pages_profiles_and_permission_set_access_query(self, apex_pages_to_check: list[str]):
-        query_results = await self.entity_access_bulk_query(['ApexPage'])
-
-        entity_access_apex_pages_async =  query_results['ApexPage']
-
-        entity_permission_set_access_apex_pages_async = entity_access_apex_pages_async[entity_access_apex_pages_async['Profile.Name'].isna()]
-        entity_profile_access_apex_pages_async = entity_access_apex_pages_async[entity_access_apex_pages_async['Profile.Name'].notna()]
-
-        # filter = ['Scheduler_Administration_vod','Network_Admin_Page_vod','searchAccts_vod']
-        filter_join = "','".join(apex_pages_to_check)
-        where_clause = f" WHERE Name IN ('{filter_join}')"
-        apex_pages_query = transform_sf_result_set_rec(self.sf.query_all(f"""
-            SELECT Id, Name From ApexPage{where_clause}""")['records'])
-
-        permission_sets_with_apex_page_access = entity_permission_set_access_apex_pages_async[entity_permission_set_access_apex_pages_async['SetupEntityAccess.SetupEntityId'].isin(apex_pages_query['ApexPage.Id'].unique())]
-        profiles_with_apex_page_access = entity_profile_access_apex_pages_async[entity_profile_access_apex_pages_async['SetupEntityAccess.SetupEntityId'].isin(apex_pages_query['ApexPage.Id'].unique())]
-        permission_sets_with_apex_page_access = pd.merge(permission_sets_with_apex_page_access, apex_pages_query, left_on='SetupEntityAccess.SetupEntityId', right_on='ApexPage.Id', how='inner').drop(columns=['ApexPage.Id'], axis=1)
-        profiles_with_apex_page_access = pd.merge(profiles_with_apex_page_access, apex_pages_query, left_on='SetupEntityAccess.SetupEntityId', right_on='ApexPage.Id', how='inner').drop(columns=['ApexPage.Id'], axis=1)
-
-        profiles_with_apex_page_access = profiles_with_apex_page_access[['PermissionSet.ProfileId','Profile.Name','SetupEntityAccess.SetupEntityType','ApexPage.Name']]
-        profiles_with_apex_page_access.columns = ['Profile Id', 'Profile Name', 'Setup Entity Type', 'Visualforce (Apex) Name']
-        
-        permission_sets_with_apex_page_access = permission_sets_with_apex_page_access[['PermissionSet.Id','PermissionSet.Name','SetupEntityAccess.SetupEntityType','ApexPage.Name']]
-        permission_sets_with_apex_page_access.columns = ['PermissionSet Id', 'PermissionSet Name', 'Setup Entity Type', 'Visualforce (ApexPage) Name']
-        
-        return {'profiles_with_apex_page_access': profiles_with_apex_page_access, 'permission_sets_with_apex_page_access': permission_sets_with_apex_page_access}
-
-    # Retrieves the Page Layout by Profile by Record Type data for listed objects in the org
-    async def retrieve_profile_layout_record_type_matrix_by_objects(self, objects_to_retrieve_profile_layout_matrix = ['Account','Address_vod__c','Child_Account_vod__c'], discard_unqueriable_objects = False, return_pivot_table = False):
-        
-        objects_to_retrieve = [object[:-3] if object.endswith('__c') else object for object in objects_to_retrieve_profile_layout_matrix]
-        
-        # Objects in the Profile Layout table's TableEnumOrId column where the value is an object name instead of an object ID
-        
-        ENUM_OBJECTS = {'Account', 'AccountTeamMember', 'Asset', 'AuthorizationForm', 'AuthorizationFormConsent', 'BusinessBrand', 'Campaign', 'CampaignMember', 'Case',
-                            'CaseClose', 'CaseInteraction', 'CommunityMemberLayout', 'Contact', 'ContactPointAddress', 'ContactPointEmail', 'ContactPointPhone', 'ContentVersion', 'Contract', 'Customer', 'DelegatedAccount',
-                            'DuplicateRecordItem', 'DuplicateRecordSet', 'EmailMessage', 'Event', 'FeedItem', 'Global', 'Idea', 'Individual', 'Lead', 'Macro', 'ObjectTerritory2AssignmentRule',
-                            'Opportunity', 'OpportunityLineItem', 'Order', 'OrderItem', 'PersonAccount', 'Pricebook2', 'PricebookEntry', 'ProcessException', 'Product2',
-                            'ProfileSkill', 'ProfileSkillEndorsement', 'ProfileSkillUser', 'QuickText', 'Scorecard', 'ScorecardAssociation', 'ScorecardMetric', 'Seller', 'ServiceAppointmentGroup',
-                            'ServiceTerritoryRelationship', 'SignupRequest', 'SocialPersona', 'SocialPost', 'Solution', 'Task', 'Territory2', 'Territory2Model', 'Territory2Type', 'User',
-                            'UserAlt', 'UserProvAccount', 'UserProvisioningLog', 'UserProvisioningRequest', 'UserTerritory2Association', 'WorkProcedure', 'WorkProcedureStep', 'WorkTypeExtension'}
-        
-        # Objects that returns empty results if queried via the WHERE clause using Salesforce Tooling API.
-        # i.e. "Select LayoutId from ProfileLayout where TableEnumOrId = 'DelegatedAccount'" returns empty results.
-        UNQUERIABLE_ENUM_OBJECTS = {'DelegatedAccount','ProfileSkill','ProfileSkillEndorsement','ProfileSkillUser','ServiceTerritoryRelationship','WorkTypeExtension'}
-        
-        
-        
-        object_dataframe = pd.DataFrame(self.tooling_query_all("Select DeveloperName from CustomObject"))
-        object_dataframe['ObjectID'] = object_dataframe.apply(lambda row: row['attributes']['url'].split('/')[-1] if row['attributes']['url'] else "", axis=1)
-        
-        profile_layout_queries = []
-        
-        for object_name in objects_to_retrieve:
-            if object_name in UNQUERIABLE_ENUM_OBJECTS and discard_unqueriable_objects == False:
-                raise Exception("Unqueriable object: " + object_name + ". Please use retrieve_profile_layout_record_type_matrix_all() instead or set discard_unqueriable_objects parameter to True")
-            elif object_name in ENUM_OBJECTS:
-                profile_layout_queries.append("Select LayoutId, ProfileId, Profile.Name, RecordTypeId, RecordType.Name, Layout.Name, TableEnumOrId from ProfileLayout where TableEnumOrId = '" + object_name + "'")
-            else:
-                object_id = object_dataframe[object_dataframe['DeveloperName'] == object_name]['ObjectID'].values[0]
-                profile_layout_queries.append(f"Select LayoutId, ProfileId, Profile.Name, RecordTypeId, RecordType.Name, Layout.Name, TableEnumOrId from ProfileLayout where TableEnumOrId = '{object_id}'")
-        
-        
-        async_tooling_query_all = async_wrap(self.tooling_query_all)
-        
-        
-        await_results = await asyncio.gather(*[async_tooling_query_all(query) for query in profile_layout_queries])
-        
-        await_result_dataframe = [transform_sf_result_set_rec(result) for result in await_results if len(result) > 0]
-        
-        account_page_layouts_bulk = pd.concat(await_result_dataframe)
-
-        account_page_layouts_bulk['ProfileName'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.Profile']['Name'] if row['ProfileLayout.Profile'] else "", axis=1)
-        account_page_layouts_bulk['RecordTypeName'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.RecordType']['Name'] if row['ProfileLayout.RecordType'] else "", axis=1)
-        account_page_layouts_bulk['PageLayout'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.Layout']['Name'] if row['ProfileLayout.Layout'] else "", axis=1)
-        account_page_layouts_bulk.drop(['ProfileLayout.Profile','ProfileLayout.RecordType','ProfileLayout.Layout'], axis=1, inplace=True)
-
-        object_dataframe['ObjectID'] = object_dataframe.apply(lambda row: row['attributes']['url'].split('/')[-1] if row['attributes']['url'] else "", axis=1)
-
-        account_page_layouts_bulk = account_page_layouts_bulk.merge(object_dataframe, left_on='ProfileLayout.TableEnumOrId', right_on='ObjectID', how='left').copy()
-        account_page_layouts_bulk['DeveloperName'] = account_page_layouts_bulk.apply(lambda row: row['DeveloperName'] if pd.notnull(row['DeveloperName']) else row['ProfileLayout.TableEnumOrId'], axis=1)
-        account_page_layouts_bulk.drop(['attributes'], axis=1, inplace=True)
-        
-        # Fill in the RecordTypeName colum with the Master Record Type Name
-        account_page_layouts_bulk['RecordTypeName'] = account_page_layouts_bulk['RecordTypeName'].apply(lambda row: row if row else 'Master')
-        # Filter out Deprecated Profiles
-        account_page_layouts_bulk = account_page_layouts_bulk[(~account_page_layouts_bulk['ProfileName'].isnull()) & (account_page_layouts_bulk['ProfileName'] != '') & (account_page_layouts_bulk['PageLayout'] != 'Veeva Vpro Unit Testing Layout')].copy()
-        
-        if self.instance.__contains__("my.salesforce.com"):
-            sf_meta_instance = self.instance.replace(".my.salesforce.com","")
-        else:
-            sf_meta_instance = ".".join(self.instance.split(".")[:1])
-        
-        account_page_layouts_bulk['Edit Link'] = account_page_layouts_bulk.apply(lambda row: "https://" + sf_meta_instance + ".lightning.force.com/lightning/setup/ObjectManager/" + (row['DeveloperName'] if str(row['ObjectID']) == 'nan' else row['ObjectID']) + "/PageLayouts/" + row['ProfileLayout.LayoutId'] + "/view", axis=1)
-        
-        if return_pivot_table:
-            return account_page_layouts_bulk.pivot(index='ProfileName', columns=['DeveloperName','RecordTypeName'], values='PageLayout')
-        else:
-            return account_page_layouts_bulk
-
-    async def field_permission_user_check(self, objects: list[str], permissions: list[str], users=None) -> pd.DataFrame:
-        # Similar to the field_permission_check function, but this one will return a list of users that have the specified permission on the specified object
-        
-        # this is to avoid having a mutable default argument
-        users = [] if users is None else users
-        
-        object_query = "','".join(objects)
-        permission_query = ' OR '.join([f"({permission} = true)" for permission in permissions])
-
-        relevant_ps_and_profiles = transform_sf_result_set_rec(self.sf.query_all(f"""
-                                                SELECT ParentId,
-                                                        Field,
-                                                        PermissionsEdit,
-                                                        PermissionsRead
-                                                FROM FieldPermissions
-                                                WHERE SObjectType IN ('{object_query}') AND
-                                                ({permission_query})
-                                                """)['records'])
-
-        relevant_ps_and_profiles['Object API Name'] = relevant_ps_and_profiles['FieldPermissions.Field'].apply(lambda row: row.split('.')[0])
-        relevant_ps_and_profiles['Field API Name'] = relevant_ps_and_profiles['FieldPermissions.Field'].apply(lambda row: row.split('.')[1])
-        relevant_ps_and_profiles.drop(columns=['FieldPermissions.Field'], inplace=True)
-
-        user_query = (" AND Assignee.UserName IN ('" + "','".join(users) + "')") if len(users) > 0 else ""
-
-        relevant_ps_and_profiles_list = "','".join(relevant_ps_and_profiles['FieldPermissions.ParentId'].unique().tolist())
-
-        data = transform_sf_result_set_rec(self.sf.query_all(f"""SELECT Assignee.Id, Assignee.Name,Assignee.IsActive, 
-                                                                Assignee.UserName, PermissionSet.Id, 
-                                                                PermissionSet.isOwnedByProfile, PermissionSet.Profile.Name, PermissionSet.Label
-                                                                FROM PermissionSetAssignment
-                                                                WHERE PermissionSetId
-                                                                IN ('{relevant_ps_and_profiles_list}')
-                                                                {user_query} AND Assignee.IsActive = TRUE""")['records'])
-        
-        if len(data) == 0:
-            return pd.DataFrame(columns=['UserName', 'Profile', 'Field API Name', 'Object API Name','Permission', 'Permission Set'])
-        
-        # Retrieve Profile FLS data
-        profiles = data[data['PermissionSet.IsOwnedByProfile']]['Profile.Name'].unique().tolist()
-        profiles = ['Admin' if x == 'System Administrator' else x for x in profiles]
-
-
-        async_metadata_read = async_wrap(self.metadata_read)
-        profile_metadata_tasks = {}
-        profile_metadata_dict = {}
-
-        for profile in profiles:
-                profile_metadata_tasks[profile] = asyncio.create_task(async_metadata_read('Profile', profile))
-
-
-        task_result_list = await asyncio.gather(*profile_metadata_tasks.values())
-
-
-        for profile in profiles:
-                profile_metadata_dict["System Administrator" if profile == 'Admin' else profile] = pd.DataFrame(task_result_list[profiles.index(profile)]['fieldPermissions'][0])
-    
-        data = data.merge(relevant_ps_and_profiles, left_on='PermissionSet.Id', right_on='FieldPermissions.ParentId', how='left').copy()
-        if (len(data) > 0):
-                
-                profile_violations = data[data['PermissionSet.IsOwnedByProfile']== True][['User.Username', 'Profile.Name']].drop_duplicates().copy()
-                # profile_violations = data[data['PermissionSet.IsOwnedByProfile']== True][['User.Username', 'Profile.Name','Field API Name']]
-                profile_metadata_pd = pd.concat(profile_metadata_dict.values(), keys=profile_metadata_dict.keys(), names=['Profile', 'Index']).reset_index(level=1, drop=True).reset_index()
-                profile_metadata_pd.rename(columns={'Profile': 'Profile.Name'}, inplace=True)
-                profile_metadata_pd['Field API Name'] = profile_metadata_pd['field'].str.split('.').str[1]
-                profile_metadata_pd['Object API Name'] = profile_metadata_pd['field'].str.split('.').str[0]
-                profile_metadata_pd = profile_metadata_pd[profile_metadata_pd['Object API Name'].isin(objects)].copy()
-                profile_metadata_pd.drop(columns=['field'], inplace=True)
-
-                # if permission == 'PermissionsEdit':
-                #         profile_metadata_pd = profile_metadata_pd[profile_metadata_pd['editable'] == True].copy()
-                #         profile_metadata_pd.drop(columns=['editable', 'readable'], inplace=True)
-                # elif permission == 'PermissionsRead':
-                #         profile_metadata_pd = profile_metadata_pd[profile_metadata_pd['readable'] == True].copy()
-                #         profile_metadata_pd.drop(columns=['editable', 'readable'], inplace=True)
-                
-                profile_violations = profile_violations.merge(profile_metadata_pd, on='Profile.Name', how='left').copy()
-                profile_editable = profile_violations[profile_violations['editable'] == True].drop(columns=['editable','readable']).copy()
-                profile_editable['Permission'] = 'PermissionsEdit'
-                profile_readable = profile_violations[profile_violations['readable'] == True].drop(columns=['editable','readable']).copy()
-                profile_readable['Permission'] = 'PermissionsRead'
-
-                profile_fls_final = pd.concat([profile_editable, profile_readable])
-                profile_fls_final.columns = ['UserName','Profile','Field API Name','Object API Name','Permission']
-                
-                permission_set_violations = data[data['PermissionSet.IsOwnedByProfile']== False][['User.Username', 'PermissionSet.Label', 'Object API Name', 'FieldPermissions.PermissionsEdit','FieldPermissions.PermissionsRead','Field API Name']]
-                
-                ps_editable = permission_set_violations[permission_set_violations['FieldPermissions.PermissionsEdit'] == True].drop(columns=['FieldPermissions.PermissionsEdit','FieldPermissions.PermissionsRead']).copy()
-                ps_editable['Permission'] = 'PermissionsEdit'
-                ps_readable = permission_set_violations[permission_set_violations['FieldPermissions.PermissionsRead'] == True].drop(columns=['FieldPermissions.PermissionsEdit','FieldPermissions.PermissionsRead']).copy()
-                ps_readable['Permission'] = 'PermissionsRead'
-                
-                ps_fls_final = pd.concat([ps_editable, ps_readable])
-                ps_fls_final.columns = ['UserName','Permission Set','Object API Name','Field API Name', 'Permission']
-                
-                return pd.merge(profile_fls_final, ps_fls_final, on=['UserName','Object API Name', 'Field API Name','Permission'], how='outer')
-        else:
-                return pd.DataFrame(columns=['UserName', 'Profile', 'Field API Name', 'Object API Name','Permission', 'Permission Set'])
-
-    async def retrieve_user_profile_metadata(self, username: str):
-        profile_metadata = pd.DataFrame(zeep.helpers.serialize_object(self.metadata_list("Profile")))
-        profile_metadata = profile_metadata[['id', 'fullName']].copy()
-        profile_metadata
-        user_profile_id = transform_sf_result_set_rec(self.sf.query_all(f"Select Id, ProfileId FROM User WHERE Username = '{username}'")['records'])
-        if len(profile_metadata[profile_metadata['id'] == user_profile_id['User.ProfileId'].values[0]]['fullName']) == 0:
-            raise Exception("User does not have a retrievable / valid profile")
-        else:
-            user_profile = profile_metadata[profile_metadata['id'] == user_profile_id['User.ProfileId'].values[0]]['fullName'].values[0]
-
-        async_profile_read = async_wrap(self.metadata_read)
-        
-        user_profile_metadata = await async_profile_read('Profile', user_profile)
-
-        return user_profile_metadata
-
-    async def retrieve_user_profile_record_type_details(self, username: str, objects: list[str]):
-        
-        profile_metadata = pd.DataFrame(zeep.helpers.serialize_object(self.metadata_list("Profile")))
-        profile_metadata = profile_metadata[['id', 'fullName']].copy()
-        profile_metadata
-        user_profile_id = transform_sf_result_set_rec(self.sf.query_all(f"Select Id, ProfileId FROM User WHERE Username = '{username}'")['records'])
-        if len(profile_metadata[profile_metadata['id'] == user_profile_id['User.ProfileId'].values[0]]['fullName']) == 0:
-            raise Exception("User does not have a retrievable / valid profile")
-        else:
-            user_profile = profile_metadata[profile_metadata['id'] == user_profile_id['User.ProfileId'].values[0]]['fullName'].values[0]
-
-        async_profile_read = async_wrap(self.metadata_read)
-        
-        user_profile_metadata = async_profile_read('Profile', user_profile)
-        
-        results = {}
-        
-        async_object_describe = async_wrap(self.object_describe)
-        
-        tasks = {}
-        
-        for object in objects:
-            tasks[object] = async_object_describe(object)
-        tasks['get_profile_data'] = user_profile_metadata
-        
-        task_result_list = await asyncio.gather(*tasks.values())
-        
-        task_result_dict = {}
-        
-        for object in objects:
-            task_result_dict[object] = task_result_list[objects.index(object)]
-            
-        task_result_dict['get_profile_data'] = task_result_list[-1]
-        
-        user_rt_visibilities = pd.DataFrame(task_result_dict['get_profile_data']['recordTypeVisibilities'][0])
-        user_rt_visibilities['Object'] = user_rt_visibilities['recordType'].apply(lambda x: x.split('.')[0])
-        user_rt_visibilities['RecordType'] = user_rt_visibilities['recordType'].apply(lambda x: x.split('.')[1])
-        
-        for object in objects:
-            if object.lower() == 'account':
-                object_describe = task_result_dict[object]['recordTypeInfos'].T
-                object_record_types = object_describe[object_describe['active'] == True].reset_index()[['name','defaultRecordTypeMapping','developerName','master','recordTypeId']].copy()
-                user_object_rt_visibilities = user_rt_visibilities[(user_rt_visibilities['Object'] == object) | (user_rt_visibilities['Object'] == 'PersonAccount')][['default','personAccountDefault','Object','RecordType','visible']].copy()
-                
-            else:
-                object_describe = task_result_dict[object]['recordTypeInfos'].T
-                object_record_types = object_describe[object_describe['active'] == True].reset_index()[['name','defaultRecordTypeMapping','developerName','master','recordTypeId']].copy()
-                user_object_rt_visibilities = user_rt_visibilities[user_rt_visibilities['Object'] == object][['default','personAccountDefault','Object','RecordType','visible']].copy()
-
-            object_rt_visibility_with_master = pd.merge(user_object_rt_visibilities, object_record_types, left_on='RecordType', right_on='developerName', how='outer')
-            object_rt_visibility_with_master['visible'].fillna(False, inplace=True)
-            if not object_rt_visibility_with_master['visible'].any():
-                object_rt_visibility_with_master.loc[object_rt_visibility_with_master['developerName'] == 'Master', 'visible'] = True
-            if not object_rt_visibility_with_master['default'].any():
-                object_rt_visibility_with_master.loc[object_rt_visibility_with_master['developerName'] == 'Master', 'default'] = True
-                
-            visible_object_rt = object_rt_visibility_with_master[object_rt_visibility_with_master['visible'] == True].drop(['defaultRecordTypeMapping'], axis=1)
-            results[object] = visible_object_rt
-        
-        return results
-    
-    
-    async def permissionable_fields_bulk_check(self, object_list):
-        permissionable_fields = {}
-        nonpermissionable_fields = {}
-        async_permissionable_fields =  async_wrap(self.object_describe)
-        async_metadata_read = async_wrap(self.metadata_read)
-        
-        
-        task_dict = {}
-        task_result_dict = {}
-        
-        for object_name in object_list:
-            task_dict[object_name] = async_permissionable_fields(object_name)
-            task_dict[object_name + '_metadata'] = async_metadata_read('CustomObject', object_name)
-            
-        task_results = await asyncio.gather(*task_dict.values())
-        
-        for object_name, task_result in zip(task_dict.keys(), task_results):
-            task_result_dict[object_name] = task_result
-        
-        
-        for object in object_list:
-            permissionable_fields[object] = pd.DataFrame(task_result_dict[object + "_metadata"]['fields'][0])['fullName'].to_list()
-            
-            nonpermissionable_fields[object] = task_result_dict[object]['fields'].T[task_result_dict[object]['fields'].T['permissionable'] == False].index.tolist()
-        return permissionable_fields, nonpermissionable_fields, task_result_dict
-    
-    async def get_layout_metadata(self, layout_name):
-        # Layout Name is the Object API Name + Page Layout Name of the layout, for example:
-        # Account-Hospital Department
-        
-        async_metadata_read = async_wrap(self.metadata_read)
-        
-        layout_metadata = await async_metadata_read('Layout', layout_name)
-        
-        def parse_layoutSections(layout_metadata):
-            layoutSections = pd.DataFrame(layout_metadata)
-            layoutSections['layoutColumns'] = layoutSections['layoutColumns'].apply(lambda row: list(filter(lambda item: item is not None, row)))
-            layoutSections = layoutSections.explode('layoutColumns').reset_index(drop=True)
-            layoutSections['layoutColumns'] = layoutSections['layoutColumns'].apply(lambda row: "" if str(row) == 'nan' else row['layoutItems'])
-            layoutSections = layoutSections.explode('layoutColumns').reset_index(drop=True)
-            layoutSections = pd.concat([layoutSections, layoutSections['layoutColumns'].apply(pd.Series, dtype=str).add_prefix('layoutColumns.')], axis=1)
-            if 'layoutColumns.0' in layoutSections.columns:
-                # drop 'layoutColumns.0' column if it exists
-                layoutSections.drop(['layoutColumns.0'], axis=1, inplace=True)
-            
-            if 'layoutColumns' in layoutSections.columns:
-                layoutSections.drop(['layoutColumns'], axis=1, inplace=True)
-
-            layoutSections.fillna("", inplace=True)
-            layoutSections.drop_duplicates(inplace=True)
-            return layoutSections
-
-        def parse_platformActionList(platformActionList_metadata):
-            platformActionList = pd.DataFrame(platformActionList_metadata)
-            platformActionList = pd.concat([platformActionList, platformActionList['platformActionListItems'].apply(pd.Series, dtype=str).add_prefix('platformActionListItems.')], axis=1).drop(['platformActionListItems'], axis=1)
-            return platformActionList
-
-
-        def parse_quickActionList(quickActionList_metadata):
-            quickActionList = pd.DataFrame(quickActionList_metadata)
-            quickActionList = pd.concat([quickActionList, quickActionList['quickActionListItems'].apply(pd.Series, dtype=str).add_prefix('quickActionListItems.')], axis=1).drop(['quickActionListItems'], axis=1)
-            return quickActionList
-
-        parsed_layout_metadata = {}
-        parsed_layout_metadata['customButtonsList'] = layout_metadata['customButtons'][0]
-        parsed_layout_metadata['excludeButtonsList'] = layout_metadata['excludeButtons'][0]
-        # Adding required fields from the main page layout gives you the final list of mini layout items
-        parsed_layout_metadata['miniLayoutDict'] = dict(layout_metadata['miniLayout'][0]) if layout_metadata['miniLayout'][0] != None else {'fields': [],'relatedLists': []}
-        parsed_layout_metadata['layoutSectionsDataFrame'] = parse_layoutSections(layout_metadata['layoutSections'][0]) if layout_metadata['layoutSections'][0] != None else pd.DataFrame()
-        parsed_layout_metadata['platformActionListDataFrame'] = parse_platformActionList(layout_metadata['platformActionList'][0]) if layout_metadata['platformActionList'][0] != None else pd.DataFrame()
-        parsed_layout_metadata['quickActionListDataFrame'] = parse_quickActionList(layout_metadata['quickActionList'][0]) if layout_metadata['quickActionList'][0] != None else pd.DataFrame()
-        parsed_layout_metadata['relatedListDataFrame'] = pd.DataFrame(layout_metadata['relatedLists'][0]) if layout_metadata['relatedLists'][0] != None else pd.DataFrame()
-        return parsed_layout_metadata
-
-    async def get_all_reports_metadata(self):
-        """
-        Asynchronously fetches metadata for all reports from Salesforce.
-
-        This function retrieves the metadata for all reports stored in Salesforce.
-        It first gathers a list of all report folders and then fetches metadata for 
-        each report in these folders. The function uses async operations to improve 
-        performance by fetching metadata for multiple reports concurrently. The 
-        results are then concatenated into a single DataFrame for easier processing.
-
-        Returns:
-            pandas.DataFrame: A DataFrame containing the metadata for all reports. 
-                              The DataFrame is reset indexed for convenience.
-        
-        Raises:
-            Exception: Any exception raised during metadata retrieval will result 
-                       in an empty list for `report_folder_full_names`.
-        """
-        
-        try:
-            report_folder_full_names = [folder['fullName'] for folder in  self.sf.mdapi.list_metadata(self.sf.mdapi.ListMetadataQuery(type='ReportFolder'))]
-        except:
-            report_folder_full_names = []
-
-
-        async_metadata_list = async_wrap(self.sf.mdapi.list_metadata)
-
-        task_list = []
-        for report_folder in report_folder_full_names:
-            list_metadata_query = self.sf.mdapi.ListMetadataQuery(type="Report", folder=report_folder)
-            task_list.append(async_metadata_list(list_metadata_query))
-
-        report_metadata_list = await asyncio.gather(*task_list)
-
-        report_metadata_list = [item for sublist in report_metadata_list for item in sublist]
-
-        async_metadata_read = async_wrap(self.metadata_read)
-
-        task_list = []
-        for report_details in report_metadata_list:
-            task_list.append(async_metadata_read('Report', report_details['fullName']))
-
-        report_metadata_result_list = await asyncio.gather(*task_list)
-
-        all_report_metadata = pd.concat(report_metadata_result_list).reset_index(drop=True)
-        
-        return all_report_metadata
-
-
-    ### ----------------------------------------------------------------------------------------------------
-    ### Synchronous Metadata Functions
-    ### ----------------------------------------------------------------------------------------------------
-
-    def object_describe(self, sobject_api_name: str, export_excel: bool=False):
-        """
-
-        """
-        sfSchema = getattr(self.sf, sobject_api_name).describe()
-        boolMetadata = {}
-        nonetypeMetadata = {}
-        strMetadata = {}
-        orderedDictMetadata = pd.Series(dtype='object')
-        childRelationshipsPD = pd.DataFrame()
-        recordTypeInfosPD = pd.DataFrame()
-        fieldsPD = pd.DataFrame()
-        supportedScopesPD = pd.DataFrame()
-        namedLayoutInfosPD = pd.DataFrame()
-        actionOverridesPD = pd.DataFrame()
-
-        for metadata in sfSchema:
-            ## Processes all metadata that would return a boolean datatype
-            if type(sfSchema[metadata]) is bool:
-                boolMetadata[metadata] = sfSchema[metadata]
-
-            ## Processes all metadata that would return a NoneType datatype
-            elif type(sfSchema[metadata]) == type(None):
-                nonetypeMetadata[metadata] = sfSchema[metadata]
-
-            ## Processes all metadata that would return a string datatype
-            elif type(sfSchema[metadata]) is str:
-                strMetadata[metadata] = sfSchema[metadata]
-            ## Processes all metadata that would return an OrderedDict data type
-            elif type(sfSchema[metadata]) is OrderedDict and len(sfSchema[metadata]) != 0:
-                orderedDictMetadata = pd.concat([orderedDictMetadata,pd.Series(sfSchema['urls'])])
-            elif type(sfSchema[metadata]) is OrderedDict and len(sfSchema[metadata]) == 0:
-                nonetypeMetadata[metadata] = "None"
-
-            ## Processes all metadata that would return a list data type
-            elif type(sfSchema[metadata]) is list and len(sfSchema[metadata]) != 0:
-                if metadata == 'childRelationships':
-                    childRelationshipsPD = pd.DataFrame(sfSchema['childRelationships'], index = pd.DataFrame(sfSchema['childRelationships'])['field'])
-                    childRelationshipsPD = childRelationshipsPD.drop('field', axis=1).T
-                if metadata == 'recordTypeInfos':
-                    recordTypeInfosPD = pd.DataFrame(sfSchema['recordTypeInfos'], index = pd.DataFrame(sfSchema['recordTypeInfos'])['name'])
-                    recordTypeInfosPD = recordTypeInfosPD.drop('name', axis = 1).T  
-                if metadata == 'fields':
-                    fieldsPD = pd.DataFrame(sfSchema['fields'], index = pd.DataFrame(sfSchema['fields'])['name'])
-                    fieldsPD = fieldsPD.drop('name', axis = 1).T
-                if metadata == 'supportedScopes':
-                    supportedScopesPD = pd.DataFrame(sfSchema['supportedScopes'], index = pd.DataFrame(sfSchema['supportedScopes'])['name'])
-                    supportedScopesPD = supportedScopesPD.drop('name', axis = 1).T
-                if metadata == 'actionOverrides':
-                    actionOverridesPD = pd.DataFrame(sfSchema['actionOverrides'], index = pd.DataFrame(sfSchema['actionOverrides'])['name'])
-                    actionOverridesPD = actionOverridesPD.drop('name', axis = 1).T
-                if metadata == 'namedLayoutInfos':
-                    namedLayoutInfosPD = pd.DataFrame(sfSchema['namedLayoutInfos'], index = pd.DataFrame(sfSchema['namedLayoutInfos'])['name'])
-                    namedLayoutInfosPD = namedLayoutInfosPD.drop('name', axis = 1).T
-            ## Parses all empty list metadata
-            elif type(sfSchema[metadata]) is list and len(sfSchema[metadata]) == 0:
-                nonetypeMetadata[metadata] = "None"
-            else:
-                nonetypeMetadata[metadata] = "Unrecognized metadata type: " + metadata
-
-        output = {'metadata': pd.concat([pd.Series(nonetypeMetadata),
-                    pd.Series(boolMetadata),
-                    pd.Series(strMetadata),
-                    orderedDictMetadata]),
-                    'childRelationships': childRelationshipsPD if len(childRelationshipsPD)!=0 else None,
-                    'recordTypeInfos': recordTypeInfosPD if len(recordTypeInfosPD)!=0 else None,
-                    'fields': fieldsPD if len(fieldsPD)!=0 else None,
-                    'supportedScopes': supportedScopesPD if len(supportedScopesPD)!=0 else None, 
-                    'namedLayoutInfos': namedLayoutInfosPD if len(namedLayoutInfosPD)!=0 else None,
-                    'actionOverrides': actionOverridesPD if len(actionOverridesPD)!=0 else None}
-        if export_excel:
-            with pd.ExcelWriter(sobject_api_name + ' describe output.xlsx') as writer:  
-                for key in output.keys():
-                    try:
-                        pd.DataFrame(output[key]).to_excel(writer, sheet_name=key)
-                    except:
-                        continue
-
-        return output
-
-    def field_describe(self, objects: List = ['Account','Address_vod__c','Child_Account_vod__c'], 
-    attributes: List = ['name','type','length']) -> pd.DataFrame:
-        """
-        Returns a dataframe of the field metadata for the specified objects and attributes.
-
-        Parameters
-        ----------
-        objects : List, optional
-            A list of objects to get field metadata for. The default is ['Account','Address_vod__c','Child_Account_vod__c'].
-        attributes : List, optional
-            A list of attributes to get field metadata for. The default is ['name','type','length'].
-            For a full list of attributes, see 
-            https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_describesobjects_describesobjectresult.htm
-            A list of attributes can also be found by using the object_describe() method's field attribute.
-
-        Returns
-        -------
-        pd.DataFrame
-            A dataframe of the field metadata for the specified objects and attributes.
-        
-        """
-        outputList = []
-        columnNames = []
-        for sObjectAPIName in objects:
-            for attribute in attributes:
-                outputList.append([field[attribute] for field in getattr(self.sf, sObjectAPIName).describe()['fields']])
-                if attribute == "name":
-                    columnNames.append(sObjectAPIName)
-                else:
-                    columnNames.append(attribute.title())
-        field_describe = pd.DataFrame(outputList).transpose()
-        field_describe.columns = columnNames
-        return field_describe
-
-    def set_user_password(self, user_id, new_password):
-        result = {}
-        try:
-            result = self.sf_api_call(f'/services/data/{self.api_version}/sobjects/User/{user_id}/password', method='POST', data={'NewPassword': new_password})
-        except Exception as e:
-            message_list = str(e).split(" : ")[1].strip().removeprefix("b'[").removesuffix("]'")
-            result = ast.literal_eval(message_list)
-            result['user_id'] = user_id
-        
-        if len(result) == 0:
-            result = {'user_id': user_id,'message': 'success',  'errorCode': None}
-        return result
-        
-
-    def picklist_dataframe_stacked(self,objects: List =['Account','Address_vod__c','Child_Account_vod__c']) -> pd.DataFrame:
-        """
-        TODO:
-        
-        Description of what it does
-        
-        Description of arguments and data types
-        
-        Description of return values and data types
-        
-        Description of Errors raised
-        
-        Extra Notes and Examples of Usage
-        """
-        output_df = pd.DataFrame()
-        for object in objects:
-            objectDescribe = getattr(self.sf, object).describe()
-            processing_df = pd.DataFrame(pd.DataFrame([pd.Series(data = [picklist['value'] for picklist in field['picklistValues']], 
-                                                                   name = object + "." + field["name"]) for field in objectDescribe['fields'] if field['type'] == 'picklist']).stack())
-            processing_df.columns = ['Picklist API Value']
-            processing_df['CRM Object and Field API'] = processing_df.index.get_level_values(0)
-            processing_df[['CRM Object API','CRM Field API']] = processing_df['CRM Object and Field API'].str.split(".", expand = True)
-            processing_df.reset_index(drop=True, inplace=True)
-            output_df = pd.concat([output_df,processing_df])
-        return output_df
-
-    def picklist_dataframe(self,objects = ['Account','Address_vod__c','Child_Account_vod__c']) -> List:
-        """
-        TODO:
-        
-        Description of what it does
-        
-        Description of arguments and data types
-        
-        Description of return values and data types
-        
-        Description of Errors raised
-        
-        Extra Notes and Examples of Usage
-        """
-        referenceList = []
-        for object in objects:
-            objectDescribe = getattr(self.sf, object).describe()
-            objectPicklistValues = pd.DataFrame(index=range(0,max(len(field["picklistValues"]) for field in objectDescribe['fields'] if field['type'] == 'picklist')))
-            for x in [pd.Series(data = [picklist['value'] for picklist in field['picklistValues']], name = object + "." + field["name"]) for field in objectDescribe['fields'] if field['type'] == 'picklist']:
-                objectPicklistValues.insert(0, str(x.name), x)
-            referenceList.append(objectPicklistValues)
-        return referenceList
-
-    def record_type_retrieval(self, objectAPIName, fieldAPINames = ["Id","Name",'SobjectType', 'IsActive']):
-        """
-        TODO:
-        
-        Description of what it does
-        
-        Description of arguments and data types
-        
-        Description of return values and data types
-        
-        Description of Errors raised
-        
-        Extra Notes and Examples of Usage
-        """
-        sfRTDF = pd.DataFrame(self.sf.query_all("SELECT "+ ",".join(fieldAPINames) + " from RecordType WHERE SobjectType = '" + objectAPIName + "'")['records'])
-        
-        # If only master RT exists
-        if len(sfRTDF) == 0:
-            master_rt = {
-                "Name": "Master",
-                "DeveloperName": "Master",
-                "IsActive": True,
-            }
-
-            sfRTDF = pd.DataFrame(master_rt, index=[0])
-        else:
-            sfRTDF.drop(columns="attributes", inplace = True)
-        return sfRTDF
-
-    def object_permission_check(self, object, permission):
-        data = transform_sf_result_set_rec(self.sf.query_all(f"""SELECT Assignee.Id, Assignee.Name,Assignee.IsActive, Assignee.UserName, PermissionSet.Id, PermissionSet.isOwnedByProfile, PermissionSet.Profile.Name, PermissionSet.Label
-            FROM PermissionSetAssignment
-            WHERE PermissionSetId
-            IN (SELECT ParentId
-            FROM ObjectPermissions
-            WHERE SObjectType IN ('{object}') AND
-            ({permission} = true)) AND Assignee.IsActive = TRUE""")['records'])
-        
-        profile_violations = data[data['PermissionSet.IsOwnedByProfile']== True][['User.Username', 'Profile.Name']]
-        permission_set_violations = data[data['PermissionSet.IsOwnedByProfile']== False][['User.Username', 'PermissionSet.Label']]
-        result = []
-        for user in profile_violations['User.Username'].unique():
-            result.append({"UserName": user, 
-                            "Object API Name" : object,
-                            "Permission": permission,
-                            "Profile": "; ".join(list(profile_violations[profile_violations['User.Username'] == user]['Profile.Name'].unique())),
-                            "Permission Set": ""
-                        
-                        }
-                        
-                        )
-            
-        for user in permission_set_violations['User.Username'].unique():
-            result.append({"UserName": user, 
-                                                            "Object API Name" : object,
-                                                            "Permission": permission,
-                                                            "Profile": "",
-                                                            "Permission Set": "; ".join(list(permission_set_violations[permission_set_violations['User.Username'] == user]['PermissionSet.Label'].unique()))})
-        return result
-
-    def field_permission_check(self, object) -> dict[str, pd.DataFrame]:
-        fls_results = transform_sf_result_set_rec(self.sf.query_all(f"""
-                                            SELECT Field,
-                                            ParentId,
-                                            PermissionsEdit,
-                                            PermissionsRead,
-                                            SobjectType FROM FieldPermissions
-                                            WHERE SobjectType in ('{object}')
-                                            """)['records'])
-
-        permissionSetProfiles = transform_sf_result_set_rec(self.sf.query_all("""
-                                                    SELECT Id,Description,IsOwnedByProfile,Name,ProfileId, 
-                                                    Profile.Name, Profile.Description,Type FROM PermissionSet
-                                                    """)['records'])
-
-        profiles = permissionSetProfiles[permissionSetProfiles['PermissionSet.IsOwnedByProfile'] == True][['PermissionSet.ProfileId','PermissionSet.Id','Profile.Name','Profile.Description']].copy()
-        permissionSets = permissionSetProfiles[permissionSetProfiles['PermissionSet.IsOwnedByProfile'] == False][['PermissionSet.Id','PermissionSet.Name','PermissionSet.Description']].copy()
-
-        permissionSetPermissions = pd.merge(fls_results, permissionSets, left_on='FieldPermissions.ParentId', right_on='PermissionSet.Id', how='inner').drop(columns=['PermissionSet.Id'], axis=1)
-        permissionSetPermissions.columns = ['Field API Name', 'Permission Set Id', 'FLS Edit', 'FLS Read', 'Object API Name', 'Permission Set Name', 'Permission Set Description']
-        permissionSetPermissions = permissionSetPermissions[['Permission Set Id', 'Permission Set Name', 'Permission Set Description', 'Object API Name', 'Field API Name', 'FLS Edit', 'FLS Read']]
-        permissionSetPermissions['Field API Name'] = permissionSetPermissions['Field API Name'].apply(lambda x: x.split('.')[-1])
-
-
-        profilePermissions = pd.merge(fls_results, profiles, left_on='FieldPermissions.ParentId', right_on='PermissionSet.Id', how='inner').drop(columns=['PermissionSet.Id','FieldPermissions.ParentId'], axis=1)
-        profilePermissions.columns = ['Field API Name', 'FLS Edit', 'FLS Read', 'Object API Name','Profile Id',  'Profile Name', 'Profile Description']
-        profilePermissions = profilePermissions[['Profile Id', 'Profile Name', 'Profile Description', 'Object API Name', 'Field API Name', 'FLS Edit', 'FLS Read']]
-        profilePermissions['Field API Name'] = profilePermissions['Field API Name'].apply(lambda x: x.split('.')[-1])
-        
-        return {'permissionSetPermissions': permissionSetPermissions, 'profilePermissions': profilePermissions}
-
-
-    # Retrieves the Page Layout by Profile by Record Type data for all objects in the org
-    def retrieve_profile_layout_record_type_matrix_all(self, return_pivot_table = False):
-        account_page_layouts_bulk = transform_sf_result_set_rec(self.tooling_query_all("""select LayoutId, 
-                                                                                    ProfileId, Profile.Name, 
-                                                                                    RecordTypeId, RecordType.Name, 
-                                                                                    Layout.Name, TableEnumOrId from 
-                                                                                    ProfileLayout"""))
-
-        account_page_layouts_bulk['ProfileName'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.Profile']['Name'] if row['ProfileLayout.Profile'] else "", axis=1)
-        account_page_layouts_bulk['RecordTypeName'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.RecordType']['Name'] if row['ProfileLayout.RecordType'] else "", axis=1)
-        account_page_layouts_bulk['PageLayout'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.Layout']['Name'] if row['ProfileLayout.Layout'] else "", axis=1)
-        account_page_layouts_bulk.drop(['ProfileLayout.Profile','ProfileLayout.RecordType','ProfileLayout.Layout'], axis=1, inplace=True)
-
-
-        object_dataframe = pd.DataFrame(self.tooling_query_all("Select DeveloperName from CustomObject"))
-        object_dataframe['ObjectID'] = object_dataframe.apply(lambda row: row['attributes']['url'].split('/')[-1] if row['attributes']['url'] else "", axis=1)
-
-
-        account_page_layouts_bulk = account_page_layouts_bulk.merge(object_dataframe, left_on='ProfileLayout.TableEnumOrId', right_on='ObjectID', how='left').copy()
-        account_page_layouts_bulk['DeveloperName'] = account_page_layouts_bulk.apply(lambda row: row['DeveloperName'] if pd.notnull(row['DeveloperName']) else row['ProfileLayout.TableEnumOrId'], axis=1)
-        account_page_layouts_bulk.drop(['ObjectID','attributes'], axis=1, inplace=True)
-            
-        # Fill in the RecordTypeName colum with the Master Record Type Name
-        account_page_layouts_bulk['RecordTypeName'] = account_page_layouts_bulk['RecordTypeName'].apply(lambda row: row if row else 'Master')
-        # Filter out Deprecated Profiles
-        account_page_layouts_bulk = account_page_layouts_bulk[(~account_page_layouts_bulk['ProfileName'].isnull()) & (account_page_layouts_bulk['ProfileName'] != '') & (account_page_layouts_bulk['PageLayout'] != 'Veeva Vpro Unit Testing Layout')]
-        
-        if return_pivot_table:
-            return account_page_layouts_bulk.pivot(index='ProfileName', columns=['DeveloperName','RecordTypeName'], values='PageLayout')
-        else:
-            return account_page_layouts_bulk
-    
-    #######################################################################################
-    # Veeva CRM Server API Functions
-    #######################################################################################
-
-    def load_veeva_common(self):
-        self.veeva_common = self.query("Select * From Veeva_Common_vod__c").to_dict()
-    
-    def load_org_info(self):
-        self.org_info = self.query("Select * From Organization").to_dict()
-        
-    def get_network_admin_sf_user_info(self):
-        
-        if self.veeva_common is None:
-            self.load_veeva_common()
-        
-        if self.org_info is None:
-            self.load_org_info()
-            
-        try:
-            response = requests.get(f"{self.veeva_common['Veeva_Server_vod__c'][0]}/{self.veeva_common['Veeva_Version_vod__c'][0]}?VER={self.veeva_common['Veeva_Version_vod__c'][0]}&SSID={self.session_id}&url=https://{self.instance}/services/Soap/u/24.0/{self.org_info['Id'][0]}&ses={self.session_id}&oType=networkAdmin&event=getSFCredentials")
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to get network admin credentials"}}
-        
-    def get_network_admin_network_user_info(self):
-        
-        if self.veeva_common is None:
-            self.load_veeva_common()
-        
-        if self.org_info is None:
-            self.load_org_info()
-            
-        try:
-            response = requests.get(f"{self.veeva_common['Veeva_Server_vod__c'][0]}/{self.veeva_common['Veeva_Version_vod__c'][0]}?VER={self.veeva_common['Veeva_Version_vod__c'][0]}&SSID={self.session_id}&url=https://{self.instance}/services/Soap/u/24.0/{self.org_info['Id'][0]}&ses={self.session_id}&oType=networkAdmin&event=getNetworkCredentials")
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to get network admin credentials"}}
-
-    def engage_admin_retrieve_groups(self):
-
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-        
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        veeva_server = self.veeva_common['Veeva_Server_vod__c'][0]
-        veeva_version = self.veeva_common['Veeva_Version_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{veeva_server}/{veeva_version}/api/v1/hcpproxy/groups', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage groups"}}
-        
-    def engage_admin_retrieve_users(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        veeva_server = self.veeva_common['Veeva_Server_vod__c'][0]
-        veeva_version = self.veeva_common['Veeva_Version_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{veeva_server}/{veeva_version}/api/v1/hcpproxy/usersinfo', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage users."}}
-
-    def engage_admin_get_license_info(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        veeva_server = self.veeva_common['Veeva_Server_vod__c'][0]
-        veeva_version = self.veeva_common['Veeva_Version_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{veeva_server}/{veeva_version}/api/v1/remoteMeetings/orgs/{self.sfOrgId}', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage license info."}}
-        
-    def engage_meeting_process_admin_retrieve_history(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/epp-service/refresh/records', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage process admin history."}}
-    
-    def engage_meeting_process_admin_retrieve_veeva_crm_connection_management(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/credentials/SalesForce_EPP?systemId={self.sfOrgId}', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage process admin Veeva CRM connection management."}}
-        
-    def engage_meeting_process_admin_retrieve_veeva_vault_login_credential_management(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/credentials/Vault_EPP', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage process admin Veeva Vault login credential management."}}
-
-    def engage_metadata_sync_admin_retrieve_vault_connection_management(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/credentials/Vault_Engage', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage metadata sync admin Veeva Vault connection management."}}
-
-    def engage_metadata_sync_admin_retrieve_crm_connection_management(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/credentials/SalesForce_Engage?systemId=00D2g0000000ipMEAQ', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage metadata sync admin CRM connection management."}}
-
-    def engage_metadata_sync_admin_retrieve_activity_debug_log(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/debug-log/collection?count=20&orgId=00D2g0000000ipMEAQ', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage metadata sync admin activity debug log."}}
-
-    def engage_metadata_sync_admin_retrieve_metadata_sync(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/mcservice/status/refresh?count=10&recordType=Engage', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Engage metadata sync admin metadata sync."}}
-        
-    def veeva_process_admin_alerts_status_report(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/email-alert/recipients', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve Veeva process admin alerts status report."}}
-
-    def process_scheduler_get_jobs(self):
-        headers = {
-            "Accept": "application/json, text/plain, */*",
-            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
-            "Sfsession": self.session_id,
-        }
-
-        if self.veeva_common is None:
-            self.load_veeva_common()
-
-        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
-        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
-
-
-        try:
-            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/scheduler/jobs', headers=headers)
-            return {'status': response.status_code, 'response': response.json()}
-        except:
-            return {'status': 500, 'response': {"error": "Unable to retrieve process scheduler jobs."}}
-
-
-    ##############################################################################################################
-    # UI Functions
-    # Functions that parses UI HTML responses
-    ##############################################################################################################
-    
-
-    async def ui_retrieve_all_installed_packages_and_components(self):
-        from bs4 import BeautifulSoup
-
-        """
-        Asynchronously retrieve all installed packages and their components in the current Salesforce instance.
-
-        This method carries out the following operations:
-        1. Queries the Salesforce Tooling API to obtain details of all installed subscriber packages.
-        2. For each package, the components are retrieved by querying the Salesforce package page using HTTP requests.
-        3. Organizes the extracted package data in a structured manner, flattening nested dictionaries and creating a Pandas DataFrame.
-        4. Merges the package components data with the main package data, providing a comprehensive view.
-        5. Extracts the Salesforce ID for each component from its corresponding link.
-        6. Finally, the method returns a DataFrame containing the detailed info of all installed packages and their associated components.
-
-        Returns:
-            pd.DataFrame: DataFrame with columns representing package and component details such as package namespace, version, and component IDs.
-
-        Dependencies:
-            - Uses Beautiful Soup (bs4) for HTML parsing.
-            - Uses Pandas for data structuring and manipulation.
-            - Assumes Salesforce session and instance details are handled by the class.
-
-        Internal Methods:
-        - `subscriber_package_to_df(data)`: Converts subscriber package data into a DataFrame.
-        - `get_package_components_by_id(package_id, sf_instance)`: Gets package components based on package ID.
-        - `get_all_packages(subscriber_package_df: pd.DataFrame, sf_instance)`: Asynchronously retrieves all package components for given packages.
-
-        Note: This method also handles specific structure of Salesforce pages and can be sensitive to changes on Salesforce's end.
-        """
-        def subscriber_package_to_df(data):
-            # Flattening the nested dictionaries
-            flattened_data = []
-            for entry in data:
-                flattened_entry = {
-                    'Id': entry.get('Id', None),
-                    'SubscriberPackageId': entry.get('SubscriberPackageId', None),
-                    'SubscriberPackage.NamespacePrefix': entry['SubscriberPackage'].get('NamespacePrefix', None),
-                    'SubscriberPackage.Name': entry['SubscriberPackage'].get('Name', None),
-                    'SubscriberPackageVersion.Id': entry['SubscriberPackageVersion'].get('Id', None),
-                    'SubscriberPackageVersion.Name': entry['SubscriberPackageVersion'].get('Name', None),
-                    'SubscriberPackageVersion.MajorVersion': entry['SubscriberPackageVersion'].get('MajorVersion', None),
-                    'SubscriberPackageVersion.MinorVersion': entry['SubscriberPackageVersion'].get('MinorVersion', None),
-                    'SubscriberPackageVersion.PatchVersion': entry['SubscriberPackageVersion'].get('PatchVersion', None),
-                    'SubscriberPackageVersion.BuildNumber': entry['SubscriberPackageVersion'].get('BuildNumber', None),
-                }
-                flattened_data.append(flattened_entry)
-
-            # Convert to Pandas DataFrame
-            df = pd.DataFrame(flattened_data)
-            return df
-
-
-        def get_package_components_by_id(package_id, sf_instance):
-            url = f"https://{sf_instance.instance}/{package_id}"
-
-            headers = {
-                "Cookie": f"sid={sf_instance.session_id};"
-            }
-
-            payload = {
-                "pkgComp": "show",
-                "isdtp": "p1"
-            }
-
-            response = requests.get(url, headers=headers, params=payload)
-
-
-            html_content = response.text
-
-            soup = BeautifulSoup(html_content, 'html.parser')
-            section_title = "Metadata Components Included in Package"
-            metadata_section = soup.find('h3', text=section_title).find_parent('div', class_='bPageBlock')
-
-            # Extract table headers
-            headers = [header.text for header in metadata_section.select('tr.headerRow th')]
-
-            # Appending "Link" to headers
-            headers.append('Link')
-
-            data = []
-
-            # Extract table rows
-            for row in metadata_section.select('tr.dataRow'):
-                cells = row.select('td, th')
-                row_data = [cell.text.strip() for cell in cells]
-                
-                # Check if the cell contains a link and extract it
-                link = cells[1].find('a')
-                row_data.append(link['href'] if link else None)
-                
-                data.append(row_data)
-
-            df = pd.DataFrame(data, columns=headers)
-
-            return df
-
-        subscriber_packages = subscriber_package_to_df(self.tooling_query_all("""
-                            SELECT Id, SubscriberPackageId, SubscriberPackage.NamespacePrefix,
-                            SubscriberPackage.Name, SubscriberPackageVersion.Id,
-                            SubscriberPackageVersion.Name, SubscriberPackageVersion.MajorVersion,
-                            SubscriberPackageVersion.MinorVersion,
-                            SubscriberPackageVersion.PatchVersion,
-                            SubscriberPackageVersion.BuildNumber
-                            FROM InstalledSubscriberPackage
-                            ORDER BY SubscriberPackageId"""))
-
-
-        async def get_all_packages(subscriber_package_df: pd.DataFrame, sf_instance):
-            package_ids = subscriber_package_df['Id'].tolist()
-            
-            async_get_package_components_by_id = async_wrap(get_package_components_by_id)
-            task_list = [async_get_package_components_by_id(package_id, sf_instance) for package_id in package_ids]
-            
-            result_list = await asyncio.gather(*task_list)
-            
-            result_df = None
-            result_dict = {}
-            for package_id, package_components in zip(package_ids, result_list):
-                if result_df is None:
-                    result_df = package_components
-                    # Add Installed Package Id column
-                    result_df['InstalledPackageId'] = package_id
-                else:
-                    # Add Installed Package Id column
-                    package_components['InstalledPackageId'] = package_id
-                    result_df = pd.concat([result_df, package_components])
-            
-            return result_df
-
-
-        all_org_subscriber_packages = await get_all_packages(subscriber_packages, self)
-
-        all_org_subscriber_packages_extended = all_org_subscriber_packages.merge(subscriber_packages[['Id','SubscriberPackage.NamespacePrefix','SubscriberPackage.Name','SubscriberPackageVersion.Name']], 
-                                                left_on='InstalledPackageId', 
-                                                right_on='Id', 
-                                                how='left')
-
-        # gets the 15 charactesr after %27%2F in the link column, this is basically the SFDC ID of the component
-        pattern = r'%27%2F(\w{15})'
-
-        all_org_subscriber_packages_extended['Component ID'] = all_org_subscriber_packages_extended['Link'].str.extract(pattern)
-
-        # Drop ID and Link column
-        all_org_subscriber_packages_extended.drop(columns=['Id','Link'], inplace=True)
-
-        return all_org_subscriber_packages_extended
-
-
-
-    ##############################################################################################################
-    # WSDL Derived Functions
-    ##############################################################################################################
-
-    @serialze_zeep
-    def metadata_read(self, metadata_type: str, fullName: str):
-        return getattr(self.sf.mdapi, metadata_type).read(fullName)
-
-    def metadata_delete(self, metadata_type: str, fullName: str):
-        return getattr(self.sf.mdapi, metadata_type).delete(fullName)
-
-    def metadata_update(self, metadata_type: str, parsed_metadata: dict):
-        mdapi_object = getattr(self.sf.mdapi, metadata_type)()
-        for key in parsed_metadata:
-            setattr(mdapi_object, key, parsed_metadata[key])
-        getattr(self.sf.mdapi, metadata_type).update(mdapi_object)
-        return mdapi_object
-
-    def metadata_create(self, metadata_type: str, parsed_metadata: dict):
-        mdapi_object = getattr(self.sf.mdapi, metadata_type)()
-        for key in parsed_metadata:
-            setattr(mdapi_object, key, parsed_metadata[key])
-        getattr(self.sf.mdapi, metadata_type).create(mdapi_object)
-        return mdapi_object
-
-    def metadata_list(self, metadata_type: str = '', metadata_type_list: list[str] = []) -> list:
-        if len(metadata_type_list) == 0 and metadata_type != '':
-            query = self.sf.mdapi.ListMetadataQuery(type=metadata_type)
-        elif len(metadata_type_list) > 3:
-            raise Exception("You can only query up to 3 metadata types at a time")
-        
-        elif len(metadata_type_list) > 0:
-            query = []
-            for metadata_type in metadata_type_list:
-                query.append(self.sf.mdapi.ListMetadataQuery(type=metadata_type))
-        else:
-            raise Exception("Please populate either metadata_type or metadata_type_list, but not both.")
-        
-        query_response = self.sf.mdapi.list_metadata(query)
-        return query_response
-    
-    def metadata_rename(self, metadata_type: str, previous_name: str, new_name: str): 
-        """
-        Renames the API name of SFDC metadata
-        """
-        getattr(self.sf.mdapi, metadata_type).rename(previous_name, new_name)
-    
-    ### ----------------------------------------------------------------------------------------------------
-    ### Custom Tooling API Methods
-    ### ----------------------------------------------------------------------------------------------------
-    
-    def tooling_query_all(self, query):
-        done = False
-        full_results = []
-        result = self.sf_api_call(f'/services/data/v52.0/tooling/query', method='get', parameters={'q': query})
-        while not done:
-            full_results.extend(result['records'])
-            done = result['done']
-            if not done:
-                result = self.sf_api_call(result['nextRecordsUrl'])
-        return full_results
-
-    ### ----------------------------------------------------------------------------------------------------
-    ### Utility Functions
-    ### ----------------------------------------------------------------------------------------------------
-    def query_performance_feedback(self, query: str):
-        # https://developer.salesforce.com/docs/atlas.en-us.240.0.api_rest.meta/api_rest/dome_query_explain.htm
-        
-        return self.sf_api_call(f'/services/data/{self.api_version}/query?explain={query}')
-    
-    def parse_sf_limits(self, sfdc_limits_result: dict, prefix=None) -> dict:
-        ## Recursively parse the limits result to find the limits that are not 0
-        result = {}
-        for key, item in sfdc_limits_result.items():
-            if set(['Max','Remaining']).issubset(set(item.keys())): 
-                if item['Max'] == 0:
-                    continue
-                else:
-                    result[key if prefix is None else prefix+' - '+key] = dict(zip(['Max','Remaining'],[item['Max'], item['Remaining']]))
-            
-            if len(set(item.keys()) - set(['Max','Remaining'])) > 0:
-                sub_item = item.copy()
-                if 'Max' in sub_item: 
-                    del sub_item['Max']
-                if 'Remaining' in sub_item: 
-                    del sub_item['Remaining']
-                result.update(self.parse_sf_limits(sub_item, prefix=key))
-        return result
-        
-    def sf_api_call(self, action, parameters = {}, method = 'get', data = {}):
-        """
-        Helper function to make calls to Salesforce REST API.
-        Parameters: action (the URL), URL params, method (get, post or patch), data for POST/PATCH.
-        """
-        headers = {
-            'Content-type': 'application/json',
-            'Accept-Encoding': 'gzip',
-            'Authorization': 'Bearer %s' % self.session_id
-        }
-        if method.lower() == 'get':
-            r = requests.request(method, 'https://'+self.instance+action, headers=headers, params=parameters, timeout=30)
-        elif method.lower() in ['post', 'patch']:
-            r = requests.request(method, 'https://'+self.instance+action, headers=headers, json=data, params=parameters, timeout=10)
-        else:
-            # other methods not implemented in this example
-            raise ValueError('Method should be get or post or patch.')
-#         print('Debug: API %s call: %s' % (method, r.url) )
-        if r.status_code < 300:
-            if method=='patch':
-                return None
-            else:
-                try:
-                    return r.json()
-                except:
-                    return {}
-        else:
-            raise Exception('API error when calling %s : %s' % (r.url, r.content))
-
-
-    def join(self, 
-                dataframe, 
-                rt_dataframe, 
-                left_on="", 
-                right_on="", 
-                new_columns=[], 
-                suffix = "_new"):
-        """
-        Joins and appends the Name and DeveloperName columns of record type to the dataframe.
-        The dataframe must contain a column named "RecordTypeId" with the 18 digit SFID of the record type.
-        """
-        df_columns = dataframe.columns.to_list()
-        if right_on not in new_columns:
-            new_columns.insert(0,right_on)
-        dataframe = pd.merge(dataframe, rt_dataframe[new_columns], how = 'inner', 
-                                left_on = left_on,right_on = right_on, suffixes=('', suffix))
-#         dataframe.drop([col for col in dataframe.columns if 'drop' in col], axis=1, inplace=True)
-        return dataframe
+from sys import platform
+import numpy as np
+import pandas as pd
+import os
+from simple_salesforce import Salesforce
+from simple_salesforce import SalesforceLogin
+from salesforce_bulk import SalesforceBulk
+from sfdclib import SfdcSession
+from sfdclib import SfdcMetadataApi
+from sfdclib import SfdcToolingApi
+import re
+import time
+import json
+from salesforce_bulk.util import IteratorBytesIO
+import pandas as pd
+import requests
+import base64
+from typing import List, Tuple, Optional, Union, Type, Callable
+from collections import OrderedDict
+import sys
+import zeep
+import datetime
+import ast
+sys.path.append("..")
+try:
+    from custom_exceptions.salesforce_exceptions import *
+    from utilities.df_utils import *
+    from utilities.async_utils import *
+    from utilities.sf_query_processors import *
+    from decorators import *
+except:
+    from salesforce.custom_exceptions.salesforce_exceptions import *
+    from salesforce.utilities.df_utils import *
+    from salesforce.utilities.async_utils import *
+    from salesforce.utilities.sf_query_processors import *
+    from salesforce.decorators import *
+import asyncio
+from functools import wraps, partial
+from pandas import json_normalize
+
+
+
+
+class Sf:
+    _REGEX_PARSE_SOQL_FIELDS = "(?<=select)(.*?)(?<!, )(?=from)"
+    _REGEX_PARSE_SOQL_OBJECT = "(?<!, from )(?<=from )\w*"
+    
+    def __init__(self) -> None:
+        self.filename: str = None
+        self.os_platform: str = platform
+        self.credentials: pd.DataFrame = pd.DataFrame()
+        self.sfUsername: str = None
+        self.sfPassword: str = None
+        self.sfOrgId: str = ""
+        self.isSandbox: bool = None
+        self.session_id: str = None
+        self.instance: str = None
+        self.domain: str = None
+        self.security_token: str = ''
+        self.sf: Salesforce = None
+        self.bulk: SalesforceBulk = None
+        self.sfMeta: SfdcMetadataApi = None
+        self.tooling: SfdcToolingApi = None
+        self.api_version: str = 'v52.0'
+        self.record_count: dict = {}
+        self.record_count_caseinsensitive: dict = {}
+        self.debug: bool = False
+        self.veeva_common:dict = None
+        self.org_info:dict = None
+        self.sfdc_limits: dict = None
+    
+    def authenticate(self, sfUsername: Optional[str]=None, 
+                                sfPassword: Optional[str]=None, 
+                                sfOrgId: Optional[str]=None, 
+                                isSandbox: Optional[bool]=None, 
+                                session_id: Optional[str]=None, 
+                                instance: Optional[str]=None, 
+                                security_token: Optional[str] = None,
+                                domain: Optional[str] = None,
+                                if_return: Optional[bool] = False,
+                                *args, **kwargs) -> Optional[dict]:
+        """
+        Authenticates Salesforce and retrieves the auth token.
+
+        Dependencies:
+            from simple_salesforce import Salesforce
+            from simple_salesforce import SalesforceLogin
+            from salesforce_bulk import SalesforceBulk
+            from sfdclib import SfdcSession
+            from sfdclib import SfdcMetadataApi
+            from sfdclib import SfdcToolingApi
+        """
+        
+        sfUsername = self.sfUsername if sfUsername is None else sfUsername
+        sfPassword = self.sfPassword if sfPassword is None else sfPassword
+        sfOrgId = self.sfOrgId if sfOrgId is None else sfOrgId
+        isSandbox = self.isSandbox if isSandbox is None else isSandbox
+        session_id = self.session_id if session_id is None else session_id
+        instance = self.instance if instance is None else instance
+        security_token = self.security_token if security_token is None else security_token
+        domain = self.domain if domain is None else domain
+        
+        # If session ID already exists and instance URL is already populated,
+        # reauthenticate using existing session ID
+        if session_id is not None and instance is not None:
+            sf = Salesforce(session_id = session_id, instance = instance)
+            self.sf = sf
+            self.instance = instance
+            self.session_id = session_id
+        
+        # If username, password, org ID, and isSandbox flags are all provided,
+        # authenticate using provided credentials
+        elif sfUsername is not None and sfPassword is not None and sfOrgId is not None and isSandbox is not None:
+            
+            # SFDC Sandbox authentication
+            if isSandbox:
+                self.domain = 'test'
+                sf = Salesforce(password=sfPassword, 
+                                username=sfUsername, 
+                                organizationId=sfOrgId, 
+                                security_token = self.security_token,domain='test')
+                session_id, instance = SalesforceLogin(
+                username=sfUsername,
+                password=sfPassword,
+                security_token=self.security_token,
+                domain= self.domain)
+                self.session_id = session_id
+                self.instance = instance
+                self.sf = sf
+                self.sfUsername = sfUsername
+                self.sfPassword = sfPassword
+                self.load_org_info()
+                self.sfOrgId = self.org_info['Id'][0]
+                self.isSandbox = isSandbox
+                
+            else:
+                sf = Salesforce(password=sfPassword, 
+                                username=sfUsername, 
+                                organizationId=sfOrgId, 
+                                security_token=self.security_token)
+                session_id, instance = SalesforceLogin(
+                username=sfUsername,
+                password=sfPassword,
+                security_token=self.security_token)
+                self.session_id = session_id
+                self.instance = instance
+                self.sf = sf
+                self.sfUsername = sfUsername
+                self.sfPassword = sfPassword
+                self.load_org_info()
+                self.sfOrgId = self.org_info['Id'][0]
+                self.isSandbox = isSandbox
+                
+        else:
+            raise Exception('Either sfUsername, sfPassword, sfOrgId and isSandbox must be populated, OR session_id and instance must be populated.')
+
+        # Alternative way to authenticate using SFDC Bulk API
+        # bulk = SalesforceBulk(username=sfUsername, password=sfPassword, security_token='')
+        bulk = SalesforceBulk(sessionId = self.session_id, host = self.instance)
+        self.bulk = bulk
+        # SFDC Metadata API
+        sf_meta_instance = ""
+        if self.instance.__contains__("my.salesforce.com"):
+            sf_meta_instance = self.instance.replace("my.salesforce.com","my")
+        else:
+            sf_meta_instance = ".".join(self.instance.split(".")[:2])
+            
+        sfMeta = SfdcSession(session_id=self.session_id, instance=sf_meta_instance)
+        self.sfMeta = sfMeta
+        # Alternative way to authenticate using SFDC Metadata API
+        # sfMeta = SfdcSession(username=sfUsername,password=sfPassword,token='',is_sandbox=isSandbox)
+        sfMeta._api_version = "54.0"
+        tooling = SfdcToolingApi(sfMeta)
+        self.tooling = tooling
+        
+        self.api_version = 'v' + self.sf_api_call('/services/data')[-1]['version']
+        
+        for x in self.sf_api_call('/services/data/'+self.api_version+'/limits/recordCount')['sObjects']:
+            self.record_count[x['name']] = x['count']
+            self.record_count_caseinsensitive[x['name'].lower()] = x['count']
+        
+        self.sfdc_limits = self.parse_sf_limits(self.sf_api_call('/services/data/'+self.api_version+'/limits'))
+        
+        
+        if if_return:
+            return {'sf':sf, 
+                    'bulk':bulk, 
+                    'sfMeta': sfMeta, 
+                    'tooling':tooling, 
+                    'session_id':session_id, 
+                    'instance':instance, 
+                    'sfMeta_is_connected':sfMeta.is_connected(), 
+                    'bulk_api_sessionId':bulk.sessionId}
+
+    ### ----------------------------------------------------------------------------------------------------
+    ### Synchronous Data Functions
+    ### ----------------------------------------------------------------------------------------------------
+
+    def query(self, query: str, excludedFields: Optional[List] = [], *args) -> pd.DataFrame:
+        """
+        Using SFDC SOQL Syntax, and allowing for Relationships and group bys. 
+        
+        Arguments:
+            query (str): A Standard SFDC SOQL Query allowing for relationships (Owner.Name)
+                Asterisks(*) represents all queryable fields and can be used in conjunction
+                with other relationship fields. 
+                i.e. (Select *, Owner.Profile.Name, Owner.Name From Account)
+        
+        Returns:
+            Pandas Dataframe Object.
+        
+        Raises:
+            KeyError: Typically raised when 0 records exist for the object
+                
+            badfield: A self-correcting error that is raised when a field is unqueriable, i.e. Address Fields
+            
+            Exception: When relationship query contains more than 4 layers, an Exception is raised.
+            i.e. Parent_Account_vod__r.Owner.Profile.LastModifiedBy.Name (<- a 5 layer deep relationship is not supported)
+        
+        Example of Usage:
+            sf.query("Select *, Owner.Profile.Name From Account ORDER BY CreatedDate DESC LIMIT 100")
+            
+            return:
+            A Pandas Dataframe of the last created 100 account records, with all queriable fields included in the query and a relationship field.
+            
+        """
+        objectName = re.search(self._REGEX_PARSE_SOQL_OBJECT, query.lower()).group(0)
+        successful = False
+        
+        extracted_object = pd.DataFrame()
+        # replaces "*" in query with all fields on object
+        sfSchema = getattr(self.sf, objectName).describe().get('fields')
+
+        schemaDict = {}
+        for x in sfSchema:
+            schemaDict[x['name']] = x
+
+        while not successful:
+            try:
+                results = []
+                for field in schemaDict:
+                    if (schemaDict[field]['type'] != 'location' and 
+                        schemaDict[field]['type'] != 'address' and 
+                        schemaDict[field]['name'] not in excludedFields):
+                        results.append(field)
+                final_query = query.replace("*", ", ".join(results))                
+                query_response = self.sf.query_all(final_query)
+                # if the object has 0 records in Salesforce, return empty dataframe
+                if query_response['totalSize'] == 0:
+                    fields_preparsed = re.search(self._REGEX_PARSE_SOQL_FIELDS, query,  re.IGNORECASE).group(0).split(",")
+                    return pd.DataFrame(columns=fields_preparsed)
+                else:
+                    result = pd.DataFrame(query_response)['records']
+                    for _ in result:
+                        del _['attributes']
+                    successful = True
+            except KeyError:
+                if self.debug:
+                    print(objectName + ' skipped. (Potentially due to no records found.)')
+                    
+                return pd.DataFrame(columns=results)
+            except Exception as badfield:
+                field_exclusion = badfield.state_message[badfield.state_message.find("No such column '")+\
+                    16:badfield.state_message.find("No such column '")+16+\
+                        badfield.state_message[badfield.state_message.find("No such column '")+16:].find("'")]
+                excludedFields.append(field_exclusion)
+                print("Excluded unqueriable field: " + field_exclusion)
+                if query.find("*") == -1:
+                    raise Exception(f"Unqueriable field {field_exclusion} found in query.")
+                else:
+                    continue
+            
+            result = result.apply(lambda x: pd.Series(x)).copy()
+
+            relationship_fields_preparsed = re.search(self._REGEX_PARSE_SOQL_FIELDS, query,  re.IGNORECASE).group(0).split(",")
+            # relationship_fields_prepared Example:
+            # ['*',
+            #  ' Parent_Account_vod__r.Owner.Profile.Name',
+            #  ' Child_Account_vod__r.Owner.Profile.Name',
+            #  'Parent_Account_vod__r.Owner.Profile.Id ']
+
+            relational_fields = [{x.strip(): x.strip().split(".")} for x in relationship_fields_preparsed if "." in x]
+            # relationship_fields Example:
+            # [{'Parent_Account_vod__r.Owner.Profile.Name': ['Parent_Account_vod__r',
+            #    'Owner',
+            #    'Profile',
+            #    'Name']},
+            #  {'Child_Account_vod__r.Owner.Profile.Name': ['Child_Account_vod__r',
+            #    'Owner',
+            #    'Profile',
+            #    'Name']},
+            #  {'Parent_Account_vod__r.Owner.Profile.Id': ['Parent_Account_vod__r',
+            #    'Owner',
+            #    'Profile',
+            #    'Id']}]
+
+            columns_to_remove = set()
+            for x in relational_fields:
+                if len(list(x.values())[0]) > 4:
+                    raise Exception("Too Many Relationship Levels. The Query you have entered contains more than 4 levels deep and is not supported.")
+                elif len(list(x.values())[0]) == 4:
+                    result[list(x.keys())[0]] = result[list(x.keys())[0].split(".")[0]].\
+                        apply(lambda z: z[list(x.values())[0][1]][list(x.values())[0][2]][list(x.values())[0][3]])
+                    columns_to_remove.add(list(x.values())[0][0])
+                elif len(list(x.values())[0]) == 3:
+                    result[list(x.keys())[0]] = result[list(x.keys())[0].split(".")[0]].\
+                        apply(lambda z: z[list(x.values())[0][1]][list(x.values())[0][2]])
+                    columns_to_remove.add(list(x.values())[0][0])
+                elif len(list(x.values())[0]) == 2:
+                    result[list(x.keys())[0]] = result[list(x.keys())[0].split(".")[0]].\
+                        apply(lambda z: z[list(x.values())[0][1]])
+                    columns_to_remove.add(list(x.values())[0][0])
+            result.drop(columns_to_remove, axis=1, inplace=True)
+            result.replace(np.nan, None, inplace=True)        
+
+                
+        return result
+
+    def create(self, object_api: str=None, record_dataframe: pd.DataFrame = pd.DataFrame()) -> pd.DataFrame:
+        """
+        Function creates records within the Salesforce instance using bulk api.
+
+        Arguments:
+        object_api: str: API name of the Salesforce Object for which the records are to be created.
+
+        record_dataframe: pd.DataFrame: A pandas dataframe object containing all the required fields for a record.
+
+        Returns:
+        result: pd.DataFrame: A pandas dataframe with the following columns:
+            success: boolean: indicates whether the create request was successful
+            created: boolean: this value should always be False in a create request
+            id: object[str]: this value typically is None in a create request
+            statusCode: object[str] - Optional: the error code of the create operation if failed
+            message: object[str] - Optional: the error message of the create operation if failed
+            fields: object[List[str]] - Optional: the fields for which the error code and message applies to.
+
+        Raises:
+            RequiredValuesNotProvidedDuringUpdate
+        """
+        if (object_api is None) or (len(record_dataframe) == 0):
+            raise RequiredValuesNotProvidedDuringCreate()
+        else:
+            result = getattr(self.sf.bulk, object_api).insert(record_dataframe.to_dict('records'), batch_size=10000, use_serial=False)
+            result = pd.DataFrame(result)
+            result = unpack_column(result, "errors")
+
+        return pd.DataFrame(result.rename(columns={'id': 'Id'}))
+
+    def delete(self, object_api: str=None, record_dataframe: pd.DataFrame = pd.DataFrame()) -> pd.DataFrame:
+        """
+        Function deletes records within the Salesforce instance using bulk api.
+
+        Arguments:
+        object_api: str: API name of the Salesforce Object for which the records are to be deleted from.
+
+        record_dataframe: pd.DataFrame: A pandas dataframe object containing at least 1 column with an Id column (case sensitive)
+
+        Returns:
+        result: pd.DataFrame: A pandas dataframe with the following columns:
+            success: boolean: indicates whether the delete request was successful
+            created: boolean: this value should always be False in a delete request
+            id: object[str]: this value typically is None in a delete request
+            statusCode: object[str] - Optional: the error code of the delete operation if failed
+            message: object[str] - Optional: the error message of the delete operation if failed
+            fields: object[List[str]] - Optional: the fields for which the error code and message applies to.
+
+        Raises:
+            RequiredValuesNotProvidedDuringDelete
+        """
+        if (object_api is None) or (len(record_dataframe) == 0) or record_dataframe.columns.__contains__('Id') == False:
+            raise RequiredValuesNotProvidedDuringDelete()
+        else:
+            result = getattr(self.sf.bulk, object_api).delete(record_dataframe['Id'].to_frame().to_dict('records'))
+            result = pd.DataFrame(result)
+            result = unpack_column(result, "errors")
+
+        return pd.DataFrame(result.rename(columns={'id': 'Id'}))
+    
+    def update(self, object_api: str=None, record_dataframe: pd.DataFrame = pd.DataFrame()) -> pd.DataFrame:
+        """
+        Function updates records within the Salesforce instance using bulk api.
+
+        Arguments:
+        object_api: str: API name of the Salesforce Object for which the records are to be updated.
+
+        record_dataframe: pd.DataFrame: A pandas dataframe object containing at least 1 column with an Id column (case sensitive)
+            and additional columns matching the Salesforce field api names.
+
+        Returns:
+        result: pd.DataFrame: A pandas dataframe with the following columns:
+            success: boolean: indicates whether the update request was successful
+            created: boolean: this value should always be False in a update request
+            id: object[str]: this value typically is None in a update request
+            statusCode: object[str] - Optional: the error code of the update operation if failed
+            message: object[str] - Optional: the error message of the update operation if failed
+            fields: object[List[str]] - Optional: the fields for which the error code and message applies to.
+
+        Raises:
+            RequiredValuesNotProvidedDuringUpdate
+        """
+
+        field_metadata = self.field_describe([object_api],attributes=['name','type','updateable','compoundFieldName'])
+
+        if ((object_api is None) or 
+        (len(record_dataframe) == 0)):
+            raise RequiredValuesNotProvidedDuringUpdate(message="Object API and Record Dataframe are required, ensure your record dataframe has at least 1 row and 1 column with an Id column")
+        elif record_dataframe.columns.__contains__('Id') == False:
+            raise RequiredValuesNotProvidedDuringUpdate(message="Record Dataframe must have an Id column")
+        elif ~record_dataframe.columns.isin(field_metadata[object_api]).all():
+            # checks whether any of the columns in the dataframe passed in are not valid field API names
+            raise RequiredValuesNotProvidedDuringUpdate(message="One of the columns in the record dataframe is not a valid field for the object")
+        elif record_dataframe.columns.isin(field_metadata[(field_metadata['Updateable'] == False) & (field_metadata[object_api] != "Id")][object_api]).any():
+            # checks whether any of the columns in the dataframe passed in are not updateable
+            non_updatable_fields = list(set(record_dataframe.columns) - set(field_metadata[(field_metadata['Updateable'] == True) | (field_metadata[object_api] == "Id")][object_api]))
+            raise RequiredValuesNotProvidedDuringUpdate(message=f"The following fields are not updatable: {', '.join(non_updatable_fields)}")
+        elif record_dataframe.columns.isin(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_api]).any():
+            # checks whether any of the columns in the dataframe passed in are compound fields
+            compound_fields = list(set(record_dataframe.columns) & set(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_api]))
+            raise RequiredValuesNotProvidedDuringUpdate(message=f"The following fields are compound fields, which are not updatable: {', '.join(compound_fields)}")
+        # checks whether an reference (lookup/master-detail) field is included in the source dataframe
+        #  or ~record_dataframe.columns.isin(field_metadata[field_metadata['Type'] == 'reference'][object_api]).any()
+            
+        else:
+            record_dataframe.replace(np.nan, None, inplace=True)
+            result = getattr(self.sf.bulk, object_api).update(record_dataframe.to_dict('records'), batch_size=10000, use_serial=False)
+            result = pd.DataFrame(result)
+            result = unpack_column(result, "errors")
+
+        return pd.DataFrame(result.rename(columns={'id': 'Id'}))
+
+    def upsert(self, object_api: str=None, external_id_field_api: str="", record_dataframe: pd.DataFrame = pd.DataFrame()) -> pd.DataFrame:
+        """
+        Function upserts records within the Salesforce instance using bulk api.
+
+        Arguments:
+        object_api: str: API name of the Salesforce Object for which the records are to be upserted into.
+
+        external_id_field_api: str: API name of the external ID field used for the upsert operation.
+
+        record_dataframe: pd.DataFrame: A pandas dataframe object containing the External column (case sensitive)
+            and additional columns matching the Salesforce field api names.
+
+        Returns:
+        result: pd.DataFrame: A pandas dataframe with the following columns:
+            success: boolean: indicates whether the upsert request was successful
+            created: boolean: this value should always be False in a upsert request
+            id: object[str]: this value typically is None in a upsert request
+            statusCode: object[str] - Optional: the error code of the upsert operation if failed
+            message: object[str] - Optional: the error message of the upsert operation if failed
+            fields: object[List[str]] - Optional: the fields for which the error code and message applies to.
+
+        Raises:
+            RequiredValuesNotProvidedDuringUpsert
+            SalesforceMalformedRequest
+        """
+
+        field_metadata = self.field_describe([object_api], ['name', 'type', 'length','externalId','updateable','compoundFieldName'])
+            
+            
+        if ((object_api is None) or 
+        (len(record_dataframe) == 0)):
+            raise RequiredValuesNotProvidedDuringUpdate(message="Object API and Record Dataframe are required, ensure your record dataframe has at least 1 row and 1 column with an Id column")
+        elif ~record_dataframe.columns.isin(field_metadata[object_api]).all():
+            # checks whether any of the columns in the dataframe passed in are not valid field API names
+            raise RequiredValuesNotProvidedDuringUpdate(message="One of the columns in the record dataframe is not a valid field for the object")
+        elif external_id_field_api == "":
+            raise RequiredValuesNotProvidedDuringUpsert(message="External ID field API is required")
+        elif record_dataframe.columns.isin(field_metadata[(field_metadata['Updateable'] == False) & (field_metadata[object_api] != "Id")][object_api]).any():
+            # checks whether any of the columns in the dataframe passed in are not updateable
+            non_updatable_fields = list(set(record_dataframe.columns) - set(field_metadata[(field_metadata['Updateable'] == True) | (field_metadata[object_api] == "Id")][object_api]))
+            raise RequiredValuesNotProvidedDuringUpdate(message=f"The following fields are not updatable: {', '.join(non_updatable_fields)}")
+        elif record_dataframe.columns.isin(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_api]).any():
+            # checks whether any of the columns in the dataframe passed in are compound fields
+            compound_fields = list(set(record_dataframe.columns) & set(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_api]))
+            raise RequiredValuesNotProvidedDuringUpdate(message=f"The following fields are compound fields, which are not updatable: {', '.join(compound_fields)}")
+        else:
+            record_dataframe.replace(np.nan, None, inplace=True)
+            result = getattr(self.sf.bulk, object_api).upsert(record_dataframe.to_dict('records'), external_id_field_api, batch_size=10000, use_serial=False)
+            result = pd.DataFrame(result)
+            result = unpack_column(result, "errors")
+
+        return pd.DataFrame(result)
+
+    def extract_bulk(self, og_query: str, 
+                        excludedFields: Optional[List] = []) -> pd.DataFrame:
+        """
+        Uses a standard SOQL query to extract Salesforce Data and outputs a pandas dataframe
+        
+        Dependencies:
+            import re
+            import time
+            import json
+            from salesforce_bulk.util import IteratorBytesIO
+            import pandas as pd
+        
+        """
+        objectName = re.search(self._REGEX_PARSE_SOQL_OBJECT, og_query.lower()).group(0)
+        successful = False
+        
+        extracted_object = pd.DataFrame()
+        # replaces "*" in query with all fields on object
+        sfSchema = getattr(self.sf, objectName).describe().get('fields')
+
+        schemaDict = {}
+        for x in sfSchema:
+            schemaDict[x['name']] = x
+
+        while not successful:
+            try:
+                results = []
+                for field in schemaDict:
+                    if (schemaDict[field]['type'] != 'location' and 
+                        schemaDict[field]['type'] != 'address' and 
+                        schemaDict[field]['name'] not in excludedFields):
+                        results.append(field)
+                query = og_query.replace("*", ", ".join(results))
+                
+#                 # if the object has 0 records in Salesforce, return empty dataframe
+#                 if objectName not in self.record_count_caseinsensitive.keys():
+#                     return pd.DataFrame(columns=results)
+                    
+                job = self.bulk.create_query_job(objectName, contentType='JSON')
+                batch = self.bulk.query(job, query)
+                while not self.bulk.is_batch_done(batch):
+                    time.sleep(1)
+                sfdf = pd.DataFrame()
+                for result in self.bulk.get_all_results_for_query_batch(batch):
+                    result = json.load(IteratorBytesIO(result))
+                    sfdf = pd.concat([sfdf, pd.DataFrame(result)])
+
+                # drops attributes column in dataframe
+                sfdf.drop(columns="attributes", inplace = True)
+
+                # formats all datetime to the proper formatting
+                for column in sfdf:
+                    if schemaDict[column]['type'] == 'datetime':
+                        sfdf[column] = pd.to_datetime(sfdf[column], unit='ms')
+                    # if the column has a 'scale' or salesforce's decimal places, then turn the column into an int
+                    elif schemaDict[column]['type'] == 'double' and schemaDict[column]['scale'] == 0:
+                        sfdf[column] = pd.to_numeric(sfdf[column], downcast='integer')
+
+            #                         pd.to_datetime(sfdf[column], unit = 's')
+            #                         sfdf[column].apply(lambda x : datetime.fromtimestamp(int(x), tz).isoformat())
+            #                 sfdf.convert_dtypes()
+                # converts the output of the bulk query to text so that the unix timestamp displays property, and fills and empty values with the '' string.
+                sfdf = sfdf.fillna('').astype(str)
+                successful = True
+            except KeyError:
+                if self.debug:
+                    print(objectName + ' skipped. (Potentially due to no records found.)')
+                    
+                return pd.DataFrame(columns=results)
+            except Exception as badfield:
+                field_exclusion = badfield.state_message[badfield.state_message.find("No such column '")+\
+                    16:badfield.state_message.find("No such column '")+16+\
+                        badfield.state_message[badfield.state_message.find("No such column '")+16:].find("'")]
+                excludedFields.append(field_exclusion)
+                print("Excluded unqueriable field: " + field_exclusion)
+                if og_query.find("*") == -1:
+                    raise Exception(f"Unqueriable field {field_exclusion} found in query.")
+                else:
+                    continue
+        if self.debug:
+            print("Extracted " + objectName + " successfully!")
+        return sfdf
+    
+    def entity_access_query(self, entity_type):
+        # Retrieves information about which Profile or PermissionSet
+        # grants permission to which Setup Entity (i.e. ApexPage, ApexClass, TabSets, etc)
+        
+        entity_access = transform_sf_result_set_rec(self.sf.query_all(f"""
+        SELECT Id, Parent.Id, Parent.ProfileId, Parent.Profile.Name, Parent.Name,SetupEntityId,SetupEntityType FROM
+        SetupEntityAccess WHERE SetupEntityType = '{entity_type}'""")['records'])
+        # entity_access.drop(columns=['PermissionSet.Profile'], inplace=True)
+        return {entity_type: entity_access}
+
+    ### ----------------------------------------------------------------------------------------------------
+    ### Asynchronous Data Functions
+    ### ----------------------------------------------------------------------------------------------------
+
+    async def async_query(self, query, excludedFields: Optional[List] = []) -> pd.DataFrame:
+        async_query = async_wrap(self.query)
+        return await async_query(query, excludedFields)
+    
+    async def async_queries(self, queries: List[str]):
+        async_queries = async_wrap(self.sf.query_all)
+        result_list = await asyncio.gather(*[async_queries(query) for query in queries])
+        result_pd_list = [transform_sf_result_set_rec(result['records']) for result in result_list]
+        return result_pd_list
+
+
+    async def async_upsert(self, object_api, record_dataframe, external_id_field_api, batchsize=2000, *args, **kwargs):
+        async_upsert = async_wrap(self.upsert)
+        batches = len(record_dataframe) / batchsize
+        result_list = await asyncio.gather(*[async_upsert(object_api= object_api, record_dataframe=batch, external_id_field_api=external_id_field_api) for batch in np.array_split(record_dataframe, batches)])
+        return pd.concat(result_list).reset_index(drop=True)
+
+    async def async_update(self, object_api, record_dataframe, batchsize=2000, *args, **kwargs):
+        async_update = async_wrap(self.update)
+        batches = len(record_dataframe) / batchsize
+        result_list = await asyncio.gather(*[async_update(object_api= object_api, record_dataframe=batch) for batch in np.array_split(record_dataframe, batches)])
+        return pd.concat(result_list).reset_index(drop=True)
+
+    async def async_create(self, object_api, record_dataframe, batchsize=2000, *args, **kwargs):
+        async_create = async_wrap(self.create)
+        batches = len(record_dataframe) / batchsize
+        result_list = await asyncio.gather(*[async_create(object_api= object_api, record_dataframe=batch) for batch in np.array_split(record_dataframe, batches)])
+        return pd.concat(result_list).reset_index(drop=True)
+
+    async def async_delete(self, object_api, record_dataframe, batchsize=2000, *args, **kwargs):
+        async_delete = async_wrap(self.delete)
+        batches = len(record_dataframe) / batchsize
+        result_list = await asyncio.gather(*[async_delete(object_api= object_api, record_dataframe=batch) for batch in np.array_split(record_dataframe, batches)])
+        return pd.concat(result_list).reset_index(drop=True)
+    
+    async def async_get_user_password_status(self, user_ids: list[str]) -> dict:
+        async_sf_api_call = async_wrap(self.sf_api_call)
+        response = await asyncio.gather(*[async_sf_api_call(f'/services/data/{self.api_version}/sobjects/User/{user_id}/password', method='GET') for user_id in user_ids])
+        # Return a dict
+        response = {user_id: result for user_id, result in zip(user_ids, response)}
+        return response
+    
+    
+    
+    ### ----------------------------------------------------------------------------------------------------
+    ### Asynchronous Metadata Functions
+    ### ----------------------------------------------------------------------------------------------------
+    async def async_get_non_updatable_fields(self, object_name: str):
+        """
+        Returns a list of fields that cannot be updated.
+        """
+        async_field_describe =  async_wrap(self.field_describe)
+        field_metadata = await async_field_describe([object_name], attributes=['name','updateable'])
+        non_updatable_fields = list(field_metadata[field_metadata['Updateable'] == False][object_name])[1:]
+        return non_updatable_fields
+
+    async def async_get_compound_field_names(self, object_name: str, include_name_compound_fields: bool=False):
+        """
+        Returns a list of compound fields. By default "Name" compound field names are excluded.
+        To return a list of compound fields including "Name" fields, set include_name_compound_fields to True.
+
+        Compound field names are fields that are composed of multiple fields. These fields are not updatable directly via the API
+        and may cause errors if updated directly.
+        """
+        async_field_describe =  async_wrap(self.field_describe)
+        field_metadata = await async_field_describe([object_name], attributes=['name','compoundFieldName'])
+
+        if include_name_compound_fields:
+            compound_field_names = list(field_metadata[(~field_metadata['Compoundfieldname'].isnull())][object_name])
+        elif include_name_compound_fields==False:
+            compound_field_names = list(field_metadata[(~field_metadata['Compoundfieldname'].isnull()) & (field_metadata['Compoundfieldname'] != 'Name')][object_name])
+        else:
+            raise ValueError('include_name_compound_fields must be a boolean.')
+        return compound_field_names
+    
+    async def get_picklist_values_by_object_record_type(self, object: str):
+        object_record_type_ids = self.query(f"Select Id, Name From RecordType Where SobjectType = '{object}'").apply(lambda row: {"Id": row['Id'], "Name": row['Name']}, axis=1)
+        if len(object_record_type_ids) == 0:
+            object_record_type_ids = pd.Series([{"Id": "012000000000000AAA", "Name": "Master"}]).to_list()
+        else:
+            object_record_type_ids = object_record_type_ids.to_list()
+            
+        object_describe = self.sf_api_call(f"/services/data/{self.api_version}/ui-api/object-info/{object}")['fields']
+        controlling_fields = []
+        for field, values in object_describe.items():
+            controlling_fields.append({"Field": field, "Controlling Field": "" if values['controllingFields'] == [] else "; ".join(values['controllingFields'])})
+        controlling_fields = pd.DataFrame(controlling_fields)
+
+        def record_type_picklist_retriever(self, object, record_type_id, record_type_name):
+            result = []
+            picklist_metadata = self.sf_api_call(f"/services/data/{self.api_version}/ui-api/object-info/{object}/picklist-values/{record_type_id}")['picklistFieldValues']
+            if len(picklist_metadata) == 0:
+                return pd.DataFrame(columns=['attributes',
+                                    'label',
+                                    'validFor',
+                                    'value',
+                                    'Field_API',
+                                    'defaultValueLabel',
+                                    'defaultValueValue',
+                                    'Controlling Field',
+                                    'RecordTypeName',
+                                    'Object'])
+                
+            for key, value in picklist_metadata.items():
+                result.append({"Field_API": key, "controllerValues": value['controllerValues'], "defaultValue":  value['defaultValue'], "values": value['values']})
+            final_result_pd = json_normalize(result, ['values'], ['defaultValue', 'controllerValues', 'Field_API'])
+            ## Converts the validFor numerical codes i.e. [0,2] to it's corresponding text values by looking it up on the controllerValues column i.e. {'Web': 0, 'Phone Inquiry': 1, 'Partner Reference': 2 ... }
+            ## [0,2] -> ['Web', 'Partner Reference']
+            final_result_pd['validFor'] = final_result_pd.apply(lambda row: "\n".join([{v: k for k, v in row['controllerValues'].items()}[value] for value in row['validFor']]), axis=1)
+            final_result_pd.drop(columns=['controllerValues'], inplace=True)
+            
+            try:
+                final_result_pd[['defaultValueLabel', 'defaultValueValue']] = json_normalize(final_result_pd['defaultValue'])[['label','value']]
+            except:
+                final_result_pd[['defaultValueLabel', 'defaultValueValue']] = [np.nan, np.nan]
+            
+            final_result_pd.drop(columns=['defaultValue'], inplace=True)
+            final_result_pd = pd.merge(final_result_pd, controlling_fields, left_on='Field_API', right_on='Field', how='left').drop(columns=['Field']).copy()
+            final_result_pd['RecordTypeName'] = record_type_name
+            final_result_pd['Object'] = object
+            return final_result_pd
+
+        async_picklist_rt_retrieve = async_wrap(record_type_picklist_retriever)
+        results = pd.concat(await asyncio.gather(*[async_picklist_rt_retrieve(self, object, record_type_id['Id'], record_type_id['Name']) for record_type_id in object_record_type_ids]))
+        results = results[['Object', 'RecordTypeName', 'Field_API', 'Controlling Field', 'defaultValueLabel', 'defaultValueValue', 'label', 'value', 'validFor']]
+        return results
+
+
+    async def object_permission_bulk_check(self, objects: list, permissions: list ):
+        async_object_permission_check = async_wrap(self.object_permission_check)
+        result_list = await asyncio.gather(*[async_object_permission_check(object, permission ) for object in objects for permission in permissions])
+        # for result in result_list:
+        #     data = deep_merge_dictionaries(data, result)
+        result_list = [item for sublist in result_list for item in sublist]
+        return result_list
+
+    async def field_permission_bulk_check(self, objects: list, ) -> dict[str, pd.DataFrame]:
+        async_field_permission_check = async_wrap(self.field_permission_check)
+        result_list = await asyncio.gather(*[async_field_permission_check( object ) for object in objects])
+        # for result in result_list:
+        #     data = deep_merge_dictionaries(data, result)
+        profile_list = [item['profilePermissions'] for item in result_list]
+        permissionSet_list = [item['permissionSetPermissions'] for item in result_list]
+        result_dict = {'profilePermissions': pd.concat(profile_list), 'permissionSetPermissions': pd.concat(permissionSet_list)}
+        
+        return result_dict
+    
+    async def async_set_user_passwords(self, user_id_password_list_dict: dict) -> dict:
+        async_set_user_password = async_wrap(self.set_user_password)
+        results = await asyncio.gather(*[async_set_user_password(user_id, password) for user_id, password in user_id_password_list_dict.items()])
+        results = {result['user_id']: result['message'] for result in results}
+        return results
+
+    async def entity_access_bulk_query(self, entity_types: list):
+        async_entity_access_query = async_wrap(self.entity_access_query)
+        results = await asyncio.gather(*[async_entity_access_query(entity_type) for entity_type in entity_types])
+        merged_dict = {}
+        for result in results:
+            for key, value in result.items():
+                merged_dict[key] = value
+        return merged_dict
+
+    async def apex_pages_profiles_and_permission_set_access_query(self, apex_pages_to_check: list[str]):
+        query_results = await self.entity_access_bulk_query(['ApexPage'])
+
+        entity_access_apex_pages_async =  query_results['ApexPage']
+
+        entity_permission_set_access_apex_pages_async = entity_access_apex_pages_async[entity_access_apex_pages_async['Profile.Name'].isna()]
+        entity_profile_access_apex_pages_async = entity_access_apex_pages_async[entity_access_apex_pages_async['Profile.Name'].notna()]
+
+        # filter = ['Scheduler_Administration_vod','Network_Admin_Page_vod','searchAccts_vod']
+        filter_join = "','".join(apex_pages_to_check)
+        where_clause = f" WHERE Name IN ('{filter_join}')"
+        apex_pages_query = transform_sf_result_set_rec(self.sf.query_all(f"""
+            SELECT Id, Name From ApexPage{where_clause}""")['records'])
+
+        permission_sets_with_apex_page_access = entity_permission_set_access_apex_pages_async[entity_permission_set_access_apex_pages_async['SetupEntityAccess.SetupEntityId'].isin(apex_pages_query['ApexPage.Id'].unique())]
+        profiles_with_apex_page_access = entity_profile_access_apex_pages_async[entity_profile_access_apex_pages_async['SetupEntityAccess.SetupEntityId'].isin(apex_pages_query['ApexPage.Id'].unique())]
+        permission_sets_with_apex_page_access = pd.merge(permission_sets_with_apex_page_access, apex_pages_query, left_on='SetupEntityAccess.SetupEntityId', right_on='ApexPage.Id', how='inner').drop(columns=['ApexPage.Id'], axis=1)
+        profiles_with_apex_page_access = pd.merge(profiles_with_apex_page_access, apex_pages_query, left_on='SetupEntityAccess.SetupEntityId', right_on='ApexPage.Id', how='inner').drop(columns=['ApexPage.Id'], axis=1)
+
+        profiles_with_apex_page_access = profiles_with_apex_page_access[['PermissionSet.ProfileId','Profile.Name','SetupEntityAccess.SetupEntityType','ApexPage.Name']]
+        profiles_with_apex_page_access.columns = ['Profile Id', 'Profile Name', 'Setup Entity Type', 'Visualforce (Apex) Name']
+        
+        permission_sets_with_apex_page_access = permission_sets_with_apex_page_access[['PermissionSet.Id','PermissionSet.Name','SetupEntityAccess.SetupEntityType','ApexPage.Name']]
+        permission_sets_with_apex_page_access.columns = ['PermissionSet Id', 'PermissionSet Name', 'Setup Entity Type', 'Visualforce (ApexPage) Name']
+        
+        return {'profiles_with_apex_page_access': profiles_with_apex_page_access, 'permission_sets_with_apex_page_access': permission_sets_with_apex_page_access}
+
+    # Retrieves the Page Layout by Profile by Record Type data for listed objects in the org
+    async def retrieve_profile_layout_record_type_matrix_by_objects(self, objects_to_retrieve_profile_layout_matrix = ['Account','Address_vod__c','Child_Account_vod__c'], discard_unqueriable_objects = False, return_pivot_table = False):
+        
+        objects_to_retrieve = [object[:-3] if object.endswith('__c') else object for object in objects_to_retrieve_profile_layout_matrix]
+        
+        # Objects in the Profile Layout table's TableEnumOrId column where the value is an object name instead of an object ID
+        
+        ENUM_OBJECTS = {'Account', 'AccountTeamMember', 'Asset', 'AuthorizationForm', 'AuthorizationFormConsent', 'BusinessBrand', 'Campaign', 'CampaignMember', 'Case',
+                            'CaseClose', 'CaseInteraction', 'CommunityMemberLayout', 'Contact', 'ContactPointAddress', 'ContactPointEmail', 'ContactPointPhone', 'ContentVersion', 'Contract', 'Customer', 'DelegatedAccount',
+                            'DuplicateRecordItem', 'DuplicateRecordSet', 'EmailMessage', 'Event', 'FeedItem', 'Global', 'Idea', 'Individual', 'Lead', 'Macro', 'ObjectTerritory2AssignmentRule',
+                            'Opportunity', 'OpportunityLineItem', 'Order', 'OrderItem', 'PersonAccount', 'Pricebook2', 'PricebookEntry', 'ProcessException', 'Product2',
+                            'ProfileSkill', 'ProfileSkillEndorsement', 'ProfileSkillUser', 'QuickText', 'Scorecard', 'ScorecardAssociation', 'ScorecardMetric', 'Seller', 'ServiceAppointmentGroup',
+                            'ServiceTerritoryRelationship', 'SignupRequest', 'SocialPersona', 'SocialPost', 'Solution', 'Task', 'Territory2', 'Territory2Model', 'Territory2Type', 'User',
+                            'UserAlt', 'UserProvAccount', 'UserProvisioningLog', 'UserProvisioningRequest', 'UserTerritory2Association', 'WorkProcedure', 'WorkProcedureStep', 'WorkTypeExtension'}
+        
+        # Objects that returns empty results if queried via the WHERE clause using Salesforce Tooling API.
+        # i.e. "Select LayoutId from ProfileLayout where TableEnumOrId = 'DelegatedAccount'" returns empty results.
+        UNQUERIABLE_ENUM_OBJECTS = {'DelegatedAccount','ProfileSkill','ProfileSkillEndorsement','ProfileSkillUser','ServiceTerritoryRelationship','WorkTypeExtension'}
+        
+        
+        
+        object_dataframe = pd.DataFrame(self.tooling_query_all("Select DeveloperName from CustomObject"))
+        object_dataframe['ObjectID'] = object_dataframe.apply(lambda row: row['attributes']['url'].split('/')[-1] if row['attributes']['url'] else "", axis=1)
+        
+        profile_layout_queries = []
+        
+        for object_name in objects_to_retrieve:
+            if object_name in UNQUERIABLE_ENUM_OBJECTS and discard_unqueriable_objects == False:
+                raise Exception("Unqueriable object: " + object_name + ". Please use retrieve_profile_layout_record_type_matrix_all() instead or set discard_unqueriable_objects parameter to True")
+            elif object_name in ENUM_OBJECTS:
+                profile_layout_queries.append("Select LayoutId, ProfileId, Profile.Name, RecordTypeId, RecordType.Name, Layout.Name, TableEnumOrId from ProfileLayout where TableEnumOrId = '" + object_name + "'")
+            else:
+                object_id = object_dataframe[object_dataframe['DeveloperName'] == object_name]['ObjectID'].values[0]
+                profile_layout_queries.append(f"Select LayoutId, ProfileId, Profile.Name, RecordTypeId, RecordType.Name, Layout.Name, TableEnumOrId from ProfileLayout where TableEnumOrId = '{object_id}'")
+        
+        
+        async_tooling_query_all = async_wrap(self.tooling_query_all)
+        
+        
+        await_results = await asyncio.gather(*[async_tooling_query_all(query) for query in profile_layout_queries])
+        
+        await_result_dataframe = [transform_sf_result_set_rec(result) for result in await_results if len(result) > 0]
+        
+        account_page_layouts_bulk = pd.concat(await_result_dataframe)
+
+        account_page_layouts_bulk['ProfileName'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.Profile']['Name'] if row['ProfileLayout.Profile'] else "", axis=1)
+        account_page_layouts_bulk['RecordTypeName'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.RecordType']['Name'] if row['ProfileLayout.RecordType'] else "", axis=1)
+        account_page_layouts_bulk['PageLayout'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.Layout']['Name'] if row['ProfileLayout.Layout'] else "", axis=1)
+        account_page_layouts_bulk.drop(['ProfileLayout.Profile','ProfileLayout.RecordType','ProfileLayout.Layout'], axis=1, inplace=True)
+
+        object_dataframe['ObjectID'] = object_dataframe.apply(lambda row: row['attributes']['url'].split('/')[-1] if row['attributes']['url'] else "", axis=1)
+
+        account_page_layouts_bulk = account_page_layouts_bulk.merge(object_dataframe, left_on='ProfileLayout.TableEnumOrId', right_on='ObjectID', how='left').copy()
+        account_page_layouts_bulk['DeveloperName'] = account_page_layouts_bulk.apply(lambda row: row['DeveloperName'] if pd.notnull(row['DeveloperName']) else row['ProfileLayout.TableEnumOrId'], axis=1)
+        account_page_layouts_bulk.drop(['attributes'], axis=1, inplace=True)
+        
+        # Fill in the RecordTypeName colum with the Master Record Type Name
+        account_page_layouts_bulk['RecordTypeName'] = account_page_layouts_bulk['RecordTypeName'].apply(lambda row: row if row else 'Master')
+        # Filter out Deprecated Profiles
+        account_page_layouts_bulk = account_page_layouts_bulk[(~account_page_layouts_bulk['ProfileName'].isnull()) & (account_page_layouts_bulk['ProfileName'] != '') & (account_page_layouts_bulk['PageLayout'] != 'Veeva Vpro Unit Testing Layout')].copy()
+        
+        if self.instance.__contains__("my.salesforce.com"):
+            sf_meta_instance = self.instance.replace(".my.salesforce.com","")
+        else:
+            sf_meta_instance = ".".join(self.instance.split(".")[:1])
+        
+        account_page_layouts_bulk['Edit Link'] = account_page_layouts_bulk.apply(lambda row: "https://" + sf_meta_instance + ".lightning.force.com/lightning/setup/ObjectManager/" + (row['DeveloperName'] if str(row['ObjectID']) == 'nan' else row['ObjectID']) + "/PageLayouts/" + row['ProfileLayout.LayoutId'] + "/view", axis=1)
+        
+        if return_pivot_table:
+            return account_page_layouts_bulk.pivot(index='ProfileName', columns=['DeveloperName','RecordTypeName'], values='PageLayout')
+        else:
+            return account_page_layouts_bulk
+
+    async def field_permission_user_check(self, objects: list[str], permissions: list[str], users=None) -> pd.DataFrame:
+        # Similar to the field_permission_check function, but this one will return a list of users that have the specified permission on the specified object
+        
+        # this is to avoid having a mutable default argument
+        users = [] if users is None else users
+        
+        object_query = "','".join(objects)
+        permission_query = ' OR '.join([f"({permission} = true)" for permission in permissions])
+
+        relevant_ps_and_profiles = transform_sf_result_set_rec(self.sf.query_all(f"""
+                                                SELECT ParentId,
+                                                        Field,
+                                                        PermissionsEdit,
+                                                        PermissionsRead
+                                                FROM FieldPermissions
+                                                WHERE SObjectType IN ('{object_query}') AND
+                                                ({permission_query})
+                                                """)['records'])
+
+        relevant_ps_and_profiles['Object API Name'] = relevant_ps_and_profiles['FieldPermissions.Field'].apply(lambda row: row.split('.')[0])
+        relevant_ps_and_profiles['Field API Name'] = relevant_ps_and_profiles['FieldPermissions.Field'].apply(lambda row: row.split('.')[1])
+        relevant_ps_and_profiles.drop(columns=['FieldPermissions.Field'], inplace=True)
+
+        user_query = (" AND Assignee.UserName IN ('" + "','".join(users) + "')") if len(users) > 0 else ""
+
+        relevant_ps_and_profiles_list = "','".join(relevant_ps_and_profiles['FieldPermissions.ParentId'].unique().tolist())
+
+        data = transform_sf_result_set_rec(self.sf.query_all(f"""SELECT Assignee.Id, Assignee.Name,Assignee.IsActive, 
+                                                                Assignee.UserName, PermissionSet.Id, 
+                                                                PermissionSet.isOwnedByProfile, PermissionSet.Profile.Name, PermissionSet.Label
+                                                                FROM PermissionSetAssignment
+                                                                WHERE PermissionSetId
+                                                                IN ('{relevant_ps_and_profiles_list}')
+                                                                {user_query} AND Assignee.IsActive = TRUE""")['records'])
+        
+        if len(data) == 0:
+            return pd.DataFrame(columns=['UserName', 'Profile', 'Field API Name', 'Object API Name','Permission', 'Permission Set'])
+        
+        # Retrieve Profile FLS data
+        profiles = data[data['PermissionSet.IsOwnedByProfile']]['Profile.Name'].unique().tolist()
+        profiles = ['Admin' if x == 'System Administrator' else x for x in profiles]
+
+
+        async_metadata_read = async_wrap(self.metadata_read)
+        profile_metadata_tasks = {}
+        profile_metadata_dict = {}
+
+        for profile in profiles:
+                profile_metadata_tasks[profile] = asyncio.create_task(async_metadata_read('Profile', profile))
+
+
+        task_result_list = await asyncio.gather(*profile_metadata_tasks.values())
+
+
+        for profile in profiles:
+                profile_metadata_dict["System Administrator" if profile == 'Admin' else profile] = pd.DataFrame(task_result_list[profiles.index(profile)]['fieldPermissions'][0])
+    
+        data = data.merge(relevant_ps_and_profiles, left_on='PermissionSet.Id', right_on='FieldPermissions.ParentId', how='left').copy()
+        if (len(data) > 0):
+                
+                profile_violations = data[data['PermissionSet.IsOwnedByProfile']== True][['User.Username', 'Profile.Name']].drop_duplicates().copy()
+                # profile_violations = data[data['PermissionSet.IsOwnedByProfile']== True][['User.Username', 'Profile.Name','Field API Name']]
+                profile_metadata_pd = pd.concat(profile_metadata_dict.values(), keys=profile_metadata_dict.keys(), names=['Profile', 'Index']).reset_index(level=1, drop=True).reset_index()
+                profile_metadata_pd.rename(columns={'Profile': 'Profile.Name'}, inplace=True)
+                profile_metadata_pd['Field API Name'] = profile_metadata_pd['field'].str.split('.').str[1]
+                profile_metadata_pd['Object API Name'] = profile_metadata_pd['field'].str.split('.').str[0]
+                profile_metadata_pd = profile_metadata_pd[profile_metadata_pd['Object API Name'].isin(objects)].copy()
+                profile_metadata_pd.drop(columns=['field'], inplace=True)
+
+                # if permission == 'PermissionsEdit':
+                #         profile_metadata_pd = profile_metadata_pd[profile_metadata_pd['editable'] == True].copy()
+                #         profile_metadata_pd.drop(columns=['editable', 'readable'], inplace=True)
+                # elif permission == 'PermissionsRead':
+                #         profile_metadata_pd = profile_metadata_pd[profile_metadata_pd['readable'] == True].copy()
+                #         profile_metadata_pd.drop(columns=['editable', 'readable'], inplace=True)
+                
+                profile_violations = profile_violations.merge(profile_metadata_pd, on='Profile.Name', how='left').copy()
+                profile_editable = profile_violations[profile_violations['editable'] == True].drop(columns=['editable','readable']).copy()
+                profile_editable['Permission'] = 'PermissionsEdit'
+                profile_readable = profile_violations[profile_violations['readable'] == True].drop(columns=['editable','readable']).copy()
+                profile_readable['Permission'] = 'PermissionsRead'
+
+                profile_fls_final = pd.concat([profile_editable, profile_readable])
+                profile_fls_final.columns = ['UserName','Profile','Field API Name','Object API Name','Permission']
+                
+                permission_set_violations = data[data['PermissionSet.IsOwnedByProfile']== False][['User.Username', 'PermissionSet.Label', 'Object API Name', 'FieldPermissions.PermissionsEdit','FieldPermissions.PermissionsRead','Field API Name']]
+                
+                ps_editable = permission_set_violations[permission_set_violations['FieldPermissions.PermissionsEdit'] == True].drop(columns=['FieldPermissions.PermissionsEdit','FieldPermissions.PermissionsRead']).copy()
+                ps_editable['Permission'] = 'PermissionsEdit'
+                ps_readable = permission_set_violations[permission_set_violations['FieldPermissions.PermissionsRead'] == True].drop(columns=['FieldPermissions.PermissionsEdit','FieldPermissions.PermissionsRead']).copy()
+                ps_readable['Permission'] = 'PermissionsRead'
+                
+                ps_fls_final = pd.concat([ps_editable, ps_readable])
+                ps_fls_final.columns = ['UserName','Permission Set','Object API Name','Field API Name', 'Permission']
+                
+                return pd.merge(profile_fls_final, ps_fls_final, on=['UserName','Object API Name', 'Field API Name','Permission'], how='outer')
+        else:
+                return pd.DataFrame(columns=['UserName', 'Profile', 'Field API Name', 'Object API Name','Permission', 'Permission Set'])
+
+    async def retrieve_user_profile_metadata(self, username: str):
+        profile_metadata = pd.DataFrame(zeep.helpers.serialize_object(self.metadata_list("Profile")))
+        profile_metadata = profile_metadata[['id', 'fullName']].copy()
+        profile_metadata
+        user_profile_id = transform_sf_result_set_rec(self.sf.query_all(f"Select Id, ProfileId FROM User WHERE Username = '{username}'")['records'])
+        if len(profile_metadata[profile_metadata['id'] == user_profile_id['User.ProfileId'].values[0]]['fullName']) == 0:
+            raise Exception("User does not have a retrievable / valid profile")
+        else:
+            user_profile = profile_metadata[profile_metadata['id'] == user_profile_id['User.ProfileId'].values[0]]['fullName'].values[0]
+
+        async_profile_read = async_wrap(self.metadata_read)
+        
+        user_profile_metadata = await async_profile_read('Profile', user_profile)
+
+        return user_profile_metadata
+
+    async def retrieve_user_profile_record_type_details(self, username: str, objects: list[str]):
+        
+        profile_metadata = pd.DataFrame(zeep.helpers.serialize_object(self.metadata_list("Profile")))
+        profile_metadata = profile_metadata[['id', 'fullName']].copy()
+        profile_metadata
+        user_profile_id = transform_sf_result_set_rec(self.sf.query_all(f"Select Id, ProfileId FROM User WHERE Username = '{username}'")['records'])
+        if len(profile_metadata[profile_metadata['id'] == user_profile_id['User.ProfileId'].values[0]]['fullName']) == 0:
+            raise Exception("User does not have a retrievable / valid profile")
+        else:
+            user_profile = profile_metadata[profile_metadata['id'] == user_profile_id['User.ProfileId'].values[0]]['fullName'].values[0]
+
+        async_profile_read = async_wrap(self.metadata_read)
+        
+        user_profile_metadata = async_profile_read('Profile', user_profile)
+        
+        results = {}
+        
+        async_object_describe = async_wrap(self.object_describe)
+        
+        tasks = {}
+        
+        for object in objects:
+            tasks[object] = async_object_describe(object)
+        tasks['get_profile_data'] = user_profile_metadata
+        
+        task_result_list = await asyncio.gather(*tasks.values())
+        
+        task_result_dict = {}
+        
+        for object in objects:
+            task_result_dict[object] = task_result_list[objects.index(object)]
+            
+        task_result_dict['get_profile_data'] = task_result_list[-1]
+        
+        user_rt_visibilities = pd.DataFrame(task_result_dict['get_profile_data']['recordTypeVisibilities'][0])
+        user_rt_visibilities['Object'] = user_rt_visibilities['recordType'].apply(lambda x: x.split('.')[0])
+        user_rt_visibilities['RecordType'] = user_rt_visibilities['recordType'].apply(lambda x: x.split('.')[1])
+        
+        for object in objects:
+            if object.lower() == 'account':
+                object_describe = task_result_dict[object]['recordTypeInfos'].T
+                object_record_types = object_describe[object_describe['active'] == True].reset_index()[['name','defaultRecordTypeMapping','developerName','master','recordTypeId']].copy()
+                user_object_rt_visibilities = user_rt_visibilities[(user_rt_visibilities['Object'] == object) | (user_rt_visibilities['Object'] == 'PersonAccount')][['default','personAccountDefault','Object','RecordType','visible']].copy()
+                
+            else:
+                object_describe = task_result_dict[object]['recordTypeInfos'].T
+                object_record_types = object_describe[object_describe['active'] == True].reset_index()[['name','defaultRecordTypeMapping','developerName','master','recordTypeId']].copy()
+                user_object_rt_visibilities = user_rt_visibilities[user_rt_visibilities['Object'] == object][['default','personAccountDefault','Object','RecordType','visible']].copy()
+
+            object_rt_visibility_with_master = pd.merge(user_object_rt_visibilities, object_record_types, left_on='RecordType', right_on='developerName', how='outer')
+            object_rt_visibility_with_master['visible'].fillna(False, inplace=True)
+            if not object_rt_visibility_with_master['visible'].any():
+                object_rt_visibility_with_master.loc[object_rt_visibility_with_master['developerName'] == 'Master', 'visible'] = True
+            if not object_rt_visibility_with_master['default'].any():
+                object_rt_visibility_with_master.loc[object_rt_visibility_with_master['developerName'] == 'Master', 'default'] = True
+                
+            visible_object_rt = object_rt_visibility_with_master[object_rt_visibility_with_master['visible'] == True].drop(['defaultRecordTypeMapping'], axis=1)
+            results[object] = visible_object_rt
+        
+        return results
+    
+    
+    async def permissionable_fields_bulk_check(self, object_list):
+        permissionable_fields = {}
+        nonpermissionable_fields = {}
+        async_permissionable_fields =  async_wrap(self.object_describe)
+        async_metadata_read = async_wrap(self.metadata_read)
+        
+        
+        task_dict = {}
+        task_result_dict = {}
+        
+        for object_name in object_list:
+            task_dict[object_name] = async_permissionable_fields(object_name)
+            task_dict[object_name + '_metadata'] = async_metadata_read('CustomObject', object_name)
+            
+        task_results = await asyncio.gather(*task_dict.values())
+        
+        for object_name, task_result in zip(task_dict.keys(), task_results):
+            task_result_dict[object_name] = task_result
+        
+        
+        for object in object_list:
+            permissionable_fields[object] = pd.DataFrame(task_result_dict[object + "_metadata"]['fields'][0])['fullName'].to_list()
+            
+            nonpermissionable_fields[object] = task_result_dict[object]['fields'].T[task_result_dict[object]['fields'].T['permissionable'] == False].index.tolist()
+        return permissionable_fields, nonpermissionable_fields, task_result_dict
+    
+    async def get_layout_metadata(self, layout_name):
+        # Layout Name is the Object API Name + Page Layout Name of the layout, for example:
+        # Account-Hospital Department
+        
+        async_metadata_read = async_wrap(self.metadata_read)
+        
+        layout_metadata = await async_metadata_read('Layout', layout_name)
+        
+        def parse_layoutSections(layout_metadata):
+            layoutSections = pd.DataFrame(layout_metadata)
+            layoutSections['layoutColumns'] = layoutSections['layoutColumns'].apply(lambda row: list(filter(lambda item: item is not None, row)))
+            layoutSections = layoutSections.explode('layoutColumns').reset_index(drop=True)
+            layoutSections['layoutColumns'] = layoutSections['layoutColumns'].apply(lambda row: "" if str(row) == 'nan' else row['layoutItems'])
+            layoutSections = layoutSections.explode('layoutColumns').reset_index(drop=True)
+            layoutSections = pd.concat([layoutSections, layoutSections['layoutColumns'].apply(pd.Series, dtype=str).add_prefix('layoutColumns.')], axis=1)
+            if 'layoutColumns.0' in layoutSections.columns:
+                # drop 'layoutColumns.0' column if it exists
+                layoutSections.drop(['layoutColumns.0'], axis=1, inplace=True)
+            
+            if 'layoutColumns' in layoutSections.columns:
+                layoutSections.drop(['layoutColumns'], axis=1, inplace=True)
+
+            layoutSections.fillna("", inplace=True)
+            layoutSections.drop_duplicates(inplace=True)
+            return layoutSections
+
+        def parse_platformActionList(platformActionList_metadata):
+            platformActionList = pd.DataFrame(platformActionList_metadata)
+            platformActionList = pd.concat([platformActionList, platformActionList['platformActionListItems'].apply(pd.Series, dtype=str).add_prefix('platformActionListItems.')], axis=1).drop(['platformActionListItems'], axis=1)
+            return platformActionList
+
+
+        def parse_quickActionList(quickActionList_metadata):
+            quickActionList = pd.DataFrame(quickActionList_metadata)
+            quickActionList = pd.concat([quickActionList, quickActionList['quickActionListItems'].apply(pd.Series, dtype=str).add_prefix('quickActionListItems.')], axis=1).drop(['quickActionListItems'], axis=1)
+            return quickActionList
+
+        parsed_layout_metadata = {}
+        parsed_layout_metadata['customButtonsList'] = layout_metadata['customButtons'][0]
+        parsed_layout_metadata['excludeButtonsList'] = layout_metadata['excludeButtons'][0]
+        # Adding required fields from the main page layout gives you the final list of mini layout items
+        parsed_layout_metadata['miniLayoutDict'] = dict(layout_metadata['miniLayout'][0]) if layout_metadata['miniLayout'][0] != None else {'fields': [],'relatedLists': []}
+        parsed_layout_metadata['layoutSectionsDataFrame'] = parse_layoutSections(layout_metadata['layoutSections'][0]) if layout_metadata['layoutSections'][0] != None else pd.DataFrame()
+        parsed_layout_metadata['platformActionListDataFrame'] = parse_platformActionList(layout_metadata['platformActionList'][0]) if layout_metadata['platformActionList'][0] != None else pd.DataFrame()
+        parsed_layout_metadata['quickActionListDataFrame'] = parse_quickActionList(layout_metadata['quickActionList'][0]) if layout_metadata['quickActionList'][0] != None else pd.DataFrame()
+        parsed_layout_metadata['relatedListDataFrame'] = pd.DataFrame(layout_metadata['relatedLists'][0]) if layout_metadata['relatedLists'][0] != None else pd.DataFrame()
+        return parsed_layout_metadata
+
+    async def get_all_reports_metadata(self):
+        """
+        Asynchronously fetches metadata for all reports from Salesforce.
+
+        This function retrieves the metadata for all reports stored in Salesforce.
+        It first gathers a list of all report folders and then fetches metadata for 
+        each report in these folders. The function uses async operations to improve 
+        performance by fetching metadata for multiple reports concurrently. The 
+        results are then concatenated into a single DataFrame for easier processing.
+
+        Returns:
+            pandas.DataFrame: A DataFrame containing the metadata for all reports. 
+                              The DataFrame is reset indexed for convenience.
+        
+        Raises:
+            Exception: Any exception raised during metadata retrieval will result 
+                       in an empty list for `report_folder_full_names`.
+        """
+        
+        try:
+            report_folder_full_names = [folder['fullName'] for folder in  self.sf.mdapi.list_metadata(self.sf.mdapi.ListMetadataQuery(type='ReportFolder'))]
+        except:
+            report_folder_full_names = []
+
+
+        async_metadata_list = async_wrap(self.sf.mdapi.list_metadata)
+
+        task_list = []
+        for report_folder in report_folder_full_names:
+            list_metadata_query = self.sf.mdapi.ListMetadataQuery(type="Report", folder=report_folder)
+            task_list.append(async_metadata_list(list_metadata_query))
+
+        report_metadata_list = await asyncio.gather(*task_list)
+
+        report_metadata_list = [item for sublist in report_metadata_list for item in sublist]
+
+        async_metadata_read = async_wrap(self.metadata_read)
+
+        task_list = []
+        for report_details in report_metadata_list:
+            task_list.append(async_metadata_read('Report', report_details['fullName']))
+
+        report_metadata_result_list = await asyncio.gather(*task_list)
+
+        all_report_metadata = pd.concat(report_metadata_result_list).reset_index(drop=True)
+        
+        return all_report_metadata
+
+
+    ### ----------------------------------------------------------------------------------------------------
+    ### Synchronous Metadata Functions
+    ### ----------------------------------------------------------------------------------------------------
+
+    def object_describe(self, sobject_api_name: str, export_excel: bool=False):
+        """
+
+        """
+        sfSchema = getattr(self.sf, sobject_api_name).describe()
+        boolMetadata = {}
+        nonetypeMetadata = {}
+        strMetadata = {}
+        orderedDictMetadata = pd.Series(dtype='object')
+        childRelationshipsPD = pd.DataFrame()
+        recordTypeInfosPD = pd.DataFrame()
+        fieldsPD = pd.DataFrame()
+        supportedScopesPD = pd.DataFrame()
+        namedLayoutInfosPD = pd.DataFrame()
+        actionOverridesPD = pd.DataFrame()
+
+        for metadata in sfSchema:
+            ## Processes all metadata that would return a boolean datatype
+            if type(sfSchema[metadata]) is bool:
+                boolMetadata[metadata] = sfSchema[metadata]
+
+            ## Processes all metadata that would return a NoneType datatype
+            elif type(sfSchema[metadata]) == type(None):
+                nonetypeMetadata[metadata] = sfSchema[metadata]
+
+            ## Processes all metadata that would return a string datatype
+            elif type(sfSchema[metadata]) is str:
+                strMetadata[metadata] = sfSchema[metadata]
+            ## Processes all metadata that would return an OrderedDict data type
+            elif type(sfSchema[metadata]) is OrderedDict and len(sfSchema[metadata]) != 0:
+                orderedDictMetadata = pd.concat([orderedDictMetadata,pd.Series(sfSchema['urls'])])
+            elif type(sfSchema[metadata]) is OrderedDict and len(sfSchema[metadata]) == 0:
+                nonetypeMetadata[metadata] = "None"
+
+            ## Processes all metadata that would return a list data type
+            elif type(sfSchema[metadata]) is list and len(sfSchema[metadata]) != 0:
+                if metadata == 'childRelationships':
+                    childRelationshipsPD = pd.DataFrame(sfSchema['childRelationships'], index = pd.DataFrame(sfSchema['childRelationships'])['field'])
+                    childRelationshipsPD = childRelationshipsPD.drop('field', axis=1).T
+                if metadata == 'recordTypeInfos':
+                    recordTypeInfosPD = pd.DataFrame(sfSchema['recordTypeInfos'], index = pd.DataFrame(sfSchema['recordTypeInfos'])['name'])
+                    recordTypeInfosPD = recordTypeInfosPD.drop('name', axis = 1).T  
+                if metadata == 'fields':
+                    fieldsPD = pd.DataFrame(sfSchema['fields'], index = pd.DataFrame(sfSchema['fields'])['name'])
+                    fieldsPD = fieldsPD.drop('name', axis = 1).T
+                if metadata == 'supportedScopes':
+                    supportedScopesPD = pd.DataFrame(sfSchema['supportedScopes'], index = pd.DataFrame(sfSchema['supportedScopes'])['name'])
+                    supportedScopesPD = supportedScopesPD.drop('name', axis = 1).T
+                if metadata == 'actionOverrides':
+                    actionOverridesPD = pd.DataFrame(sfSchema['actionOverrides'], index = pd.DataFrame(sfSchema['actionOverrides'])['name'])
+                    actionOverridesPD = actionOverridesPD.drop('name', axis = 1).T
+                if metadata == 'namedLayoutInfos':
+                    namedLayoutInfosPD = pd.DataFrame(sfSchema['namedLayoutInfos'], index = pd.DataFrame(sfSchema['namedLayoutInfos'])['name'])
+                    namedLayoutInfosPD = namedLayoutInfosPD.drop('name', axis = 1).T
+            ## Parses all empty list metadata
+            elif type(sfSchema[metadata]) is list and len(sfSchema[metadata]) == 0:
+                nonetypeMetadata[metadata] = "None"
+            else:
+                nonetypeMetadata[metadata] = "Unrecognized metadata type: " + metadata
+
+        output = {'metadata': pd.concat([pd.Series(nonetypeMetadata),
+                    pd.Series(boolMetadata),
+                    pd.Series(strMetadata),
+                    orderedDictMetadata]),
+                    'childRelationships': childRelationshipsPD if len(childRelationshipsPD)!=0 else None,
+                    'recordTypeInfos': recordTypeInfosPD if len(recordTypeInfosPD)!=0 else None,
+                    'fields': fieldsPD if len(fieldsPD)!=0 else None,
+                    'supportedScopes': supportedScopesPD if len(supportedScopesPD)!=0 else None, 
+                    'namedLayoutInfos': namedLayoutInfosPD if len(namedLayoutInfosPD)!=0 else None,
+                    'actionOverrides': actionOverridesPD if len(actionOverridesPD)!=0 else None}
+        if export_excel:
+            with pd.ExcelWriter(sobject_api_name + ' describe output.xlsx') as writer:  
+                for key in output.keys():
+                    try:
+                        pd.DataFrame(output[key]).to_excel(writer, sheet_name=key)
+                    except:
+                        continue
+
+        return output
+
+    def field_describe(self, objects: List = ['Account','Address_vod__c','Child_Account_vod__c'], 
+    attributes: List = ['name','type','length']) -> pd.DataFrame:
+        """
+        Returns a dataframe of the field metadata for the specified objects and attributes.
+
+        Parameters
+        ----------
+        objects : List, optional
+            A list of objects to get field metadata for. The default is ['Account','Address_vod__c','Child_Account_vod__c'].
+        attributes : List, optional
+            A list of attributes to get field metadata for. The default is ['name','type','length'].
+            For a full list of attributes, see 
+            https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_describesobjects_describesobjectresult.htm
+            A list of attributes can also be found by using the object_describe() method's field attribute.
+
+        Returns
+        -------
+        pd.DataFrame
+            A dataframe of the field metadata for the specified objects and attributes.
+        
+        """
+        outputList = []
+        columnNames = []
+        for sObjectAPIName in objects:
+            for attribute in attributes:
+                outputList.append([field[attribute] for field in getattr(self.sf, sObjectAPIName).describe()['fields']])
+                if attribute == "name":
+                    columnNames.append(sObjectAPIName)
+                else:
+                    columnNames.append(attribute.title())
+        field_describe = pd.DataFrame(outputList).transpose()
+        field_describe.columns = columnNames
+        return field_describe
+
+    def set_user_password(self, user_id, new_password):
+        result = {}
+        try:
+            result = self.sf_api_call(f'/services/data/{self.api_version}/sobjects/User/{user_id}/password', method='POST', data={'NewPassword': new_password})
+        except Exception as e:
+            message_list = str(e).split(" : ")[1].strip().removeprefix("b'[").removesuffix("]'")
+            result = ast.literal_eval(message_list)
+            result['user_id'] = user_id
+        
+        if len(result) == 0:
+            result = {'user_id': user_id,'message': 'success',  'errorCode': None}
+        return result
+        
+
+    def picklist_dataframe_stacked(self,objects: List =['Account','Address_vod__c','Child_Account_vod__c']) -> pd.DataFrame:
+        """
+        TODO:
+        
+        Description of what it does
+        
+        Description of arguments and data types
+        
+        Description of return values and data types
+        
+        Description of Errors raised
+        
+        Extra Notes and Examples of Usage
+        """
+        output_df = pd.DataFrame()
+        for object in objects:
+            objectDescribe = getattr(self.sf, object).describe()
+            processing_df = pd.DataFrame(pd.DataFrame([pd.Series(data = [picklist['value'] for picklist in field['picklistValues']], 
+                                                                   name = object + "." + field["name"]) for field in objectDescribe['fields'] if field['type'] == 'picklist']).stack())
+            processing_df.columns = ['Picklist API Value']
+            processing_df['CRM Object and Field API'] = processing_df.index.get_level_values(0)
+            processing_df[['CRM Object API','CRM Field API']] = processing_df['CRM Object and Field API'].str.split(".", expand = True)
+            processing_df.reset_index(drop=True, inplace=True)
+            output_df = pd.concat([output_df,processing_df])
+        return output_df
+
+    def picklist_dataframe(self,objects = ['Account','Address_vod__c','Child_Account_vod__c']) -> List:
+        """
+        TODO:
+        
+        Description of what it does
+        
+        Description of arguments and data types
+        
+        Description of return values and data types
+        
+        Description of Errors raised
+        
+        Extra Notes and Examples of Usage
+        """
+        referenceList = []
+        for object in objects:
+            objectDescribe = getattr(self.sf, object).describe()
+            objectPicklistValues = pd.DataFrame(index=range(0,max(len(field["picklistValues"]) for field in objectDescribe['fields'] if field['type'] == 'picklist')))
+            for x in [pd.Series(data = [picklist['value'] for picklist in field['picklistValues']], name = object + "." + field["name"]) for field in objectDescribe['fields'] if field['type'] == 'picklist']:
+                objectPicklistValues.insert(0, str(x.name), x)
+            referenceList.append(objectPicklistValues)
+        return referenceList
+
+    def record_type_retrieval(self, objectAPIName, fieldAPINames = ["Id","Name",'SobjectType', 'IsActive']):
+        """
+        TODO:
+        
+        Description of what it does
+        
+        Description of arguments and data types
+        
+        Description of return values and data types
+        
+        Description of Errors raised
+        
+        Extra Notes and Examples of Usage
+        """
+        sfRTDF = pd.DataFrame(self.sf.query_all("SELECT "+ ",".join(fieldAPINames) + " from RecordType WHERE SobjectType = '" + objectAPIName + "'")['records'])
+        
+        # If only master RT exists
+        if len(sfRTDF) == 0:
+            master_rt = {
+                "Name": "Master",
+                "DeveloperName": "Master",
+                "IsActive": True,
+            }
+
+            sfRTDF = pd.DataFrame(master_rt, index=[0])
+        else:
+            sfRTDF.drop(columns="attributes", inplace = True)
+        return sfRTDF
+
+    def object_permission_check(self, object, permission):
+        data = transform_sf_result_set_rec(self.sf.query_all(f"""SELECT Assignee.Id, Assignee.Name,Assignee.IsActive, Assignee.UserName, PermissionSet.Id, PermissionSet.isOwnedByProfile, PermissionSet.Profile.Name, PermissionSet.Label
+            FROM PermissionSetAssignment
+            WHERE PermissionSetId
+            IN (SELECT ParentId
+            FROM ObjectPermissions
+            WHERE SObjectType IN ('{object}') AND
+            ({permission} = true)) AND Assignee.IsActive = TRUE""")['records'])
+        
+        profile_violations = data[data['PermissionSet.IsOwnedByProfile']== True][['User.Username', 'Profile.Name']]
+        permission_set_violations = data[data['PermissionSet.IsOwnedByProfile']== False][['User.Username', 'PermissionSet.Label']]
+        result = []
+        for user in profile_violations['User.Username'].unique():
+            result.append({"UserName": user, 
+                            "Object API Name" : object,
+                            "Permission": permission,
+                            "Profile": "; ".join(list(profile_violations[profile_violations['User.Username'] == user]['Profile.Name'].unique())),
+                            "Permission Set": ""
+                        
+                        }
+                        
+                        )
+            
+        for user in permission_set_violations['User.Username'].unique():
+            result.append({"UserName": user, 
+                                                            "Object API Name" : object,
+                                                            "Permission": permission,
+                                                            "Profile": "",
+                                                            "Permission Set": "; ".join(list(permission_set_violations[permission_set_violations['User.Username'] == user]['PermissionSet.Label'].unique()))})
+        return result
+
+    def field_permission_check(self, object) -> dict[str, pd.DataFrame]:
+        fls_results = transform_sf_result_set_rec(self.sf.query_all(f"""
+                                            SELECT Field,
+                                            ParentId,
+                                            PermissionsEdit,
+                                            PermissionsRead,
+                                            SobjectType FROM FieldPermissions
+                                            WHERE SobjectType in ('{object}')
+                                            """)['records'])
+
+        permissionSetProfiles = transform_sf_result_set_rec(self.sf.query_all("""
+                                                    SELECT Id,Description,IsOwnedByProfile,Name,ProfileId, 
+                                                    Profile.Name, Profile.Description,Type FROM PermissionSet
+                                                    """)['records'])
+
+        profiles = permissionSetProfiles[permissionSetProfiles['PermissionSet.IsOwnedByProfile'] == True][['PermissionSet.ProfileId','PermissionSet.Id','Profile.Name','Profile.Description']].copy()
+        permissionSets = permissionSetProfiles[permissionSetProfiles['PermissionSet.IsOwnedByProfile'] == False][['PermissionSet.Id','PermissionSet.Name','PermissionSet.Description']].copy()
+
+        permissionSetPermissions = pd.merge(fls_results, permissionSets, left_on='FieldPermissions.ParentId', right_on='PermissionSet.Id', how='inner').drop(columns=['PermissionSet.Id'], axis=1)
+        permissionSetPermissions.columns = ['Field API Name', 'Permission Set Id', 'FLS Edit', 'FLS Read', 'Object API Name', 'Permission Set Name', 'Permission Set Description']
+        permissionSetPermissions = permissionSetPermissions[['Permission Set Id', 'Permission Set Name', 'Permission Set Description', 'Object API Name', 'Field API Name', 'FLS Edit', 'FLS Read']]
+        permissionSetPermissions['Field API Name'] = permissionSetPermissions['Field API Name'].apply(lambda x: x.split('.')[-1])
+
+
+        profilePermissions = pd.merge(fls_results, profiles, left_on='FieldPermissions.ParentId', right_on='PermissionSet.Id', how='inner').drop(columns=['PermissionSet.Id','FieldPermissions.ParentId'], axis=1)
+        profilePermissions.columns = ['Field API Name', 'FLS Edit', 'FLS Read', 'Object API Name','Profile Id',  'Profile Name', 'Profile Description']
+        profilePermissions = profilePermissions[['Profile Id', 'Profile Name', 'Profile Description', 'Object API Name', 'Field API Name', 'FLS Edit', 'FLS Read']]
+        profilePermissions['Field API Name'] = profilePermissions['Field API Name'].apply(lambda x: x.split('.')[-1])
+        
+        return {'permissionSetPermissions': permissionSetPermissions, 'profilePermissions': profilePermissions}
+
+
+    # Retrieves the Page Layout by Profile by Record Type data for all objects in the org
+    def retrieve_profile_layout_record_type_matrix_all(self, return_pivot_table = False):
+        account_page_layouts_bulk = transform_sf_result_set_rec(self.tooling_query_all("""select LayoutId, 
+                                                                                    ProfileId, Profile.Name, 
+                                                                                    RecordTypeId, RecordType.Name, 
+                                                                                    Layout.Name, TableEnumOrId from 
+                                                                                    ProfileLayout"""))
+
+        account_page_layouts_bulk['ProfileName'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.Profile']['Name'] if row['ProfileLayout.Profile'] else "", axis=1)
+        account_page_layouts_bulk['RecordTypeName'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.RecordType']['Name'] if row['ProfileLayout.RecordType'] else "", axis=1)
+        account_page_layouts_bulk['PageLayout'] = account_page_layouts_bulk.apply(lambda row: row['ProfileLayout.Layout']['Name'] if row['ProfileLayout.Layout'] else "", axis=1)
+        account_page_layouts_bulk.drop(['ProfileLayout.Profile','ProfileLayout.RecordType','ProfileLayout.Layout'], axis=1, inplace=True)
+
+
+        object_dataframe = pd.DataFrame(self.tooling_query_all("Select DeveloperName from CustomObject"))
+        object_dataframe['ObjectID'] = object_dataframe.apply(lambda row: row['attributes']['url'].split('/')[-1] if row['attributes']['url'] else "", axis=1)
+
+
+        account_page_layouts_bulk = account_page_layouts_bulk.merge(object_dataframe, left_on='ProfileLayout.TableEnumOrId', right_on='ObjectID', how='left').copy()
+        account_page_layouts_bulk['DeveloperName'] = account_page_layouts_bulk.apply(lambda row: row['DeveloperName'] if pd.notnull(row['DeveloperName']) else row['ProfileLayout.TableEnumOrId'], axis=1)
+        account_page_layouts_bulk.drop(['ObjectID','attributes'], axis=1, inplace=True)
+            
+        # Fill in the RecordTypeName colum with the Master Record Type Name
+        account_page_layouts_bulk['RecordTypeName'] = account_page_layouts_bulk['RecordTypeName'].apply(lambda row: row if row else 'Master')
+        # Filter out Deprecated Profiles
+        account_page_layouts_bulk = account_page_layouts_bulk[(~account_page_layouts_bulk['ProfileName'].isnull()) & (account_page_layouts_bulk['ProfileName'] != '') & (account_page_layouts_bulk['PageLayout'] != 'Veeva Vpro Unit Testing Layout')]
+        
+        if return_pivot_table:
+            return account_page_layouts_bulk.pivot(index='ProfileName', columns=['DeveloperName','RecordTypeName'], values='PageLayout')
+        else:
+            return account_page_layouts_bulk
+    
+    #######################################################################################
+    # Veeva CRM Server API Functions
+    #######################################################################################
+
+    def load_veeva_common(self):
+        self.veeva_common = self.query("Select * From Veeva_Common_vod__c").to_dict()
+    
+    def load_org_info(self):
+        self.org_info = self.query("Select * From Organization").to_dict()
+        
+    def get_network_admin_sf_user_info(self):
+        
+        if self.veeva_common is None:
+            self.load_veeva_common()
+        
+        if self.org_info is None:
+            self.load_org_info()
+            
+        try:
+            response = requests.get(f"{self.veeva_common['Veeva_Server_vod__c'][0]}/{self.veeva_common['Veeva_Version_vod__c'][0]}?VER={self.veeva_common['Veeva_Version_vod__c'][0]}&SSID={self.session_id}&url=https://{self.instance}/services/Soap/u/24.0/{self.org_info['Id'][0]}&ses={self.session_id}&oType=networkAdmin&event=getSFCredentials")
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to get network admin credentials"}}
+        
+    def get_network_admin_network_user_info(self):
+        
+        if self.veeva_common is None:
+            self.load_veeva_common()
+        
+        if self.org_info is None:
+            self.load_org_info()
+            
+        try:
+            response = requests.get(f"{self.veeva_common['Veeva_Server_vod__c'][0]}/{self.veeva_common['Veeva_Version_vod__c'][0]}?VER={self.veeva_common['Veeva_Version_vod__c'][0]}&SSID={self.session_id}&url=https://{self.instance}/services/Soap/u/24.0/{self.org_info['Id'][0]}&ses={self.session_id}&oType=networkAdmin&event=getNetworkCredentials")
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to get network admin credentials"}}
+
+    def engage_admin_retrieve_groups(self):
+
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+        
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        veeva_server = self.veeva_common['Veeva_Server_vod__c'][0]
+        veeva_version = self.veeva_common['Veeva_Version_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{veeva_server}/{veeva_version}/api/v1/hcpproxy/groups', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage groups"}}
+        
+    def engage_admin_retrieve_users(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        veeva_server = self.veeva_common['Veeva_Server_vod__c'][0]
+        veeva_version = self.veeva_common['Veeva_Version_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{veeva_server}/{veeva_version}/api/v1/hcpproxy/usersinfo', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage users."}}
+
+    def engage_admin_get_license_info(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        veeva_server = self.veeva_common['Veeva_Server_vod__c'][0]
+        veeva_version = self.veeva_common['Veeva_Version_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{veeva_server}/{veeva_version}/api/v1/remoteMeetings/orgs/{self.sfOrgId}', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage license info."}}
+        
+    def engage_meeting_process_admin_retrieve_history(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/epp-service/refresh/records', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage process admin history."}}
+    
+    def engage_meeting_process_admin_retrieve_veeva_crm_connection_management(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/credentials/SalesForce_EPP?systemId={self.sfOrgId}', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage process admin Veeva CRM connection management."}}
+        
+    def engage_meeting_process_admin_retrieve_veeva_vault_login_credential_management(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/credentials/Vault_EPP', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage process admin Veeva Vault login credential management."}}
+
+    def engage_metadata_sync_admin_retrieve_vault_connection_management(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/credentials/Vault_Engage', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage metadata sync admin Veeva Vault connection management."}}
+
+    def engage_metadata_sync_admin_retrieve_crm_connection_management(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/credentials/SalesForce_Engage?systemId=00D2g0000000ipMEAQ', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage metadata sync admin CRM connection management."}}
+
+    def engage_metadata_sync_admin_retrieve_activity_debug_log(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/debug-log/collection?count=20&orgId=00D2g0000000ipMEAQ', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage metadata sync admin activity debug log."}}
+
+    def engage_metadata_sync_admin_retrieve_metadata_sync(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/mcservice/status/refresh?count=10&recordType=Engage', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Engage metadata sync admin metadata sync."}}
+        
+    def veeva_process_admin_alerts_status_report(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/email-alert/recipients', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve Veeva process admin alerts status report."}}
+
+    def process_scheduler_get_jobs(self):
+        headers = {
+            "Accept": "application/json, text/plain, */*",
+            "Sfendpoint": f"https://{self.instance.split('.')[0]}--c{'' if self.isSandbox == False else '.sandbox'}.vf.force.com/services/Soap/u/54.0/{self.sfOrgId}",
+            "Sfsession": self.session_id,
+        }
+
+        if self.veeva_common is None:
+            self.load_veeva_common()
+
+        mc_server = self.veeva_common['Multichannel_Server_vod__c'][0]
+        mc_context_root = self.veeva_common['Multichannel_Context_Root_vod__c'][0]
+
+
+        try:
+            response = requests.get(f'{mc_server}/{mc_context_root}/api/v1/scheduler/jobs', headers=headers)
+            return {'status': response.status_code, 'response': response.json()}
+        except:
+            return {'status': 500, 'response': {"error": "Unable to retrieve process scheduler jobs."}}
+
+
+    ##############################################################################################################
+    # UI Functions
+    # Functions that parses UI HTML responses
+    ##############################################################################################################
+    
+
+    async def ui_retrieve_all_installed_packages_and_components(self):
+        from bs4 import BeautifulSoup
+
+        """
+        Asynchronously retrieve all installed packages and their components in the current Salesforce instance.
+
+        This method carries out the following operations:
+        1. Queries the Salesforce Tooling API to obtain details of all installed subscriber packages.
+        2. For each package, the components are retrieved by querying the Salesforce package page using HTTP requests.
+        3. Organizes the extracted package data in a structured manner, flattening nested dictionaries and creating a Pandas DataFrame.
+        4. Merges the package components data with the main package data, providing a comprehensive view.
+        5. Extracts the Salesforce ID for each component from its corresponding link.
+        6. Finally, the method returns a DataFrame containing the detailed info of all installed packages and their associated components.
+
+        Returns:
+            pd.DataFrame: DataFrame with columns representing package and component details such as package namespace, version, and component IDs.
+
+        Dependencies:
+            - Uses Beautiful Soup (bs4) for HTML parsing.
+            - Uses Pandas for data structuring and manipulation.
+            - Assumes Salesforce session and instance details are handled by the class.
+
+        Internal Methods:
+        - `subscriber_package_to_df(data)`: Converts subscriber package data into a DataFrame.
+        - `get_package_components_by_id(package_id, sf_instance)`: Gets package components based on package ID.
+        - `get_all_packages(subscriber_package_df: pd.DataFrame, sf_instance)`: Asynchronously retrieves all package components for given packages.
+
+        Note: This method also handles specific structure of Salesforce pages and can be sensitive to changes on Salesforce's end.
+        """
+        def subscriber_package_to_df(data):
+            # Flattening the nested dictionaries
+            flattened_data = []
+            for entry in data:
+                flattened_entry = {
+                    'Id': entry.get('Id', None),
+                    'SubscriberPackageId': entry.get('SubscriberPackageId', None),
+                    'SubscriberPackage.NamespacePrefix': entry['SubscriberPackage'].get('NamespacePrefix', None),
+                    'SubscriberPackage.Name': entry['SubscriberPackage'].get('Name', None),
+                    'SubscriberPackageVersion.Id': entry['SubscriberPackageVersion'].get('Id', None),
+                    'SubscriberPackageVersion.Name': entry['SubscriberPackageVersion'].get('Name', None),
+                    'SubscriberPackageVersion.MajorVersion': entry['SubscriberPackageVersion'].get('MajorVersion', None),
+                    'SubscriberPackageVersion.MinorVersion': entry['SubscriberPackageVersion'].get('MinorVersion', None),
+                    'SubscriberPackageVersion.PatchVersion': entry['SubscriberPackageVersion'].get('PatchVersion', None),
+                    'SubscriberPackageVersion.BuildNumber': entry['SubscriberPackageVersion'].get('BuildNumber', None),
+                }
+                flattened_data.append(flattened_entry)
+
+            # Convert to Pandas DataFrame
+            df = pd.DataFrame(flattened_data)
+            return df
+
+
+        def get_package_components_by_id(package_id, sf_instance):
+            url = f"https://{sf_instance.instance}/{package_id}"
+
+            headers = {
+                "Cookie": f"sid={sf_instance.session_id};"
+            }
+
+            payload = {
+                "pkgComp": "show",
+                "isdtp": "p1"
+            }
+
+            response = requests.get(url, headers=headers, params=payload)
+
+
+            html_content = response.text
+
+            soup = BeautifulSoup(html_content, 'html.parser')
+            section_title = "Metadata Components Included in Package"
+            metadata_section = soup.find('h3', text=section_title).find_parent('div', class_='bPageBlock')
+
+            # Extract table headers
+            headers = [header.text for header in metadata_section.select('tr.headerRow th')]
+
+            # Appending "Link" to headers
+            headers.append('Link')
+
+            data = []
+
+            # Extract table rows
+            for row in metadata_section.select('tr.dataRow'):
+                cells = row.select('td, th')
+                row_data = [cell.text.strip() for cell in cells]
+                
+                # Check if the cell contains a link and extract it
+                link = cells[1].find('a')
+                row_data.append(link['href'] if link else None)
+                
+                data.append(row_data)
+
+            df = pd.DataFrame(data, columns=headers)
+
+            return df
+
+        subscriber_packages = subscriber_package_to_df(self.tooling_query_all("""
+                            SELECT Id, SubscriberPackageId, SubscriberPackage.NamespacePrefix,
+                            SubscriberPackage.Name, SubscriberPackageVersion.Id,
+                            SubscriberPackageVersion.Name, SubscriberPackageVersion.MajorVersion,
+                            SubscriberPackageVersion.MinorVersion,
+                            SubscriberPackageVersion.PatchVersion,
+                            SubscriberPackageVersion.BuildNumber
+                            FROM InstalledSubscriberPackage
+                            ORDER BY SubscriberPackageId"""))
+
+
+        async def get_all_packages(subscriber_package_df: pd.DataFrame, sf_instance):
+            package_ids = subscriber_package_df['Id'].tolist()
+            
+            async_get_package_components_by_id = async_wrap(get_package_components_by_id)
+            task_list = [async_get_package_components_by_id(package_id, sf_instance) for package_id in package_ids]
+            
+            result_list = await asyncio.gather(*task_list)
+            
+            result_df = None
+            result_dict = {}
+            for package_id, package_components in zip(package_ids, result_list):
+                if result_df is None:
+                    result_df = package_components
+                    # Add Installed Package Id column
+                    result_df['InstalledPackageId'] = package_id
+                else:
+                    # Add Installed Package Id column
+                    package_components['InstalledPackageId'] = package_id
+                    result_df = pd.concat([result_df, package_components])
+            
+            return result_df
+
+
+        all_org_subscriber_packages = await get_all_packages(subscriber_packages, self)
+
+        all_org_subscriber_packages_extended = all_org_subscriber_packages.merge(subscriber_packages[['Id','SubscriberPackage.NamespacePrefix','SubscriberPackage.Name','SubscriberPackageVersion.Name']], 
+                                                left_on='InstalledPackageId', 
+                                                right_on='Id', 
+                                                how='left')
+
+        # gets the 15 charactesr after %27%2F in the link column, this is basically the SFDC ID of the component
+        pattern = r'%27%2F(\w{15})'
+
+        all_org_subscriber_packages_extended['Component ID'] = all_org_subscriber_packages_extended['Link'].str.extract(pattern)
+
+        # Drop ID and Link column
+        all_org_subscriber_packages_extended.drop(columns=['Id','Link'], inplace=True)
+
+        return all_org_subscriber_packages_extended
+
+
+
+    ##############################################################################################################
+    # WSDL Derived Functions
+    ##############################################################################################################
+
+    @serialze_zeep
+    def metadata_read(self, metadata_type: str, fullName: str):
+        return getattr(self.sf.mdapi, metadata_type).read(fullName)
+
+    def metadata_delete(self, metadata_type: str, fullName: str):
+        return getattr(self.sf.mdapi, metadata_type).delete(fullName)
+
+    def metadata_update(self, metadata_type: str, parsed_metadata: dict):
+        mdapi_object = getattr(self.sf.mdapi, metadata_type)()
+        for key in parsed_metadata:
+            setattr(mdapi_object, key, parsed_metadata[key])
+        getattr(self.sf.mdapi, metadata_type).update(mdapi_object)
+        return mdapi_object
+
+    def metadata_create(self, metadata_type: str, parsed_metadata: dict):
+        mdapi_object = getattr(self.sf.mdapi, metadata_type)()
+        for key in parsed_metadata:
+            setattr(mdapi_object, key, parsed_metadata[key])
+        getattr(self.sf.mdapi, metadata_type).create(mdapi_object)
+        return mdapi_object
+
+    def metadata_list(self, metadata_type: str = '', metadata_type_list: list[str] = []) -> list:
+        if len(metadata_type_list) == 0 and metadata_type != '':
+            query = self.sf.mdapi.ListMetadataQuery(type=metadata_type)
+        elif len(metadata_type_list) > 3:
+            raise Exception("You can only query up to 3 metadata types at a time")
+        
+        elif len(metadata_type_list) > 0:
+            query = []
+            for metadata_type in metadata_type_list:
+                query.append(self.sf.mdapi.ListMetadataQuery(type=metadata_type))
+        else:
+            raise Exception("Please populate either metadata_type or metadata_type_list, but not both.")
+        
+        query_response = self.sf.mdapi.list_metadata(query)
+        return query_response
+    
+    def metadata_rename(self, metadata_type: str, previous_name: str, new_name: str): 
+        """
+        Renames the API name of SFDC metadata
+        """
+        getattr(self.sf.mdapi, metadata_type).rename(previous_name, new_name)
+    
+    ### ----------------------------------------------------------------------------------------------------
+    ### Custom Tooling API Methods
+    ### ----------------------------------------------------------------------------------------------------
+    
+    def tooling_query_all(self, query):
+        done = False
+        full_results = []
+        result = self.sf_api_call(f'/services/data/v52.0/tooling/query', method='get', parameters={'q': query})
+        while not done:
+            full_results.extend(result['records'])
+            done = result['done']
+            if not done:
+                result = self.sf_api_call(result['nextRecordsUrl'])
+        return full_results
+
+    ### ----------------------------------------------------------------------------------------------------
+    ### Utility Functions
+    ### ----------------------------------------------------------------------------------------------------
+    def query_performance_feedback(self, query: str):
+        # https://developer.salesforce.com/docs/atlas.en-us.240.0.api_rest.meta/api_rest/dome_query_explain.htm
+        
+        return self.sf_api_call(f'/services/data/{self.api_version}/query?explain={query}')
+    
+    def parse_sf_limits(self, sfdc_limits_result: dict, prefix=None) -> dict:
+        ## Recursively parse the limits result to find the limits that are not 0
+        result = {}
+        for key, item in sfdc_limits_result.items():
+            if set(['Max','Remaining']).issubset(set(item.keys())): 
+                if item['Max'] == 0:
+                    continue
+                else:
+                    result[key if prefix is None else prefix+' - '+key] = dict(zip(['Max','Remaining'],[item['Max'], item['Remaining']]))
+            
+            if len(set(item.keys()) - set(['Max','Remaining'])) > 0:
+                sub_item = item.copy()
+                if 'Max' in sub_item: 
+                    del sub_item['Max']
+                if 'Remaining' in sub_item: 
+                    del sub_item['Remaining']
+                result.update(self.parse_sf_limits(sub_item, prefix=key))
+        return result
+        
+    def sf_api_call(self, action, parameters = {}, method = 'get', data = {}):
+        """
+        Helper function to make calls to Salesforce REST API.
+        Parameters: action (the URL), URL params, method (get, post or patch), data for POST/PATCH.
+        """
+        headers = {
+            'Content-type': 'application/json',
+            'Accept-Encoding': 'gzip',
+            'Authorization': 'Bearer %s' % self.session_id
+        }
+        if method.lower() == 'get':
+            r = requests.request(method, 'https://'+self.instance+action, headers=headers, params=parameters, timeout=30)
+        elif method.lower() in ['post', 'patch']:
+            r = requests.request(method, 'https://'+self.instance+action, headers=headers, json=data, params=parameters, timeout=10)
+        else:
+            # other methods not implemented in this example
+            raise ValueError('Method should be get or post or patch.')
+#         print('Debug: API %s call: %s' % (method, r.url) )
+        if r.status_code < 300:
+            if method=='patch':
+                return None
+            else:
+                try:
+                    return r.json()
+                except:
+                    return {}
+        else:
+            raise Exception('API error when calling %s : %s' % (r.url, r.content))
+
+
+    def join(self, 
+                dataframe, 
+                rt_dataframe, 
+                left_on="", 
+                right_on="", 
+                new_columns=[], 
+                suffix = "_new"):
+        """
+        Joins and appends the Name and DeveloperName columns of record type to the dataframe.
+        The dataframe must contain a column named "RecordTypeId" with the 18 digit SFID of the record type.
+        """
+        df_columns = dataframe.columns.to_list()
+        if right_on not in new_columns:
+            new_columns.insert(0,right_on)
+        dataframe = pd.merge(dataframe, rt_dataframe[new_columns], how = 'inner', 
+                                left_on = left_on,right_on = right_on, suffixes=('', suffix))
+#         dataframe.drop([col for col in dataframe.columns if 'drop' in col], axis=1, inplace=True)
+        return dataframe
```

### Comparing `veevatools-0.1.8/salesforce/utilities/async_utils.py` & `veevatools-0.1.9/salesforce/utilities/async_utils.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-import asyncio
-from functools import wraps, partial
-
-async def async_parallel(func, args):
-    # runs the function(s) in parallel
-    return await asyncio.gather(*[func(arg) for arg in args])
-
-async def async_serial(func, args):
-    # runs the function(s) in serial order, 
-    # awaiting for each iteration's completion before executing the next.
-    return [await func(arg) for arg in args]
-
-def async_wrap(func):
-    @wraps(func)
-    async def run(*args, loop=None, executor=None, **kwargs):
-        if loop is None:
-            loop = asyncio.get_event_loop()
-        pfunc = partial(func, *args, **kwargs)
-        return await loop.run_in_executor(executor, pfunc)
+import asyncio
+from functools import wraps, partial
+
+async def async_parallel(func, args):
+    # runs the function(s) in parallel
+    return await asyncio.gather(*[func(arg) for arg in args])
+
+async def async_serial(func, args):
+    # runs the function(s) in serial order, 
+    # awaiting for each iteration's completion before executing the next.
+    return [await func(arg) for arg in args]
+
+def async_wrap(func):
+    @wraps(func)
+    async def run(*args, loop=None, executor=None, **kwargs):
+        if loop is None:
+            loop = asyncio.get_event_loop()
+        pfunc = partial(func, *args, **kwargs)
+        return await loop.run_in_executor(executor, pfunc)
     return run
```

### Comparing `veevatools-0.1.8/salesforce/utilities/df_utils.py` & `veevatools-0.1.9/salesforce/utilities/df_utils.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,70 +1,70 @@
-import pandas as pd
-from collections import OrderedDict
-from typing import Union, Iterable, final
-
-# ================================================
-# Account Object Functions
-# ================================================
-
-def object_account_drop_personaccount_cols(df: pd.DataFrame) -> pd.DataFrame:
-    # Drops Person Account columns from the DataFrame
-    person_account_list = ['FirstName', 'LastName', 'MiddleName', 'PersonDoNotCall','PersonIndividualId','PersonAssistantName', 'PersonAssistantPhone','PersonBirthdate', 'PersonBirthDate', 'PersonContactId', 'PersonDepartment', 'PersonEmail', 'PersonEmailBouncedDate', 'PersonEmailBouncedReason','PersonHasOptedOutOfFax', 'PersonHasOptedOutOfEmail', 'PersonHomePhone', 'PersonLeadSource', 'PersonMailingAddress', 'PersonMailingCity',
-                           'PersonMailingGeocodeAccuracy', 'PersonMailingLatitude', 'PersonMailingLongitude', 'PersonMailingStreet', 'PersonMobilePhone', 'PersonOtherCity', 'PersonOtherCountry', 'PersonOtherPostalCode', 'PersonOtherState', 'PersonOtherCountryCode', 'PersonOtherStateCode', 'PersonOtherLatitude', 'PersonOtherLongitude', 'PersonOtherPhone', 'PersonOtherStreet', 'PersonTitle', 'Suffix']
-    final_drop = []
-    for column in df.columns:
-        if column[-4:] == '__pc':
-            final_drop.append(column)
-        elif column in person_account_list:
-            final_drop.append(column)
-    
-    return df.drop(columns=final_drop, axis=1)
-
-def object_account_drop_businessaccount_cols(df: pd.DataFrame) -> pd.DataFrame:
-    # Drops Person Account columns from the DataFrame
-    business_account_list = ['DunsNumber','Jigsaw','NaicsCode','NaicsDesc','Name','Sic','Tradestyle','SicDesc','TickerSymbol']
-    final_drop = []
-    for column in df.columns:
-        if column in business_account_list:
-            final_drop.append(column)
-    return df.drop(columns=final_drop, axis=1)
-
-def unpack_column(result: pd.DataFrame, column: str='errors'):
-    return pd.concat([result, result[column].apply(lambda row: pd.Series(row[0]) if len(row) >0 else pd.Series(dtype='int64')).fillna("")], axis=1).drop(columns=[column])
-
-def metadata_parse(metadata_value: Union[pd.DataFrame, Iterable, OrderedDict, bool, list, int, None]) -> Union[Iterable, OrderedDict, dict, bool, list, int, None]:
-    """
-    Function recursively traverses down a set of nested DataFrame, Dict, List, Ordered Dict iterables until
-    it reaches a str, bool, empty list, or None value to return a dict comprising of the original hierarchical data.
-    """
-    if type(metadata_value) == str:
-        return metadata_value
-    elif type(metadata_value) == bool:
-        return metadata_value
-    elif metadata_value is None:
-        return None
-    elif type(metadata_value) == int:
-        return metadata_value
-    elif type(metadata_value) == list:
-        if len(metadata_value) == 0:
-            return []
-        else:
-            working_list = []
-            for item in metadata_value:
-                working_list.append(metadata_parse(item))
-            return working_list
-    elif type(metadata_value) == OrderedDict:
-        working_dict = {}
-        for key in metadata_value.keys():
-            working_dict[key] = metadata_parse(metadata_value[key])
-        return working_dict
-    elif type(metadata_value) == pd.DataFrame:
-        working_df_dict = {}
-        for column in metadata_value.columns:
-            if len(metadata_value[column]) == 0:
-                working_df_dict[column] = None
-            elif len(metadata_value[column]) > 1:
-                for item in metadata_value[column]:
-                    working_df_dict[column] = metadata_parse(item)
-            elif len(metadata_value[column]) == 1:
-                working_df_dict[column] = metadata_parse(metadata_value[column][0])
-        return working_df_dict
+import pandas as pd
+from collections import OrderedDict
+from typing import Union, Iterable, final
+
+# ================================================
+# Account Object Functions
+# ================================================
+
+def object_account_drop_personaccount_cols(df: pd.DataFrame) -> pd.DataFrame:
+    # Drops Person Account columns from the DataFrame
+    person_account_list = ['FirstName', 'LastName', 'MiddleName', 'PersonDoNotCall','PersonIndividualId','PersonAssistantName', 'PersonAssistantPhone','PersonBirthdate', 'PersonBirthDate', 'PersonContactId', 'PersonDepartment', 'PersonEmail', 'PersonEmailBouncedDate', 'PersonEmailBouncedReason','PersonHasOptedOutOfFax', 'PersonHasOptedOutOfEmail', 'PersonHomePhone', 'PersonLeadSource', 'PersonMailingAddress', 'PersonMailingCity',
+                           'PersonMailingGeocodeAccuracy', 'PersonMailingLatitude', 'PersonMailingLongitude', 'PersonMailingStreet', 'PersonMobilePhone', 'PersonOtherCity', 'PersonOtherCountry', 'PersonOtherPostalCode', 'PersonOtherState', 'PersonOtherCountryCode', 'PersonOtherStateCode', 'PersonOtherLatitude', 'PersonOtherLongitude', 'PersonOtherPhone', 'PersonOtherStreet', 'PersonTitle', 'Suffix']
+    final_drop = []
+    for column in df.columns:
+        if column[-4:] == '__pc':
+            final_drop.append(column)
+        elif column in person_account_list:
+            final_drop.append(column)
+    
+    return df.drop(columns=final_drop, axis=1)
+
+def object_account_drop_businessaccount_cols(df: pd.DataFrame) -> pd.DataFrame:
+    # Drops Person Account columns from the DataFrame
+    business_account_list = ['DunsNumber','Jigsaw','NaicsCode','NaicsDesc','Name','Sic','Tradestyle','SicDesc','TickerSymbol']
+    final_drop = []
+    for column in df.columns:
+        if column in business_account_list:
+            final_drop.append(column)
+    return df.drop(columns=final_drop, axis=1)
+
+def unpack_column(result: pd.DataFrame, column: str='errors'):
+    return pd.concat([result, result[column].apply(lambda row: pd.Series(row[0]) if len(row) >0 else pd.Series(dtype='int64')).fillna("")], axis=1).drop(columns=[column])
+
+def metadata_parse(metadata_value: Union[pd.DataFrame, Iterable, OrderedDict, bool, list, int, None]) -> Union[Iterable, OrderedDict, dict, bool, list, int, None]:
+    """
+    Function recursively traverses down a set of nested DataFrame, Dict, List, Ordered Dict iterables until
+    it reaches a str, bool, empty list, or None value to return a dict comprising of the original hierarchical data.
+    """
+    if type(metadata_value) == str:
+        return metadata_value
+    elif type(metadata_value) == bool:
+        return metadata_value
+    elif metadata_value is None:
+        return None
+    elif type(metadata_value) == int:
+        return metadata_value
+    elif type(metadata_value) == list:
+        if len(metadata_value) == 0:
+            return []
+        else:
+            working_list = []
+            for item in metadata_value:
+                working_list.append(metadata_parse(item))
+            return working_list
+    elif type(metadata_value) == OrderedDict:
+        working_dict = {}
+        for key in metadata_value.keys():
+            working_dict[key] = metadata_parse(metadata_value[key])
+        return working_dict
+    elif type(metadata_value) == pd.DataFrame:
+        working_df_dict = {}
+        for column in metadata_value.columns:
+            if len(metadata_value[column]) == 0:
+                working_df_dict[column] = None
+            elif len(metadata_value[column]) > 1:
+                for item in metadata_value[column]:
+                    working_df_dict[column] = metadata_parse(item)
+            elif len(metadata_value[column]) == 1:
+                working_df_dict[column] = metadata_parse(metadata_value[column][0])
+        return working_df_dict
```

### Comparing `veevatools-0.1.8/salesforce/utilities/sf_query_processors.py` & `veevatools-0.1.9/salesforce/utilities/sf_query_processors.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,58 +1,58 @@
-from collections import OrderedDict
-import pandas as pd
-
-
-def recursive_walk(od_field: OrderedDict):
-    """
-    Recursively flattens each row the results of simple salesforce.
-    Only works for bottom up queries.
-    :param od_field: results returned by simple salesforce (multiple objects)
-    :return: returns a flattened list of dictionaries
-    """
-    d = {}
-    for k in od_field.keys():
-        if isinstance(od_field[k], OrderedDict) & (k != 'attributes'):
-            if 'attributes' in od_field[k].keys():
-                ret_df = recursive_walk(od_field[k])
-                d = {**d, **ret_df}
-            else:
-                obj = od_field['attributes']['type'].replace(" ", ".")
-                d[f'{obj}.{k}'] = ",\n".join([   f'{k}: {v}' for k, v in od_field[k].items() if v is not None])
-        else:
-            if k != 'attributes':
-                obj = od_field['attributes']['type'].replace(" ", ".")
-                d[f'{obj}.{k}'] = od_field[k]
-    return d
-
-def transform_sf_result_set_rec(query_results: OrderedDict):
-    """
-    Recursively flattens the results of simple salesforce. It needs flattening when  selecting
-    multiple objects.
-    :param query_results:
-    :return:
-    """
-    data = []
-    for res in query_results:
-        d = recursive_walk(res)
-        data.append(d)
-    data = pd.DataFrame(data)
-    return data
-
-def deep_merge_dictionaries(source, destination):
-    """
-    run me with nosetests --with-doctest file.py
-
-    >>> a = { 'first' : { 'all_rows' : { 'pass' : 'dog', 'number' : '1' } } }
-    >>> b = { 'first' : { 'all_rows' : { 'fail' : 'cat', 'number' : '5' } } }
-    >>> deep_merge_dictionaries(b, a) == { 'first' : { 'all_rows' : { 'pass' : 'dog', 'fail' : 'cat', 'number' : '5' } } }
-    True
-    """
-    for key, value in source.items():
-        if isinstance(value, dict):
-            # get node or create one
-            node = destination.setdefault(key, {})
-            deep_merge_dictionaries(value, node)
-        else:
-            destination[key] = value
-
+from collections import OrderedDict
+import pandas as pd
+
+
+def recursive_walk(od_field: OrderedDict):
+    """
+    Recursively flattens each row the results of simple salesforce.
+    Only works for bottom up queries.
+    :param od_field: results returned by simple salesforce (multiple objects)
+    :return: returns a flattened list of dictionaries
+    """
+    d = {}
+    for k in od_field.keys():
+        if isinstance(od_field[k], OrderedDict) & (k != 'attributes'):
+            if 'attributes' in od_field[k].keys():
+                ret_df = recursive_walk(od_field[k])
+                d = {**d, **ret_df}
+            else:
+                obj = od_field['attributes']['type'].replace(" ", ".")
+                d[f'{obj}.{k}'] = ",\n".join([   f'{k}: {v}' for k, v in od_field[k].items() if v is not None])
+        else:
+            if k != 'attributes':
+                obj = od_field['attributes']['type'].replace(" ", ".")
+                d[f'{obj}.{k}'] = od_field[k]
+    return d
+
+def transform_sf_result_set_rec(query_results: OrderedDict):
+    """
+    Recursively flattens the results of simple salesforce. It needs flattening when  selecting
+    multiple objects.
+    :param query_results:
+    :return:
+    """
+    data = []
+    for res in query_results:
+        d = recursive_walk(res)
+        data.append(d)
+    data = pd.DataFrame(data)
+    return data
+
+def deep_merge_dictionaries(source, destination):
+    """
+    run me with nosetests --with-doctest file.py
+
+    >>> a = { 'first' : { 'all_rows' : { 'pass' : 'dog', 'number' : '1' } } }
+    >>> b = { 'first' : { 'all_rows' : { 'fail' : 'cat', 'number' : '5' } } }
+    >>> deep_merge_dictionaries(b, a) == { 'first' : { 'all_rows' : { 'pass' : 'dog', 'fail' : 'cat', 'number' : '5' } } }
+    True
+    """
+    for key, value in source.items():
+        if isinstance(value, dict):
+            # get node or create one
+            node = destination.setdefault(key, {})
+            deep_merge_dictionaries(value, node)
+        else:
+            destination[key] = value
+
     return destination
```

### Comparing `veevatools-0.1.8/utilities/async_utils.py` & `veevatools-0.1.9/utilities/async_utils.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-import asyncio
-from functools import wraps, partial
-
-async def async_parallel(func, args):
-    # runs the function(s) in parallel
-    return await asyncio.gather(*[func(arg) for arg in args])
-
-async def async_serial(func, args):
-    # runs the function(s) in serial order, 
-    # awaiting for each iteration's completion before executing the next.
-    return [await func(arg) for arg in args]
-
-def async_wrap(func):
-    @wraps(func)
-    async def run(*args, loop=None, executor=None, **kwargs):
-        if loop is None:
-            loop = asyncio.get_event_loop()
-        pfunc = partial(func, *args, **kwargs)
-        return await loop.run_in_executor(executor, pfunc)
+import asyncio
+from functools import wraps, partial
+
+async def async_parallel(func, args):
+    # runs the function(s) in parallel
+    return await asyncio.gather(*[func(arg) for arg in args])
+
+async def async_serial(func, args):
+    # runs the function(s) in serial order, 
+    # awaiting for each iteration's completion before executing the next.
+    return [await func(arg) for arg in args]
+
+def async_wrap(func):
+    @wraps(func)
+    async def run(*args, loop=None, executor=None, **kwargs):
+        if loop is None:
+            loop = asyncio.get_event_loop()
+        pfunc = partial(func, *args, **kwargs)
+        return await loop.run_in_executor(executor, pfunc)
     return run
```

### Comparing `veevatools-0.1.8/veevanetwork/custom_exceptions/veevanetwork_exceptions.py` & `veevatools-0.1.9/veevanetwork/custom_exceptions/veevanetwork_exceptions.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,77 +1,77 @@
-class NetworkAPIHeaderValueNotFound(Exception):
-    """Exception raised when the required values are not provided to the
-    Vn.api_call() method.
-
-    Expecting to find a api['request']['header'][key]['value'] attribute in the json/dict provided, 
-    where 'key' represents Authorization or Content Type header.
-    """
-
-    def __init__(self, message="The defined API does not contain a value parameter in its header.\
-Expecting to find a api['request']['header'][key]['value'] attribute in the json/dict provided, \
-where 'key' represents Authorization or Content Type header."):
-        self.message = message
-        super().__init__(self.message)
-
-class NetworkAPIRequestMethodNotFound(Exception):
-    """Exception raised when the required values are not provided to the
-    Vn.api_call() method.
-
-    Required Values:
-        Expecting to find a api['request']['method'] attribute in the json/dict provided.
-    """
-
-    def __init__(self, message="The defined API does not contain a method parameter in its request method.\
-Expecting to find a api['request']['method'] attribute in the json/dict provided."):
-        self.message = message
-        super().__init__(self.message)
-
-class NetworkAPIRequestURLNotFound(Exception):
-    """Exception raised when the required values are not provided to the
-    Vn.api_call() method.
-
-    Required Values:
-        Expecting to find a api['request']['url']['raw'] attribute in the json/dict provided.
-    """
-
-    def __init__(self, message="The defined API does not contain a method parameter in its request method.\
-Expecting to find a api['request']['url']['raw'] attribute in the json/dict provided."):
-        self.message = message
-        super().__init__(self.message)
-
-class NetworkAPIRequestBodyNotFound(Exception):
-    """Exception raised when the required values are not provided to the
-    Vn.api_call() method.
-
-    Required Values:
-        The parameter body: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example.
-    """
-
-    def __init__(self, message="The parameter body: dict is is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example."):
-        self.message = message
-        super().__init__(self.message)
-
-class NetworkAPIRequestVariableNotFound(Exception):
-    """Exception raised when the required values are not provided to the
-    Vn.api_call() method.
-
-    Required Values:
-        The parameter variables: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example.
-    """
-
-    def __init__(self, message="The parameter variables: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example."):
-        self.message = message
-        super().__init__(self.message)
-
-class NetworkAPIRequestQueryNotFound(Exception):
-    """Exception raised when the required values are not provided to the
-    Vn.api_call() method.
-
-    Required Values:
-        The parameter queries: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example.
-    """
-
-    def __init__(self, message="The parameter queries: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example."):
-        self.message = message
-        super().__init__(self.message)
-
-
+class NetworkAPIHeaderValueNotFound(Exception):
+    """Exception raised when the required values are not provided to the
+    Vn.api_call() method.
+
+    Expecting to find a api['request']['header'][key]['value'] attribute in the json/dict provided, 
+    where 'key' represents Authorization or Content Type header.
+    """
+
+    def __init__(self, message="The defined API does not contain a value parameter in its header.\
+Expecting to find a api['request']['header'][key]['value'] attribute in the json/dict provided, \
+where 'key' represents Authorization or Content Type header."):
+        self.message = message
+        super().__init__(self.message)
+
+class NetworkAPIRequestMethodNotFound(Exception):
+    """Exception raised when the required values are not provided to the
+    Vn.api_call() method.
+
+    Required Values:
+        Expecting to find a api['request']['method'] attribute in the json/dict provided.
+    """
+
+    def __init__(self, message="The defined API does not contain a method parameter in its request method.\
+Expecting to find a api['request']['method'] attribute in the json/dict provided."):
+        self.message = message
+        super().__init__(self.message)
+
+class NetworkAPIRequestURLNotFound(Exception):
+    """Exception raised when the required values are not provided to the
+    Vn.api_call() method.
+
+    Required Values:
+        Expecting to find a api['request']['url']['raw'] attribute in the json/dict provided.
+    """
+
+    def __init__(self, message="The defined API does not contain a method parameter in its request method.\
+Expecting to find a api['request']['url']['raw'] attribute in the json/dict provided."):
+        self.message = message
+        super().__init__(self.message)
+
+class NetworkAPIRequestBodyNotFound(Exception):
+    """Exception raised when the required values are not provided to the
+    Vn.api_call() method.
+
+    Required Values:
+        The parameter body: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example.
+    """
+
+    def __init__(self, message="The parameter body: dict is is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example."):
+        self.message = message
+        super().__init__(self.message)
+
+class NetworkAPIRequestVariableNotFound(Exception):
+    """Exception raised when the required values are not provided to the
+    Vn.api_call() method.
+
+    Required Values:
+        The parameter variables: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example.
+    """
+
+    def __init__(self, message="The parameter variables: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example."):
+        self.message = message
+        super().__init__(self.message)
+
+class NetworkAPIRequestQueryNotFound(Exception):
+    """Exception raised when the required values are not provided to the
+    Vn.api_call() method.
+
+    Required Values:
+        The parameter queries: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example.
+    """
+
+    def __init__(self, message="The parameter queries: dict is required in this API call, please refer to the Network API documentation for the syntax of the body parameter or set the if_example parameter to True for an example."):
+        self.message = message
+        super().__init__(self.message)
+
+
```

### Comparing `veevatools-0.1.8/veevanetwork/network_api_v25.json` & `veevatools-0.1.9/veevanetwork/network_api_v25.json`

 * *Files identical despite different names*

### Comparing `veevatools-0.1.8/veevanetwork/veevanetwork.py` & `veevatools-0.1.9/veevanetwork/veevanetwork.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,1569 +1,1569 @@
-from sys import platform
-import requests
-import pandas as pd
-import os
-import json
-from typing import List, Tuple, Optional, Union, Type, OrderedDict, Iterable
-import numpy as np
-import sys
-import importlib.resources
-from urllib.parse import urlparse
-try:
-    from custom_exceptions.veevanetwork_exceptions import *
-except:
-    from veevanetwork.custom_exceptions.veevanetwork_exceptions import *
-
-class Vn:
-    def __init__(self):
-        self.os_platform: str = platform
-        self.networkURL: str = None # https://verteonetwork.veevanetwork.com
-        self.networkUserName: str = None
-        self.networkPassword: str = None
-        self.networkCountry: str = 'US'
-        self.networkConnection: requests.models.Response = None
-        self.networkLanguages: list = None # List of languages supported by this instance of Veeva Network
-        self.networkObjects: dict = None # Dictionary of Network Objects and their properties
-        self.networkObjectMetadata: dict = None # {'HCP': {'my_custom_field__c': {'fieldId': 'my_custom_field__c','type': {'dataType': 'STRING', 'discriminator': None}, 'labels': {'en': 'My Custom Field'}}}}
-        self.networkReferenceTypes: dict = None # {'AddressAdminArea': {'type': 'AddressAdminArea','customerOwned': False,'inactive': False,'description': 'AddressAdminArea'}, 'AddressCBSA': {'type': 'AddressCBSA' ... }}
-        self.networkReferenceValueMetadata: dict = None # Dictionary of Network Reference Value Metadata, including countries, reference codes, translated values, etc.
-        self.sessionId: str = None
-        self.networkId: str = None
-        self.APIheaders: dict = None
-        self.APIversionList: list = []
-        self.LatestAPIversion: str = None
-        self.network_references_all: pd.DataFrame = None
-        self.network_DNS: str = None # verteonetwork.veevanetwork.com
-        self.network_protocol: str = None # https
-
-        #----------------------------------------------------------------
-        # Load Network API Json
-        self.network_api_json: dict = None
-        try: # Try to load the network API json, to be used in a packaged distribution context
-            with importlib.resources.open_text("veevanetwork", "network_api_v25.json") as file:
-                self.network_api_json = json.load(file)
-        except: # If the above fails, try to load the network API json, to be used in a development context
-            with open('network_api_v25.json', encoding="utf-8") as file:
-                self.network_api_json = json.load(file)
-        self.network_api_parsed: dict = self.__parse_network_api_json(self.network_api_json)
-        self.api_categories: list = list(self.network_api_parsed['item'].keys())
-
-        self.api_change_request = self.network_api_parsed['item']['Change Request']
-        self.api_custom_key = self.network_api_parsed['item']['Custom Key']
-        self.api_entity = self.network_api_parsed['item']['Entity']
-        self.api_hco = self.network_api_parsed['item']['HCO']
-        self.api_hcp = self.network_api_parsed['item']['HCP']
-        self.api_metadata = self.network_api_parsed['item']['Metadata']
-        self.api_subscriptions = self.network_api_parsed['item']['Subscriptions']
-        self.api_subscriptions_compliance = self.network_api_parsed['item']['Subscriptions - Compliance']
-        self.api_subscriptions_source = self.network_api_parsed['item']['Subscriptions - Source']
-        self.api_subscriptions_target = self.network_api_parsed['item']['Subscriptions - Target']
-        self.api_events = self.network_api_parsed['item']['Events']
-        self.api_match = self.network_api_parsed['item']['Match']
-        self.api_suspect_match = self.network_api_parsed['item']['Suspect Match']
-        self.api_authentication = self.network_api_parsed['item']['Authentication']
-        self.api_retrieve_available_api_versions = self.network_api_parsed['item']['Retrieve Available API Versions']
-        self.api_search = self.network_api_parsed['item']['Search']
-        self.call = {
-            "Change Request": {
-                "change_request_create": self.change_request_create,
-                "change_request_cancel": self.change_request_cancel,
-                "change_request_retrieve": self.change_request_retrieve,
-                "change_request_batch_retrieve": self.change_request_batch_retrieve,
-                "change_request_update": self.change_request_update,
-                "change_request_batch_update": self.change_request_batch_update,
-                "change_request_process": self.change_request_process,
-                "change_request_batch_process": self.change_request_batch_process,
-                "change_request_search": self.change_request_search,
-                "change_request_match": self.change_request_match,
-                "change_request_batch_approve": self.change_request_batch_approve,
-                "change_request_batch_reject": self.change_request_batch_reject
-            },
-            "Custom Key": {
-                "custom_key_associate_to_entity": self.custom_key_associate_to_entity,
-                "custom_key_associate_to_child": self.custom_key_associate_to_child,
-                "custom_key_batch_associate_to_entities": self.custom_key_batch_associate_to_entities,
-                "custom_key_batch_associate_to_children": self.custom_key_batch_associate_to_children,
-                "custom_key_disassociate": self.custom_key_disassociate,
-                "custom_key_batch_disassociate": self.custom_key_batch_disassociate
-            },
-            "Entity": {
-                "entity_retrieve": self.entity_retrieve,
-                "entity_retrieve_child": self.entity_retrieve_child,
-                "entity_batch_retrieve": self.entity_batch_retrieve,
-                "entity_batch_retrieve_children": self.entity_batch_retrieve_children
-            },
-            "HCO": {
-                "hco_retrieve": self.hco_retrieve,
-                "hco_associate_custom_key": self.hco_associate_custom_key,
-                "hco_address_associate_custom_key": self.hco_address_associate_custom_key,
-                "hco_license_associate_custom_key": self.hco_license_associate_custom_key,
-                "hco_parenthco_associate_custom_key": self.hco_parenthco_associate_custom_key
-            },
-            "HCP": {
-                "hcp_retrive": self.hcp_retrive,
-                "hcp_associate_custom_key": self.hcp_associate_custom_key,
-                "hcp_address_associate_custom_key": self.hcp_address_associate_custom_key,
-                "hcp_license_associate_custom_key": self.hcp_license_associate_custom_key,
-                "hcp_parenthco_associate_custom_key": self.hcp_parenthco_associate_custom_key
-            },
-            "Metadata": {
-                "metadata_retrieve_available_api_versions": self.metadata_retrieve_available_api_versions,
-                "metadata_retrieve_hashtags": self.metadata_retrieve_hashtags,
-                "metadata_retrieve_object_types": self.metadata_retrieve_object_types,
-                "metadata_retrieve_field": self.metadata_retrieve_field,
-                "metadata_retrieve_field_details": self.metadata_retrieve_field_details,
-                "metadata_retrieve_field_groups": self.metadata_retrieve_field_groups,
-                "metadata_retrieve_reference_data_types": self.metadata_retrieve_reference_data_types,
-                "metadata_retrieve_reference_data_type_details": self.metadata_retrieve_reference_data_type_details,
-                "metadata_retrieve_reference_data_type_code_details": self.metadata_retrieve_reference_data_type_code_details
-            },
-            "Subscriptions": {
-                "subscriptions_create_job": self.subscriptions_create_job,
-                "subscriptions_retrieve_job": self.subscriptions_retrieve_job,
-                "subscriptions_cancel_job": self.subscriptions_cancel_job,
-                "subscriptions_retrieve_export_job_file": self.subscriptions_retrieve_export_job_file
-            },
-            "Subscriptions - Compliance": {
-                "subscriptions_compliance_create_job": self.subscriptions_compliance_create_job,
-                "subscriptions_compliance_retrieve_job": self.subscriptions_compliance_retrieve_job,
-                "subscriptions_compliance_cancel_job": self.subscriptions_compliance_cancel_job
-            },
-            "Subscriptions - Source": {
-                "subscriptions_source_create_job": self.subscriptions_source_create_job,
-                "subscriptions_source_retrieve_job": self.subscriptions_source_retrieve_job,
-                "subscriptions_source_cancel_job": self.subscriptions_source_cancel_job
-            },
-            "Subscriptions - Target": {
-                "subscriptions_target_create_job": self.subscriptions_target_create_job,
-                "subscriptions_target_retrieve_job": self.subscriptions_target_retrieve_job,
-                "subscriptions_target_cancel_job": self.subscriptions_target_cancel_job
-            },
-            "Events": {
-                "events_retrieve_merge": self.events_retrieve_merge,
-                "events_retrieve_unmerge": self.events_retrieve_unmerge
-            },
-            "Match": {
-                "match_retrieve": self.match_retrieve,
-                "suspect_match_batch_reject_task": self.suspect_match_batch_reject_task,
-
-            },
-            "Suspect Match": {
-                "suspect_match_batch_process": self.suspect_match_batch_process,
-                "suspect_match_batch_create": self.suspect_match_batch_create,
-                "suspect_match_batch_reject_task": self.suspect_match_batch_reject_task,
-                "suspect_match_batch_retrieve": self.suspect_match_batch_retrieve
-            },
-            "Retrieve Available API Versions": {
-                "retrieve_available_api_versions": self.retrieve_available_api_versions
-            },
-            "Search": {
-                "search": self.search
-            }
-            }
-    
-    # =============================================================================
-    # Authentication
-    # =============================================================================
-
-    # Refactored - MP 20220610
-    def authenticate(
-        self, 
-        networkURL: str=None, 
-        networkUserName: str=None, 
-        networkPassword: str=None, 
-        networkCountry: str=None, 
-        networkId: str=None,
-        sessionId: str=None,
-        if_return: bool=False, 
-        *args, **kwargs
-    ) -> Optional[dict]:
-        """
-        Authenticates Veeva Network and retrieves the auth token.
-
-        Example:
-        authenticate using unpacked kwargs from the retrieve_credentials function
-            authenticate_vn(**retrieve_credentials(platform, 'credentials.xlsx')[0])
-
-        Return Example:
-            {'sf': <simple_salesforce.api.Salesforce at 0x24a045c7b50>,
-             'bulk': <salesforce_bulk.salesforce_bulk.SalesforceBulk at 0x24a045c7e20>,
-             'sfMeta': <sfdclib.session.SfdcSession at 0x24a044b3400>,
-             'tooling': <sfdclib.tooling.SfdcToolingApi at 0x24a045d17f0>,
-             'session_id': '00D3F000000FZCq!AQYAQHYfSLYGI9cTyjDfxAAzYm.1uOKmNPXlKMW0sVz5ilIQ9ZwVTh6kOlaRuqfPuuzNnZNb3461sUGeUZ57ttE.GBawbt5h',
-             'instance': 'cslbehring-core--devr01.my.salesforce.com',
-             'sfMeta_is_connected': True,
-             'bulk_api_sessionId': '00D3F000000FZCq!AQYAQHYfSLYGI9cTyjDfxAAzYm.1uOKmNPXlKMW0sVz5ilIQ9ZwVTh6kOlaRuqfPuuzNnZNb3461sUGeUZ57ttE.GBawbt5h'}
-
-        Dependencies:
-            import requests
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Authenticate
-        
-        """
-        if (networkId and sessionId and networkURL):
-            self.networkId = self.networkId if networkId is None else networkId
-            self.sessionId = self.sessionId if sessionId is None else sessionId
-        
-        url_parse = urlparse(networkURL)
-        if len(url_parse.scheme) == 0:
-            self.network_protocol = 'https'
-            if len(url_parse.path) > 0:
-                self.network_DNS = url_parse.path
-                self.networkURL = self.network_protocol + '://' + url_parse.path
-
-        if len(url_parse.scheme) > 0:
-            self.network_protocol = url_parse.scheme
-            if len(url_parse.netloc) > 0:
-                self.network_DNS = url_parse.netloc
-                self.networkURL = url_parse.scheme + '://' + url_parse.netloc
-
-        if (self.networkURL is None) or (len(self.networkURL) == 0):
-            raise Exception('networkURL is required')
-
-
-        # self.networkURL = self.networkURL if networkURL is None else networkURL
-        self.networkUserName = self.networkUserName if networkUserName is None else networkUserName
-        self.networkPassword = self.networkPassword if networkPassword is None else networkPassword
-        self.networkCountry = self.networkCountry if networkCountry is None else networkCountry
-        
-        if self.networkUserName and self.networkPassword and self.networkURL:
-            payload = {
-                'username': self.networkUserName,
-                'password': self.networkPassword
-            }
-            headers = {
-                'Content-Type': 'application/x-www-form-urlencoded'
-            }
-            
-            self.networkConnection = requests.post(self.networkURL + '/api/v29.0/auth', data=payload, headers=headers)
-            
-            if self.networkConnection.json()['responseStatus'] == 'SUCCESS':
-                self.sessionId = self.networkConnection.json()['sessionId']
-                self.userId = self.networkConnection.json()['userId']
-                self.networkId = self.networkConnection.json()['networkId']
-            else:
-                raise Exception(self.networkConnection.json())
-
-
-        
-        self.APIheaders = {'authorization': self.sessionId}
-        self.APIversionList = []
-        
-        # Error checking whether the required parameters are passed in
-        # The check happens here because this is where all the self assignments has completed
-        if (not (self.networkId and self.sessionId and self.networkURL)) and (not (self.networkUserName and self.networkPassword and self.networkCountry and self.networkURL)):
-            raise Exception("Please provide either networkId, sessionId, and networkURL or networkUserName, networkPassword, and networkURL")
-        
-        for API in requests.get(self.networkURL +'/api', headers=self.APIheaders).json()['values'].keys():
-            self.APIversionList.append(float(API.replace("v", "")))
-        self.APIversionList.sort()
-        self.LatestAPIversion = "v" + str(self.APIversionList[-1])
-        
-
-        if if_return:
-            return {'networkURL':self.networkURL, 
-                    'networkUserName':self.networkUserName, 
-                    'networkPassword':self.networkPassword, 
-                    'networkConnection':self.networkConnection, 
-                    'sessionId':self.sessionId, 
-                    'APIheaders':self.APIheaders, 
-                    'APIversionList':self.APIversionList, 
-                    'LatestAPIversion':self.LatestAPIversion}    
-
-    # Refactored - MP 20220610
-    def get_networkObjects(self) -> pd.DataFrame:
-        """
-        Returns a list of all objects in the Veeva Network.
-        """
-        self.authenticate()
-
-        self.networkObjects = self.list_of_dicts_to_dict(requests.get(self.networkURL + '/api/' + self.LatestAPIversion + '/metadata/objectTypes',
-                                      headers=self.APIheaders).json()['objectTypes'], 'name')
-        return self.networkObjects
-
-    # Refactored - MP 20220610
-    def get_networkObjectMetadata(self) -> pd.DataFrame:
-        self.authenticate()
-        if self.networkObjects is None:
-            self.get_networkObjects()
-
-        processing_dict = {}
-        __empty =[
-            processing_dict.update({networkObject: 
-                self.list_of_dicts_to_dict(requests.get(
-                        self.networkURL + 
-                        '/api/'+ self.LatestAPIversion +
-                        '/metadata/fields?objectTypes=' + 
-                        networkObject + '&details=full' + 
-                        '&countries='+ self.networkCountry, 
-                        headers=self.APIheaders).json()['attributes'],
-                        'fieldId')}) 
-                        for networkObject in self.networkObjects.keys()]
-        self.networkObjectMetadata = processing_dict
-        return self.networkObjectMetadata
-
-
-    # Refactored - MP 20220612
-    def process_networkReferenceCodeMetadata(
-        self,
-        referenceTypes: Optional[list] = None, # List of reference types to retrieve, leave empty (None) to retrieve all
-        customerOwned: Optional[bool] = None, # True (customer owned only), False (ootb), None (customer owned and ootb)
-        activeReferences: Optional[bool]= None, # True (active only), False (inactive only), None (active and inactive)
-        languages: Optional[list]= None, # List of languages to retrieve, leave empty (None) to retrieve all
-        countries: Optional[list]= None, # List of countries to retrieve, leave empty (None) to retrieve all
-    ):
-        """
-        Processes Network Reference Metadata and returns a DataFrame of the reference codes based on the parameters.
-
-        Parameters:
-        referenceTypes: List of reference types to retrieve, leave empty (None) to retrieve all
-        customerOwned (bool): Filter references by customerOwned status. Values: True (customerOwned only), False (ootb only), None (customerOwned and ootb)
-        activeReferences (bool): Filter references by status. Values: True (active only), False (inactive only), None (active and inactive)
-        languages (list): List of languages to return. Default: ['en']
-        countries (list): List of countries to return. Default: ['US']
-
-        Returns:
-        DataFrame: A DataFrame of the reference codes based on the parameters.
-        """
-
-        if self.networkReferenceValueMetadata is None:
-            self.get_networkReferenceValueMetadata()
-        
-        if languages is None:
-            if self.networkLanguages is None:
-                self.get_networkLanguages()
-            languages = self.networkLanguages
-            
-        networkReferenceDF = pd.DataFrame(self.networkReferenceValueMetadata)
-        networkReferenceCodeDataframe = networkReferenceDF.loc['reference_type_codes', :].dropna()
-        reference_code_dict_unfiltered: dict[str, pd.DataFrame] = {}
-        for index, values in zip(networkReferenceCodeDataframe.index, networkReferenceCodeDataframe.values):
-            reference_code_dict_unfiltered.update({index: pd.DataFrame(self.list_of_dicts_to_dict(values, 'code'))})
-        
-        final_df = pd.DataFrame()
-        for reference_type, reference_dataframe in zip(reference_code_dict_unfiltered.keys(), reference_code_dict_unfiltered.values()):
-            if referenceTypes is None or reference_type in referenceTypes:
-                activeReferences = None
-                customerOwned = None
-                activeReferences_filter = [True,False] if activeReferences is None else [not(activeReferences)]
-                customerOwned_filter = [True,False] if customerOwned is None else [customerOwned]
-                reference_dataframe = reference_dataframe.T.copy()
-                filtered_customerOwned_and_active = reference_dataframe[
-                                                (reference_dataframe['customerOwned'].isin(customerOwned_filter)) & 
-                                                (reference_dataframe['inactive'].isin(activeReferences_filter))
-                                                ]
-
-                filtered_languages = pd.DataFrame()
-
-                for language in languages:
-                    filtered_languages = pd.concat([filtered_languages,
-                                                pd.DataFrame(
-                                                    filtered_customerOwned_and_active["values"]
-                                                    .apply(lambda value: value[language] 
-                                                    if value.keys()
-                                                    .__contains__(language) 
-                                                    else np.nan)
-                                                    .dropna()
-                                                    .rename(language))], axis=1)
-                filtered_languages.insert(0, 'Network Code', filtered_languages.index)
-                filtered_languages.insert(1, 'Reference Type', reference_type)
-                filtered_languages.insert(2, 'Active Countries', pd.DataFrame(filtered_customerOwned_and_active["countries"]
-                                                    .apply(lambda value: ";".join(sorted(value)) if (countries is None or len(set(value).intersection(set(countries)))>0 ) else np.nan).rename('countries')
-                                                )['countries'])
-                filtered_languages.insert(3, 'Definition', pd.DataFrame(
-                                                    filtered_customerOwned_and_active["values"]
-                                                    .apply(lambda value: value['en'] 
-                                                    if value.keys()
-                                                    .__contains__('en') 
-                                                    else np.nan)
-                                                    .dropna()
-                                                    .rename('en'))['en'])
-                filtered_languages.insert(4, 'Active?', filtered_customerOwned_and_active["inactive"] == False)
-                filtered_languages.insert(5, 'Veeva Maintained?', filtered_customerOwned_and_active["customerOwned"] == False)             
-                filtered_languages.reset_index(drop=True, inplace=True)
-                filtered_languages.dropna(subset=['Active Countries'], inplace=True)
-                filtered_languages.replace(np.nan, "", inplace=True)
-                filtered_languages
-                final_df = pd.concat([final_df, filtered_languages], axis=0)
-
-        final_df.reset_index(drop=True, inplace=True)
-        
-        return final_df
-
-    # To be deprecated, used by object_metadata_dataframe()
-    def object_metadata(self):
-        self.networkObjects = requests.get(self.networkURL + '/api/' + self.LatestAPIversion + '/metadata/objectTypes',
-                                      headers=self.APIheaders).json()['objectTypes']
-        networkObjectList = []
-        for obj in self.networkObjects:
-            if obj['status'] == 'ACTIVE':
-                networkObjectList.append(obj['name'])
-            else:
-                pass
-        object_metadata = pd.DataFrame([requests.get(self.networkURL + '/api/'+ self.LatestAPIversion +'/metadata/fields?objectTypes=' + networkObject + '&details=full' + '&countries='+ self.networkCountry, headers=self.APIheaders).json()['attributes'] 
-                                              for networkObject in networkObjectList])
-        object_metadata = object_metadata.transpose()
-        object_metadata.columns = networkObjectList
-        return object_metadata
-
-    # To be deprecated, use get_networkObjectMetadata() instead
-    def object_metadata_dataframe(self, object_metadata = None, attribute = None, *args):
-        """
-        Function that takes an input of data table with metadata values containing field for each row and objects for each column, 
-        lists of input attributes available in the meta data (i.e. ['type','dataType']), 
-        and optional arguments containing comma separated lists of additional attributes available in the meta data 
-        
-        Example:
-            VeevaNetwork.object_metadata_dataframe(self.object_metadata(), ['fieldId'], ['type','dataType'], ['type','discriminator'], ['labels','en'],['maximumLength'])
-            
-        Return Example:
-        (Dataframe)
-            HCP.fieldId    HCP.type.dataType    HCP.type.discriminator    HCP.labels.en    HCP.maximumLength    HCO.fieldId      ...
-            hcp_type__v    REFERENCE            HCPType                   HCP Type         100.0                340B_eligible__v ...
-        
-        """
-        self.authenticate()
-        
-        object_metadata = self.object_metadata() if object_metadata is None else object_metadata
-        
-        object_metadata_dataframe = pd.DataFrame()
-        attribute1 = attribute[0]
-        attribute2 = attribute[1] if len(attribute) > 1 else ""
-        for networkObjectName, networkObjectMetaData in object_metadata.iteritems():
-            attributeList = []
-            for fieldMetaData in networkObjectMetaData:
-                try:
-                    if attribute2 == "":
-                        attributeList.append(fieldMetaData[attribute1])
-                    else:
-                        attributeList.append(fieldMetaData[attribute1][attribute2])
-                except TypeError:
-                    continue
-    #        object_metadata_dataframe[networkObjectName + '.' + attribute1 + (("." + attribute2) if attribute2 != "" else "")] = pd.Series(attributeList, name = networkObjectName)
-            object_metadata_dataframe = pd.concat([object_metadata_dataframe,pd.Series(attributeList, name = networkObjectName + '.' + attribute1 + (("." + attribute2) if attribute2 != "" else "")).to_frame()], ignore_index=False, axis=1)
-
-
-            # parse arguments
-            if args:
-                for arg in args:
-                    argAttribute1 = arg[0]
-                    argAttribute2 = arg[1] if len(arg)>1 else ""
-                    argAttributeList = []
-                    for fieldMetaData in networkObjectMetaData:
-                        try:
-                            if argAttribute2 == "":
-                                argAttributeList.append(fieldMetaData[argAttribute1])
-                            else:
-                                argAttributeList.append(fieldMetaData[argAttribute1][argAttribute2])
-                        except:
-                            argAttributeList.append("")
-                            continue
-    #                object_metadata_dataframe[networkObjectName + '.' + argAttribute1 + (("." + argAttribute2) if argAttribute2 != "" else "")] = pd.Series(argAttributeList, name = networkObjectName)
-                    object_metadata_dataframe = pd.concat([object_metadata_dataframe,pd.Series(argAttributeList, name = networkObjectName + '.' + argAttribute1 + (("." + argAttribute2) if argAttribute2 != "" else "")).to_frame()], ignore_index=False, axis=1)
-            else:
-                continue
-        return object_metadata_dataframe
-
-    # Refactored - MP 20220611
-    def get_networkReferenceValueMetadata(self):
-        """
-        Retruns a Dictionary of Network Reference Value Metadata, including countries, reference codes, translated values, etc.
-        """
-        self.authenticate()
-        self.networkReferenceValueMetadata = self.list_of_dicts_to_dict(requests.get(self.networkURL + '/api/' + self.LatestAPIversion + '/metadata/reference_values?includeCodes=True', headers = self.APIheaders).json()['reference_type_values'],'type')
-        return self.networkReferenceValueMetadata
-
-    # Deprecated
-    def reference_value_dataframe(self):
-        """
-        Retrieve all reference values in Network  
-        ** formula can be enhanced or take input parameters so it doesn't query every single reference alias
-
-        """
-        self.authenticate()
-
-        self.networkReferenceTypes = self.list_of_dicts_to_dict(requests.get(self.networkURL + '/api/' + self.LatestAPIversion + '/metadata/reference_values?includeCodes=True', headers = self.APIheaders).json()['reference_type_values'],'type')
-        reference_value_dataframe = pd.DataFrame()
-        for x in self.networkReferenceTypes.keys():
-            try:
-                referenceCall = requests.get(self.networkURL + '/api/'+ self.LatestAPIversion + '/metadata/reference_values/' + x + '?countries='+ self.networkCountry, headers = self.APIheaders).json()['reference_type_codes']
-                newColumn = pd.Series([x['values']['en'] for x in referenceCall],name = str(x) + " Value")
-                
-                newColumn2 = pd.Series([x['code'] for x in referenceCall], name = x)
-                reference_value_dataframe.insert(len(reference_value_dataframe.columns), column = x, value = newColumn2)
-                reference_value_dataframe.insert(len(reference_value_dataframe.columns), column = str(x) + " Value", value = newColumn)
-            except:
-                pass
-        return reference_value_dataframe
-
-    def extract_network_reference_table(self):
-        self.authenticate()
-        
-        references_all = pd.DataFrame(requests.get(self.networkURL + '/api/'+ self.LatestAPIversion + '/metadata/reference_values?includeCodes=true&countries='+ self.networkCountry, headers = self.APIheaders).json()['reference_type_values'])
-        network_reference_table = pd.DataFrame()
-        self.network_references_all = references_all
-        for row in references_all['reference_type_codes']:
-            if isinstance(row, list):
-                network_reference_table = pd.concat([network_reference_table, pd.json_normalize(row)], axis=1)
-            else:
-                continue
-        network_reference_table.fillna('',inplace=True)
-        return network_reference_table
-    
-    # =============================================================================
-    # WIP Functions
-    # =============================================================================
-
-
-    # =============================================================================
-    # Change Request
-    # =============================================================================
-
-    def change_request_create(self, *args, **kwargs):
-        """
-        This API enables you to create a Network change request to add or update an HCP or HCO and related entities (including addresses, licenses, or parentHCOs) for **gray** data only.
-
-        Change requests created using the API against orange data will be rejected.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createachangerequest
-
-        """
-        
-        return self.api_call(self.api_change_request['item']['Create Change Request'], *args, **kwargs)
-        
-    def change_request_cancel(self, *args, **kwargs):
-        """
-        This API enables you to cancel a change request by providing the change request ID.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelchangerequest
-
-        """
-        return self.api_call(self.api_change_request['item']['Cancel Change Request'], *args, **kwargs)
-
-    def change_request_retrieve(self, *args, **kwargs):
-        """
-        This API enables you to retrieve response information for the create, update, and merge change requests submitted by a client application.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveChangeRequest
-
-        """
-        return self.api_call(self.api_change_request['item']['Retrieve Change Request'], *args, **kwargs)
-        
-    def change_request_batch_retrieve(self, *args, **kwargs):
-        """
-        This API enables you to obtain information about multiple change requests through the API.
-
-        Documenatation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchretrievechangerequest  
-
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Batch Retrieve'], *args, **kwargs)
-        
-    def change_request_update(self, *args, **kwargs):
-        """
-        This API enables you to update an unprocessed change request through the API.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#UpdateChangeRequest
-
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Update'], *args, **kwargs)
-
-    def change_request_batch_update(self, *args, **kwargs):
-        """
-        This API enables you to update multiple unprocessed change requests.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchUpdateChangeRequests
-
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Batch Update'], *args, **kwargs)
-
-    def change_request_process(self, *args, **kwargs):
-        """
-        This API enables you to process an unprocessed change request through the API.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#ProcessChangeRequest
-
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Process'], *args, **kwargs)
-
-    def change_request_batch_process(self, *args, **kwargs):
-        """
-        This API enables you to process multiple unprocessed change requests.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchProcessChangeRequests
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Batch Process'], *args, **kwargs)
-
-    def change_request_search(self, *args, **kwargs):
-        """
-        This API enables you to retrieve all change requests that match a specified search criteria.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#ChangeRequestSearch
-
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Search'], *args, **kwargs)
-
-    def change_request_match(self, *args, **kwargs):
-        """
-        This API enables you to match a request to an existing entity. You can use either the Veeva ID or custom key of an existing entity to match the request against.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#ChangeRequestMatch
-
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Match'], *args, **kwargs)
-
-    def change_request_batch_approve(self, *args, **kwargs):
-        """
-        This API enables you to bulk approve up to 500 change requests.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchApproveChangeRequests
-
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Batch Approve'], *args, **kwargs)
-
-    def change_request_batch_reject(self, *args, **kwargs):
-        """
-        This API enables you to bulk reject up to 500 change requests.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchRejectChangeRequests
-
-        """
-        return self.api_call(self.api_change_request['item']['Change Request Batch Reject'], *args, **kwargs)
-    
-    # =============================================================================
-    # Custom Key
-    # =============================================================================
-
-    def custom_key_associate_to_entity (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCPs or HCOs are downloaded from Network without going through the full change request process.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoentity
-
-        """
-        return self.api_call(self.api_custom_key['item']['Associate Custom Key to Entity'], *args, **kwargs)
-
-    def custom_key_associate_to_child (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new children (address, license, or parent HCOs) are downloaded from Network without going through the full change request process.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytochildren
-
-        """
-        return self.api_call(self.api_custom_key['item']['Associate Custom Key to Children'], *args, **kwargs)
-
-    def custom_key_batch_associate_to_entities (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers whenever new HCPs or HCOs are downloaded from Network without going through the full change request process.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchassociatecustomkeystoentities
-
-        """
-        return self.api_call(self.api_custom_key['item']['Batch Associate Custom Keys to Entities'], *args, **kwargs)
-
-    def custom_key_batch_associate_to_children (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new children (address, license, or parent HCOs) are downloaded from Network without going through the full change request process.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchassociatecustomkeytochildren
-
-        """
-        return self.api_call(self.api_custom_key['item']['Batch Associate Custom Keys to Children'], *args, **kwargs)
-
-    def custom_key_disassociate (self, *args, **kwargs):
-        """
-        This API enables you to deactivate external key identifiers for any entity (an HCP, HCO, Address, License, or ParentHCO) in Network without going through the full change request process.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Disassociatecustomkey
-
-        """
-        return self.api_call(self.api_custom_key['item']['Disassociate Custom Key'], *args, **kwargs)
-
-    def custom_key_batch_disassociate (self, *args, **kwargs):
-        """
-        This API enables you to inactivate external key identifiers for any entity (HCP, HCO, Address, License, or ParentHCO) in Network without going through the full change request process.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchdisassociatecustomkey
-
-        """
-        return self.api_call(self.api_custom_key['item']['Batch Disassociate Custom Key'], *args, **kwargs)
-
-
-    # =============================================================================
-    # Entity
-    # =============================================================================
-
-    def entity_retrieve (self, *args, **kwargs):
-        """
-        This API enables you to obtain information on any entity without identifying the specific entity type. It is only used to retrieve information from Network using the GET method.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveentity
-
-        """
-        return self.api_call(self.api_entity['item']['Retrieve Entity'], *args, **kwargs)
-
-    def entity_retrieve_child (self, *args, **kwargs):
-        """
-        This API enables you to retrieve child entity information; for example address or license details, for the Network ID provided without identifying the specific entity type.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievechildentity
-
-        """
-        return self.api_call(self.api_entity['item']['Retrieve Child Entity'], *args, **kwargs)
-
-    def entity_batch_retrieve (self, *args, **kwargs):
-        """
-        This API enables you to retrieve entity details directly from Network. It is only used to retrieve information using the GET method. To update or delete entity data, you must use the change request APIs.
-
-        The entities you can retrieve include HCPs and HCOs, and details are returned for all corresponding child entities: addresses, licenses, parent HCOs, and custom keys.
-        
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchretrieveentities
-
-        """
-        return self.api_call(self.api_entity['item']['Batch Retrieve Entities'], *args, **kwargs)
-
-    def entity_batch_retrieve_children (self, *args, **kwargs):
-        """
-        This API enables you to obtain information on child entities without identifying the specific entity type. Users are only allowed to retrieve (GET) information from Network.
-
-        All other operations (POST and DELETE) are restricted and can only be performed by submitting a change request using the change request APIs.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchretrievechildentities
-
-        """
-        return self.api_call(self.api_entity['item']['Batch Retrieve Child Entities'], *args, **kwargs)
-
-
-    # =============================================================================
-    # HCO
-    # =============================================================================
-
-    def hco_retrieve (self, *args, **kwargs):
-        """
-        This API enables you to retrieve information about an HCO. Information you can retrieve for an HCO includes the HCO, address, license, and parent HCO information (including their custom keys) for the HCO vid_key you provide.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveHCO
-
-        """
-        return self.api_call(self.api_hco['item']['Retrieve HCO'], *args, **kwargs)
-
-    def hco_associate_custom_key (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCOs are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the HCO vid_key you provide.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#AssociatecustomkeytoHCO
-
-        """
-        return self.api_call(self.api_hco['item']['Associate Custom Key to HCO'], *args, **kwargs)
-
-    def hco_address_associate_custom_key (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCO child objects (addresses) 
-        are downloaded from Network without going through the full change request process. 
-        This API associates the external identifier you submit to the child object key you provide.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject
-
-        """
-        return self.api_call(self.api_hco['item']['Associate Custom Key to HCO Address'], *args, **kwargs)
-
-    def hco_license_associate_custom_key (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCO child objects (licenses) 
-        are downloaded from Network without going through the full change request process. 
-        This API associates the external identifier you submit to the child object key you provide.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject
-
-        """
-        return self.api_call(self.api_hco['item']['Associate Custom Key to HCO License'], *args, **kwargs)
-
-    def hco_parenthco_associate_custom_key (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCO child objects (parent HCOs) 
-        are downloaded from Network without going through the full change request process. 
-        This API associates the external identifier you submit to the child object key you provide.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject
-
-        """
-        return self.api_call(self.api_hco['item']['Associate Custom Key to HCO ParentHCO'], *args, **kwargs)
-
-    # =============================================================================
-    # HCP
-    # =============================================================================
-    def hcp_retrive (self, *args, **kwargs):
-        """
-        This API enables you to retrieve information about an HCP including the HCP itself, address, license, and parent HCO information (including their custom keys) for the HCP vid_key you provide.
-
-        This API downloads the record for the specified entity from Veeva OpenData to your customer instance.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveHCP
-
-        """
-        return self.api_call(self.api_hcp['item']['Retrieve HCP'], *args, **kwargs)
-
-    def hcp_associate_custom_key (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCPs are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the HCP vid_key you provide.
-
-        This API requires system administrator or API-only permissions.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#AssociatecustomkeytoHCP
-
-        """
-        return self.api_call(self.api_hcp['item']['Associate Custom Key to HCP'], *args, **kwargs)
-
-    def hcp_address_associate_custom_key (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCP child objects (addresses) are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the child object key you provide.
-
-        This API requires system administrator or API-only permissions.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject1
-
-        """
-        return self.api_call(self.api_hcp['item']['Associate Custom Key to HCP Address'], *args, **kwargs)
-
-    def hcp_license_associate_custom_key (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCP child objects (licenses) are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the child object key you provide.
-
-        This API requires system administrator or API-only permissions.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject1
-        
-        """
-        return self.api_call(self.api_hcp['item']['Associate Custom Key to HCP License'], *args, **kwargs)
-
-    def hcp_parenthco_associate_custom_key (self, *args, **kwargs):
-        """
-        This API enables you to submit external key identifiers when new HCP child objects (parent HCOs) are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the child object key you provide.
-
-        This API requires system administrator or API-only permissions.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject1
-        
-        """
-        return self.api_call(self.api_hcp['item']['Associate Custom Key to HCP ParentHCO'], *args, **kwargs)
-
-    # =============================================================================
-    # Metadata
-    # =============================================================================
-    def metadata_retrieve_available_api_versions (self, *args, **kwargs):
-        """
-        This enables you to retrieve summary information about each API version available in Network.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveavailableAPIversions
-        
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve Available API Versions'], *args, **kwargs)
-        
-    def metadata_retrieve_hashtags (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the list of hashtags available in a Network instance.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievehashtags
-
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve hashtags'], *args, **kwargs)
-
-    # TODO: rename/refactor method.
-    def get_networkLanguages(self) -> list:
-        """
-        This API enables you to retrieve the list of reference data languages available in a Network instance.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievelanguages
-
-        """
-
-        self.authenticate()
-        self.networkLanguages = list(self.list_of_dicts_to_dict(
-            requests.get(
-                self.networkURL + 
-                '/api/' + 
-                self.LatestAPIversion + 
-                '/metadata/languages', 
-                headers=self.APIheaders).json()['languages'], 
-                'name'
-                ).keys())
-        return self.networkLanguages
-
-    def metadata_retrieve_object_types (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the list of object types available in Network.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveobjecttypesmetadata
-
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve Object Types Metadata'], *args, **kwargs)
-
-    def metadata_retrieve_field (self, *args, **kwargs):
-        """
-        This API enables you to retrieve detailed or summary information about the fields on each entity in Network.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievefieldsmetadata
-
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve Fields Metadata'], *args, **kwargs)
-
-    def metadata_retrieve_field_details (self, *args, **kwargs):
-        """
-        This API enables you to retrieve detailed information about the fields on each entity in Network.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievefielddetailsmetadata
-
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve Field Details Metadata'], *args, **kwargs)
-
-    def metadata_retrieve_field_groups (self, *args, **kwargs):
-        """
-        This API enables you to retrieve detailed information about the field groups available in Network. These field groups are used by the CRM bridge when retrieving and displaying information from Network in CRM.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievefieldgroupsmetadata
-
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve Field Groups Metadata'], *args, **kwargs)
-
-    def metadata_retrieve_reference_data_types (self, *args, **kwargs):
-        """
-        This API enables you to retrieve information about reference data types in Network.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievereferencedatatypesmetadata
-
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve Reference Data Types Metadata'], *args, **kwargs)
-
-    def metadata_retrieve_reference_data_type_details (self, *args, **kwargs):
-        """
-        This API enables you to retrieve detailed information about reference data types in Network.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievereferencedatatypedetailsmetadata
-
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve Reference Data Type Details Metadata'], *args, **kwargs)
-
-    def metadata_retrieve_reference_data_type_code_details (self, *args, **kwargs):
-        """
-        This API enables you to retrieve detailed information about reference data type codes in Network.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievereferencedatatypecodedetailsmetadata
-
-        """
-        return self.api_call(self.api_metadata['item']['Retrieve Reference Data Type Code Details Metadata'], *args, **kwargs)
-
-    # =============================================================================
-    # Subscriptions
-    # =============================================================================
-    def subscriptions_create_job (self, *args, **kwargs):
-        """
-        This API enables you to create a subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createasubscriptionjob
-
-        """
-        return self.api_call(self.api_subscriptions['item']['Create Subscription Job'], *args, **kwargs)
-
-    def subscriptions_retrieve_job (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the status of a source or target subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveasubscriptionjobstatus
-
-        """
-        return self.api_call(self.api_subscriptions['item']['Retrieve Subscription Job'], *args, **kwargs)
-
-    def subscriptions_cancel_job (self, *args, **kwargs):
-        """
-        This API enables you to cancel a subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelasubscriptionjob
-
-        """
-        return self.api_call(self.api_subscriptions['item']['Cancel Subscription Job'], *args, **kwargs)
-
-    def subscriptions_retrieve_export_job_file (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the artifacts (file contents) of a target subscription job.
-        AKA: Retrieve target subscription artifact
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievetargetsubscriptionartifact
-        
-        """
-        return self.api_call(self.api_subscriptions['item']['Retrieve Export Job File'], *args, **kwargs)
-
-    # =============================================================================
-    # Subscriptions - Compliance
-    # =============================================================================
-    def subscriptions_compliance_create_job (self, *args, **kwargs):
-        """
-        This API enables you to create a compliance subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createacompliancesubscriptionjob
-
-        """
-        return self.api_call(self.api_subscriptions_compliance['item']['Create Compiance Subscription Job'], *args, **kwargs)
-
-    def subscriptions_compliance_retrieve_job (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the status of a source or target subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveacompliancesubscriptionjobstatus
-        
-        """
-        return self.api_call(self.api_subscriptions_compliance['item']['Retrieve Compliance Subscription Job'], *args, **kwargs)
-
-    def subscriptions_compliance_cancel_job (self, *args, **kwargs):
-        """
-        This API enables you to cancel a compliance subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelacompliancesubscriptionjob
-
-        """
-        return self.api_call(self.api_subscriptions_compliance['item']['Cancel Compliance Subscription Job'], *args, **kwargs)
-
-    # =============================================================================
-    # Subscriptions - Source
-    # =============================================================================
-    def subscriptions_source_create_job (self, *args, **kwargs):
-        """
-        This API enables you to create a source subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createasourcesubscriptionjob
-
-        """
-        return self.api_call(self.api_subscriptions_source['item']['Create Source Subscription Job'], *args, **kwargs)
-
-    def subscriptions_source_retrieve_job (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the status of a source subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveasourcesubscriptionjobstatus
-
-        """
-        return self.api_call(self.api_subscriptions_source['item']['Retrieve Source Subscription Job'], *args, **kwargs)
-
-    def subscriptions_source_cancel_job (self, *args, **kwargs):
-        """
-        This API enables you to cancel a source subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelasourcesubscriptionjob
-        
-        """
-        return self.api_call(self.api_subscriptions_source['item']['Cancel Source Subscription Job'], *args, **kwargs)
-
-    # =============================================================================
-    # Subscriptions - Target
-    # =============================================================================
-    def subscriptions_target_create_job (self, *args, **kwargs):
-        """
-        This API enables you to create a target subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createatargetsubscriptionjob
-
-        """
-        return self.api_call(self.api_subscriptions_target['item']['Create Target Subscription Job'], *args, **kwargs)
-
-    def subscriptions_target_retrieve_job (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the status of a source or target subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveatargetsubscriptionjobstatus
-
-        """
-        return self.api_call(self.api_subscriptions_target['item']['Retrieve Target Subscription Job'], *args, **kwargs)
-
-    def subscriptions_target_cancel_job (self, *args, **kwargs):
-        """
-        This API enables you to cancel a target subscription job.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelatargetsubscriptionjob
-        """
-        return self.api_call(self.api_subscriptions_target['item']['Cancel Target Subscription Job'], *args, **kwargs)
-
-    # =============================================================================
-    # Events
-    # =============================================================================
-    def events_retrieve_merge (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the results of merge events that occurred in your Network instance.
-
-        Merges initiated by Veeva OpenData on a master instance are included if the surviving and losing records of the merge have been downloaded to your instance.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveMerges
-
-        """
-        return self.api_call(self.api_events['item']['Retrieve Merge Events'], *args, **kwargs)
-
-    def events_retrieve_unmerge (self, *args, **kwargs):
-        """
-        This API enables you to retrieve the results of unmerge events that occurred in your Network instance.
-
-        Unmerges include events that occurred in your Network instance; only customer (gray) records are reported.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveUnmerges
-
-        """
-        return self.api_call(self.api_events['item']['Retrieve Unmerge Events'], *args, **kwargs)
-
-    # =============================================================================
-    # Match
-    # =============================================================================
-    def match_retrieve (self, *args, **kwargs):
-        """
-        This API enables you to match data immediately for a single record using match rules from the specified Network instance.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveMatches
-
-        """
-        return self.api_call(self.api_match['item']['Retrieve Matches'], *args, **kwargs)
-
-    # =============================================================================
-    # Suspect Match
-    # =============================================================================
-    def suspect_match_batch_process (self, *args, **kwargs):
-        """
-        This API enables enables you to process multiple unprocessed suspect matches.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchProcessSuspectMatch
-
-        """
-        return self.api_call(self.api_suspect_match['item']['Batch Process Suspect Match'], *args, **kwargs)
-
-    def suspect_match_batch_create (self, *args, **kwargs):
-        """
-        This API enables enables you to create multiple suspect matches.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchCreateSuspectMatch
-
-        """
-        return self.api_call(self.api_suspect_match['item']['Batch Create Suspect Match'], *args, **kwargs)
-
-    def suspect_match_batch_reject_task (self, *args, **kwargs):
-        """
-        This API enables enables you to reject multiple suspect match tasks.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchRejectSuspectMatch
-
-        """
-        return self.api_call(self.api_suspect_match['item']['Batch Reject Suspect Match Task'], *args, **kwargs)
-
-    def suspect_match_batch_retrieve (self, *args, **kwargs):
-        """
-        This API enables enables you to retrieve information about multiple suspect matches.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchRetrieveSuspectMatch
-
-        """
-        self.api_call(suspect_match['item']['Batch Retrieve Suspect Match'], *args, **kwargs)
-
-    # =============================================================================
-    # Retrieve Available API Versions
-    # =============================================================================
-    def retrieve_available_api_versions (self, *args, **kwargs):
-        """
-        This enables you to retrieve summary information about each API version available in Network.
-
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveavailableAPIversions
-
-        """
-        return self.api_call(self.api_retrieve_available_api_versions, *args, **kwargs)
-    # =============================================================================
-    # Search
-    # =============================================================================
-    def search (self, *args, **kwargs):
-        """
-        Search calls enable you to construct simple, yet powerful searches to retrieve data from Network.
-
-        Calls through the Search API pass a query string in an expression that specifies the search text and specific parameters to get the intended set of entities from Network. Search results are ranked according to closeness to the search terms specified.
-        
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#search
-        
-        """
-        return self.api_call(self.api_search, *args, **kwargs)
-    # =============================================================================
-    # System Settings
-    # =============================================================================
-    def system_settings_retrieve (self):
-        """
-        This API enables you to retrieve the value for the geolocation system setting.
-
-        Currently only api.search.geolocation.countries is supported.
-        
-        Documentation:
-        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievesystemsettings
-        
-        """
-        result = requests.get(
-            url=f"{self.networkURL}/api/v26.0/systemSettings/api.search.geolocation.countries", 
-            headers=self.APIheaders).json()
-        return result
-        
-
-    # =============================================================================
-    # Utilities
-    # =============================================================================
-
-    def api_call (
-        self,
-        api: dict, 
-        body: dict = None, 
-        variables: dict = None, 
-        queries: dict = None, 
-        if_print: bool=False,  # If True, prints each component of the api call, the api call will still execute unless if_debug or if_example paramters are set to True.
-        if_debug: bool=False, # If True, the api call does not execute, but instead returns the api call as a string for debugging
-        if_example: bool=False # If True, the api call does not execute and returns examples of any body, variables, or queries.
-    ):
-
-        examples = {}
-
-        result = {
-            'api_body' : body,
-            'api_variables' : variables,
-            'api_queries' : queries
-        }
-
-        request_params = {}
-
-        def print_if(text):
-            if if_print:
-                print(text)
-
-        if api.keys().__contains__('name'):
-            print_if('\n- Name: ')
-            print_if(api['name'])
-            result['api_name'] = api['name'] ### Updating Result Name
-
-        if api.keys().__contains__('protocolProfileBehavior'):
-            print_if('\n- protocolProfileBehavior: ')
-            if api['protocolProfileBehavior'].keys().__contains__('disableBodyPruning'):
-                print_if('- disableBodyPruning: ')
-                print_if(api['protocolProfileBehavior']['disableBodyPruning'])
-                result['api_protocolProfileBehavior_disableBodyPruning'] = api['protocolProfileBehavior']['disableBodyPruning'] ### Updating Result disableBodyPruning
-
-        if api.keys().__contains__('request'):
-
-            ### =============================================================================
-            ### Parsing Header
-            ### =============================================================================
-
-            if api['request'].keys().__contains__('header'):
-                if isinstance(api['request']['header'], dict):
-                    print_if("\n- Request header keys: ")
-                    print_if(api['request']['header'].keys())
-                    result['api_header'] = {}
-                    request_params['headers'] = {}
-                    for header_key, header_value in api['request']['header'].items():
-                        print_if("\n- Request header key:")
-                        print_if(header_key)
-                        if isinstance(header_value, dict):
-                            if header_value.keys().__contains__('value'):
-                                result['api_header'].update({header_key: self.sub_request_params(api['request']['header'][header_key]['value'])}) ### Updating Result API Header
-                                request_params['headers'].update({header_key: self.sub_request_params(api['request']['header'][header_key]['value'])}) ### Updating Request Header
-
-                            for key, value in header_value.items():
-                                print_if("\n- Request header value dict key and value:")
-                                print_if(key)
-                                print_if(value)
-                        else:
-                            print_if("Request Header Value: ")
-                            print_if(header_value)
-                            raise NetworkAPIHeaderValueNotFound
-
-            ### =============================================================================
-            ### Parsing Method
-            ### =============================================================================
-
-            if api['request'].keys().__contains__('method'):
-                print_if("\n- Request method: ")
-                print_if(api['request']['method'])
-
-                match api['request']['method']:
-                    case 'POST':
-                        result['api_method'] = requests.post # Updating Result Method
-                        print_if("\n- Request Method Post:")
-                        print_if("requests.post")
-                    case 'GET':
-                        result['api_method'] = requests.get # Updating Result Method
-                        print_if("\n- Request Method Get:")
-                        print_if("requests.get")
-                    case 'PUT':
-                        result['api_method'] = requests.put # Updating Result Method
-                        print_if("\n- Request Method Put:")
-                        print_if("requests.put")
-                    case 'DELETE':
-                        result['api_method'] = requests.delete # Updating Result Method
-                        print_if("\n- Request Method Delete:")
-                        print_if("requests.delete")
-                    case _:
-                        print_if("\n- Request Method Unknown:")
-                        print_if("unknown method")
-                        raise NetworkAPIRequestMethodNotFound
-
-            ### =============================================================================
-            ### Parsing Body
-            ### =============================================================================
-
-            if (api['request'].keys().__contains__('body') == True) and \
-                (api['request']['body'].keys().__contains__('raw') == True) and \
-                (api['request']['body']['raw'] != ''):
-                print_if("\n- Request body raw: ")
-                print_if(json.loads(api['request']['body']['raw']))
-                examples['body'] = json.loads(api['request']['body']['raw']) ### Updating Result API Body
-                # If the body parameter is not provided in an API call that requires a body. Raise Error.
-                if body is None and if_example==False:
-                    raise NetworkAPIRequestBodyNotFound
-                else:
-                    request_params['data']=json.dumps(body)
-            else:
-                print_if("\n- Request body raw: ")
-                print_if("No Body Found")
-            
-            ### =============================================================================
-            ### Parsing URL
-            ### =============================================================================
-
-            if api['request'].keys().__contains__('url'):
-                print_if("\n- Request url keys: ")
-                print_if(api['request']['url'].keys())
-
-                ### =============================================================================
-                ### Parsing Raw URL
-                ### =============================================================================
-
-                if api['request']['url'].keys().__contains__('raw'):
-                    print_if("\n- Request url raw: ")
-                    print_if(api['request']['url']['raw'])
-                    result['api_url'] = self.sub_request_params(api['request']['url']['protocol'] + "://" + api['request']['url']['host'][0] + "/" + "/".join(api['request']['url']['path'])) ### Updating Result API URL
-                    request_params['url'] = self.sub_request_params(api['request']['url']['protocol'] + "://" + api['request']['url']['host'][0] + "/" + "/".join(api['request']['url']['path'])) ### Updating Request URL
-                else:
-                    raise NetworkAPIRequestURLNotFound
-
-                
-                ### =============================================================================
-                ### Parsing URL Protocol
-                ### =============================================================================
-                
-                if api['request']['url'].keys().__contains__('protocol'):
-                    print_if("\n- Request url protocol: ")
-                    # always "https"
-                    print_if(api['request']['url']['protocol'])
-
-                ### =============================================================================
-                ### Parsing URL Host
-                ### =============================================================================
-                
-                if api['request']['url'].keys().__contains__('host'):
-                    print_if("\n- Request url host: ")
-                    # always ['{{DNS}}]
-                    print_if(api['request']['url']['host'][0])
-
-                ### =============================================================================
-                ### Parsing URL Path
-                ### =============================================================================
-
-                if api['request']['url'].keys().__contains__('path'):
-                    print_if("\n- Request url path: ")
-                    # A list of path components. i.e. ['api', '{{version}}', 'hcos', ':vid_key', 'addresses', ':address_key', 'custom_keys']
-                    print_if(api['request']['url']['path'])
-
-                ### =============================================================================
-                ### Parsing URL Variable
-                ### =============================================================================
-
-                if api['request']['url'].keys().__contains__('variable'):
-                    if variables is None and if_example==False:
-                        raise NetworkAPIRequestVariableNotFound
-                    elif if_example==False:
-                        for variable in variables.keys():
-                            result['api_url'] = result['api_url'].replace(":" + variable, variables[variable]['value'])
-                            request_params['url'] = request_params['url'].replace(":" + variable, variables[variable]['value'])
-
-                    if isinstance(api['request']['url']['variable'], dict):
-                        print_if("\n- Request url variable keys: ")
-                        print_if(api['request']['url']['variable'].keys())
-                        variables: dict = api['request']['url']['variable']
-                        examples['variables'] = variables ### Updating Result API URL Variable Examples
-                        
-                        for key, value in variables.items():
-                            if isinstance(value, dict):
-                                print_if("\n- Request url variable key and value dict: ")
-                                print_if(key)
-                                print_if(value)
-                            else:
-                                print_if("\n- Request url variable value: ") 
-                                print_if(str(value))
-
-                ### =============================================================================
-                ### Parsing URL Query
-                ### =============================================================================
-
-                if api['request']['url'].keys().__contains__('query'):
-                    if queries is None and if_example==False:
-                        raise NetworkAPIRequestQueryNotFound
-                    elif if_example==False:
-                        result['api_url'] = result['api_url'] + '?'
-                        request_params['url'] = request_params['url'] + '?'
-                        for key, value in queries.items():
-                            if result['api_url'][-1] == '?':
-                                result['api_url'] = result['api_url'] + key + '=' + value['value']
-                                request_params['url'] = request_params['url'] + key + '=' + value['value']
-                            else:
-                                result['api_url'] = result['api_url'] + '&' + key + '=' + value['value']
-                                request_params['url'] = request_params['url'] + '&' + key + '=' + value['value']
-
-                    print_if("\n- Request url query keys: ")
-                    print_if(api['request']['url']['query'].keys())
-                    queries: dict = api['request']['url']['query'] 
-                    examples['query'] = queries ### Updating Result API URL Query Examples
-                    for key, value in queries.items():
-                        print_if("\n- Request url query key and value: ")
-                        if isinstance(value, dict):
-                            print_if(key)
-                            print_if(value)
-                        else:
-                            print_if(str(value))
-
-            ### =============================================================================
-            ### Parsing Description
-            ### =============================================================================
-
-            if api['request'].keys().__contains__('description'):
-                print_if("\n- Request Description: ")
-                print_if(api['request']['description'])
-                examples['description'] = api['request']['description'] ### Updating Description
-
-        if api.keys().__contains__('response'):
-            print_if(api['response'])
-
-        if (not if_debug) & (not if_example) & (result.keys().__contains__('api_method')):
-            response = result['api_method'](**request_params)
-
-        if if_debug & if_example:
-            return result, examples, request_params
-        if if_debug:
-            return result, request_params
-        if if_example:
-            return examples
-        return response
-
-
-    @staticmethod
-    def list_of_dicts_to_dict(list_of_dict: list, key) -> dict:
-        """
-        Function takes a list of dicts and returns a single dict.
-
-        Parameters:
-        list_of_dict: list of dicts, i.e. [{'key1': 'value1', 'key2': 'value2'}, {'key1': 'value1', 'key2': 'value2'}]
-        key (str): key to use for the dict. i.e. 'key1'
-            in our example, [{'key1': 'value1', 'key2': 'value2'}, {'key1': 'value1', 'key2': 'value2'}]
-            The output dictionary would have value1, value2 as the keys:
-            {'value1': {'key1': 'value1', 'key2': 'value2'}, 'value2': {'key1': 'value1', 'key2': 'value2'}}
-
-        """
-        obj_dict = {}
-        __empty = [obj_dict.update({x[key]: x}) for x in list_of_dict]
-        return obj_dict
-
-    @staticmethod
-    def cartesian_join(pd1, pd2):
-        df1 = pd1.copy()
-        df2 = pd2.copy()
-        df1.reset_index()
-        df2.reset_index()
-        df1['cartesian_join_key'] = 1
-        df2['cartesian_join_key'] = 1
-        result = pd.merge(df1, df2, on ='cartesian_join_key').drop(labels="cartesian_join_key", axis=1)
-        return result
-        
-    def sub_request_params (self, request: str) -> str:
-        substitutions_dict = {
-            '{{AUTHORIZATION}}': self.APIheaders['authorization'],
-            '{{DNS}}': self.network_DNS,
-            '{{version}}': self.LatestAPIversion
-        }
-        for key, value in substitutions_dict.items():
-            request = request.replace(key, value)
-        return request
-    
-    def __parse_network_api_json(self, network_api: dict):
-        output = {}
-        for key, value in network_api.items():
-            if isinstance(value, dict):
-                output[key] = self.__parse_network_api_json(value)
-            elif isinstance(value, list):
-                first_key_set = set()
-                for item in value:
-                    if isinstance(item, dict):
-                        first_key_set.add(list(item.keys())[0])
-                if len(first_key_set) == 1:
-                    output[key] = self.__parse_network_api_json(self.list_of_dicts_to_dict(value, list(first_key_set)[0]))
-                else:
-                    output[key] = value
-            else:
-                output[key] = value
+from sys import platform
+import requests
+import pandas as pd
+import os
+import json
+from typing import List, Tuple, Optional, Union, Type, OrderedDict, Iterable
+import numpy as np
+import sys
+import importlib.resources
+from urllib.parse import urlparse
+try:
+    from custom_exceptions.veevanetwork_exceptions import *
+except:
+    from veevanetwork.custom_exceptions.veevanetwork_exceptions import *
+
+class Vn:
+    def __init__(self):
+        self.os_platform: str = platform
+        self.networkURL: str = None # https://verteonetwork.veevanetwork.com
+        self.networkUserName: str = None
+        self.networkPassword: str = None
+        self.networkCountry: str = 'US'
+        self.networkConnection: requests.models.Response = None
+        self.networkLanguages: list = None # List of languages supported by this instance of Veeva Network
+        self.networkObjects: dict = None # Dictionary of Network Objects and their properties
+        self.networkObjectMetadata: dict = None # {'HCP': {'my_custom_field__c': {'fieldId': 'my_custom_field__c','type': {'dataType': 'STRING', 'discriminator': None}, 'labels': {'en': 'My Custom Field'}}}}
+        self.networkReferenceTypes: dict = None # {'AddressAdminArea': {'type': 'AddressAdminArea','customerOwned': False,'inactive': False,'description': 'AddressAdminArea'}, 'AddressCBSA': {'type': 'AddressCBSA' ... }}
+        self.networkReferenceValueMetadata: dict = None # Dictionary of Network Reference Value Metadata, including countries, reference codes, translated values, etc.
+        self.sessionId: str = None
+        self.networkId: str = None
+        self.APIheaders: dict = None
+        self.APIversionList: list = []
+        self.LatestAPIversion: str = None
+        self.network_references_all: pd.DataFrame = None
+        self.network_DNS: str = None # verteonetwork.veevanetwork.com
+        self.network_protocol: str = None # https
+
+        #----------------------------------------------------------------
+        # Load Network API Json
+        self.network_api_json: dict = None
+        try: # Try to load the network API json, to be used in a packaged distribution context
+            with importlib.resources.open_text("veevanetwork", "network_api_v25.json") as file:
+                self.network_api_json = json.load(file)
+        except: # If the above fails, try to load the network API json, to be used in a development context
+            with open('network_api_v25.json', encoding="utf-8") as file:
+                self.network_api_json = json.load(file)
+        self.network_api_parsed: dict = self.__parse_network_api_json(self.network_api_json)
+        self.api_categories: list = list(self.network_api_parsed['item'].keys())
+
+        self.api_change_request = self.network_api_parsed['item']['Change Request']
+        self.api_custom_key = self.network_api_parsed['item']['Custom Key']
+        self.api_entity = self.network_api_parsed['item']['Entity']
+        self.api_hco = self.network_api_parsed['item']['HCO']
+        self.api_hcp = self.network_api_parsed['item']['HCP']
+        self.api_metadata = self.network_api_parsed['item']['Metadata']
+        self.api_subscriptions = self.network_api_parsed['item']['Subscriptions']
+        self.api_subscriptions_compliance = self.network_api_parsed['item']['Subscriptions - Compliance']
+        self.api_subscriptions_source = self.network_api_parsed['item']['Subscriptions - Source']
+        self.api_subscriptions_target = self.network_api_parsed['item']['Subscriptions - Target']
+        self.api_events = self.network_api_parsed['item']['Events']
+        self.api_match = self.network_api_parsed['item']['Match']
+        self.api_suspect_match = self.network_api_parsed['item']['Suspect Match']
+        self.api_authentication = self.network_api_parsed['item']['Authentication']
+        self.api_retrieve_available_api_versions = self.network_api_parsed['item']['Retrieve Available API Versions']
+        self.api_search = self.network_api_parsed['item']['Search']
+        self.call = {
+            "Change Request": {
+                "change_request_create": self.change_request_create,
+                "change_request_cancel": self.change_request_cancel,
+                "change_request_retrieve": self.change_request_retrieve,
+                "change_request_batch_retrieve": self.change_request_batch_retrieve,
+                "change_request_update": self.change_request_update,
+                "change_request_batch_update": self.change_request_batch_update,
+                "change_request_process": self.change_request_process,
+                "change_request_batch_process": self.change_request_batch_process,
+                "change_request_search": self.change_request_search,
+                "change_request_match": self.change_request_match,
+                "change_request_batch_approve": self.change_request_batch_approve,
+                "change_request_batch_reject": self.change_request_batch_reject
+            },
+            "Custom Key": {
+                "custom_key_associate_to_entity": self.custom_key_associate_to_entity,
+                "custom_key_associate_to_child": self.custom_key_associate_to_child,
+                "custom_key_batch_associate_to_entities": self.custom_key_batch_associate_to_entities,
+                "custom_key_batch_associate_to_children": self.custom_key_batch_associate_to_children,
+                "custom_key_disassociate": self.custom_key_disassociate,
+                "custom_key_batch_disassociate": self.custom_key_batch_disassociate
+            },
+            "Entity": {
+                "entity_retrieve": self.entity_retrieve,
+                "entity_retrieve_child": self.entity_retrieve_child,
+                "entity_batch_retrieve": self.entity_batch_retrieve,
+                "entity_batch_retrieve_children": self.entity_batch_retrieve_children
+            },
+            "HCO": {
+                "hco_retrieve": self.hco_retrieve,
+                "hco_associate_custom_key": self.hco_associate_custom_key,
+                "hco_address_associate_custom_key": self.hco_address_associate_custom_key,
+                "hco_license_associate_custom_key": self.hco_license_associate_custom_key,
+                "hco_parenthco_associate_custom_key": self.hco_parenthco_associate_custom_key
+            },
+            "HCP": {
+                "hcp_retrive": self.hcp_retrive,
+                "hcp_associate_custom_key": self.hcp_associate_custom_key,
+                "hcp_address_associate_custom_key": self.hcp_address_associate_custom_key,
+                "hcp_license_associate_custom_key": self.hcp_license_associate_custom_key,
+                "hcp_parenthco_associate_custom_key": self.hcp_parenthco_associate_custom_key
+            },
+            "Metadata": {
+                "metadata_retrieve_available_api_versions": self.metadata_retrieve_available_api_versions,
+                "metadata_retrieve_hashtags": self.metadata_retrieve_hashtags,
+                "metadata_retrieve_object_types": self.metadata_retrieve_object_types,
+                "metadata_retrieve_field": self.metadata_retrieve_field,
+                "metadata_retrieve_field_details": self.metadata_retrieve_field_details,
+                "metadata_retrieve_field_groups": self.metadata_retrieve_field_groups,
+                "metadata_retrieve_reference_data_types": self.metadata_retrieve_reference_data_types,
+                "metadata_retrieve_reference_data_type_details": self.metadata_retrieve_reference_data_type_details,
+                "metadata_retrieve_reference_data_type_code_details": self.metadata_retrieve_reference_data_type_code_details
+            },
+            "Subscriptions": {
+                "subscriptions_create_job": self.subscriptions_create_job,
+                "subscriptions_retrieve_job": self.subscriptions_retrieve_job,
+                "subscriptions_cancel_job": self.subscriptions_cancel_job,
+                "subscriptions_retrieve_export_job_file": self.subscriptions_retrieve_export_job_file
+            },
+            "Subscriptions - Compliance": {
+                "subscriptions_compliance_create_job": self.subscriptions_compliance_create_job,
+                "subscriptions_compliance_retrieve_job": self.subscriptions_compliance_retrieve_job,
+                "subscriptions_compliance_cancel_job": self.subscriptions_compliance_cancel_job
+            },
+            "Subscriptions - Source": {
+                "subscriptions_source_create_job": self.subscriptions_source_create_job,
+                "subscriptions_source_retrieve_job": self.subscriptions_source_retrieve_job,
+                "subscriptions_source_cancel_job": self.subscriptions_source_cancel_job
+            },
+            "Subscriptions - Target": {
+                "subscriptions_target_create_job": self.subscriptions_target_create_job,
+                "subscriptions_target_retrieve_job": self.subscriptions_target_retrieve_job,
+                "subscriptions_target_cancel_job": self.subscriptions_target_cancel_job
+            },
+            "Events": {
+                "events_retrieve_merge": self.events_retrieve_merge,
+                "events_retrieve_unmerge": self.events_retrieve_unmerge
+            },
+            "Match": {
+                "match_retrieve": self.match_retrieve,
+                "suspect_match_batch_reject_task": self.suspect_match_batch_reject_task,
+
+            },
+            "Suspect Match": {
+                "suspect_match_batch_process": self.suspect_match_batch_process,
+                "suspect_match_batch_create": self.suspect_match_batch_create,
+                "suspect_match_batch_reject_task": self.suspect_match_batch_reject_task,
+                "suspect_match_batch_retrieve": self.suspect_match_batch_retrieve
+            },
+            "Retrieve Available API Versions": {
+                "retrieve_available_api_versions": self.retrieve_available_api_versions
+            },
+            "Search": {
+                "search": self.search
+            }
+            }
+    
+    # =============================================================================
+    # Authentication
+    # =============================================================================
+
+    # Refactored - MP 20220610
+    def authenticate(
+        self, 
+        networkURL: str=None, 
+        networkUserName: str=None, 
+        networkPassword: str=None, 
+        networkCountry: str=None, 
+        networkId: str=None,
+        sessionId: str=None,
+        if_return: bool=False, 
+        *args, **kwargs
+    ) -> Optional[dict]:
+        """
+        Authenticates Veeva Network and retrieves the auth token.
+
+        Example:
+        authenticate using unpacked kwargs from the retrieve_credentials function
+            authenticate_vn(**retrieve_credentials(platform, 'credentials.xlsx')[0])
+
+        Return Example:
+            {'sf': <simple_salesforce.api.Salesforce at 0x24a045c7b50>,
+             'bulk': <salesforce_bulk.salesforce_bulk.SalesforceBulk at 0x24a045c7e20>,
+             'sfMeta': <sfdclib.session.SfdcSession at 0x24a044b3400>,
+             'tooling': <sfdclib.tooling.SfdcToolingApi at 0x24a045d17f0>,
+             'session_id': '00D3F000000FZCq!AQYAQHYfSLYGI9cTyjDfxAAzYm.1uOKmNPXlKMW0sVz5ilIQ9ZwVTh6kOlaRuqfPuuzNnZNb3461sUGeUZ57ttE.GBawbt5h',
+             'instance': 'cslbehring-core--devr01.my.salesforce.com',
+             'sfMeta_is_connected': True,
+             'bulk_api_sessionId': '00D3F000000FZCq!AQYAQHYfSLYGI9cTyjDfxAAzYm.1uOKmNPXlKMW0sVz5ilIQ9ZwVTh6kOlaRuqfPuuzNnZNb3461sUGeUZ57ttE.GBawbt5h'}
+
+        Dependencies:
+            import requests
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Authenticate
+        
+        """
+        if (networkId and sessionId and networkURL):
+            self.networkId = self.networkId if networkId is None else networkId
+            self.sessionId = self.sessionId if sessionId is None else sessionId
+        
+        url_parse = urlparse(networkURL)
+        if len(url_parse.scheme) == 0:
+            self.network_protocol = 'https'
+            if len(url_parse.path) > 0:
+                self.network_DNS = url_parse.path
+                self.networkURL = self.network_protocol + '://' + url_parse.path
+
+        if len(url_parse.scheme) > 0:
+            self.network_protocol = url_parse.scheme
+            if len(url_parse.netloc) > 0:
+                self.network_DNS = url_parse.netloc
+                self.networkURL = url_parse.scheme + '://' + url_parse.netloc
+
+        if (self.networkURL is None) or (len(self.networkURL) == 0):
+            raise Exception('networkURL is required')
+
+
+        # self.networkURL = self.networkURL if networkURL is None else networkURL
+        self.networkUserName = self.networkUserName if networkUserName is None else networkUserName
+        self.networkPassword = self.networkPassword if networkPassword is None else networkPassword
+        self.networkCountry = self.networkCountry if networkCountry is None else networkCountry
+        
+        if self.networkUserName and self.networkPassword and self.networkURL:
+            payload = {
+                'username': self.networkUserName,
+                'password': self.networkPassword
+            }
+            headers = {
+                'Content-Type': 'application/x-www-form-urlencoded'
+            }
+            
+            self.networkConnection = requests.post(self.networkURL + '/api/v29.0/auth', data=payload, headers=headers)
+            
+            if self.networkConnection.json()['responseStatus'] == 'SUCCESS':
+                self.sessionId = self.networkConnection.json()['sessionId']
+                self.userId = self.networkConnection.json()['userId']
+                self.networkId = self.networkConnection.json()['networkId']
+            else:
+                raise Exception(self.networkConnection.json())
+
+
+        
+        self.APIheaders = {'authorization': self.sessionId}
+        self.APIversionList = []
+        
+        # Error checking whether the required parameters are passed in
+        # The check happens here because this is where all the self assignments has completed
+        if (not (self.networkId and self.sessionId and self.networkURL)) and (not (self.networkUserName and self.networkPassword and self.networkCountry and self.networkURL)):
+            raise Exception("Please provide either networkId, sessionId, and networkURL or networkUserName, networkPassword, and networkURL")
+        
+        for API in requests.get(self.networkURL +'/api', headers=self.APIheaders).json()['values'].keys():
+            self.APIversionList.append(float(API.replace("v", "")))
+        self.APIversionList.sort()
+        self.LatestAPIversion = "v" + str(self.APIversionList[-1])
+        
+
+        if if_return:
+            return {'networkURL':self.networkURL, 
+                    'networkUserName':self.networkUserName, 
+                    'networkPassword':self.networkPassword, 
+                    'networkConnection':self.networkConnection, 
+                    'sessionId':self.sessionId, 
+                    'APIheaders':self.APIheaders, 
+                    'APIversionList':self.APIversionList, 
+                    'LatestAPIversion':self.LatestAPIversion}    
+
+    # Refactored - MP 20220610
+    def get_networkObjects(self) -> pd.DataFrame:
+        """
+        Returns a list of all objects in the Veeva Network.
+        """
+        self.authenticate()
+
+        self.networkObjects = self.list_of_dicts_to_dict(requests.get(self.networkURL + '/api/' + self.LatestAPIversion + '/metadata/objectTypes',
+                                      headers=self.APIheaders).json()['objectTypes'], 'name')
+        return self.networkObjects
+
+    # Refactored - MP 20220610
+    def get_networkObjectMetadata(self) -> pd.DataFrame:
+        self.authenticate()
+        if self.networkObjects is None:
+            self.get_networkObjects()
+
+        processing_dict = {}
+        __empty =[
+            processing_dict.update({networkObject: 
+                self.list_of_dicts_to_dict(requests.get(
+                        self.networkURL + 
+                        '/api/'+ self.LatestAPIversion +
+                        '/metadata/fields?objectTypes=' + 
+                        networkObject + '&details=full' + 
+                        '&countries='+ self.networkCountry, 
+                        headers=self.APIheaders).json()['attributes'],
+                        'fieldId')}) 
+                        for networkObject in self.networkObjects.keys()]
+        self.networkObjectMetadata = processing_dict
+        return self.networkObjectMetadata
+
+
+    # Refactored - MP 20220612
+    def process_networkReferenceCodeMetadata(
+        self,
+        referenceTypes: Optional[list] = None, # List of reference types to retrieve, leave empty (None) to retrieve all
+        customerOwned: Optional[bool] = None, # True (customer owned only), False (ootb), None (customer owned and ootb)
+        activeReferences: Optional[bool]= None, # True (active only), False (inactive only), None (active and inactive)
+        languages: Optional[list]= None, # List of languages to retrieve, leave empty (None) to retrieve all
+        countries: Optional[list]= None, # List of countries to retrieve, leave empty (None) to retrieve all
+    ):
+        """
+        Processes Network Reference Metadata and returns a DataFrame of the reference codes based on the parameters.
+
+        Parameters:
+        referenceTypes: List of reference types to retrieve, leave empty (None) to retrieve all
+        customerOwned (bool): Filter references by customerOwned status. Values: True (customerOwned only), False (ootb only), None (customerOwned and ootb)
+        activeReferences (bool): Filter references by status. Values: True (active only), False (inactive only), None (active and inactive)
+        languages (list): List of languages to return. Default: ['en']
+        countries (list): List of countries to return. Default: ['US']
+
+        Returns:
+        DataFrame: A DataFrame of the reference codes based on the parameters.
+        """
+
+        if self.networkReferenceValueMetadata is None:
+            self.get_networkReferenceValueMetadata()
+        
+        if languages is None:
+            if self.networkLanguages is None:
+                self.get_networkLanguages()
+            languages = self.networkLanguages
+            
+        networkReferenceDF = pd.DataFrame(self.networkReferenceValueMetadata)
+        networkReferenceCodeDataframe = networkReferenceDF.loc['reference_type_codes', :].dropna()
+        reference_code_dict_unfiltered: dict[str, pd.DataFrame] = {}
+        for index, values in zip(networkReferenceCodeDataframe.index, networkReferenceCodeDataframe.values):
+            reference_code_dict_unfiltered.update({index: pd.DataFrame(self.list_of_dicts_to_dict(values, 'code'))})
+        
+        final_df = pd.DataFrame()
+        for reference_type, reference_dataframe in zip(reference_code_dict_unfiltered.keys(), reference_code_dict_unfiltered.values()):
+            if referenceTypes is None or reference_type in referenceTypes:
+                activeReferences = None
+                customerOwned = None
+                activeReferences_filter = [True,False] if activeReferences is None else [not(activeReferences)]
+                customerOwned_filter = [True,False] if customerOwned is None else [customerOwned]
+                reference_dataframe = reference_dataframe.T.copy()
+                filtered_customerOwned_and_active = reference_dataframe[
+                                                (reference_dataframe['customerOwned'].isin(customerOwned_filter)) & 
+                                                (reference_dataframe['inactive'].isin(activeReferences_filter))
+                                                ]
+
+                filtered_languages = pd.DataFrame()
+
+                for language in languages:
+                    filtered_languages = pd.concat([filtered_languages,
+                                                pd.DataFrame(
+                                                    filtered_customerOwned_and_active["values"]
+                                                    .apply(lambda value: value[language] 
+                                                    if value.keys()
+                                                    .__contains__(language) 
+                                                    else np.nan)
+                                                    .dropna()
+                                                    .rename(language))], axis=1)
+                filtered_languages.insert(0, 'Network Code', filtered_languages.index)
+                filtered_languages.insert(1, 'Reference Type', reference_type)
+                filtered_languages.insert(2, 'Active Countries', pd.DataFrame(filtered_customerOwned_and_active["countries"]
+                                                    .apply(lambda value: ";".join(sorted(value)) if (countries is None or len(set(value).intersection(set(countries)))>0 ) else np.nan).rename('countries')
+                                                )['countries'])
+                filtered_languages.insert(3, 'Definition', pd.DataFrame(
+                                                    filtered_customerOwned_and_active["values"]
+                                                    .apply(lambda value: value['en'] 
+                                                    if value.keys()
+                                                    .__contains__('en') 
+                                                    else np.nan)
+                                                    .dropna()
+                                                    .rename('en'))['en'])
+                filtered_languages.insert(4, 'Active?', filtered_customerOwned_and_active["inactive"] == False)
+                filtered_languages.insert(5, 'Veeva Maintained?', filtered_customerOwned_and_active["customerOwned"] == False)             
+                filtered_languages.reset_index(drop=True, inplace=True)
+                filtered_languages.dropna(subset=['Active Countries'], inplace=True)
+                filtered_languages.replace(np.nan, "", inplace=True)
+                filtered_languages
+                final_df = pd.concat([final_df, filtered_languages], axis=0)
+
+        final_df.reset_index(drop=True, inplace=True)
+        
+        return final_df
+
+    # To be deprecated, used by object_metadata_dataframe()
+    def object_metadata(self):
+        self.networkObjects = requests.get(self.networkURL + '/api/' + self.LatestAPIversion + '/metadata/objectTypes',
+                                      headers=self.APIheaders).json()['objectTypes']
+        networkObjectList = []
+        for obj in self.networkObjects:
+            if obj['status'] == 'ACTIVE':
+                networkObjectList.append(obj['name'])
+            else:
+                pass
+        object_metadata = pd.DataFrame([requests.get(self.networkURL + '/api/'+ self.LatestAPIversion +'/metadata/fields?objectTypes=' + networkObject + '&details=full' + '&countries='+ self.networkCountry, headers=self.APIheaders).json()['attributes'] 
+                                              for networkObject in networkObjectList])
+        object_metadata = object_metadata.transpose()
+        object_metadata.columns = networkObjectList
+        return object_metadata
+
+    # To be deprecated, use get_networkObjectMetadata() instead
+    def object_metadata_dataframe(self, object_metadata = None, attribute = None, *args):
+        """
+        Function that takes an input of data table with metadata values containing field for each row and objects for each column, 
+        lists of input attributes available in the meta data (i.e. ['type','dataType']), 
+        and optional arguments containing comma separated lists of additional attributes available in the meta data 
+        
+        Example:
+            VeevaNetwork.object_metadata_dataframe(self.object_metadata(), ['fieldId'], ['type','dataType'], ['type','discriminator'], ['labels','en'],['maximumLength'])
+            
+        Return Example:
+        (Dataframe)
+            HCP.fieldId    HCP.type.dataType    HCP.type.discriminator    HCP.labels.en    HCP.maximumLength    HCO.fieldId      ...
+            hcp_type__v    REFERENCE            HCPType                   HCP Type         100.0                340B_eligible__v ...
+        
+        """
+        self.authenticate()
+        
+        object_metadata = self.object_metadata() if object_metadata is None else object_metadata
+        
+        object_metadata_dataframe = pd.DataFrame()
+        attribute1 = attribute[0]
+        attribute2 = attribute[1] if len(attribute) > 1 else ""
+        for networkObjectName, networkObjectMetaData in object_metadata.iteritems():
+            attributeList = []
+            for fieldMetaData in networkObjectMetaData:
+                try:
+                    if attribute2 == "":
+                        attributeList.append(fieldMetaData[attribute1])
+                    else:
+                        attributeList.append(fieldMetaData[attribute1][attribute2])
+                except TypeError:
+                    continue
+    #        object_metadata_dataframe[networkObjectName + '.' + attribute1 + (("." + attribute2) if attribute2 != "" else "")] = pd.Series(attributeList, name = networkObjectName)
+            object_metadata_dataframe = pd.concat([object_metadata_dataframe,pd.Series(attributeList, name = networkObjectName + '.' + attribute1 + (("." + attribute2) if attribute2 != "" else "")).to_frame()], ignore_index=False, axis=1)
+
+
+            # parse arguments
+            if args:
+                for arg in args:
+                    argAttribute1 = arg[0]
+                    argAttribute2 = arg[1] if len(arg)>1 else ""
+                    argAttributeList = []
+                    for fieldMetaData in networkObjectMetaData:
+                        try:
+                            if argAttribute2 == "":
+                                argAttributeList.append(fieldMetaData[argAttribute1])
+                            else:
+                                argAttributeList.append(fieldMetaData[argAttribute1][argAttribute2])
+                        except:
+                            argAttributeList.append("")
+                            continue
+    #                object_metadata_dataframe[networkObjectName + '.' + argAttribute1 + (("." + argAttribute2) if argAttribute2 != "" else "")] = pd.Series(argAttributeList, name = networkObjectName)
+                    object_metadata_dataframe = pd.concat([object_metadata_dataframe,pd.Series(argAttributeList, name = networkObjectName + '.' + argAttribute1 + (("." + argAttribute2) if argAttribute2 != "" else "")).to_frame()], ignore_index=False, axis=1)
+            else:
+                continue
+        return object_metadata_dataframe
+
+    # Refactored - MP 20220611
+    def get_networkReferenceValueMetadata(self):
+        """
+        Retruns a Dictionary of Network Reference Value Metadata, including countries, reference codes, translated values, etc.
+        """
+        self.authenticate()
+        self.networkReferenceValueMetadata = self.list_of_dicts_to_dict(requests.get(self.networkURL + '/api/' + self.LatestAPIversion + '/metadata/reference_values?includeCodes=True', headers = self.APIheaders).json()['reference_type_values'],'type')
+        return self.networkReferenceValueMetadata
+
+    # Deprecated
+    def reference_value_dataframe(self):
+        """
+        Retrieve all reference values in Network  
+        ** formula can be enhanced or take input parameters so it doesn't query every single reference alias
+
+        """
+        self.authenticate()
+
+        self.networkReferenceTypes = self.list_of_dicts_to_dict(requests.get(self.networkURL + '/api/' + self.LatestAPIversion + '/metadata/reference_values?includeCodes=True', headers = self.APIheaders).json()['reference_type_values'],'type')
+        reference_value_dataframe = pd.DataFrame()
+        for x in self.networkReferenceTypes.keys():
+            try:
+                referenceCall = requests.get(self.networkURL + '/api/'+ self.LatestAPIversion + '/metadata/reference_values/' + x + '?countries='+ self.networkCountry, headers = self.APIheaders).json()['reference_type_codes']
+                newColumn = pd.Series([x['values']['en'] for x in referenceCall],name = str(x) + " Value")
+                
+                newColumn2 = pd.Series([x['code'] for x in referenceCall], name = x)
+                reference_value_dataframe.insert(len(reference_value_dataframe.columns), column = x, value = newColumn2)
+                reference_value_dataframe.insert(len(reference_value_dataframe.columns), column = str(x) + " Value", value = newColumn)
+            except:
+                pass
+        return reference_value_dataframe
+
+    def extract_network_reference_table(self):
+        self.authenticate()
+        
+        references_all = pd.DataFrame(requests.get(self.networkURL + '/api/'+ self.LatestAPIversion + '/metadata/reference_values?includeCodes=true&countries='+ self.networkCountry, headers = self.APIheaders).json()['reference_type_values'])
+        network_reference_table = pd.DataFrame()
+        self.network_references_all = references_all
+        for row in references_all['reference_type_codes']:
+            if isinstance(row, list):
+                network_reference_table = pd.concat([network_reference_table, pd.json_normalize(row)], axis=1)
+            else:
+                continue
+        network_reference_table.fillna('',inplace=True)
+        return network_reference_table
+    
+    # =============================================================================
+    # WIP Functions
+    # =============================================================================
+
+
+    # =============================================================================
+    # Change Request
+    # =============================================================================
+
+    def change_request_create(self, *args, **kwargs):
+        """
+        This API enables you to create a Network change request to add or update an HCP or HCO and related entities (including addresses, licenses, or parentHCOs) for **gray** data only.
+
+        Change requests created using the API against orange data will be rejected.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createachangerequest
+
+        """
+        
+        return self.api_call(self.api_change_request['item']['Create Change Request'], *args, **kwargs)
+        
+    def change_request_cancel(self, *args, **kwargs):
+        """
+        This API enables you to cancel a change request by providing the change request ID.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelchangerequest
+
+        """
+        return self.api_call(self.api_change_request['item']['Cancel Change Request'], *args, **kwargs)
+
+    def change_request_retrieve(self, *args, **kwargs):
+        """
+        This API enables you to retrieve response information for the create, update, and merge change requests submitted by a client application.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveChangeRequest
+
+        """
+        return self.api_call(self.api_change_request['item']['Retrieve Change Request'], *args, **kwargs)
+        
+    def change_request_batch_retrieve(self, *args, **kwargs):
+        """
+        This API enables you to obtain information about multiple change requests through the API.
+
+        Documenatation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchretrievechangerequest  
+
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Batch Retrieve'], *args, **kwargs)
+        
+    def change_request_update(self, *args, **kwargs):
+        """
+        This API enables you to update an unprocessed change request through the API.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#UpdateChangeRequest
+
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Update'], *args, **kwargs)
+
+    def change_request_batch_update(self, *args, **kwargs):
+        """
+        This API enables you to update multiple unprocessed change requests.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchUpdateChangeRequests
+
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Batch Update'], *args, **kwargs)
+
+    def change_request_process(self, *args, **kwargs):
+        """
+        This API enables you to process an unprocessed change request through the API.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#ProcessChangeRequest
+
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Process'], *args, **kwargs)
+
+    def change_request_batch_process(self, *args, **kwargs):
+        """
+        This API enables you to process multiple unprocessed change requests.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchProcessChangeRequests
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Batch Process'], *args, **kwargs)
+
+    def change_request_search(self, *args, **kwargs):
+        """
+        This API enables you to retrieve all change requests that match a specified search criteria.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#ChangeRequestSearch
+
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Search'], *args, **kwargs)
+
+    def change_request_match(self, *args, **kwargs):
+        """
+        This API enables you to match a request to an existing entity. You can use either the Veeva ID or custom key of an existing entity to match the request against.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#ChangeRequestMatch
+
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Match'], *args, **kwargs)
+
+    def change_request_batch_approve(self, *args, **kwargs):
+        """
+        This API enables you to bulk approve up to 500 change requests.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchApproveChangeRequests
+
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Batch Approve'], *args, **kwargs)
+
+    def change_request_batch_reject(self, *args, **kwargs):
+        """
+        This API enables you to bulk reject up to 500 change requests.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchRejectChangeRequests
+
+        """
+        return self.api_call(self.api_change_request['item']['Change Request Batch Reject'], *args, **kwargs)
+    
+    # =============================================================================
+    # Custom Key
+    # =============================================================================
+
+    def custom_key_associate_to_entity (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCPs or HCOs are downloaded from Network without going through the full change request process.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoentity
+
+        """
+        return self.api_call(self.api_custom_key['item']['Associate Custom Key to Entity'], *args, **kwargs)
+
+    def custom_key_associate_to_child (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new children (address, license, or parent HCOs) are downloaded from Network without going through the full change request process.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytochildren
+
+        """
+        return self.api_call(self.api_custom_key['item']['Associate Custom Key to Children'], *args, **kwargs)
+
+    def custom_key_batch_associate_to_entities (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers whenever new HCPs or HCOs are downloaded from Network without going through the full change request process.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchassociatecustomkeystoentities
+
+        """
+        return self.api_call(self.api_custom_key['item']['Batch Associate Custom Keys to Entities'], *args, **kwargs)
+
+    def custom_key_batch_associate_to_children (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new children (address, license, or parent HCOs) are downloaded from Network without going through the full change request process.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchassociatecustomkeytochildren
+
+        """
+        return self.api_call(self.api_custom_key['item']['Batch Associate Custom Keys to Children'], *args, **kwargs)
+
+    def custom_key_disassociate (self, *args, **kwargs):
+        """
+        This API enables you to deactivate external key identifiers for any entity (an HCP, HCO, Address, License, or ParentHCO) in Network without going through the full change request process.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Disassociatecustomkey
+
+        """
+        return self.api_call(self.api_custom_key['item']['Disassociate Custom Key'], *args, **kwargs)
+
+    def custom_key_batch_disassociate (self, *args, **kwargs):
+        """
+        This API enables you to inactivate external key identifiers for any entity (HCP, HCO, Address, License, or ParentHCO) in Network without going through the full change request process.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchdisassociatecustomkey
+
+        """
+        return self.api_call(self.api_custom_key['item']['Batch Disassociate Custom Key'], *args, **kwargs)
+
+
+    # =============================================================================
+    # Entity
+    # =============================================================================
+
+    def entity_retrieve (self, *args, **kwargs):
+        """
+        This API enables you to obtain information on any entity without identifying the specific entity type. It is only used to retrieve information from Network using the GET method.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveentity
+
+        """
+        return self.api_call(self.api_entity['item']['Retrieve Entity'], *args, **kwargs)
+
+    def entity_retrieve_child (self, *args, **kwargs):
+        """
+        This API enables you to retrieve child entity information; for example address or license details, for the Network ID provided without identifying the specific entity type.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievechildentity
+
+        """
+        return self.api_call(self.api_entity['item']['Retrieve Child Entity'], *args, **kwargs)
+
+    def entity_batch_retrieve (self, *args, **kwargs):
+        """
+        This API enables you to retrieve entity details directly from Network. It is only used to retrieve information using the GET method. To update or delete entity data, you must use the change request APIs.
+
+        The entities you can retrieve include HCPs and HCOs, and details are returned for all corresponding child entities: addresses, licenses, parent HCOs, and custom keys.
+        
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchretrieveentities
+
+        """
+        return self.api_call(self.api_entity['item']['Batch Retrieve Entities'], *args, **kwargs)
+
+    def entity_batch_retrieve_children (self, *args, **kwargs):
+        """
+        This API enables you to obtain information on child entities without identifying the specific entity type. Users are only allowed to retrieve (GET) information from Network.
+
+        All other operations (POST and DELETE) are restricted and can only be performed by submitting a change request using the change request APIs.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Batchretrievechildentities
+
+        """
+        return self.api_call(self.api_entity['item']['Batch Retrieve Child Entities'], *args, **kwargs)
+
+
+    # =============================================================================
+    # HCO
+    # =============================================================================
+
+    def hco_retrieve (self, *args, **kwargs):
+        """
+        This API enables you to retrieve information about an HCO. Information you can retrieve for an HCO includes the HCO, address, license, and parent HCO information (including their custom keys) for the HCO vid_key you provide.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveHCO
+
+        """
+        return self.api_call(self.api_hco['item']['Retrieve HCO'], *args, **kwargs)
+
+    def hco_associate_custom_key (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCOs are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the HCO vid_key you provide.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#AssociatecustomkeytoHCO
+
+        """
+        return self.api_call(self.api_hco['item']['Associate Custom Key to HCO'], *args, **kwargs)
+
+    def hco_address_associate_custom_key (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCO child objects (addresses) 
+        are downloaded from Network without going through the full change request process. 
+        This API associates the external identifier you submit to the child object key you provide.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject
+
+        """
+        return self.api_call(self.api_hco['item']['Associate Custom Key to HCO Address'], *args, **kwargs)
+
+    def hco_license_associate_custom_key (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCO child objects (licenses) 
+        are downloaded from Network without going through the full change request process. 
+        This API associates the external identifier you submit to the child object key you provide.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject
+
+        """
+        return self.api_call(self.api_hco['item']['Associate Custom Key to HCO License'], *args, **kwargs)
+
+    def hco_parenthco_associate_custom_key (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCO child objects (parent HCOs) 
+        are downloaded from Network without going through the full change request process. 
+        This API associates the external identifier you submit to the child object key you provide.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject
+
+        """
+        return self.api_call(self.api_hco['item']['Associate Custom Key to HCO ParentHCO'], *args, **kwargs)
+
+    # =============================================================================
+    # HCP
+    # =============================================================================
+    def hcp_retrive (self, *args, **kwargs):
+        """
+        This API enables you to retrieve information about an HCP including the HCP itself, address, license, and parent HCO information (including their custom keys) for the HCP vid_key you provide.
+
+        This API downloads the record for the specified entity from Veeva OpenData to your customer instance.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveHCP
+
+        """
+        return self.api_call(self.api_hcp['item']['Retrieve HCP'], *args, **kwargs)
+
+    def hcp_associate_custom_key (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCPs are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the HCP vid_key you provide.
+
+        This API requires system administrator or API-only permissions.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#AssociatecustomkeytoHCP
+
+        """
+        return self.api_call(self.api_hcp['item']['Associate Custom Key to HCP'], *args, **kwargs)
+
+    def hcp_address_associate_custom_key (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCP child objects (addresses) are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the child object key you provide.
+
+        This API requires system administrator or API-only permissions.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject1
+
+        """
+        return self.api_call(self.api_hcp['item']['Associate Custom Key to HCP Address'], *args, **kwargs)
+
+    def hcp_license_associate_custom_key (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCP child objects (licenses) are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the child object key you provide.
+
+        This API requires system administrator or API-only permissions.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject1
+        
+        """
+        return self.api_call(self.api_hcp['item']['Associate Custom Key to HCP License'], *args, **kwargs)
+
+    def hcp_parenthco_associate_custom_key (self, *args, **kwargs):
+        """
+        This API enables you to submit external key identifiers when new HCP child objects (parent HCOs) are downloaded from Network without going through the full change request process. This API associates the external identifier you submit to the child object key you provide.
+
+        This API requires system administrator or API-only permissions.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Associatecustomkeytoachildobject1
+        
+        """
+        return self.api_call(self.api_hcp['item']['Associate Custom Key to HCP ParentHCO'], *args, **kwargs)
+
+    # =============================================================================
+    # Metadata
+    # =============================================================================
+    def metadata_retrieve_available_api_versions (self, *args, **kwargs):
+        """
+        This enables you to retrieve summary information about each API version available in Network.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveavailableAPIversions
+        
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve Available API Versions'], *args, **kwargs)
+        
+    def metadata_retrieve_hashtags (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the list of hashtags available in a Network instance.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievehashtags
+
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve hashtags'], *args, **kwargs)
+
+    # TODO: rename/refactor method.
+    def get_networkLanguages(self) -> list:
+        """
+        This API enables you to retrieve the list of reference data languages available in a Network instance.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievelanguages
+
+        """
+
+        self.authenticate()
+        self.networkLanguages = list(self.list_of_dicts_to_dict(
+            requests.get(
+                self.networkURL + 
+                '/api/' + 
+                self.LatestAPIversion + 
+                '/metadata/languages', 
+                headers=self.APIheaders).json()['languages'], 
+                'name'
+                ).keys())
+        return self.networkLanguages
+
+    def metadata_retrieve_object_types (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the list of object types available in Network.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveobjecttypesmetadata
+
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve Object Types Metadata'], *args, **kwargs)
+
+    def metadata_retrieve_field (self, *args, **kwargs):
+        """
+        This API enables you to retrieve detailed or summary information about the fields on each entity in Network.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievefieldsmetadata
+
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve Fields Metadata'], *args, **kwargs)
+
+    def metadata_retrieve_field_details (self, *args, **kwargs):
+        """
+        This API enables you to retrieve detailed information about the fields on each entity in Network.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievefielddetailsmetadata
+
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve Field Details Metadata'], *args, **kwargs)
+
+    def metadata_retrieve_field_groups (self, *args, **kwargs):
+        """
+        This API enables you to retrieve detailed information about the field groups available in Network. These field groups are used by the CRM bridge when retrieving and displaying information from Network in CRM.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievefieldgroupsmetadata
+
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve Field Groups Metadata'], *args, **kwargs)
+
+    def metadata_retrieve_reference_data_types (self, *args, **kwargs):
+        """
+        This API enables you to retrieve information about reference data types in Network.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievereferencedatatypesmetadata
+
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve Reference Data Types Metadata'], *args, **kwargs)
+
+    def metadata_retrieve_reference_data_type_details (self, *args, **kwargs):
+        """
+        This API enables you to retrieve detailed information about reference data types in Network.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievereferencedatatypedetailsmetadata
+
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve Reference Data Type Details Metadata'], *args, **kwargs)
+
+    def metadata_retrieve_reference_data_type_code_details (self, *args, **kwargs):
+        """
+        This API enables you to retrieve detailed information about reference data type codes in Network.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievereferencedatatypecodedetailsmetadata
+
+        """
+        return self.api_call(self.api_metadata['item']['Retrieve Reference Data Type Code Details Metadata'], *args, **kwargs)
+
+    # =============================================================================
+    # Subscriptions
+    # =============================================================================
+    def subscriptions_create_job (self, *args, **kwargs):
+        """
+        This API enables you to create a subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createasubscriptionjob
+
+        """
+        return self.api_call(self.api_subscriptions['item']['Create Subscription Job'], *args, **kwargs)
+
+    def subscriptions_retrieve_job (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the status of a source or target subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveasubscriptionjobstatus
+
+        """
+        return self.api_call(self.api_subscriptions['item']['Retrieve Subscription Job'], *args, **kwargs)
+
+    def subscriptions_cancel_job (self, *args, **kwargs):
+        """
+        This API enables you to cancel a subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelasubscriptionjob
+
+        """
+        return self.api_call(self.api_subscriptions['item']['Cancel Subscription Job'], *args, **kwargs)
+
+    def subscriptions_retrieve_export_job_file (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the artifacts (file contents) of a target subscription job.
+        AKA: Retrieve target subscription artifact
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievetargetsubscriptionartifact
+        
+        """
+        return self.api_call(self.api_subscriptions['item']['Retrieve Export Job File'], *args, **kwargs)
+
+    # =============================================================================
+    # Subscriptions - Compliance
+    # =============================================================================
+    def subscriptions_compliance_create_job (self, *args, **kwargs):
+        """
+        This API enables you to create a compliance subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createacompliancesubscriptionjob
+
+        """
+        return self.api_call(self.api_subscriptions_compliance['item']['Create Compiance Subscription Job'], *args, **kwargs)
+
+    def subscriptions_compliance_retrieve_job (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the status of a source or target subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveacompliancesubscriptionjobstatus
+        
+        """
+        return self.api_call(self.api_subscriptions_compliance['item']['Retrieve Compliance Subscription Job'], *args, **kwargs)
+
+    def subscriptions_compliance_cancel_job (self, *args, **kwargs):
+        """
+        This API enables you to cancel a compliance subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelacompliancesubscriptionjob
+
+        """
+        return self.api_call(self.api_subscriptions_compliance['item']['Cancel Compliance Subscription Job'], *args, **kwargs)
+
+    # =============================================================================
+    # Subscriptions - Source
+    # =============================================================================
+    def subscriptions_source_create_job (self, *args, **kwargs):
+        """
+        This API enables you to create a source subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createasourcesubscriptionjob
+
+        """
+        return self.api_call(self.api_subscriptions_source['item']['Create Source Subscription Job'], *args, **kwargs)
+
+    def subscriptions_source_retrieve_job (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the status of a source subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveasourcesubscriptionjobstatus
+
+        """
+        return self.api_call(self.api_subscriptions_source['item']['Retrieve Source Subscription Job'], *args, **kwargs)
+
+    def subscriptions_source_cancel_job (self, *args, **kwargs):
+        """
+        This API enables you to cancel a source subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelasourcesubscriptionjob
+        
+        """
+        return self.api_call(self.api_subscriptions_source['item']['Cancel Source Subscription Job'], *args, **kwargs)
+
+    # =============================================================================
+    # Subscriptions - Target
+    # =============================================================================
+    def subscriptions_target_create_job (self, *args, **kwargs):
+        """
+        This API enables you to create a target subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Createatargetsubscriptionjob
+
+        """
+        return self.api_call(self.api_subscriptions_target['item']['Create Target Subscription Job'], *args, **kwargs)
+
+    def subscriptions_target_retrieve_job (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the status of a source or target subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrieveatargetsubscriptionjobstatus
+
+        """
+        return self.api_call(self.api_subscriptions_target['item']['Retrieve Target Subscription Job'], *args, **kwargs)
+
+    def subscriptions_target_cancel_job (self, *args, **kwargs):
+        """
+        This API enables you to cancel a target subscription job.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Cancelatargetsubscriptionjob
+        """
+        return self.api_call(self.api_subscriptions_target['item']['Cancel Target Subscription Job'], *args, **kwargs)
+
+    # =============================================================================
+    # Events
+    # =============================================================================
+    def events_retrieve_merge (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the results of merge events that occurred in your Network instance.
+
+        Merges initiated by Veeva OpenData on a master instance are included if the surviving and losing records of the merge have been downloaded to your instance.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveMerges
+
+        """
+        return self.api_call(self.api_events['item']['Retrieve Merge Events'], *args, **kwargs)
+
+    def events_retrieve_unmerge (self, *args, **kwargs):
+        """
+        This API enables you to retrieve the results of unmerge events that occurred in your Network instance.
+
+        Unmerges include events that occurred in your Network instance; only customer (gray) records are reported.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveUnmerges
+
+        """
+        return self.api_call(self.api_events['item']['Retrieve Unmerge Events'], *args, **kwargs)
+
+    # =============================================================================
+    # Match
+    # =============================================================================
+    def match_retrieve (self, *args, **kwargs):
+        """
+        This API enables you to match data immediately for a single record using match rules from the specified Network instance.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveMatches
+
+        """
+        return self.api_call(self.api_match['item']['Retrieve Matches'], *args, **kwargs)
+
+    # =============================================================================
+    # Suspect Match
+    # =============================================================================
+    def suspect_match_batch_process (self, *args, **kwargs):
+        """
+        This API enables enables you to process multiple unprocessed suspect matches.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchProcessSuspectMatch
+
+        """
+        return self.api_call(self.api_suspect_match['item']['Batch Process Suspect Match'], *args, **kwargs)
+
+    def suspect_match_batch_create (self, *args, **kwargs):
+        """
+        This API enables enables you to create multiple suspect matches.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchCreateSuspectMatch
+
+        """
+        return self.api_call(self.api_suspect_match['item']['Batch Create Suspect Match'], *args, **kwargs)
+
+    def suspect_match_batch_reject_task (self, *args, **kwargs):
+        """
+        This API enables enables you to reject multiple suspect match tasks.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchRejectSuspectMatch
+
+        """
+        return self.api_call(self.api_suspect_match['item']['Batch Reject Suspect Match Task'], *args, **kwargs)
+
+    def suspect_match_batch_retrieve (self, *args, **kwargs):
+        """
+        This API enables enables you to retrieve information about multiple suspect matches.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#BatchRetrieveSuspectMatch
+
+        """
+        self.api_call(suspect_match['item']['Batch Retrieve Suspect Match'], *args, **kwargs)
+
+    # =============================================================================
+    # Retrieve Available API Versions
+    # =============================================================================
+    def retrieve_available_api_versions (self, *args, **kwargs):
+        """
+        This enables you to retrieve summary information about each API version available in Network.
+
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#RetrieveavailableAPIversions
+
+        """
+        return self.api_call(self.api_retrieve_available_api_versions, *args, **kwargs)
+    # =============================================================================
+    # Search
+    # =============================================================================
+    def search (self, *args, **kwargs):
+        """
+        Search calls enable you to construct simple, yet powerful searches to retrieve data from Network.
+
+        Calls through the Search API pass a query string in an expression that specifies the search text and specific parameters to get the intended set of entities from Network. Search results are ranked according to closeness to the search terms specified.
+        
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#search
+        
+        """
+        return self.api_call(self.api_search, *args, **kwargs)
+    # =============================================================================
+    # System Settings
+    # =============================================================================
+    def system_settings_retrieve (self):
+        """
+        This API enables you to retrieve the value for the geolocation system setting.
+
+        Currently only api.search.geolocation.countries is supported.
+        
+        Documentation:
+        https://developer.veevanetwork.com/API_reference/API_reference.htm#Retrievesystemsettings
+        
+        """
+        result = requests.get(
+            url=f"{self.networkURL}/api/v26.0/systemSettings/api.search.geolocation.countries", 
+            headers=self.APIheaders).json()
+        return result
+        
+
+    # =============================================================================
+    # Utilities
+    # =============================================================================
+
+    def api_call (
+        self,
+        api: dict, 
+        body: dict = None, 
+        variables: dict = None, 
+        queries: dict = None, 
+        if_print: bool=False,  # If True, prints each component of the api call, the api call will still execute unless if_debug or if_example paramters are set to True.
+        if_debug: bool=False, # If True, the api call does not execute, but instead returns the api call as a string for debugging
+        if_example: bool=False # If True, the api call does not execute and returns examples of any body, variables, or queries.
+    ):
+
+        examples = {}
+
+        result = {
+            'api_body' : body,
+            'api_variables' : variables,
+            'api_queries' : queries
+        }
+
+        request_params = {}
+
+        def print_if(text):
+            if if_print:
+                print(text)
+
+        if api.keys().__contains__('name'):
+            print_if('\n- Name: ')
+            print_if(api['name'])
+            result['api_name'] = api['name'] ### Updating Result Name
+
+        if api.keys().__contains__('protocolProfileBehavior'):
+            print_if('\n- protocolProfileBehavior: ')
+            if api['protocolProfileBehavior'].keys().__contains__('disableBodyPruning'):
+                print_if('- disableBodyPruning: ')
+                print_if(api['protocolProfileBehavior']['disableBodyPruning'])
+                result['api_protocolProfileBehavior_disableBodyPruning'] = api['protocolProfileBehavior']['disableBodyPruning'] ### Updating Result disableBodyPruning
+
+        if api.keys().__contains__('request'):
+
+            ### =============================================================================
+            ### Parsing Header
+            ### =============================================================================
+
+            if api['request'].keys().__contains__('header'):
+                if isinstance(api['request']['header'], dict):
+                    print_if("\n- Request header keys: ")
+                    print_if(api['request']['header'].keys())
+                    result['api_header'] = {}
+                    request_params['headers'] = {}
+                    for header_key, header_value in api['request']['header'].items():
+                        print_if("\n- Request header key:")
+                        print_if(header_key)
+                        if isinstance(header_value, dict):
+                            if header_value.keys().__contains__('value'):
+                                result['api_header'].update({header_key: self.sub_request_params(api['request']['header'][header_key]['value'])}) ### Updating Result API Header
+                                request_params['headers'].update({header_key: self.sub_request_params(api['request']['header'][header_key]['value'])}) ### Updating Request Header
+
+                            for key, value in header_value.items():
+                                print_if("\n- Request header value dict key and value:")
+                                print_if(key)
+                                print_if(value)
+                        else:
+                            print_if("Request Header Value: ")
+                            print_if(header_value)
+                            raise NetworkAPIHeaderValueNotFound
+
+            ### =============================================================================
+            ### Parsing Method
+            ### =============================================================================
+
+            if api['request'].keys().__contains__('method'):
+                print_if("\n- Request method: ")
+                print_if(api['request']['method'])
+
+                match api['request']['method']:
+                    case 'POST':
+                        result['api_method'] = requests.post # Updating Result Method
+                        print_if("\n- Request Method Post:")
+                        print_if("requests.post")
+                    case 'GET':
+                        result['api_method'] = requests.get # Updating Result Method
+                        print_if("\n- Request Method Get:")
+                        print_if("requests.get")
+                    case 'PUT':
+                        result['api_method'] = requests.put # Updating Result Method
+                        print_if("\n- Request Method Put:")
+                        print_if("requests.put")
+                    case 'DELETE':
+                        result['api_method'] = requests.delete # Updating Result Method
+                        print_if("\n- Request Method Delete:")
+                        print_if("requests.delete")
+                    case _:
+                        print_if("\n- Request Method Unknown:")
+                        print_if("unknown method")
+                        raise NetworkAPIRequestMethodNotFound
+
+            ### =============================================================================
+            ### Parsing Body
+            ### =============================================================================
+
+            if (api['request'].keys().__contains__('body') == True) and \
+                (api['request']['body'].keys().__contains__('raw') == True) and \
+                (api['request']['body']['raw'] != ''):
+                print_if("\n- Request body raw: ")
+                print_if(json.loads(api['request']['body']['raw']))
+                examples['body'] = json.loads(api['request']['body']['raw']) ### Updating Result API Body
+                # If the body parameter is not provided in an API call that requires a body. Raise Error.
+                if body is None and if_example==False:
+                    raise NetworkAPIRequestBodyNotFound
+                else:
+                    request_params['data']=json.dumps(body)
+            else:
+                print_if("\n- Request body raw: ")
+                print_if("No Body Found")
+            
+            ### =============================================================================
+            ### Parsing URL
+            ### =============================================================================
+
+            if api['request'].keys().__contains__('url'):
+                print_if("\n- Request url keys: ")
+                print_if(api['request']['url'].keys())
+
+                ### =============================================================================
+                ### Parsing Raw URL
+                ### =============================================================================
+
+                if api['request']['url'].keys().__contains__('raw'):
+                    print_if("\n- Request url raw: ")
+                    print_if(api['request']['url']['raw'])
+                    result['api_url'] = self.sub_request_params(api['request']['url']['protocol'] + "://" + api['request']['url']['host'][0] + "/" + "/".join(api['request']['url']['path'])) ### Updating Result API URL
+                    request_params['url'] = self.sub_request_params(api['request']['url']['protocol'] + "://" + api['request']['url']['host'][0] + "/" + "/".join(api['request']['url']['path'])) ### Updating Request URL
+                else:
+                    raise NetworkAPIRequestURLNotFound
+
+                
+                ### =============================================================================
+                ### Parsing URL Protocol
+                ### =============================================================================
+                
+                if api['request']['url'].keys().__contains__('protocol'):
+                    print_if("\n- Request url protocol: ")
+                    # always "https"
+                    print_if(api['request']['url']['protocol'])
+
+                ### =============================================================================
+                ### Parsing URL Host
+                ### =============================================================================
+                
+                if api['request']['url'].keys().__contains__('host'):
+                    print_if("\n- Request url host: ")
+                    # always ['{{DNS}}]
+                    print_if(api['request']['url']['host'][0])
+
+                ### =============================================================================
+                ### Parsing URL Path
+                ### =============================================================================
+
+                if api['request']['url'].keys().__contains__('path'):
+                    print_if("\n- Request url path: ")
+                    # A list of path components. i.e. ['api', '{{version}}', 'hcos', ':vid_key', 'addresses', ':address_key', 'custom_keys']
+                    print_if(api['request']['url']['path'])
+
+                ### =============================================================================
+                ### Parsing URL Variable
+                ### =============================================================================
+
+                if api['request']['url'].keys().__contains__('variable'):
+                    if variables is None and if_example==False:
+                        raise NetworkAPIRequestVariableNotFound
+                    elif if_example==False:
+                        for variable in variables.keys():
+                            result['api_url'] = result['api_url'].replace(":" + variable, variables[variable]['value'])
+                            request_params['url'] = request_params['url'].replace(":" + variable, variables[variable]['value'])
+
+                    if isinstance(api['request']['url']['variable'], dict):
+                        print_if("\n- Request url variable keys: ")
+                        print_if(api['request']['url']['variable'].keys())
+                        variables: dict = api['request']['url']['variable']
+                        examples['variables'] = variables ### Updating Result API URL Variable Examples
+                        
+                        for key, value in variables.items():
+                            if isinstance(value, dict):
+                                print_if("\n- Request url variable key and value dict: ")
+                                print_if(key)
+                                print_if(value)
+                            else:
+                                print_if("\n- Request url variable value: ") 
+                                print_if(str(value))
+
+                ### =============================================================================
+                ### Parsing URL Query
+                ### =============================================================================
+
+                if api['request']['url'].keys().__contains__('query'):
+                    if queries is None and if_example==False:
+                        raise NetworkAPIRequestQueryNotFound
+                    elif if_example==False:
+                        result['api_url'] = result['api_url'] + '?'
+                        request_params['url'] = request_params['url'] + '?'
+                        for key, value in queries.items():
+                            if result['api_url'][-1] == '?':
+                                result['api_url'] = result['api_url'] + key + '=' + value['value']
+                                request_params['url'] = request_params['url'] + key + '=' + value['value']
+                            else:
+                                result['api_url'] = result['api_url'] + '&' + key + '=' + value['value']
+                                request_params['url'] = request_params['url'] + '&' + key + '=' + value['value']
+
+                    print_if("\n- Request url query keys: ")
+                    print_if(api['request']['url']['query'].keys())
+                    queries: dict = api['request']['url']['query'] 
+                    examples['query'] = queries ### Updating Result API URL Query Examples
+                    for key, value in queries.items():
+                        print_if("\n- Request url query key and value: ")
+                        if isinstance(value, dict):
+                            print_if(key)
+                            print_if(value)
+                        else:
+                            print_if(str(value))
+
+            ### =============================================================================
+            ### Parsing Description
+            ### =============================================================================
+
+            if api['request'].keys().__contains__('description'):
+                print_if("\n- Request Description: ")
+                print_if(api['request']['description'])
+                examples['description'] = api['request']['description'] ### Updating Description
+
+        if api.keys().__contains__('response'):
+            print_if(api['response'])
+
+        if (not if_debug) & (not if_example) & (result.keys().__contains__('api_method')):
+            response = result['api_method'](**request_params)
+
+        if if_debug & if_example:
+            return result, examples, request_params
+        if if_debug:
+            return result, request_params
+        if if_example:
+            return examples
+        return response
+
+
+    @staticmethod
+    def list_of_dicts_to_dict(list_of_dict: list, key) -> dict:
+        """
+        Function takes a list of dicts and returns a single dict.
+
+        Parameters:
+        list_of_dict: list of dicts, i.e. [{'key1': 'value1', 'key2': 'value2'}, {'key1': 'value1', 'key2': 'value2'}]
+        key (str): key to use for the dict. i.e. 'key1'
+            in our example, [{'key1': 'value1', 'key2': 'value2'}, {'key1': 'value1', 'key2': 'value2'}]
+            The output dictionary would have value1, value2 as the keys:
+            {'value1': {'key1': 'value1', 'key2': 'value2'}, 'value2': {'key1': 'value1', 'key2': 'value2'}}
+
+        """
+        obj_dict = {}
+        __empty = [obj_dict.update({x[key]: x}) for x in list_of_dict]
+        return obj_dict
+
+    @staticmethod
+    def cartesian_join(pd1, pd2):
+        df1 = pd1.copy()
+        df2 = pd2.copy()
+        df1.reset_index()
+        df2.reset_index()
+        df1['cartesian_join_key'] = 1
+        df2['cartesian_join_key'] = 1
+        result = pd.merge(df1, df2, on ='cartesian_join_key').drop(labels="cartesian_join_key", axis=1)
+        return result
+        
+    def sub_request_params (self, request: str) -> str:
+        substitutions_dict = {
+            '{{AUTHORIZATION}}': self.APIheaders['authorization'],
+            '{{DNS}}': self.network_DNS,
+            '{{version}}': self.LatestAPIversion
+        }
+        for key, value in substitutions_dict.items():
+            request = request.replace(key, value)
+        return request
+    
+    def __parse_network_api_json(self, network_api: dict):
+        output = {}
+        for key, value in network_api.items():
+            if isinstance(value, dict):
+                output[key] = self.__parse_network_api_json(value)
+            elif isinstance(value, list):
+                first_key_set = set()
+                for item in value:
+                    if isinstance(item, dict):
+                        first_key_set.add(list(item.keys())[0])
+                if len(first_key_set) == 1:
+                    output[key] = self.__parse_network_api_json(self.list_of_dicts_to_dict(value, list(first_key_set)[0]))
+                else:
+                    output[key] = value
+            else:
+                output[key] = value
         return output
```

### Comparing `veevatools-0.1.8/veevanitro/veevanitro.py` & `veevatools-0.1.9/veevanitro/veevanitro.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,1574 +1,1574 @@
-from sys import platform
-import requests
-import pandas as pd
-import os
-import json
-from urllib.parse import urlparse
-from typing import List, Optional
-import asyncio
-from datetime import datetime, timezone
-import boto3
-from botocore.exceptions import ClientError
-
-import psycopg2
-from psycopg2.extras import RealDictCursor
-from sqlalchemy import create_engine
-from urllib.parse import quote_plus
-
-try:
-    from nitro_utils.s3_utils import display_progress
-except:
-    from veevanitro.nitro_utils.s3_utils import display_progress
-
-# Async
-from utilities.async_utils import async_wrap
-
-
-
-class Vnitro:
-    
-    def __init__(self):
-        self.serverUrl: str = None # from authenticate
-        self.nitroUserName: str = None # from authenticate
-        self.nitroPassword: str = None # from authenticate
-        self.accessToken: str = None # from authenticate
-        self.refreshToken: str = None # from authenticate
-        self.appServerUrl: str = None # from authenticate
-        self.tenantName: str = None # from authenticate
-        self.workingRedshiftPwd: str = None # from initialize_cdw_config
-        self.cdw_config: dict = None # from initialize_cdw_config
-        self.instances: List[Optional(dict)] = None # from authenticate
-        self.tenantRoles: List[Optional(dict)] = None # from authenticate
-        self.instanceRoles: List[Optional(dict)] = None # from authenticate
-        self.instancePermissions: dict = None # from authenticate
-        self.cdwAPItoken: str = None # from get_cdw_api_token
-        self.tenant: dict = None # from get_tenant
-        self.configuration: dict = None # from get_configuration
-        self.users: List[Optional(dict)] = None # from get_users
-        self.applicationRoles: List[Optional(dict)] = None # from get_application_roles
-        self.rules: dict = {} # from get_rules
-        self.groups: dict = {} # from get_groups
-        self.jobs: dict = {} # from get_jobs
-        self.connectors: dict = {} # from get_connectors
-        self.clusterDetails: dict = {} # from get_cluster_details
-        self.jobResults: dict = {} # from get_results
-        self.workingInstance: str = None # Set by any method that requires an instance name, last used instance name is stored here
-                                         # Upon authentication, the first instance in the list of instances is set as the working instance
-        
-        # Redshift
-        self.workingRedshiftUser: str = None # from set_redshift_user
-        self.workspaces: dict = {} # from get_workspaces
-        self.workingWorkspaceName: dict = {} # from connect_to_user_workspace
-        self.workingWorkspaceConnection: dict = {} # from connect_to_user_workspace
-        self.redshiftDBdetails: dict = {} # from get_redshift_dbs
-        self.workingDB: str = None # from get_redshift_dbs
-        self.workingDBConnection: psycopg2.extensions.connection = None # from from get_db_connection
-        self.workspaceConnections: dict = {} # from connect_to_user_workspace
-        self.redshiftPort: str = '5439'
-        self.workingDBConnection: psycopg2.extensions.connection = None # from from get_db_connection
-        self.workingDBCursor: psycopg2.extensions.cursor = None # from from get_db_connection
-        self.workingSQLalchemyEngine: sqlalchemy.engine.base.Engine = None # from get_sqlalchemy_engine
-        
-        # S3 Client
-        self.s3_clients: boto3.client = {} # from get_s3_client
-        self.workingS3Client: boto3.client = None # from get_s3_client
-        self.workingS3Bucket: str = None # from get_s3_client
-        self.workingS3PathPrefix: str = None # from get_s3_client
-        
-        
-    def _handle_response(self, response):
-        """
-        A helper method to handle API responses.
-        
-        Args:
-            response (Response): The response object from the requests library.
-            
-        Returns:
-            dict: The response JSON content.
-            
-        Raises:
-            Exception: If the response indicates an error.
-        """
-        if response.status_code == 200:
-            return response.json()
-        
-        elif response.status_code == 401:
-            if 'error' in response.json().keys():
-                raise Exception(f"Unauthorized: {response.json()['error']}")
-                
-            else:
-                raise Exception(f"Request failed. Response from server: {response.json()}")
-        else:
-            raise Exception(f"Request failed. Response from server: {response.json()}")
-    
-    def authenticate(
-        self,
-        serverUrl: str = None,
-        nitroUserName: str = None,
-        nitroPassword: str = None,
-        accessToken: str = None
-    ):
-        """
-        Authenticates the user with the Veeva Nitro API. If the accessToken is provided, the username and password are not required.
-        The authentication also retrieves the tenant information and sets the attributes of the class to the response JSON.
-        It loads the following attributes:
-            self.accessToken, self.refreshToken, self.serverUrl, self.appServerUrl, self.tenantName,
-            self.instances, self.tenantRoles, self.instanceRoles, self.instancePermissions
-        
-        Args:
-            serverUrl (str): Required. The base URL for the Veeva Nitro API. Example: https://mycompany.veevanitro.com
-            nitroUserName (str, optional): The username for authentication. Defaults to None. Must be provided if accessToken is not provided.
-            nitroPassword (str, optional): The password for authentication. Defaults to None. Must be provided if accessToken is not provided.
-            accessToken (str, optional): The session ID for authentication. Defaults to None. Must be provided if nitroUserName and nitroPassword are not provided.
-            
-        Raises:
-            Exception: If the necessary parameters for authentication are not provided.
-            Exception: If the authentication fails.
-        """
-        self.serverUrl = serverUrl if serverUrl is not None else self.serverUrl
-        self.nitroUserName = nitroUserName if nitroUserName is not None else self.nitroUserName
-        self.nitroPassword = nitroPassword if nitroPassword is not None else self.nitroPassword
-        self.accessToken = accessToken if accessToken is not None else self.accessToken
-        
-        url = f"{self.serverUrl}/api/v1/auth/login"
-        
-        # Ensure at least serverUrl and accessToken are provided or serverUrl and nitroUserName and nitroPassword are provided
-        if (self.serverUrl is None) or (self.accessToken is None and (self.nitroUserName is None or self.nitroPassword is None)):
-            raise Exception("serverUrl and accessToken are required or serverUrl and nitroUserName and nitroPassword are required")
-        
-        # If authenticating with username and password:
-        if self.accessToken is None:
-            # Get the session ID
-            payload = {
-                "username": self.nitroUserName,
-                "password": self.nitroPassword
-            }
-
-            response = requests.post(url, json=payload)
-            
-        # If authenticating with session ID
-        else:
-            # There is not a clear way to authenticate using accessToken, so we will just make a request to the tenant endpoint to test the validity of the session ID
-            url = f"{self.serverUrl}/api/v1/admin/tenant"
-            payload = {
-                "Authorization": self.accessToken
-            }
-
-            response = requests.get(url, headers=payload)
-            
-        response_json = self._handle_response(response)
-            
-
-        attributes = [
-            'accessToken', 'refreshToken', 'serverUrl', 'appServerUrl', 'tenantName',
-            'instances', 'tenantRoles', 'instanceRoles', 'instancePermissions'
-        ]
-
-        # Decision was made here to raise an exception if
-        # the response does not contain the expected attributes
-        # This is to ensure that the attributes of the class are set correctly
-        # and that future methods can rely on the attributes being set
-        # MPay 2023-08-18
-        try:
-            # Set the attributes of the class to the response JSON
-            for attr in attributes:
-                setattr(self, attr, response_json[attr])
-        except:
-            raise Exception(f"""API response did not contain the expected attributes.
-            Expected attributes: {attributes}
-            Response JSON: {response_json}
-            Please contact the developer or system administrator for assistance.
-            Has the API changed due to latest release?""")
-        
-        # Set working instance
-        try:
-            self.workingInstance = self.instances[0]['instanceName']
-        except:
-            self.workingInstance = None
-        
-        return response_json
-    
-    def initialize_cdw_config(self, redshiftPassword: str = None):
-        self.get_cdw_api_token()
-        self.workingRedshiftPwd = self.nitroPassword if redshiftPassword is None else redshiftPassword
-        
-        self.cdw_config = {
-                        'serverUrl' : self.serverUrl,
-                        'apiKey': self.cdwAPItoken,
-                        'tenantName': self.tenantName,
-                        'dwInstanceName': self.workingInstance,
-                        'redshiftUser': self.workingRedshiftUser,
-                        'redshiftPwd': self.workingRedshiftPwd,
-                        'connectorName':'global__v'
-                        }
-    
-    def refreshAuthToken(self):
-        
-        # https://cdw-us2-app-us.veevanitro.com/api/v1/users/tokens/renew
-
-        if self.accessToken is None or self.refreshToken is None:
-            raise Exception("You must authenticate first before executing this method")
-
-        url = f"{self.serverUrl}/api/v1/users/tokens/renew"
-        
-        headers = {
-            "refreshToken": self.refreshToken,
-        }
-        response = requests.post(url, headers=headers)
-        
-        # response_json = self._handle_response(response)
-        
-        # if 'content' in response_json and 'token' in response_json['content']:
-        #     self.accessToken = response_json['content']['token']
-            
-        return response
-    
-    def download_cli(self) -> bytes:
-        """
-        Downloads the Command-Line Interface (CLI) zip file from the server.
-
-        Raises:
-            Exception: If the user is not authenticated.
-            Exception: If the server returns an unauthorized error.
-            Exception: If any other server-side error occurs.
-
-        Returns:
-            bytes: The raw content of the downloaded ZIP file.
-        """
-
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-
-        url = f"{self.serverUrl}/api/v1/download/cli"
-        
-        headers = {
-            "Authorization": self.accessToken
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        if response.status_code == 200:
-            # get the zip file content from the response
-            data = getattr(response,'content', '')
-
-            # define the filename
-            filename = "cdw-cli"
-
-            # save the data to the file
-            with open(filename, "wb") as f:
-                f.write(data)
-
-            print(f"ZIP file saved as {filename} in {os.getcwd()}")
-            return data
-        
-        elif response.status_code == 401:
-            if 'error' in response.json().keys():
-                raise Exception(f"Unauthorized: {response.json()['error']}")
-            else:
-                raise Exception(f"Request failed. Response from server: {response.json()}")
-        else:
-            raise Exception(f"Request failed. Response from server: {response.json()}")
-
-    def download_sdk(self) -> bytes:
-        """
-        Downloads the Software Development Kit (SDK) zip file from the server.
-
-        Raises:
-            Exception: If the user is not authenticated.
-            Exception: If the server returns an unauthorized error.
-            Exception: If any other server-side error occurs.
-
-        Returns:
-            bytes: The raw content of the downloaded ZIP file.
-        """
-
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-
-        url = f"{self.serverUrl}/api/v1/download/sdk"
-        
-        headers = {
-            "Authorization": self.accessToken
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        if response.status_code == 200:
-            # get the zip file content from the response
-            data = getattr(response, 'content', '')
-
-            # define the filename
-            filename = "nitro_sdk_latest.whl"
-
-            # save the data to the file
-            with open(filename, "wb") as f:
-                f.write(data)
-
-            print(f"ZIP file saved as {filename} in {os.getcwd()}")
-            return data
-        
-        elif response.status_code == 401:
-            if 'error' in response.json().keys():
-                raise Exception(f"Unauthorized: {response.json()['error']}")
-            else:
-                raise Exception(f"Request failed. Response from server: {response.json()}")
-        else:
-            raise Exception(f"Request failed. Response from server: {response.json()}")
-
-
-        return response
-    
-    def get_cdw_api_token(self):
-        """
-        Retrieves the CDW API token using the authenticated session.
-        
-        Returns:
-            dict: The response JSON containing the CDW API token.
-            
-        Raises:
-            Exception: If the request for the CDW API token fails.
-            Exception: If not authenticated.
-        """
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/api/v1/users/tokens/issue"
-        
-        headers = {
-            "Authorization": self.accessToken
-        }
-        
-        response = requests.post(url, headers=headers)
-        
-        respone_json = self._handle_response(response)
-        
-        if 'content' in respone_json and 'token' in respone_json['content']:
-            self.cdwAPItoken = respone_json['content']['token']
-        
-        return respone_json
-            
-    def get_tenant(self) -> dict:
-        """
-        Retrieves tenant information from the Veeva Nitro API.
-        
-        Returns:
-            dict: The response JSON containing tenant details.
-            
-        Raises:
-            Exception: If the request for tenant information fails.
-            Exception: If not authenticated.
-        """
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/api/v1/admin/tenant"
-        headers = {
-            "Authorization": self.accessToken,
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.tenant = response_json['content']
-        
-        return response_json
-
-    def get_configuration(self) -> dict:
-        """
-        Retrieves cluster configuration from the Veeva Nitro API.
-        
-        Returns:
-            dict: The response JSON containing cluster configuration details.
-            
-        Raises:
-            Exception: If the request for cluster configuration fails.
-            Exception: If not authenticated.
-        """
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/api/v1/admin/cluster/configuration"
-        headers = {
-            "Authorization": self.accessToken
-        }
-        
-        response = requests.get(url, headers=headers)
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.configuration = response_json['content']
-        
-        return response_json
-
-    def get_redshift_dbs(self, Dwinstancename = None) -> dict:
-        """
-        Retrieves Redshift database configuration from the Veeva Nitro API.
-
-        Args:
-            Dwinstancename (str, optional): The name of the instance you're working with. Defaults to the currently set working instance.
-
-        Returns:
-            dict: The response JSON containing Redshift database configuration.
-
-        Raises:
-            Exception: If the request for Redshift database configuration fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-
-        if self.workingInstance is None:
-            raise Exception("You must provide an instance name or set the working instance before executing this method")
-
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        # Building the request
-        url = f"{self.serverUrl}/mds/api/v1/configuration?view=condensed"
-        headers = {
-            "Authorization": self.accessToken,
-            "Dwinstancename": self.workingInstance,
-            "Tenantname": self.tenantName
-        }
-        
-        # Making the GET request
-        response = requests.get(url, headers=headers)
-        response_json = self._handle_response(response)
-        
-        # Save the response content under the Dwinstancename key
-        if 'content' in response_json:
-            self.redshiftDBdetails[self.workingInstance] = response_json['content']
-        
-        if 'content' in response_json and 'instanceDatabase' in response_json['content'] and 'database' in response_json['content']['instanceDatabase']:
-            self.workingDB = response_json['content']['instanceDatabase']['database']
-
-        # Return the response JSON containing Redshift database configuration
-        return response_json
-    
-    def get_users(self) -> dict:
-        """
-        Retrieves user information from the Veeva Nitro API.
-        
-        Returns:
-            dict: The response JSON containing user details.
-            
-        Raises:
-            Exception: If the request for user information fails.
-            Exception: If not authenticated.
-        """
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/api/v1/admin/users"
-        headers = {
-            "Authorization": self.accessToken
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.users = response_json['content']
-        
-        return response_json
-
-    # Question: Where can I find the app parameter values?
-    def get_application_roles(self, app: str = "APP_SERVER") -> dict:
-        """
-        Retrieves application roles from the Veeva Nitro API.
-        
-        Args:
-            app (str, optional): The application type. Defaults to "APP_SERVER".
-            
-        Returns:
-            dict: The response JSON containing application roles.
-            
-        Raises:
-            Exception: If the request for application roles fails.
-            Exception: If not authenticated.
-        """
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/api/v1/admin/users/application-roles?app={app}"
-        headers = {
-            "Authorization": self.accessToken
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.applicationRoles = response_json['content']
-        
-        return response_json
-
-
-    def get_rules(self, Dwinstancename = None) -> dict:
-        """
-        Retrieves rule information from the Veeva Nitro API.
-        
-        Returns:
-            dict: The response JSON containing rule details.
-            
-        Raises:
-            Exception: If the request for rule information fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-        
-        if self.workingInstance is None:
-            raise Exception("You must provide an instance name or set the working instance before executing this method")
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/mds/api/v1/rules"
-        headers = {
-            "Authorization": self.accessToken,
-            "Dwinstancename": self.workingInstance,
-            "Tenantname": self.tenantName
-        }
-        
-        response = requests.get(url, headers=headers)
-        response_json = self._handle_response(response)
-        
-        # Save the response content under the Dwinstancename key
-        if 'content' in response_json:
-            self.rules[self.workingInstance] = response_json['content']
-        
-        return response_json
-
-    def get_groups(self, Dwinstancename = None) -> dict:
-        """
-        Retrieves rule group information from the Veeva Nitro API.
-        
-        Returns:
-            dict: The response JSON containing rule group details.
-            
-        Raises:
-            Exception: If the request for rule group information fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-        
-        if self.workingInstance is None:
-            raise Exception("You must provide an instance name or set the working instance before executing this method")
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/mds/api/v1/rule/groups"
-        headers = {
-            "Authorization": self.accessToken,
-            "Dwinstancename": self.workingInstance,
-            "Tenantname": self.tenantName
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.groups[self.workingInstance] = response_json['content']
-        
-        return response_json
-
-    def get_jobs(self, Dwinstancename = None, view: str = "condensed") -> dict:
-        """
-        Retrieves job information from the Veeva Nitro API.
-        
-        Args:
-            view (str, optional): The view type for the jobs. Defaults to "condensed".
-            
-        Returns:
-            dict: The response JSON containing job details.
-            
-        Raises:
-            Exception: If the request for job information fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-        
-        if self.workingInstance is None:
-            raise Exception("You must provide an instance name or set the working instance before executing this method")
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/mds/api/v1/jobs?view={view}"
-        headers = {
-            "Authorization": self.accessToken,
-            "Dwinstancename": self.workingInstance,
-            "Tenantname": self.tenantName
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.jobs[self.workingInstance] = response_json['content']
-        
-        return response_json
-
-    def get_connectors(self, Dwinstancename = None, internalOnly: bool = False, ) -> dict:
-        """
-        Retrieves connector information from the Veeva Nitro API.
-        
-        Args:
-            internalOnly (bool, optional): Filter for internal connectors. Defaults to False.
-            
-        Returns:
-            dict: The response JSON containing connector details.
-            
-        Raises:
-            Exception: If the request for connectors fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-        
-        if self.workingInstance is None:
-            raise Exception("You must provide an instance name or set the working instance before executing this method")
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/mds/api/v1/connectors?internalOnly={internalOnly}"
-        headers = {
-            "Authorization": self.accessToken,
-            "Dwinstancename": self.workingInstance,
-            "Tenantname": self.tenantName
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.connectors[self.workingInstance] = response_json['content']
-        
-        return response_json
-
-    def get_cluster_details(self, Dwinstancename = None) -> dict:
-        """
-        Retrieves cluster details from the Veeva Nitro API.
-        
-        Returns:
-            dict: The response JSON containing cluster details.
-            
-        Raises:
-            Exception: If the request for cluster details fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-        
-        if self.workingInstance is None:
-            raise Exception("You must provide an instance name or set the working instance before executing this method")
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/api/v1/admin/cluster-details"
-        headers = {
-            "Authorization": self.accessToken,
-            "Dwinstancename": self.workingInstance,
-            "Tenantname": self.tenantName
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.clusterDetails[self.workingInstance] = response_json['content']
-        
-        return response_json
-
-    def get_job_results(self, Dwinstancename: str = None, size: int = 1000, jobId: str = None) -> dict:
-        """
-        Retrieves job results from the Veeva Nitro API.
-        
-        Args:
-            instanceName (str): The name of the instance.
-            size (int, optional): The number of results to retrieve. Defaults to 1000.
-            jobId (str, optional): The ID of the job. Defaults to None.
-            
-        Returns:
-            dict: The response JSON containing job results.
-            
-        Raises:
-            Exception: If the request for job results fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-        
-        if self.workingInstance is None:
-            raise Exception("You must provide an instance name or set the working instance before executing this method")
-        
-        # Check if authentication has taken place
-        if self.accessToken is None:
-            raise Exception("You must authenticate first before executing this method")
-        
-        url = f"{self.serverUrl}/api/v1/admin/jobs/results?instanceName={self.workingInstance}&size={size}&jobId={jobId}"
-        headers = {
-            "Authorization": self.accessToken
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        response_json = self._handle_response(response)
-        
-        if 'content' in response_json:
-            self.jobResults[self.workingInstance] = response_json['content']
-        
-        return response_json
-    
-
-    ##############################################################################################################
-    # Workspace methods
-    ##############################################################################################################
-    def set_redshift_user(self, nitroUserName: str = None, redshiftUserName: str = None):
-        """
-        Sets the current Redshift user based on either nitroUserName, redshiftUserName or self.nitroUserName.
-        
-        Args:
-            nitroUserName (str, optional): Nitro username to search for and set the corresponding Redshift user.
-            redshiftUserName (str, optional): Directly provide the Redshift username to set.
-            
-        Raises:
-            ValueError: If both nitroUserName and redshiftUserName are provided.
-            Exception: If the Redshift username cannot be found.
-        """
-        
-        # If both parameters are provided, raise a value error.
-        if nitroUserName and redshiftUserName:
-            raise ValueError("Provide either nitroUserName or redshiftUserName, not both.")
-
-        # If self.users is None, attempt to populate it using the get_users method.
-        if self.users is None:
-            self.get_users()
-
-        # Check if self.users is still None after trying to populate it.
-        if self.users is None:
-            raise Exception("Unable to fetch users. Ensure self.get_users() is properly implemented and data source is available.")
-        
-        # Use self.nitroUserName if no parameters are provided
-        if not nitroUserName and not redshiftUserName:
-            nitroUserName = self.nitroUserName
-
-        if nitroUserName:
-            for user in self.users:
-                if user['username'] == nitroUserName and 'redshiftUserName' in user:
-                    self.workingRedshiftUser = user['redshiftUserName']
-                    return
-            raise Exception(f"Redshift user not found for Nitro username {nitroUserName}")
-        
-        if redshiftUserName:
-            for user in self.users:
-                if user.get('redshiftUserName') == redshiftUserName:
-                    self.workingRedshiftUser = redshiftUserName
-                    return
-            raise Exception("RedshiftUserName not found.")
-      
-    def get_workspaces(self, redshiftUserName: str = None, Dwinstancename: str = None):
-        """
-        Fetches a list of user workspaces for a given Redshift user.
-
-        This function attempts to get workspaces for a specified Redshift user. If no Redshift user is provided, 
-        it checks and uses the workingRedshiftUser attribute. If the attribute is also not set, it attempts to set it 
-        using the set_redshift_user() method. In addition, if a data warehouse instance name (Dwinstancename) is provided, 
-        it updates the working instance to the given name. If not, it uses the currently set working instance.
-        
-        Args:
-            redshiftUserName (str, optional): Redshift username for which workspaces are to be fetched. Defaults to None.
-            Dwinstancename (str, optional): Data warehouse instance name to set as the working instance. Defaults to the currently set instance.
-        
-        Returns:
-            dict: JSON response from the server containing user workspace information.
-            
-        Raises:
-            Exception: 
-                - If there's an issue fetching the workspaces.
-                - If RedshiftUserName isn't provided and cannot be set via set_redshift_user method.
-                - If instance name isn't provided and hasn't been set via authenticate method.
-        """
-
-        # Update self.workingRedshiftUser if redshiftUserName is provided
-        if redshiftUserName:
-            self.workingRedshiftUser = redshiftUserName
-        elif self.workingRedshiftUser is None:
-            self.set_redshift_user()
-            
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-
-
-        # Check if self.workingRedshiftUser is set after all checks and assignments
-        if self.workingRedshiftUser is None:
-            raise Exception("RedshiftUserName must be provided or set via set_redshift_user method.")
-    
-        # Check if self.workingInstance is set after all checks and assignments
-        if self.workingInstance is None:
-            raise Exception("Instance name must be provided or set via authenticate method.")
-
-        
-        headers = {
-            'Tenantname': self.tenantName,
-            'Dwinstancename': self.workingInstance,
-            'Connectorname': 'global__v', # Currently hard-coded
-            "Authorization": self.accessToken
-        }
-        
-        
-        url = f"{self.serverUrl}/mds/api/v1/workspaces"
-        
-        response = requests.get(url, headers=headers)
-        response_json = self._handle_response(response)
-        
-        # Save the response in self.workspaces using the workingInstance as the key
-        if 'content' in response_json:
-            self.workspaces[self.workingInstance] = response_json['content']
-    
-        # Filter the content if redshiftUserName is provided
-        if redshiftUserName and 'content' in response_json:
-            filtered_content = [entry for entry in response_json['content'] if entry.get('owner') == redshiftUserName]
-            response_json['content'] = filtered_content
-
-        return response_json
-
-    def connect_to_user_workspace(self, workspaceName: str = None, Dwinstancename: str = None, redshiftUserName: str = None):
-        """
-        Connects to a specified user workspace.
-        
-        Args:
-            workspaceName (str): The name of the workspace to connect to.
-            
-        Returns:
-            dict: The workspace details.
-            
-        Raises:
-            Exception: If there's an issue connecting to the workspace.
-        """
-        
-        
-        if self.workspaces is None:
-            self.get_workspaces(Dwinstancename = Dwinstancename, redshiftUserName = redshiftUserName)
-            
-        if redshiftUserName:
-            self.workingRedshiftUser = redshiftUserName
-        elif self.workingRedshiftUser is None:
-            self.set_redshift_user()
-        
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-        
-        if workspaceName is None and self.workingWorkspaceName is None:
-            raise Exception("You must provide a workspace name or set the working workspace before executing this method")
-        
-        if workspaceName is not None:
-            self.workingWorkspaceName = workspaceName
-        else:
-            workspaceName = self.workingWorkspaceName
-        
-        
-        print(f"Connecting to workspace {workspaceName} for Redshift user {self.workingRedshiftUser} on instance {self.workingInstance}")
-        headers = {
-            'tenantName': self.tenantName,
-            'dwInstanceName': self.workingInstance,
-            'connectorName': 'global__v',
-            "Authorization": self.accessToken
-        }
-        
-        params = {'redshiftUser': self.workingRedshiftUser}
-        url = f"{self.serverUrl}/api/v1/admin/workspaces/{workspaceName}/session-token"
-        
-        response = requests.get(url, headers=headers, params=params)
-        response_json = self._handle_response(response)
-        
-        
-        # Save the response in self.workspaceConnections using the { self.workingInstance: { workspaceName: { self.workingRedshiftUser: response_json } } } as the key
-        if 'content' in response_json:
-            if self.workingInstance not in self.workspaceConnections:
-                self.workspaceConnections[self.workingInstance] = {}
-                
-            if workspaceName not in self.workspaceConnections[self.workingInstance]:
-                self.workspaceConnections[self.workingInstance][workspaceName] = {}
-                
-            self.workspaceConnections[self.workingInstance][workspaceName][self.workingRedshiftUser] = response_json['content']
-            
-        self.workingWorkspaceConnection = response_json['content']
-        
-        return response_json
-    
-    ##############################################################################################################
-    # S3 client methods
-    ##############################################################################################################
-    
-    def get_s3_client(self, workspaceName: str = None, Dwinstancename: str = None, redshiftUserName: str = None):
-        # Check or instantiate necessary instance variables same as connect_to_user_workspace
-        if self.workspaces is None:
-            self.get_workspaces(Dwinstancename=Dwinstancename, redshiftUserName=redshiftUserName)
-
-        if redshiftUserName:
-            self.workingRedshiftUser = redshiftUserName
-        elif self.workingRedshiftUser is None:
-            self.set_redshift_user()
-
-        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
-
-        if workspaceName is None and self.workingWorkspaceName is None:
-            raise Exception("You must provide a workspace name or set the working workspace before executing this method")
-
-        if workspaceName is not None:
-            self.workingWorkspaceName = workspaceName
-
-        # Check if workspaceConnections exists. If not, connect to user workspace and reattempt
-        if not hasattr(self, 'workspaceConnections') or self.workingInstance not in self.workspaceConnections or \
-                self.workingWorkspaceName not in self.workspaceConnections[self.workingInstance] or \
-                self.workingRedshiftUser not in self.workspaceConnections[self.workingInstance][self.workingWorkspaceName]:
-            print(f"Credentials not found. Connecting to workspace...")
-            self.connect_to_user_workspace(workspaceName=self.workingWorkspaceName, Dwinstancename=self.workingInstance,
-                                        redshiftUserName=self.workingRedshiftUser)
-
-        # Try to get credentials again after connecting
-        try:
-            credentials = self.workspaceConnections[self.workingInstance][self.workingWorkspaceName][self.workingRedshiftUser]['credentials']
-        except KeyError:
-            raise Exception("Credentials not found for the provided combination of Dwinstancename, workspaceName, and redshiftUserName")
-
-        # Check expiration
-        expiration_datetime = datetime.strptime(credentials['expiration'], '%Y-%m-%dT%H:%M:%S.%f+00:00').replace(tzinfo=timezone.utc)
-        if expiration_datetime <= datetime.now(timezone.utc):
-            raise Exception("The token has expired!")
-
-        # Create and save the S3 client
-        session = boto3.Session(
-            aws_access_key_id=credentials['accessKeyId'],
-            aws_secret_access_key=credentials['secretAccessKey'],
-            aws_session_token=credentials['sessionToken']
-        )
-        s3_client = session.client('s3')
-
-        # Saving s3 client in the desired format
-        if not hasattr(self, 's3_clients'):
-            self.s3_clients = {}
-
-        if self.workingInstance not in self.s3_clients:
-            self.s3_clients[self.workingInstance] = {}
-
-        if self.workingWorkspaceName not in self.s3_clients[self.workingInstance]:
-            self.s3_clients[self.workingInstance][self.workingWorkspaceName] = {}
-
-        self.s3_clients[self.workingInstance][self.workingWorkspaceName][self.workingRedshiftUser] = s3_client
-
-        self.workingS3Client = s3_client
-        
-        self.workingWorkspaceConnection = self.workspaceConnections[self.workingInstance][self.workingWorkspaceName][self.workingRedshiftUser]
-        
-        s3_url = urlparse(self.workspaceConnections[self.workingInstance][self.workingWorkspaceName][self.workingRedshiftUser]['s3ObjectKey'], allow_fragments=False)
-        
-        self.workingS3Bucket = s3_url.netloc
-        self.workingS3PathPrefix = s3_url.path.lstrip('/')
-        
-        return s3_client
-
-    def list_user_workspace(self):
-        """
-        Lists the files in the user's workspace on S3 based on the specified prefix.
-        
-        Args:
-            parameters (dict, optional): Additional parameters for filtering the files. Defaults to None.
-
-        Returns:
-            dict: A dictionary mapping the file keys to their respective sizes.
-        """
-        objects = dict()
-        try:
-            paginator = self.workingS3Client.get_paginator('list_objects_v2')
-            pages = paginator.paginate(Bucket=self.workingS3Bucket, Prefix=self.workingS3PathPrefix)
-
-            for page in pages:
-                if 'Contents' in page:
-                    for obj in page['Contents']:
-                        objKey = obj['Key']
-                        objSize = obj['Size']
-                        if objKey:
-                            temp = objKey.replace(self.workingS3PathPrefix, '')
-                            objects[temp] = objSize
-                                
-        except Exception as ex:
-            print('list-user-workspace error :', str(ex))
-
-        return objects
-
-
-    def get_file_from_workspace(self, key, filePath, callback=None):
-        """
-        Downloads a file from the user's workspace on S3.
-
-        Args:
-            key (str): The key of the file to download.
-            filePath (str): The local path to save the downloaded file.
-            callback (function, optional): A function to track download progress. Defaults to `display_progress`.
-
-        Returns:
-            File: The downloaded file object.
-
-        Raises:
-            Exception: If there's any error during the file download process.
-        """
-        s3Key = self.workingS3PathPrefix + key
-        meta_data = self.workingS3Client.head_object(Bucket=self.workingS3Bucket, Key=s3Key)
-        total_length = int(meta_data.get('ContentLength', 0))
-
-        if callback is None:
-            callback = display_progress(total_length)
-
-        with open(filePath, 'wb') as localFile:
-            self.workingS3Client.download_fileobj(Bucket=self.workingS3Bucket, Key=s3Key, Fileobj=localFile, Callback=callback)
-            sys.stdout.write("\n")
-            sys.stdout.flush()
-        
-        print(f"Downloaded {s3Key} to {filePath}")
-        return None
-
-    def upload_file_to_workspace(self, filePath, key, callback=None):
-        """
-        Uploads a file to the user's workspace on S3.
-
-        Args:
-            filePath (str): The local path of the file to be uploaded.
-            key (str): The key to save the file under in S3.
-            callback (function, optional): A function to track upload progress. Defaults to `display_progress`.
-
-        Returns:
-            str: "Success" if the upload completes without errors, "Failed" otherwise.
-
-        Raises:
-            Exception: If there's any error during the file upload process.
-        """
-        total = os.stat(filePath).st_size
-        s3Key = self.workingS3PathPrefix + key
-        
-        if callback is None:
-            callback = display_progress(total)
-
-        with open(filePath, 'rb') as localFile:
-            self.workingS3Client.upload_fileobj(
-                Bucket=self.workingS3Bucket, 
-                Key=s3Key, 
-                Fileobj=localFile, 
-                Callback=callback
-            )
-            sys.stdout.write("\n")
-            sys.stdout.flush()
-            print(f"Uploaded {filePath} to {s3Key}")
-            return None
-        # Catching an exception and re-raising it will allow the caller to handle the exception as needed.
-        raise Exception("Error uploading file to workspace.")
-
-    def delete_file_from_workspace(self, *keys) -> dict:
-        """
-        Deletes one or more files from the user's workspace on S3.
-        
-        Args:
-            *keys (str): The keys of the files to delete.
-        """
-        try:
-            for key in keys:
-                s3Key = self.workingS3PathPrefix + key
-                return self.workingS3Client.delete_object(Bucket=self.workingS3Bucket, Key=s3Key)
-        except Exception as ex:
-            raise Exception(f"Error deleting {key} from workspace: {str(ex)}")
-
-
-    def check_key_file_exists(self, key) -> bool:
-        """
-        Checks if a file exists in the user's workspace on S3.
-        
-        Args:
-            key (str): The key of the file to check.
-
-        Returns:
-            bool: True if the file exists, False otherwise.
-        """
-        try:
-            self.workingS3Client.head_object(Bucket=self.workingS3Bucket, Key=self.workingS3PathPrefix + key)
-        except ClientError as e:
-            print("Key file " + key + " does not exist on s3: ", str(e))
-            return False
-
-        return True
-
-    ##############################################################################################################
-    # Redshift Methods
-    ##############################################################################################################
-    def get_db_connection(self):
-        """
-        Establishes and returns a database connection using the psycopg2 library.
-
-        This method checks the necessary attributes of the instance to form a connection string. 
-        The attributes checked are:
-        - workingDB: The name of the working database.
-        - configuration: A dictionary containing the cluster's endpoint. The key to check is 'clusterEndpoint'.
-        - redshiftPort: The port to connect to on the Redshift cluster.
-        - workingRedshiftUser: The Redshift username.
-        - workingRedshiftPwd: The Redshift password.
-
-        If any of the above attributes are empty or None, a ValueError is raised.
-
-        :return: A psycopg2 connection object established using the attributes provided.
-        :raises ValueError: If any necessary attributes are empty or None.
-        """
-    
-        if not self.workingDB:
-            raise ValueError("workingDB attribute is empty or None!")
-
-        if not self.configuration or 'clusterEndpoint' not in self.configuration or not self.configuration['clusterEndpoint']:
-            raise ValueError("clusterEndpoint in configuration is empty or None!")
-
-        if not self.redshiftPort:
-            raise ValueError("redshiftPort attribute is empty or None!")
-
-        if not self.workingRedshiftUser:
-            raise ValueError("workingRedshiftUser attribute is empty or None!")
-
-        if not self.workingRedshiftPwd:
-            raise ValueError("workingRedshiftPwd attribute is empty or None!")
-        
-        connectionString = ("dbname={dbname} host={host} port={port} "
-                        "user={userid} password={password}").format(
-                            dbname=self.workingDB,
-                            host=self.configuration['clusterEndpoint'],
-                            port=self.redshiftPort,
-                            userid=self.workingRedshiftUser,
-                            password=self.workingRedshiftPwd
-                        )
-        
-        connection = psycopg2.connect(connectionString)
-        connection.autocommit = True
-        
-        self.workingDBConnection = connection
-        
-        return connection
-    
-    def get_db_cursor(self, connection: psycopg2.extensions.connection = None):
-        """
-        Creates a database cursor using the given connection.
-
-        :param connection: A psycopg2 connection object to be used for creating the cursor.
-        :return: A psycopg2 cursor object.
-        :raises ValueError: If no connection is provided and workingDBConnection attribute is empty or None.
-        """
-        if connection is None and self.workingDBConnection is None:
-            raise ValueError("No connection provided and workingDBConnection attribute is empty or None!")
-        elif connection is None:
-            connection = self.workingDBConnection
-        
-        cursor = connection.cursor(cursor_factory=RealDictCursor)
-        self.workingDBCursor = cursor
-        
-        return cursor
-    
-    def close_db_connection(self, connection: psycopg2.extensions.connection = None):
-        """
-        Closes the given database connection.
-
-        :param connection: A psycopg2 connection object to be closed.
-        """
-        if connection is None and self.workingDBConnection is None:
-            raise ValueError("No connection provided and workingDBConnection attribute is empty or None!")
-        elif connection is None:
-            connection = self.workingDBConnection
-        
-        connection.close()
-    
-
-    def get_sqlalchemy_engine(self):
-        """
-        Establishes and returns a database connection using SQLAlchemy with the psycopg2 driver.
-
-        This method checks the necessary attributes of the instance to form a connection string. 
-        The attributes checked are:
-        - workingDB: The name of the working database.
-        - configuration: A dictionary containing the cluster's endpoint. The key to check is 'clusterEndpoint'.
-        - redshiftPort: The port to connect to on the Redshift cluster.
-        - workingRedshiftUser: The Redshift username.
-        - workingRedshiftPwd: The Redshift password.
-
-        If any of the above attributes are empty or None, a ValueError is raised.
-
-        :return: A SQLAlchemy engine object established using the attributes provided.
-        :raises ValueError: If any necessary attributes are empty or None.
-        """
-
-        if not self.workingDB:
-            raise ValueError("workingDB attribute is empty or None!")
-
-        if not self.configuration or 'clusterEndpoint' not in self.configuration or not self.configuration['clusterEndpoint']:
-            raise ValueError("clusterEndpoint in configuration is empty or None!")
-
-        if not self.redshiftPort:
-            raise ValueError("redshiftPort attribute is empty or None!")
-
-        if not self.workingRedshiftUser:
-            raise ValueError("workingRedshiftUser attribute is empty or None!")
-
-        if not self.workingRedshiftPwd:
-            raise ValueError("workingRedshiftPwd attribute is empty or None!")
-
-        connection_string = ("postgresql+psycopg2://{userid}:{password}@{host}:{port}/{dbname}").format(
-            userid=quote_plus(self.workingRedshiftUser),
-            password=quote_plus(self.workingRedshiftPwd),
-            host=self.configuration['clusterEndpoint'],
-            port=self.redshiftPort,
-            dbname=self.workingDB
-        )
-
-        engine = create_engine(connection_string, echo=False)  # echo=False disables logging of SQL statements
-
-        # Store the engine for later use (optional)
-        self.workingSQLalchemyEngine = engine
-        
-        return engine
-    
-    ##############################################################################################################
-    # Async methods
-    ##############################################################################################################
-    
-    async def get_rules_from_instances(self, instances: List[str] = None):
-        """
-        Retrieves rule information from the Veeva Nitro API for a list of instances.
-        
-        Args:
-            instances (List[str], optional): A list of instance names. Defaults to None.
-            
-        Returns:
-            dict: The response JSON containing rule details.
-            
-        Raises:
-            Exception: If the request for rule information fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-
-        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
-        
-        # Create a list of async tasks
-        tasks = []
-        
-        async_get_rules = async_wrap(self.get_rules)
-        
-        rules_dict = {}
-        
-        for instance in instances:
-            tasks.append(async_get_rules(Dwinstancename=instance))
-        
-        # Execute the async tasks
-        responses = await asyncio.gather(*tasks)
-        
-        # Create a dictionary of the responses
-        for i, instance in enumerate(instances):
-            rules_dict[instance] = responses[i]['content']
-        
-        self.rules = rules_dict
-        
-        return rules_dict
-    
-    async def get_groups_from_instances(self, instances: List[str] = None):
-        """
-        Retrieves rule group information from the Veeva Nitro API for a list of instances.
-        
-        Args:
-            instances (List[str], optional): A list of instance names. Defaults to None.
-            
-        Returns:
-            dict: The response JSON containing rule group details.
-            
-        Raises:
-            Exception: If the request for rule group information fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
-        
-        # Create a list of async tasks
-        tasks = []
-        
-        async_get_groups = async_wrap(self.get_groups)
-        
-        groups_dict = {}
-        
-        for instance in instances:
-            tasks.append(async_get_groups(Dwinstancename=instance))
-        
-        # Execute the async tasks
-        responses = await asyncio.gather(*tasks)
-        
-        # Create a dictionary of the responses
-        for i, instance in enumerate(instances):
-            groups_dict[instance] = responses[i]['content']
-        
-        self.groups = groups_dict
-        
-        return groups_dict
-
-    async def get_jobs_from_instances(self, instances: List[str] = None, view: str = "condensed"):
-        """
-        Retrieves job information from the Veeva Nitro API for a list of instances.
-        
-        Args:
-            instances (List[str], optional): A list of instance names. Defaults to None.
-            view (str, optional): The view type for the jobs. Defaults to "condensed".
-            
-        Returns:
-            dict: The response JSON containing job details.
-            
-        Raises:
-            Exception: If the request for job information fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
-        
-        # Create a list of async tasks
-        tasks = []
-        
-        async_get_jobs = async_wrap(self.get_jobs)
-        
-        jobs_dict = {}
-        
-        for instance in instances:
-            tasks.append(async_get_jobs(Dwinstancename=instance, view=view))
-        
-        # Execute the async tasks
-        responses = await asyncio.gather(*tasks)
-        
-        # Create a dictionary of the responses
-        for i, instance in enumerate(instances):
-            jobs_dict[instance] = responses[i]['content']
-        
-        self.jobs = jobs_dict
-        
-        return jobs_dict
-    
-    async def get_connectors_from_instances(self, instances: List[str] = None, internalOnly: bool = False):
-        """
-        Retrieves connector information from the Veeva Nitro API for a list of instances.
-        
-        Args:
-            instances (List[str], optional): A list of instance names. Defaults to None.
-            internalOnly (bool, optional): Filter for internal connectors. Defaults to False.
-            
-        Returns:
-            dict: The response JSON containing connector details.
-            
-        Raises:
-            Exception: If the request for connectors fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
-        
-        # Create a list of async tasks
-        tasks = []
-        
-        async_get_connectors = async_wrap(self.get_connectors)
-        
-        connectors_dict = {}
-        
-        for instance in instances:
-            tasks.append(async_get_connectors(Dwinstancename=instance, internalOnly=internalOnly))
-        
-        # Execute the async tasks
-        responses = await asyncio.gather(*tasks)
-        
-        # Create a dictionary of the responses
-        for i, instance in enumerate(instances):
-            connectors_dict[instance] = responses[i]['content']
-        
-        self.connectors = connectors_dict
-        
-        return connectors_dict
-    
-    async def get_cluster_details_from_instances(self, instances: List[str] = None):
-        """
-        Retrieves cluster details from the Veeva Nitro API for a list of instances.
-        
-        Args:
-            instances (List[str], optional): A list of instance names. Defaults to None.
-            
-        Returns:
-            dict: The response JSON containing cluster details.
-            
-        Raises:
-            Exception: If the request for cluster details fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
-        
-        # Create a list of async tasks
-        tasks = []
-        
-        async_get_cluster_details = async_wrap(self.get_cluster_details)
-        
-        cluster_details_dict = {}
-        
-        for instance in instances:
-            tasks.append(async_get_cluster_details(Dwinstancename=instance))
-        
-        # Execute the async tasks
-        responses = await asyncio.gather(*tasks)
-        
-        # Create a dictionary of the responses
-        for i, instance in enumerate(instances):
-            cluster_details_dict[instance] = responses[i]['content']
-        
-        self.clusterDetails = cluster_details_dict
-        
-        return cluster_details_dict
-    
-    async def get_job_results_from_instances(self, instances: List[str] = None, size: int = 1000, jobId: str = None):
-        """
-        Retrieves job results from the Veeva Nitro API for a list of instances.
-        
-        Args:
-            instances (List[str], optional): A list of instance names. Defaults to None.
-            size (int, optional): The number of results to retrieve. Defaults to 1000.
-            jobId (str, optional): The ID of the job. Defaults to None.
-            
-        Returns:
-            dict: The response JSON containing job results.
-            
-        Raises:
-            Exception: If the request for job results fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
-        
-        # Create a list of async tasks
-        tasks = []
-        
-        async_get_job_results = async_wrap(self.get_job_results)
-        
-        job_results_dict = {}
-        
-        for instance in instances:
-            tasks.append(async_get_job_results(Dwinstancename=instance, size=size, jobId=jobId))
-        
-        # Execute the async tasks
-        responses = await asyncio.gather(*tasks)
-        
-        # Create a dictionary of the responses
-        for i, instance in enumerate(instances):
-            job_results_dict[instance] = responses[i]['content']
-        
-        self.jobResults = job_results_dict
-        
-        return job_results_dict
-
-    async def get_workspaces_from_instances(self, instances: List[str] = None):
-        """
-        Retrieves workspace information from the Veeva Nitro API for a list of instances.
-        
-        Args:
-            instances (List[str], optional): A list of instance names. Defaults to None.
-            
-        Returns:
-            dict: The response JSON containing workspace details.
-            
-        Raises:
-            Exception: If the request for workspaces fails.
-            Exception: If not authenticated.
-            Exception: If no instance name is provided or set as the working instance.
-        """
-        
-        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
-        
-        # Create a list of async tasks
-        tasks = []
-
-        async_get_workspaces = async_wrap(self.get_workspaces)
-        
-        for instance in instances:
-            tasks.append(async_get_workspaces(Dwinstancename=instance))
-        
-        # Execute the async tasks
-        responses = await asyncio.gather(*tasks)
-        
-        # Create a dictionary of the responses
-        workspaces_dict = {}
-        for i, instance in enumerate(instances):
-            workspaces_dict[instance] = responses[i]['content']
-        
-        self.workspaces = workspaces_dict
-        
-        return workspaces_dict
-    
-    async def get_all_tenant_details(self):
-        
-        tasks = [
-            self.get_rules_from_instances(),
-            self.get_groups_from_instances(),
-            self.get_jobs_from_instances(),
-            self.get_connectors_from_instances(),
-            self.get_cluster_details_from_instances(),
-            self.get_job_results_from_instances(),
-            self.get_workspaces_from_instances()
-        ]
-        
-        result_dict = {}
-        
-        result = await asyncio.gather(*tasks)
-        
-        for i, instance in enumerate(self.instances):
-            result_dict[instance['instanceName']] = {
-                'rules': result[0][instance['instanceName']],
-                'groups': result[1][instance['instanceName']],
-                'jobs': result[2][instance['instanceName']],
-                'connectors': result[3][instance['instanceName']],
-                'clusterDetails': result[4][instance['instanceName']],
-                'jobResults': result[5][instance['instanceName']],
-                'workspaces': result[6][instance['instanceName']]
-            }
-        
+from sys import platform
+import requests
+import pandas as pd
+import os
+import json
+from urllib.parse import urlparse
+from typing import List, Optional
+import asyncio
+from datetime import datetime, timezone
+import boto3
+from botocore.exceptions import ClientError
+
+import psycopg2
+from psycopg2.extras import RealDictCursor
+from sqlalchemy import create_engine
+from urllib.parse import quote_plus
+
+try:
+    from nitro_utils.s3_utils import display_progress
+except:
+    from veevanitro.nitro_utils.s3_utils import display_progress
+
+# Async
+from utilities.async_utils import async_wrap
+
+
+
+class Vnitro:
+    
+    def __init__(self):
+        self.serverUrl: str = None # from authenticate
+        self.nitroUserName: str = None # from authenticate
+        self.nitroPassword: str = None # from authenticate
+        self.accessToken: str = None # from authenticate
+        self.refreshToken: str = None # from authenticate
+        self.appServerUrl: str = None # from authenticate
+        self.tenantName: str = None # from authenticate
+        self.workingRedshiftPwd: str = None # from initialize_cdw_config
+        self.cdw_config: dict = None # from initialize_cdw_config
+        self.instances: List[Optional(dict)] = None # from authenticate
+        self.tenantRoles: List[Optional(dict)] = None # from authenticate
+        self.instanceRoles: List[Optional(dict)] = None # from authenticate
+        self.instancePermissions: dict = None # from authenticate
+        self.cdwAPItoken: str = None # from get_cdw_api_token
+        self.tenant: dict = None # from get_tenant
+        self.configuration: dict = None # from get_configuration
+        self.users: List[Optional(dict)] = None # from get_users
+        self.applicationRoles: List[Optional(dict)] = None # from get_application_roles
+        self.rules: dict = {} # from get_rules
+        self.groups: dict = {} # from get_groups
+        self.jobs: dict = {} # from get_jobs
+        self.connectors: dict = {} # from get_connectors
+        self.clusterDetails: dict = {} # from get_cluster_details
+        self.jobResults: dict = {} # from get_results
+        self.workingInstance: str = None # Set by any method that requires an instance name, last used instance name is stored here
+                                         # Upon authentication, the first instance in the list of instances is set as the working instance
+        
+        # Redshift
+        self.workingRedshiftUser: str = None # from set_redshift_user
+        self.workspaces: dict = {} # from get_workspaces
+        self.workingWorkspaceName: dict = {} # from connect_to_user_workspace
+        self.workingWorkspaceConnection: dict = {} # from connect_to_user_workspace
+        self.redshiftDBdetails: dict = {} # from get_redshift_dbs
+        self.workingDB: str = None # from get_redshift_dbs
+        self.workingDBConnection: psycopg2.extensions.connection = None # from from get_db_connection
+        self.workspaceConnections: dict = {} # from connect_to_user_workspace
+        self.redshiftPort: str = '5439'
+        self.workingDBConnection: psycopg2.extensions.connection = None # from from get_db_connection
+        self.workingDBCursor: psycopg2.extensions.cursor = None # from from get_db_connection
+        self.workingSQLalchemyEngine: sqlalchemy.engine.base.Engine = None # from get_sqlalchemy_engine
+        
+        # S3 Client
+        self.s3_clients: boto3.client = {} # from get_s3_client
+        self.workingS3Client: boto3.client = None # from get_s3_client
+        self.workingS3Bucket: str = None # from get_s3_client
+        self.workingS3PathPrefix: str = None # from get_s3_client
+        
+        
+    def _handle_response(self, response):
+        """
+        A helper method to handle API responses.
+        
+        Args:
+            response (Response): The response object from the requests library.
+            
+        Returns:
+            dict: The response JSON content.
+            
+        Raises:
+            Exception: If the response indicates an error.
+        """
+        if response.status_code == 200:
+            return response.json()
+        
+        elif response.status_code == 401:
+            if 'error' in response.json().keys():
+                raise Exception(f"Unauthorized: {response.json()['error']}")
+                
+            else:
+                raise Exception(f"Request failed. Response from server: {response.json()}")
+        else:
+            raise Exception(f"Request failed. Response from server: {response.json()}")
+    
+    def authenticate(
+        self,
+        serverUrl: str = None,
+        nitroUserName: str = None,
+        nitroPassword: str = None,
+        accessToken: str = None
+    ):
+        """
+        Authenticates the user with the Veeva Nitro API. If the accessToken is provided, the username and password are not required.
+        The authentication also retrieves the tenant information and sets the attributes of the class to the response JSON.
+        It loads the following attributes:
+            self.accessToken, self.refreshToken, self.serverUrl, self.appServerUrl, self.tenantName,
+            self.instances, self.tenantRoles, self.instanceRoles, self.instancePermissions
+        
+        Args:
+            serverUrl (str): Required. The base URL for the Veeva Nitro API. Example: https://mycompany.veevanitro.com
+            nitroUserName (str, optional): The username for authentication. Defaults to None. Must be provided if accessToken is not provided.
+            nitroPassword (str, optional): The password for authentication. Defaults to None. Must be provided if accessToken is not provided.
+            accessToken (str, optional): The session ID for authentication. Defaults to None. Must be provided if nitroUserName and nitroPassword are not provided.
+            
+        Raises:
+            Exception: If the necessary parameters for authentication are not provided.
+            Exception: If the authentication fails.
+        """
+        self.serverUrl = serverUrl if serverUrl is not None else self.serverUrl
+        self.nitroUserName = nitroUserName if nitroUserName is not None else self.nitroUserName
+        self.nitroPassword = nitroPassword if nitroPassword is not None else self.nitroPassword
+        self.accessToken = accessToken if accessToken is not None else self.accessToken
+        
+        url = f"{self.serverUrl}/api/v1/auth/login"
+        
+        # Ensure at least serverUrl and accessToken are provided or serverUrl and nitroUserName and nitroPassword are provided
+        if (self.serverUrl is None) or (self.accessToken is None and (self.nitroUserName is None or self.nitroPassword is None)):
+            raise Exception("serverUrl and accessToken are required or serverUrl and nitroUserName and nitroPassword are required")
+        
+        # If authenticating with username and password:
+        if self.accessToken is None:
+            # Get the session ID
+            payload = {
+                "username": self.nitroUserName,
+                "password": self.nitroPassword
+            }
+
+            response = requests.post(url, json=payload)
+            
+        # If authenticating with session ID
+        else:
+            # There is not a clear way to authenticate using accessToken, so we will just make a request to the tenant endpoint to test the validity of the session ID
+            url = f"{self.serverUrl}/api/v1/admin/tenant"
+            payload = {
+                "Authorization": self.accessToken
+            }
+
+            response = requests.get(url, headers=payload)
+            
+        response_json = self._handle_response(response)
+            
+
+        attributes = [
+            'accessToken', 'refreshToken', 'serverUrl', 'appServerUrl', 'tenantName',
+            'instances', 'tenantRoles', 'instanceRoles', 'instancePermissions'
+        ]
+
+        # Decision was made here to raise an exception if
+        # the response does not contain the expected attributes
+        # This is to ensure that the attributes of the class are set correctly
+        # and that future methods can rely on the attributes being set
+        # MPay 2023-08-18
+        try:
+            # Set the attributes of the class to the response JSON
+            for attr in attributes:
+                setattr(self, attr, response_json[attr])
+        except:
+            raise Exception(f"""API response did not contain the expected attributes.
+            Expected attributes: {attributes}
+            Response JSON: {response_json}
+            Please contact the developer or system administrator for assistance.
+            Has the API changed due to latest release?""")
+        
+        # Set working instance
+        try:
+            self.workingInstance = self.instances[0]['instanceName']
+        except:
+            self.workingInstance = None
+        
+        return response_json
+    
+    def initialize_cdw_config(self, redshiftPassword: str = None):
+        self.get_cdw_api_token()
+        self.workingRedshiftPwd = self.nitroPassword if redshiftPassword is None else redshiftPassword
+        
+        self.cdw_config = {
+                        'serverUrl' : self.serverUrl,
+                        'apiKey': self.cdwAPItoken,
+                        'tenantName': self.tenantName,
+                        'dwInstanceName': self.workingInstance,
+                        'redshiftUser': self.workingRedshiftUser,
+                        'redshiftPwd': self.workingRedshiftPwd,
+                        'connectorName':'global__v'
+                        }
+    
+    def refreshAuthToken(self):
+        
+        # https://cdw-us2-app-us.veevanitro.com/api/v1/users/tokens/renew
+
+        if self.accessToken is None or self.refreshToken is None:
+            raise Exception("You must authenticate first before executing this method")
+
+        url = f"{self.serverUrl}/api/v1/users/tokens/renew"
+        
+        headers = {
+            "refreshToken": self.refreshToken,
+        }
+        response = requests.post(url, headers=headers)
+        
+        # response_json = self._handle_response(response)
+        
+        # if 'content' in response_json and 'token' in response_json['content']:
+        #     self.accessToken = response_json['content']['token']
+            
+        return response
+    
+    def download_cli(self) -> bytes:
+        """
+        Downloads the Command-Line Interface (CLI) zip file from the server.
+
+        Raises:
+            Exception: If the user is not authenticated.
+            Exception: If the server returns an unauthorized error.
+            Exception: If any other server-side error occurs.
+
+        Returns:
+            bytes: The raw content of the downloaded ZIP file.
+        """
+
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+
+        url = f"{self.serverUrl}/api/v1/download/cli"
+        
+        headers = {
+            "Authorization": self.accessToken
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        if response.status_code == 200:
+            # get the zip file content from the response
+            data = getattr(response,'content', '')
+
+            # define the filename
+            filename = "cdw-cli"
+
+            # save the data to the file
+            with open(filename, "wb") as f:
+                f.write(data)
+
+            print(f"ZIP file saved as {filename} in {os.getcwd()}")
+            return data
+        
+        elif response.status_code == 401:
+            if 'error' in response.json().keys():
+                raise Exception(f"Unauthorized: {response.json()['error']}")
+            else:
+                raise Exception(f"Request failed. Response from server: {response.json()}")
+        else:
+            raise Exception(f"Request failed. Response from server: {response.json()}")
+
+    def download_sdk(self) -> bytes:
+        """
+        Downloads the Software Development Kit (SDK) zip file from the server.
+
+        Raises:
+            Exception: If the user is not authenticated.
+            Exception: If the server returns an unauthorized error.
+            Exception: If any other server-side error occurs.
+
+        Returns:
+            bytes: The raw content of the downloaded ZIP file.
+        """
+
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+
+        url = f"{self.serverUrl}/api/v1/download/sdk"
+        
+        headers = {
+            "Authorization": self.accessToken
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        if response.status_code == 200:
+            # get the zip file content from the response
+            data = getattr(response, 'content', '')
+
+            # define the filename
+            filename = "nitro_sdk_latest.whl"
+
+            # save the data to the file
+            with open(filename, "wb") as f:
+                f.write(data)
+
+            print(f"ZIP file saved as {filename} in {os.getcwd()}")
+            return data
+        
+        elif response.status_code == 401:
+            if 'error' in response.json().keys():
+                raise Exception(f"Unauthorized: {response.json()['error']}")
+            else:
+                raise Exception(f"Request failed. Response from server: {response.json()}")
+        else:
+            raise Exception(f"Request failed. Response from server: {response.json()}")
+
+
+        return response
+    
+    def get_cdw_api_token(self):
+        """
+        Retrieves the CDW API token using the authenticated session.
+        
+        Returns:
+            dict: The response JSON containing the CDW API token.
+            
+        Raises:
+            Exception: If the request for the CDW API token fails.
+            Exception: If not authenticated.
+        """
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/api/v1/users/tokens/issue"
+        
+        headers = {
+            "Authorization": self.accessToken
+        }
+        
+        response = requests.post(url, headers=headers)
+        
+        respone_json = self._handle_response(response)
+        
+        if 'content' in respone_json and 'token' in respone_json['content']:
+            self.cdwAPItoken = respone_json['content']['token']
+        
+        return respone_json
+            
+    def get_tenant(self) -> dict:
+        """
+        Retrieves tenant information from the Veeva Nitro API.
+        
+        Returns:
+            dict: The response JSON containing tenant details.
+            
+        Raises:
+            Exception: If the request for tenant information fails.
+            Exception: If not authenticated.
+        """
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/api/v1/admin/tenant"
+        headers = {
+            "Authorization": self.accessToken,
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.tenant = response_json['content']
+        
+        return response_json
+
+    def get_configuration(self) -> dict:
+        """
+        Retrieves cluster configuration from the Veeva Nitro API.
+        
+        Returns:
+            dict: The response JSON containing cluster configuration details.
+            
+        Raises:
+            Exception: If the request for cluster configuration fails.
+            Exception: If not authenticated.
+        """
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/api/v1/admin/cluster/configuration"
+        headers = {
+            "Authorization": self.accessToken
+        }
+        
+        response = requests.get(url, headers=headers)
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.configuration = response_json['content']
+        
+        return response_json
+
+    def get_redshift_dbs(self, Dwinstancename = None) -> dict:
+        """
+        Retrieves Redshift database configuration from the Veeva Nitro API.
+
+        Args:
+            Dwinstancename (str, optional): The name of the instance you're working with. Defaults to the currently set working instance.
+
+        Returns:
+            dict: The response JSON containing Redshift database configuration.
+
+        Raises:
+            Exception: If the request for Redshift database configuration fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+
+        if self.workingInstance is None:
+            raise Exception("You must provide an instance name or set the working instance before executing this method")
+
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        # Building the request
+        url = f"{self.serverUrl}/mds/api/v1/configuration?view=condensed"
+        headers = {
+            "Authorization": self.accessToken,
+            "Dwinstancename": self.workingInstance,
+            "Tenantname": self.tenantName
+        }
+        
+        # Making the GET request
+        response = requests.get(url, headers=headers)
+        response_json = self._handle_response(response)
+        
+        # Save the response content under the Dwinstancename key
+        if 'content' in response_json:
+            self.redshiftDBdetails[self.workingInstance] = response_json['content']
+        
+        if 'content' in response_json and 'instanceDatabase' in response_json['content'] and 'database' in response_json['content']['instanceDatabase']:
+            self.workingDB = response_json['content']['instanceDatabase']['database']
+
+        # Return the response JSON containing Redshift database configuration
+        return response_json
+    
+    def get_users(self) -> dict:
+        """
+        Retrieves user information from the Veeva Nitro API.
+        
+        Returns:
+            dict: The response JSON containing user details.
+            
+        Raises:
+            Exception: If the request for user information fails.
+            Exception: If not authenticated.
+        """
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/api/v1/admin/users"
+        headers = {
+            "Authorization": self.accessToken
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.users = response_json['content']
+        
+        return response_json
+
+    # Question: Where can I find the app parameter values?
+    def get_application_roles(self, app: str = "APP_SERVER") -> dict:
+        """
+        Retrieves application roles from the Veeva Nitro API.
+        
+        Args:
+            app (str, optional): The application type. Defaults to "APP_SERVER".
+            
+        Returns:
+            dict: The response JSON containing application roles.
+            
+        Raises:
+            Exception: If the request for application roles fails.
+            Exception: If not authenticated.
+        """
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/api/v1/admin/users/application-roles?app={app}"
+        headers = {
+            "Authorization": self.accessToken
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.applicationRoles = response_json['content']
+        
+        return response_json
+
+
+    def get_rules(self, Dwinstancename = None) -> dict:
+        """
+        Retrieves rule information from the Veeva Nitro API.
+        
+        Returns:
+            dict: The response JSON containing rule details.
+            
+        Raises:
+            Exception: If the request for rule information fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+        
+        if self.workingInstance is None:
+            raise Exception("You must provide an instance name or set the working instance before executing this method")
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/mds/api/v1/rules"
+        headers = {
+            "Authorization": self.accessToken,
+            "Dwinstancename": self.workingInstance,
+            "Tenantname": self.tenantName
+        }
+        
+        response = requests.get(url, headers=headers)
+        response_json = self._handle_response(response)
+        
+        # Save the response content under the Dwinstancename key
+        if 'content' in response_json:
+            self.rules[self.workingInstance] = response_json['content']
+        
+        return response_json
+
+    def get_groups(self, Dwinstancename = None) -> dict:
+        """
+        Retrieves rule group information from the Veeva Nitro API.
+        
+        Returns:
+            dict: The response JSON containing rule group details.
+            
+        Raises:
+            Exception: If the request for rule group information fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+        
+        if self.workingInstance is None:
+            raise Exception("You must provide an instance name or set the working instance before executing this method")
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/mds/api/v1/rule/groups"
+        headers = {
+            "Authorization": self.accessToken,
+            "Dwinstancename": self.workingInstance,
+            "Tenantname": self.tenantName
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.groups[self.workingInstance] = response_json['content']
+        
+        return response_json
+
+    def get_jobs(self, Dwinstancename = None, view: str = "condensed") -> dict:
+        """
+        Retrieves job information from the Veeva Nitro API.
+        
+        Args:
+            view (str, optional): The view type for the jobs. Defaults to "condensed".
+            
+        Returns:
+            dict: The response JSON containing job details.
+            
+        Raises:
+            Exception: If the request for job information fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+        
+        if self.workingInstance is None:
+            raise Exception("You must provide an instance name or set the working instance before executing this method")
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/mds/api/v1/jobs?view={view}"
+        headers = {
+            "Authorization": self.accessToken,
+            "Dwinstancename": self.workingInstance,
+            "Tenantname": self.tenantName
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.jobs[self.workingInstance] = response_json['content']
+        
+        return response_json
+
+    def get_connectors(self, Dwinstancename = None, internalOnly: bool = False, ) -> dict:
+        """
+        Retrieves connector information from the Veeva Nitro API.
+        
+        Args:
+            internalOnly (bool, optional): Filter for internal connectors. Defaults to False.
+            
+        Returns:
+            dict: The response JSON containing connector details.
+            
+        Raises:
+            Exception: If the request for connectors fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+        
+        if self.workingInstance is None:
+            raise Exception("You must provide an instance name or set the working instance before executing this method")
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/mds/api/v1/connectors?internalOnly={internalOnly}"
+        headers = {
+            "Authorization": self.accessToken,
+            "Dwinstancename": self.workingInstance,
+            "Tenantname": self.tenantName
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.connectors[self.workingInstance] = response_json['content']
+        
+        return response_json
+
+    def get_cluster_details(self, Dwinstancename = None) -> dict:
+        """
+        Retrieves cluster details from the Veeva Nitro API.
+        
+        Returns:
+            dict: The response JSON containing cluster details.
+            
+        Raises:
+            Exception: If the request for cluster details fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+        
+        if self.workingInstance is None:
+            raise Exception("You must provide an instance name or set the working instance before executing this method")
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/api/v1/admin/cluster-details"
+        headers = {
+            "Authorization": self.accessToken,
+            "Dwinstancename": self.workingInstance,
+            "Tenantname": self.tenantName
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.clusterDetails[self.workingInstance] = response_json['content']
+        
+        return response_json
+
+    def get_job_results(self, Dwinstancename: str = None, size: int = 1000, jobId: str = None) -> dict:
+        """
+        Retrieves job results from the Veeva Nitro API.
+        
+        Args:
+            instanceName (str): The name of the instance.
+            size (int, optional): The number of results to retrieve. Defaults to 1000.
+            jobId (str, optional): The ID of the job. Defaults to None.
+            
+        Returns:
+            dict: The response JSON containing job results.
+            
+        Raises:
+            Exception: If the request for job results fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+        
+        if self.workingInstance is None:
+            raise Exception("You must provide an instance name or set the working instance before executing this method")
+        
+        # Check if authentication has taken place
+        if self.accessToken is None:
+            raise Exception("You must authenticate first before executing this method")
+        
+        url = f"{self.serverUrl}/api/v1/admin/jobs/results?instanceName={self.workingInstance}&size={size}&jobId={jobId}"
+        headers = {
+            "Authorization": self.accessToken
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        response_json = self._handle_response(response)
+        
+        if 'content' in response_json:
+            self.jobResults[self.workingInstance] = response_json['content']
+        
+        return response_json
+    
+
+    ##############################################################################################################
+    # Workspace methods
+    ##############################################################################################################
+    def set_redshift_user(self, nitroUserName: str = None, redshiftUserName: str = None):
+        """
+        Sets the current Redshift user based on either nitroUserName, redshiftUserName or self.nitroUserName.
+        
+        Args:
+            nitroUserName (str, optional): Nitro username to search for and set the corresponding Redshift user.
+            redshiftUserName (str, optional): Directly provide the Redshift username to set.
+            
+        Raises:
+            ValueError: If both nitroUserName and redshiftUserName are provided.
+            Exception: If the Redshift username cannot be found.
+        """
+        
+        # If both parameters are provided, raise a value error.
+        if nitroUserName and redshiftUserName:
+            raise ValueError("Provide either nitroUserName or redshiftUserName, not both.")
+
+        # If self.users is None, attempt to populate it using the get_users method.
+        if self.users is None:
+            self.get_users()
+
+        # Check if self.users is still None after trying to populate it.
+        if self.users is None:
+            raise Exception("Unable to fetch users. Ensure self.get_users() is properly implemented and data source is available.")
+        
+        # Use self.nitroUserName if no parameters are provided
+        if not nitroUserName and not redshiftUserName:
+            nitroUserName = self.nitroUserName
+
+        if nitroUserName:
+            for user in self.users:
+                if user['username'] == nitroUserName and 'redshiftUserName' in user:
+                    self.workingRedshiftUser = user['redshiftUserName']
+                    return
+            raise Exception(f"Redshift user not found for Nitro username {nitroUserName}")
+        
+        if redshiftUserName:
+            for user in self.users:
+                if user.get('redshiftUserName') == redshiftUserName:
+                    self.workingRedshiftUser = redshiftUserName
+                    return
+            raise Exception("RedshiftUserName not found.")
+      
+    def get_workspaces(self, redshiftUserName: str = None, Dwinstancename: str = None):
+        """
+        Fetches a list of user workspaces for a given Redshift user.
+
+        This function attempts to get workspaces for a specified Redshift user. If no Redshift user is provided, 
+        it checks and uses the workingRedshiftUser attribute. If the attribute is also not set, it attempts to set it 
+        using the set_redshift_user() method. In addition, if a data warehouse instance name (Dwinstancename) is provided, 
+        it updates the working instance to the given name. If not, it uses the currently set working instance.
+        
+        Args:
+            redshiftUserName (str, optional): Redshift username for which workspaces are to be fetched. Defaults to None.
+            Dwinstancename (str, optional): Data warehouse instance name to set as the working instance. Defaults to the currently set instance.
+        
+        Returns:
+            dict: JSON response from the server containing user workspace information.
+            
+        Raises:
+            Exception: 
+                - If there's an issue fetching the workspaces.
+                - If RedshiftUserName isn't provided and cannot be set via set_redshift_user method.
+                - If instance name isn't provided and hasn't been set via authenticate method.
+        """
+
+        # Update self.workingRedshiftUser if redshiftUserName is provided
+        if redshiftUserName:
+            self.workingRedshiftUser = redshiftUserName
+        elif self.workingRedshiftUser is None:
+            self.set_redshift_user()
+            
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+
+
+        # Check if self.workingRedshiftUser is set after all checks and assignments
+        if self.workingRedshiftUser is None:
+            raise Exception("RedshiftUserName must be provided or set via set_redshift_user method.")
+    
+        # Check if self.workingInstance is set after all checks and assignments
+        if self.workingInstance is None:
+            raise Exception("Instance name must be provided or set via authenticate method.")
+
+        
+        headers = {
+            'Tenantname': self.tenantName,
+            'Dwinstancename': self.workingInstance,
+            'Connectorname': 'global__v', # Currently hard-coded
+            "Authorization": self.accessToken
+        }
+        
+        
+        url = f"{self.serverUrl}/mds/api/v1/workspaces"
+        
+        response = requests.get(url, headers=headers)
+        response_json = self._handle_response(response)
+        
+        # Save the response in self.workspaces using the workingInstance as the key
+        if 'content' in response_json:
+            self.workspaces[self.workingInstance] = response_json['content']
+    
+        # Filter the content if redshiftUserName is provided
+        if redshiftUserName and 'content' in response_json:
+            filtered_content = [entry for entry in response_json['content'] if entry.get('owner') == redshiftUserName]
+            response_json['content'] = filtered_content
+
+        return response_json
+
+    def connect_to_user_workspace(self, workspaceName: str = None, Dwinstancename: str = None, redshiftUserName: str = None):
+        """
+        Connects to a specified user workspace.
+        
+        Args:
+            workspaceName (str): The name of the workspace to connect to.
+            
+        Returns:
+            dict: The workspace details.
+            
+        Raises:
+            Exception: If there's an issue connecting to the workspace.
+        """
+        
+        
+        if self.workspaces is None:
+            self.get_workspaces(Dwinstancename = Dwinstancename, redshiftUserName = redshiftUserName)
+            
+        if redshiftUserName:
+            self.workingRedshiftUser = redshiftUserName
+        elif self.workingRedshiftUser is None:
+            self.set_redshift_user()
+        
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+        
+        if workspaceName is None and self.workingWorkspaceName is None:
+            raise Exception("You must provide a workspace name or set the working workspace before executing this method")
+        
+        if workspaceName is not None:
+            self.workingWorkspaceName = workspaceName
+        else:
+            workspaceName = self.workingWorkspaceName
+        
+        
+        print(f"Connecting to workspace {workspaceName} for Redshift user {self.workingRedshiftUser} on instance {self.workingInstance}")
+        headers = {
+            'tenantName': self.tenantName,
+            'dwInstanceName': self.workingInstance,
+            'connectorName': 'global__v',
+            "Authorization": self.accessToken
+        }
+        
+        params = {'redshiftUser': self.workingRedshiftUser}
+        url = f"{self.serverUrl}/api/v1/admin/workspaces/{workspaceName}/session-token"
+        
+        response = requests.get(url, headers=headers, params=params)
+        response_json = self._handle_response(response)
+        
+        
+        # Save the response in self.workspaceConnections using the { self.workingInstance: { workspaceName: { self.workingRedshiftUser: response_json } } } as the key
+        if 'content' in response_json:
+            if self.workingInstance not in self.workspaceConnections:
+                self.workspaceConnections[self.workingInstance] = {}
+                
+            if workspaceName not in self.workspaceConnections[self.workingInstance]:
+                self.workspaceConnections[self.workingInstance][workspaceName] = {}
+                
+            self.workspaceConnections[self.workingInstance][workspaceName][self.workingRedshiftUser] = response_json['content']
+            
+        self.workingWorkspaceConnection = response_json['content']
+        
+        return response_json
+    
+    ##############################################################################################################
+    # S3 client methods
+    ##############################################################################################################
+    
+    def get_s3_client(self, workspaceName: str = None, Dwinstancename: str = None, redshiftUserName: str = None):
+        # Check or instantiate necessary instance variables same as connect_to_user_workspace
+        if self.workspaces is None:
+            self.get_workspaces(Dwinstancename=Dwinstancename, redshiftUserName=redshiftUserName)
+
+        if redshiftUserName:
+            self.workingRedshiftUser = redshiftUserName
+        elif self.workingRedshiftUser is None:
+            self.set_redshift_user()
+
+        self.workingInstance = Dwinstancename if Dwinstancename is not None else self.workingInstance
+
+        if workspaceName is None and self.workingWorkspaceName is None:
+            raise Exception("You must provide a workspace name or set the working workspace before executing this method")
+
+        if workspaceName is not None:
+            self.workingWorkspaceName = workspaceName
+
+        # Check if workspaceConnections exists. If not, connect to user workspace and reattempt
+        if not hasattr(self, 'workspaceConnections') or self.workingInstance not in self.workspaceConnections or \
+                self.workingWorkspaceName not in self.workspaceConnections[self.workingInstance] or \
+                self.workingRedshiftUser not in self.workspaceConnections[self.workingInstance][self.workingWorkspaceName]:
+            print(f"Credentials not found. Connecting to workspace...")
+            self.connect_to_user_workspace(workspaceName=self.workingWorkspaceName, Dwinstancename=self.workingInstance,
+                                        redshiftUserName=self.workingRedshiftUser)
+
+        # Try to get credentials again after connecting
+        try:
+            credentials = self.workspaceConnections[self.workingInstance][self.workingWorkspaceName][self.workingRedshiftUser]['credentials']
+        except KeyError:
+            raise Exception("Credentials not found for the provided combination of Dwinstancename, workspaceName, and redshiftUserName")
+
+        # Check expiration
+        expiration_datetime = datetime.strptime(credentials['expiration'], '%Y-%m-%dT%H:%M:%S.%f+00:00').replace(tzinfo=timezone.utc)
+        if expiration_datetime <= datetime.now(timezone.utc):
+            raise Exception("The token has expired!")
+
+        # Create and save the S3 client
+        session = boto3.Session(
+            aws_access_key_id=credentials['accessKeyId'],
+            aws_secret_access_key=credentials['secretAccessKey'],
+            aws_session_token=credentials['sessionToken']
+        )
+        s3_client = session.client('s3')
+
+        # Saving s3 client in the desired format
+        if not hasattr(self, 's3_clients'):
+            self.s3_clients = {}
+
+        if self.workingInstance not in self.s3_clients:
+            self.s3_clients[self.workingInstance] = {}
+
+        if self.workingWorkspaceName not in self.s3_clients[self.workingInstance]:
+            self.s3_clients[self.workingInstance][self.workingWorkspaceName] = {}
+
+        self.s3_clients[self.workingInstance][self.workingWorkspaceName][self.workingRedshiftUser] = s3_client
+
+        self.workingS3Client = s3_client
+        
+        self.workingWorkspaceConnection = self.workspaceConnections[self.workingInstance][self.workingWorkspaceName][self.workingRedshiftUser]
+        
+        s3_url = urlparse(self.workspaceConnections[self.workingInstance][self.workingWorkspaceName][self.workingRedshiftUser]['s3ObjectKey'], allow_fragments=False)
+        
+        self.workingS3Bucket = s3_url.netloc
+        self.workingS3PathPrefix = s3_url.path.lstrip('/')
+        
+        return s3_client
+
+    def list_user_workspace(self):
+        """
+        Lists the files in the user's workspace on S3 based on the specified prefix.
+        
+        Args:
+            parameters (dict, optional): Additional parameters for filtering the files. Defaults to None.
+
+        Returns:
+            dict: A dictionary mapping the file keys to their respective sizes.
+        """
+        objects = dict()
+        try:
+            paginator = self.workingS3Client.get_paginator('list_objects_v2')
+            pages = paginator.paginate(Bucket=self.workingS3Bucket, Prefix=self.workingS3PathPrefix)
+
+            for page in pages:
+                if 'Contents' in page:
+                    for obj in page['Contents']:
+                        objKey = obj['Key']
+                        objSize = obj['Size']
+                        if objKey:
+                            temp = objKey.replace(self.workingS3PathPrefix, '')
+                            objects[temp] = objSize
+                                
+        except Exception as ex:
+            print('list-user-workspace error :', str(ex))
+
+        return objects
+
+
+    def get_file_from_workspace(self, key, filePath, callback=None):
+        """
+        Downloads a file from the user's workspace on S3.
+
+        Args:
+            key (str): The key of the file to download.
+            filePath (str): The local path to save the downloaded file.
+            callback (function, optional): A function to track download progress. Defaults to `display_progress`.
+
+        Returns:
+            File: The downloaded file object.
+
+        Raises:
+            Exception: If there's any error during the file download process.
+        """
+        s3Key = self.workingS3PathPrefix + key
+        meta_data = self.workingS3Client.head_object(Bucket=self.workingS3Bucket, Key=s3Key)
+        total_length = int(meta_data.get('ContentLength', 0))
+
+        if callback is None:
+            callback = display_progress(total_length)
+
+        with open(filePath, 'wb') as localFile:
+            self.workingS3Client.download_fileobj(Bucket=self.workingS3Bucket, Key=s3Key, Fileobj=localFile, Callback=callback)
+            sys.stdout.write("\n")
+            sys.stdout.flush()
+        
+        print(f"Downloaded {s3Key} to {filePath}")
+        return None
+
+    def upload_file_to_workspace(self, filePath, key, callback=None):
+        """
+        Uploads a file to the user's workspace on S3.
+
+        Args:
+            filePath (str): The local path of the file to be uploaded.
+            key (str): The key to save the file under in S3.
+            callback (function, optional): A function to track upload progress. Defaults to `display_progress`.
+
+        Returns:
+            str: "Success" if the upload completes without errors, "Failed" otherwise.
+
+        Raises:
+            Exception: If there's any error during the file upload process.
+        """
+        total = os.stat(filePath).st_size
+        s3Key = self.workingS3PathPrefix + key
+        
+        if callback is None:
+            callback = display_progress(total)
+
+        with open(filePath, 'rb') as localFile:
+            self.workingS3Client.upload_fileobj(
+                Bucket=self.workingS3Bucket, 
+                Key=s3Key, 
+                Fileobj=localFile, 
+                Callback=callback
+            )
+            sys.stdout.write("\n")
+            sys.stdout.flush()
+            print(f"Uploaded {filePath} to {s3Key}")
+            return None
+        # Catching an exception and re-raising it will allow the caller to handle the exception as needed.
+        raise Exception("Error uploading file to workspace.")
+
+    def delete_file_from_workspace(self, *keys) -> dict:
+        """
+        Deletes one or more files from the user's workspace on S3.
+        
+        Args:
+            *keys (str): The keys of the files to delete.
+        """
+        try:
+            for key in keys:
+                s3Key = self.workingS3PathPrefix + key
+                return self.workingS3Client.delete_object(Bucket=self.workingS3Bucket, Key=s3Key)
+        except Exception as ex:
+            raise Exception(f"Error deleting {key} from workspace: {str(ex)}")
+
+
+    def check_key_file_exists(self, key) -> bool:
+        """
+        Checks if a file exists in the user's workspace on S3.
+        
+        Args:
+            key (str): The key of the file to check.
+
+        Returns:
+            bool: True if the file exists, False otherwise.
+        """
+        try:
+            self.workingS3Client.head_object(Bucket=self.workingS3Bucket, Key=self.workingS3PathPrefix + key)
+        except ClientError as e:
+            print("Key file " + key + " does not exist on s3: ", str(e))
+            return False
+
+        return True
+
+    ##############################################################################################################
+    # Redshift Methods
+    ##############################################################################################################
+    def get_db_connection(self):
+        """
+        Establishes and returns a database connection using the psycopg2 library.
+
+        This method checks the necessary attributes of the instance to form a connection string. 
+        The attributes checked are:
+        - workingDB: The name of the working database.
+        - configuration: A dictionary containing the cluster's endpoint. The key to check is 'clusterEndpoint'.
+        - redshiftPort: The port to connect to on the Redshift cluster.
+        - workingRedshiftUser: The Redshift username.
+        - workingRedshiftPwd: The Redshift password.
+
+        If any of the above attributes are empty or None, a ValueError is raised.
+
+        :return: A psycopg2 connection object established using the attributes provided.
+        :raises ValueError: If any necessary attributes are empty or None.
+        """
+    
+        if not self.workingDB:
+            raise ValueError("workingDB attribute is empty or None!")
+
+        if not self.configuration or 'clusterEndpoint' not in self.configuration or not self.configuration['clusterEndpoint']:
+            raise ValueError("clusterEndpoint in configuration is empty or None!")
+
+        if not self.redshiftPort:
+            raise ValueError("redshiftPort attribute is empty or None!")
+
+        if not self.workingRedshiftUser:
+            raise ValueError("workingRedshiftUser attribute is empty or None!")
+
+        if not self.workingRedshiftPwd:
+            raise ValueError("workingRedshiftPwd attribute is empty or None!")
+        
+        connectionString = ("dbname={dbname} host={host} port={port} "
+                        "user={userid} password={password}").format(
+                            dbname=self.workingDB,
+                            host=self.configuration['clusterEndpoint'],
+                            port=self.redshiftPort,
+                            userid=self.workingRedshiftUser,
+                            password=self.workingRedshiftPwd
+                        )
+        
+        connection = psycopg2.connect(connectionString)
+        connection.autocommit = True
+        
+        self.workingDBConnection = connection
+        
+        return connection
+    
+    def get_db_cursor(self, connection: psycopg2.extensions.connection = None):
+        """
+        Creates a database cursor using the given connection.
+
+        :param connection: A psycopg2 connection object to be used for creating the cursor.
+        :return: A psycopg2 cursor object.
+        :raises ValueError: If no connection is provided and workingDBConnection attribute is empty or None.
+        """
+        if connection is None and self.workingDBConnection is None:
+            raise ValueError("No connection provided and workingDBConnection attribute is empty or None!")
+        elif connection is None:
+            connection = self.workingDBConnection
+        
+        cursor = connection.cursor(cursor_factory=RealDictCursor)
+        self.workingDBCursor = cursor
+        
+        return cursor
+    
+    def close_db_connection(self, connection: psycopg2.extensions.connection = None):
+        """
+        Closes the given database connection.
+
+        :param connection: A psycopg2 connection object to be closed.
+        """
+        if connection is None and self.workingDBConnection is None:
+            raise ValueError("No connection provided and workingDBConnection attribute is empty or None!")
+        elif connection is None:
+            connection = self.workingDBConnection
+        
+        connection.close()
+    
+
+    def get_sqlalchemy_engine(self):
+        """
+        Establishes and returns a database connection using SQLAlchemy with the psycopg2 driver.
+
+        This method checks the necessary attributes of the instance to form a connection string. 
+        The attributes checked are:
+        - workingDB: The name of the working database.
+        - configuration: A dictionary containing the cluster's endpoint. The key to check is 'clusterEndpoint'.
+        - redshiftPort: The port to connect to on the Redshift cluster.
+        - workingRedshiftUser: The Redshift username.
+        - workingRedshiftPwd: The Redshift password.
+
+        If any of the above attributes are empty or None, a ValueError is raised.
+
+        :return: A SQLAlchemy engine object established using the attributes provided.
+        :raises ValueError: If any necessary attributes are empty or None.
+        """
+
+        if not self.workingDB:
+            raise ValueError("workingDB attribute is empty or None!")
+
+        if not self.configuration or 'clusterEndpoint' not in self.configuration or not self.configuration['clusterEndpoint']:
+            raise ValueError("clusterEndpoint in configuration is empty or None!")
+
+        if not self.redshiftPort:
+            raise ValueError("redshiftPort attribute is empty or None!")
+
+        if not self.workingRedshiftUser:
+            raise ValueError("workingRedshiftUser attribute is empty or None!")
+
+        if not self.workingRedshiftPwd:
+            raise ValueError("workingRedshiftPwd attribute is empty or None!")
+
+        connection_string = ("postgresql+psycopg2://{userid}:{password}@{host}:{port}/{dbname}").format(
+            userid=quote_plus(self.workingRedshiftUser),
+            password=quote_plus(self.workingRedshiftPwd),
+            host=self.configuration['clusterEndpoint'],
+            port=self.redshiftPort,
+            dbname=self.workingDB
+        )
+
+        engine = create_engine(connection_string, echo=False)  # echo=False disables logging of SQL statements
+
+        # Store the engine for later use (optional)
+        self.workingSQLalchemyEngine = engine
+        
+        return engine
+    
+    ##############################################################################################################
+    # Async methods
+    ##############################################################################################################
+    
+    async def get_rules_from_instances(self, instances: List[str] = None):
+        """
+        Retrieves rule information from the Veeva Nitro API for a list of instances.
+        
+        Args:
+            instances (List[str], optional): A list of instance names. Defaults to None.
+            
+        Returns:
+            dict: The response JSON containing rule details.
+            
+        Raises:
+            Exception: If the request for rule information fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+
+        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
+        
+        # Create a list of async tasks
+        tasks = []
+        
+        async_get_rules = async_wrap(self.get_rules)
+        
+        rules_dict = {}
+        
+        for instance in instances:
+            tasks.append(async_get_rules(Dwinstancename=instance))
+        
+        # Execute the async tasks
+        responses = await asyncio.gather(*tasks)
+        
+        # Create a dictionary of the responses
+        for i, instance in enumerate(instances):
+            rules_dict[instance] = responses[i]['content']
+        
+        self.rules = rules_dict
+        
+        return rules_dict
+    
+    async def get_groups_from_instances(self, instances: List[str] = None):
+        """
+        Retrieves rule group information from the Veeva Nitro API for a list of instances.
+        
+        Args:
+            instances (List[str], optional): A list of instance names. Defaults to None.
+            
+        Returns:
+            dict: The response JSON containing rule group details.
+            
+        Raises:
+            Exception: If the request for rule group information fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
+        
+        # Create a list of async tasks
+        tasks = []
+        
+        async_get_groups = async_wrap(self.get_groups)
+        
+        groups_dict = {}
+        
+        for instance in instances:
+            tasks.append(async_get_groups(Dwinstancename=instance))
+        
+        # Execute the async tasks
+        responses = await asyncio.gather(*tasks)
+        
+        # Create a dictionary of the responses
+        for i, instance in enumerate(instances):
+            groups_dict[instance] = responses[i]['content']
+        
+        self.groups = groups_dict
+        
+        return groups_dict
+
+    async def get_jobs_from_instances(self, instances: List[str] = None, view: str = "condensed"):
+        """
+        Retrieves job information from the Veeva Nitro API for a list of instances.
+        
+        Args:
+            instances (List[str], optional): A list of instance names. Defaults to None.
+            view (str, optional): The view type for the jobs. Defaults to "condensed".
+            
+        Returns:
+            dict: The response JSON containing job details.
+            
+        Raises:
+            Exception: If the request for job information fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
+        
+        # Create a list of async tasks
+        tasks = []
+        
+        async_get_jobs = async_wrap(self.get_jobs)
+        
+        jobs_dict = {}
+        
+        for instance in instances:
+            tasks.append(async_get_jobs(Dwinstancename=instance, view=view))
+        
+        # Execute the async tasks
+        responses = await asyncio.gather(*tasks)
+        
+        # Create a dictionary of the responses
+        for i, instance in enumerate(instances):
+            jobs_dict[instance] = responses[i]['content']
+        
+        self.jobs = jobs_dict
+        
+        return jobs_dict
+    
+    async def get_connectors_from_instances(self, instances: List[str] = None, internalOnly: bool = False):
+        """
+        Retrieves connector information from the Veeva Nitro API for a list of instances.
+        
+        Args:
+            instances (List[str], optional): A list of instance names. Defaults to None.
+            internalOnly (bool, optional): Filter for internal connectors. Defaults to False.
+            
+        Returns:
+            dict: The response JSON containing connector details.
+            
+        Raises:
+            Exception: If the request for connectors fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
+        
+        # Create a list of async tasks
+        tasks = []
+        
+        async_get_connectors = async_wrap(self.get_connectors)
+        
+        connectors_dict = {}
+        
+        for instance in instances:
+            tasks.append(async_get_connectors(Dwinstancename=instance, internalOnly=internalOnly))
+        
+        # Execute the async tasks
+        responses = await asyncio.gather(*tasks)
+        
+        # Create a dictionary of the responses
+        for i, instance in enumerate(instances):
+            connectors_dict[instance] = responses[i]['content']
+        
+        self.connectors = connectors_dict
+        
+        return connectors_dict
+    
+    async def get_cluster_details_from_instances(self, instances: List[str] = None):
+        """
+        Retrieves cluster details from the Veeva Nitro API for a list of instances.
+        
+        Args:
+            instances (List[str], optional): A list of instance names. Defaults to None.
+            
+        Returns:
+            dict: The response JSON containing cluster details.
+            
+        Raises:
+            Exception: If the request for cluster details fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
+        
+        # Create a list of async tasks
+        tasks = []
+        
+        async_get_cluster_details = async_wrap(self.get_cluster_details)
+        
+        cluster_details_dict = {}
+        
+        for instance in instances:
+            tasks.append(async_get_cluster_details(Dwinstancename=instance))
+        
+        # Execute the async tasks
+        responses = await asyncio.gather(*tasks)
+        
+        # Create a dictionary of the responses
+        for i, instance in enumerate(instances):
+            cluster_details_dict[instance] = responses[i]['content']
+        
+        self.clusterDetails = cluster_details_dict
+        
+        return cluster_details_dict
+    
+    async def get_job_results_from_instances(self, instances: List[str] = None, size: int = 1000, jobId: str = None):
+        """
+        Retrieves job results from the Veeva Nitro API for a list of instances.
+        
+        Args:
+            instances (List[str], optional): A list of instance names. Defaults to None.
+            size (int, optional): The number of results to retrieve. Defaults to 1000.
+            jobId (str, optional): The ID of the job. Defaults to None.
+            
+        Returns:
+            dict: The response JSON containing job results.
+            
+        Raises:
+            Exception: If the request for job results fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
+        
+        # Create a list of async tasks
+        tasks = []
+        
+        async_get_job_results = async_wrap(self.get_job_results)
+        
+        job_results_dict = {}
+        
+        for instance in instances:
+            tasks.append(async_get_job_results(Dwinstancename=instance, size=size, jobId=jobId))
+        
+        # Execute the async tasks
+        responses = await asyncio.gather(*tasks)
+        
+        # Create a dictionary of the responses
+        for i, instance in enumerate(instances):
+            job_results_dict[instance] = responses[i]['content']
+        
+        self.jobResults = job_results_dict
+        
+        return job_results_dict
+
+    async def get_workspaces_from_instances(self, instances: List[str] = None):
+        """
+        Retrieves workspace information from the Veeva Nitro API for a list of instances.
+        
+        Args:
+            instances (List[str], optional): A list of instance names. Defaults to None.
+            
+        Returns:
+            dict: The response JSON containing workspace details.
+            
+        Raises:
+            Exception: If the request for workspaces fails.
+            Exception: If not authenticated.
+            Exception: If no instance name is provided or set as the working instance.
+        """
+        
+        instances = instances if instances is not None else [instance['instanceName'] for instance in self.instances]
+        
+        # Create a list of async tasks
+        tasks = []
+
+        async_get_workspaces = async_wrap(self.get_workspaces)
+        
+        for instance in instances:
+            tasks.append(async_get_workspaces(Dwinstancename=instance))
+        
+        # Execute the async tasks
+        responses = await asyncio.gather(*tasks)
+        
+        # Create a dictionary of the responses
+        workspaces_dict = {}
+        for i, instance in enumerate(instances):
+            workspaces_dict[instance] = responses[i]['content']
+        
+        self.workspaces = workspaces_dict
+        
+        return workspaces_dict
+    
+    async def get_all_tenant_details(self):
+        
+        tasks = [
+            self.get_rules_from_instances(),
+            self.get_groups_from_instances(),
+            self.get_jobs_from_instances(),
+            self.get_connectors_from_instances(),
+            self.get_cluster_details_from_instances(),
+            self.get_job_results_from_instances(),
+            self.get_workspaces_from_instances()
+        ]
+        
+        result_dict = {}
+        
+        result = await asyncio.gather(*tasks)
+        
+        for i, instance in enumerate(self.instances):
+            result_dict[instance['instanceName']] = {
+                'rules': result[0][instance['instanceName']],
+                'groups': result[1][instance['instanceName']],
+                'jobs': result[2][instance['instanceName']],
+                'connectors': result[3][instance['instanceName']],
+                'clusterDetails': result[4][instance['instanceName']],
+                'jobResults': result[5][instance['instanceName']],
+                'workspaces': result[6][instance['instanceName']]
+            }
+        
         return result_dict
```

### Comparing `veevatools-0.1.8/veevatools.egg-info/SOURCES.txt` & `veevatools-0.1.9/veevatools.egg-info/SOURCES.txt`

 * *Files identical despite different names*

### Comparing `veevatools-0.1.8/veevavault/veevavault.py` & `veevatools-0.1.9/veevavault/veevavault.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,12188 +1,12189 @@
-from sys import platform
-import requests
-import pandas as pd
-import os
-import json
-from urllib.parse import urlparse
-from typing import List
-import time
-from datetime import datetime
-
-# Async
-import asyncio
-from functools import wraps, partial
-from utilities.async_utils import async_wrap
-
-
-
-
-class Vv:
-    def __init__(self):
-        self.vaultURL = None
-        self.vaultUserName = None
-        self.vaultPassword = None
-        self.vaultConnection = None
-        self.sessionId = None
-        self.vaultId: str = None
-        self.vaultDNS: str = None
-        self.APIheaders = None
-        self.APIversionList = []
-        self.LatestAPIversion = 'v21.3'
-#         self.vaultObjects = None
-#         self.all_references_metadata = None
-#         self.all_references_names = None
-#         self.vault_references_all = None
-
-
-
-    def authenticate(self, 
-                     vaultURL=None, 
-                     vaultUserName=None, 
-                     vaultPassword=None, 
-                     sessionId=None,
-                     vaultId=None,
-                     if_return=False, *args, **kwargs):
-        """
-        TODO: Docs
-        """
-
-        self.LatestAPIversion = 'v21.3'
-        
-        self.vaultURL = self.vaultURL if vaultURL is None else vaultURL
-        self.vaultUserName = self.vaultUserName if vaultUserName is None else vaultUserName
-        self.vaultPassword = self.vaultPassword if vaultPassword is None else vaultPassword
-        self.sessionId = self.sessionId if sessionId is None else sessionId
-        self.vaultId = self.vaultId if vaultId is None else vaultId
-        
-        url_parse = urlparse(self.vaultURL)
-        if len(url_parse.scheme) == 0:
-            self.network_protocol = 'https'
-            if len(url_parse.path) > 0:
-                self.vaultDNS = url_parse.path
-                self.vaultURL = self.network_protocol + '://' + url_parse.path
-
-        if len(url_parse.scheme) > 0:
-            self.network_protocol = url_parse.scheme
-            if len(url_parse.netloc) > 0:
-                self.vaultDNS = url_parse.netloc
-                self.vaultURL = url_parse.scheme + '://' + url_parse.netloc
-
-        if (self.vaultURL is None) or (len(self.vaultURL) == 0):
-            raise Exception('vaultURL is required')
-        
-        if (self.vaultUserName and self.vaultPassword and self.vaultURL):
-            pload = {'username': self.vaultUserName,'password': self.vaultPassword}
-            self.vaultConnection = requests.post(f'{self.vaultURL}/api/{self.LatestAPIversion}/auth',data = pload)
-            if self.vaultConnection.json()['responseStatus'] == 'FAILURE':
-                exceptionMessage = ""
-                exceptionMessage += "Error: " + self.vaultConnection.json()['responseMessage'] + "\n"
-                exceptionMessage += self.vaultConnection.json()['errorType'] + "\n"
-                for error in self.vaultConnection.json()['errors']:
-                    exceptionMessage += error['type'] + ": " + error['message'] + "\n"
-                raise Exception(exceptionMessage)
-            
-            self.sessionId = self.vaultConnection.json()['sessionId']
-            self.vaultId = self.vaultConnection.json()['vaultId']
-            
-        self.APIheaders = {'Authorization': self.sessionId}
-        self.APIversionList = []
-        
-        # Error checking whether the required parameters are passed in
-        # The check happens here because this is where all the self assignments has completed
-        if (not (self.vaultId and self.sessionId and self.vaultURL)) and (not (self.vaultUserName and self.vaultPassword and  self.vaultURL)):
-            raise Exception("Please provide either vaultId, sessionId and vaultURL or vaultUserName, vaultPassword and vaultURL")
-        
-        for API in requests.get(self.vaultURL +'/api', headers=self.APIheaders).json()['values'].keys():
-            self.APIversionList.append(float(API.replace("v", "")))
-        self.APIversionList.sort()
-        self.LatestAPIversion = "v" + str(self.APIversionList[-1])
-        
-        if if_return:
-            return {'vaultURL':self.vaultURL, 
-                    'vaultUserName':self.vaultUserName, 
-                    'vaultPassword':self.vaultPassword, 
-                    'vaultConnection':self.vaultConnection, 
-                    'sessionId':self.sessionId, 
-                    'APIheaders':self.APIheaders, 
-                    'APIversionList':self.APIversionList, 
-                    'LatestAPIversion':self.LatestAPIversion}
-
-
-        
-    def query(self, query):
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/query"
-        
-        self.LatestAPIversion = 'v21.3'
-        
-        h = {
-        "X-VaultAPI-DescribeQuery":"true",
-        "Content-Type":"application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        params = {
-        "q":query
-        }
-
-        r = requests.get(url, headers=h, params=params).json()
-
-        if r['responseStatus'] == 'FAILURE':
-            raise Exception(r['errors'])
-        else:
-            r = pd.DataFrame(r['data'])
-        
-        return r
-    
-    def bulk_query(self, query):
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/query"
-        
-        self.LatestAPIversion = 'v21.3'
-        
-        h = {
-        "X-VaultAPI-DescribeQuery":"true",
-        "Content-Type":"application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        params = {
-        "q":query
-        }
-
-        r = requests.get(url, headers=h, params=params).json()
-
-        if r['responseStatus'] == 'FAILURE':
-            raise Exception(r['errors'])
-        
-        output = pd.DataFrame(r['data'])
-        
-        try:
-            next_page_url = r['responseDetails']['next_page'][:-4]
-            more_pages = True
-            page_count = 1000
-            
-            while more_pages:
-                r = pd.DataFrame(requests.get(f"{self.vaultURL}"+ next_page_url+ str(page_count), headers=h).json()['data'])
-                if len(r) == 0:
-                    more_pages = False
-                else:
-                    output = pd.concat([output,r],ignore_index=True).copy()
-                    page_count += 1000
-        except:
-            pass
-        
-        return output
-    
-    def object_field_metadata(self, object_api_name):
-        
-        self.LatestAPIversion = 'v21.3'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_api_name}"
-        r = requests.get(url, headers = self.APIheaders).json()['object']['fields']
-        return pd.DataFrame(r)
-    
-    def describe_objects(self):
-        
-        self.LatestAPIversion = 'v21.3'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects"
-        r = requests.get(url, headers = self.APIheaders).json()['objects']
-        return pd.DataFrame(r).sort_values(by='name')
-    
-    def retrieve_picklist_values(self, picklist_name):
-        """
-        Note: This is not the picklist field's API name, but the picklist (to which the picklist field looks up to) API name.
-        For example, the picklist field "specialty_1__v", "specialty_2__v" and "specialty_3__v" all look up to the picklist "specialty__v".
-        """
-        
-        self.LatestAPIversion = 'v21.3'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}"
-        r = requests.get(url, headers = self.APIheaders).json()
-        if r['responseStatus'] == 'SUCCESS':
-            if 'picklistValues' in r.keys():
-                result = pd.DataFrame(r['picklistValues'])
-                result['picklist_api_name'] = picklist_name
-                return result
-            else:
-                print(f"Warning: Picklist {picklist_name} does not contain any values.")
-                result = pd.DataFrame(columns=['name','label','picklist_api_name'])
-                return result
-        else:
-            raise Exception(r['errors'][0]['type'] + ": " + r['errors'][0]['message'])
-    
-    
-    ###############################################################
-    # Async Functions
-    ###############################################################
-    
-    async def async_bulk_retrieve_picklist_values(self, queries: List[str]) -> pd.DataFrame:
-        """_summary_: This function is the async version of the retrieve_picklist_values function. It is used to retrieve multiple picklist values in parallel.
-
-        Args:
-            queries (List[str]): List of picklist API names
-
-        Returns:
-            _type_: pd.DataFrame
-        """
-        async_queries = async_wrap(self.retrieve_picklist_values)
-        result_list = await asyncio.gather(*[async_queries(query) for query in queries])
-        result_length = 0
-        for result in result_list:
-            result_length += len(result)
-        
-        if result_length > 0:
-            result = pd.concat(result_list, ignore_index=True)
-        else:
-            result = pd.DataFrame(columns=['name','label','picklist_api_name'])
-            
-        return result
-    
-
-    ###############################################################
-    # Authentication
-    ###############################################################
-    
-    
-    # Untested
-    def authenticate_with_username_password(self, username, password, vaultDNS=None):
-        """
-        Authenticate your account using your Vault user name and password to obtain Vault Session ID.
-        
-        Documentation URL: https://developer.veevavault.com/api/23.2/#user-name-and-password
-        
-        :param username: Your Vault user name assigned by your administrator.
-        :param password: Your Vault password associated with your assigned Vault user name.
-        :param vaultDNS: The DNS of the Vault for which you want to generate a session. Optional.
-        :return: JSON response containing session ID and related details.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/auth"
-        
-        data = {
-            "username": username,
-            "password": password
-        }
-        
-        if vaultDNS:
-            data["vaultDNS"] = vaultDNS
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, data=data, headers=headers).json()
-        
-        if response.get('responseStatus') == "SUCCESS":
-            self.sessionId = response.get('sessionId')
-            self.vaultId = str(response.get('vaultId'))
-        
-        return response.json()
-
-    # Untested
-    def authenticate_with_oauth_openid_connect(self, oath_oidc_profile_id, vaultDNS=None, client_id=None, access_token=None):
-        """
-        Authenticate your account using OAuth 2.0 / Open ID Connect token to obtain a Vault Session ID.
-        API Documentation: https://developer.veevavault.com/api/23.2/#oauth-2-0-openid-connect
-
-        Parameters:
-        oath_oidc_profile_id (str): The ID of your OAuth2.0 / Open ID Connect profile.
-        vaultDNS (str, optional): The DNS of the Vault for which you want to generate a session. Defaults to None.
-        client_id (str, optional): The ID of the client application at the Authorization server. Defaults to None.
-        access_token (str): The access token for authorization.
-
-        Returns:
-        dict: Response from the API call
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        url = f"https://login.veevavault.com/auth/oauth/session/{oath_oidc_profile_id}"
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Authorization": f"Bearer {access_token}",
-            "Accept": "application/json"
-        }
-        
-        data = {}
-        if vaultDNS:
-            data["vaultDNS"] = vaultDNS
-        if client_id:
-            data["client_id"] = client_id
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        if response.status_code == 200:
-            self.sessionId = response.json().get('sessionId')
-            self.vaultId = str(response.json().get('vaultId'))
-        
-        return response.json()
-
-    # Untested
-    def retrieve_api_version(self):
-        """
-        Retrieve all supported versions of the Vault REST API.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-api-versions
-
-        Returns:
-        dict: Response from the API call containing the available API versions
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        if response.status_code == 200:
-            self.APIversionList = list(response.json().get('values').keys())
-        
-        return response.json()
-
-    # Untested
-    def authentication_type_discovery(self, username, client_id=None):
-        """
-        Discover the authentication type of a user. This API allows applications to dynamically adjust the login requirements per user, 
-        and support either username/password or OAuth2.0 / OpenID Connect authentication schemes.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-api-versions
-
-        Args:
-        username (str): The user’s Vault user name.
-        client_id (str, optional): The user’s mapped Authorization Server client_id. Applies only to the SSO and OAuth / OpenID Connect Profiles auth_type.
-
-        Returns:
-        dict: Response from the API call containing information about the user's authentication type and profiles (if any).
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"https://login.veevavault.com/auth/discovery"
-        params = {
-            "username": username,
-            "client_id": client_id
-        }
-        
-        headers = {
-            "Accept": "application/json",
-            "X-VaultAPI-AuthIncludeMsal": "true"
-        }
-        
-        response = requests.post(url, headers=headers, params=params)
-        return response.json()
-
-    # Untested
-    def authentication_type_discovery(self, username, client_id=None):
-        """
-        Discover the authentication type of a user. This API allows applications to dynamically adjust the login requirements per user, 
-        and support either username/password or OAuth2.0 / OpenID Connect authentication schemes.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-api-versions
-
-        Args:
-        username (str): The user’s Vault user name.
-        client_id (str, optional): The user’s mapped Authorization Server client_id. Applies only to the SSO and OAuth / OpenID Connect Profiles auth_type.
-
-        Returns:
-        dict: Response from the API call containing information about the user's authentication type and profiles (if any).
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"https://login.veevavault.com/auth/discovery"
-        params = {
-            "username": username,
-            "client_id": client_id
-        }
-        
-        headers = {
-            "Accept": "application/json",
-            "X-VaultAPI-AuthIncludeMsal": "true"
-        }
-        
-        response = requests.post(url, headers=headers, params=params)
-        return response.json()
-    
-    # Untested
-    def session_keep_alive(self):
-        """
-        Given an active sessionId, keep the session active by refreshing the session duration.
-        A Vault session remains active as long as some activity (either through the UI or API) happens within the 
-        maximum inactive session duration defined by your Vault Admin.
-        API Documentation: https://developer.veevavault.com/api/23.2/#session-keep-alive
-        
-        Returns:
-        dict: Response from the API call indicating the success status.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/keep-alive"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        response = requests.post(url, headers=headers)
-        return response.json()
-
-    # Untested
-    def validate_session_user(self, exclude_vault_membership=False, exclude_app_licensing=False):
-        """
-        Given a valid session ID, this request returns information for the currently authenticated user.
-        In case of an invalid session ID, it returns an INVALID_SESSION_ID error. This method acts similar to a whoami request.
-        API Documentation: https://developer.veevavault.com/api/23.2/#validate-session-user
-        
-        Parameters:
-        exclude_vault_membership (bool): If set to true, vault_membership fields are omitted from the response. Defaults to False.
-        exclude_app_licensing (bool): If set to true, app_licensing fields are omitted from the response. Defaults to False.
-        
-        Returns:
-        dict: Information of the currently authenticated user or an error message for invalid session ID.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/me"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        params = {
-            "exclude_vault_membership": exclude_vault_membership,
-            "exclude_app_licensing": exclude_app_licensing
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-    
-    # Untested
-    def salesforce_delegated_requests(self, sfdc_session_token, my_sfdc_domain, vault_endpoint, auth=None, ext_url=None, ext_ns=None):
-        """
-        Makes a request to the Vault API using Salesforce™ session token, following Salesforce™ Delegated Authentication procedure. 
-        Learn more at: https://developer.veevavault.com/api/23.2/#salesforce-trade-delegated-requests
-        
-        Prerequisites:
-        - A valid Vault user with a Security Policy enabled for Salesforce.com™ Delegated Authentication must exist.
-        - The trusted 18-character Salesforce.com™ Org ID must be provided.
-        - A user with a matching username in Salesforce.com™ Org ID must exist.
-        
-        Parameters:
-        sfdc_session_token (str): Salesforce™ session token.
-        my_sfdc_domain (str): Salesforce™ URL used to validate the session token.
-        vault_endpoint (str): The Vault endpoint to make the request to.
-        auth (str, optional): Salesforce™ session token, can be used as an alternative to setting in headers. Defaults to None.
-        ext_url (str, optional): Salesforce™ URL for validation, alternative to setting in headers. Defaults to None.
-        ext_ns (str, optional): Set to 'sfdc' to indicate Salesforce™ as the authorization provider, alternative to setting in headers. Defaults to None.
-        
-        Returns:
-        Response: API Response object.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/{vault_endpoint}"
-        
-        headers = {
-            "Authorization": sfdc_session_token,
-            "X-Auth-Provider": "sfdc",
-            "X-Auth-Host": my_sfdc_domain
-        }
-        
-        params = {
-            "auth": auth,
-            "ext_url": ext_url,
-            "ext_ns": ext_ns
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-    # Untested
-    def retrieve_delegations(self):
-        """
-        Retrieves the vaults where the currently authenticated user has delegate access. 
-        This information can be used to initiate a delegated session. Learn more about the feature at: 
-        https://developer.veevavault.com/api/23.2/#delegated-access
-        
-        Returns:
-        dict: A dictionary containing details of the vaults the user has delegate access to, if any.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/delegation/vaults"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-    ###############################################################
-    # Domain Information
-    ###############################################################
-
-    def retrieve_domain_information(self, include_application=True):
-        """
-        Allows domain admins to retrieve a list of all Vaults present in their domain. 
-        More details can be found at: 
-        https://developer.veevavault.com/api/23.2/#retrieve-domain-information
-
-        Args:
-        include_application (bool): If set to true, the response includes information about 
-        the Vault application type. Defaults to true.
-
-        Returns:
-        dict: A dictionary containing the response details with information about the domain and vaults.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/domain"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        params = {
-            "include_application": include_application
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-    def retrieve_domains(self):
-        """
-        Allows non-domain admins to retrieve a list of all their domains, including the domain of the current Vault. This data can be used as a valid domain value when creating a sandbox Vault. More details can be found at:
-        https://developer.veevavault.com/api/23.2/#retrieve-domains
-
-        Returns:
-        dict: A dictionary containing the response details with information about the domains.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/domains"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-    #######################################################
-    # Vault Query Language (VQL)
-    #######################################################
-
-    def submit_query(self, query, describe_query=True, record_properties=None):
-        """
-        Allows an application to invoke a query call where it passes in a Vault Query Language (VQL) statement to specify the object to query, the fields to retrieve, and any optional filters to narrow down the results. Further information can be found at:
-        https://developer.veevavault.com/api/23.2/#submitting-a-query
-        
-        Args:
-        query (str): A VQL statement specifying the object to query, the fields to retrieve, and any optional filters.
-        describe_query (bool, optional): Set to true to include static field metadata in the response for the data record. Defaults to True.
-        record_properties (str, optional): Optionally include the record properties object in the response. Possible values are "all", "hidden", "redacted", and "weblink". Defaults to None.
-
-        Returns:
-        dict: A dictionary containing the response from the query call including details about the fields retrieved and data records found.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/query"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "X-VaultAPI-DescribeQuery": str(describe_query).lower()
-        }
-        
-        if record_properties:
-            headers["X-VaultAPI-RecordProperties"] = record_properties
-        
-        data = {
-            "q": query
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        return response.json()
-
-
-
-    #######################################################
-    # Metadata Definition Language (MDL)
-    #######################################################
-
-    def execute_mdl_script(self, mdl_script):
-        """
-        Executes the given MDL script on a Vault. This synchronous endpoint allows various operations like CREATE, RECREATE, RENAME, ALTER, and DROP to be performed through MDL scripts. More details can be found at:
-        https://developer.veevavault.com/api/23.2/#execute-mdl-script
-        
-        Args:
-        mdl_script (str): The MDL script to be executed as a raw string. The script should start with one of the valid MDL commands (CREATE, RECREATE, RENAME, ALTER, DROP).
-        
-        Returns:
-        dict: A dictionary containing the response details from the execution of the MDL script.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/mdl/execute"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-
-        response = requests.post(url, headers=headers, data=mdl_script)
-        return response.json()
-
-    def execute_mdl_script_async(self, mdl_script):
-        """
-        Executes the given MDL script on a Vault asynchronously. This endpoint is used particularly when operating on 10,000+ high volume object records and performing certain operations as mentioned in the documentation. The method returns details of the initiated job which can be used to track the execution status. Refer to the documentation for more details:
-        https://developer.veevavault.com/api/23.2/#execute-mdl-script-asynchronously
-        
-        Args:
-        mdl_script (str): The MDL script to be executed as a raw string. The script should start with one of the valid MDL commands (CREATE, RECREATE, RENAME, ALTER, DROP).
-        
-        Returns:
-        dict: A dictionary containing the response details from the execution of the MDL script, including job_id and url to check the status of the execution.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/mdl/execute_async"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-
-        response = requests.post(url, headers=headers, data=mdl_script)
-        return response.json()
-
-
-    def retrieve_async_mdl_script_results(self, job_id):
-        """
-        Retrieves the results of an asynchronously executed MDL script. This method can be used to query Vault to determine the results of the MDL script execution request, including any errors. Refer to the documentation for more details:
-        https://developer.veevavault.com/api/23.2/#retrieve-asynchronous-mdl-script-results
-        
-        Args:
-        job_id (int): The job_id field value that was returned from the Execute MDL Script Asynchronously request.
-        
-        Returns:
-        dict: A dictionary containing the response details from the executed MDL script, which includes details of script execution and statement execution.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/mdl/execute_async/{job_id}/results"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-    def cancel_hvo_deployment(self, job_id):
-        """
-        Cancels a high volume object (HVO) deployment in the Vault. The deployment can only be cancelled if it has not begun execution. Refer to the documentation for more details:
-        https://developer.veevavault.com/api/23.2/#cancel-hvo-deployment
-        
-        Args:
-        job_id (int): The job ID obtained from the response of initiating an HVO deployment or executing an MDL script asynchronously.
-        
-        Returns:
-        dict: A dictionary containing the response details of the cancel request.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/mdl/execute_async/{job_id}/cancel"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.post(url, headers=headers)
-        return response.json()
-
-    def retrieve_all_component_metadata(self):
-        """
-        Retrieves the metadata of all component types in the Vault. The method returns a list of dictionaries with details for each component type in the currently authenticated Vault. Refer to the documentation for more details:
-        https://developer.veevavault.com/api/23.2/#retrieve-all-component-metadata
-        
-        Returns:
-        list: A list of dictionaries containing metadata details for each component type.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/components"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_component_type_metadata(self, component_type):
-        """
-        Retrieves the metadata of a specific component type in the Vault. The method returns a dictionary containing detailed metadata for the specified component type. Refer to the documentation for more details:
-        https://developer.veevavault.com/api/23.2/#retrieve-component-type-metadata
-        
-        Args:
-        component_type (str): The name of the component type (e.g., "Picklist", "Docfield", "Doctype", etc.).
-        
-        Returns:
-        dict: A dictionary containing detailed metadata for the specified component type.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/components/{component_type}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_component_record_collection(self, component_type):
-        """
-        Retrieves all records for a specific component type in the Vault. This method returns a list of dictionaries containing details for each record of the specified component type. Refer to the documentation for more details:
-        https://developer.veevavault.com/api/23.2/#component-record-collection
-        
-        Args:
-        component_type (str): The name of the component type (e.g., "Picklist", "Docfield", "Doctype", etc.).
-        
-        Returns:
-        list: A list of dictionaries containing details of each record for the specified component type.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/{component_type}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-    def retrieve_component_record(self, component_type_and_record_name):
-        """
-        Retrieves the metadata of a specific component record either in JSON or XML format. This method returns a dictionary containing detailed information about the specified component record. Refer to the documentation for more details:
-        https://developer.veevavault.com/api/23.2/#retrieve-component-record-xml-json
-        
-        Args:
-        component_type_and_record_name (str): The combination of the component type name and the record name to retrieve the metadata from. The format is {Componenttype}.{record_name}, for example, "Picklist.color__c".
-        
-        Returns:
-        dict: A dictionary containing details of the specified component record.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/{component_type_and_record_name}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-    def retrieve_component_record_mdl(self, component_type_and_record_name):
-        """
-        Retrieves metadata of a specific component record as MDL format. This method returns the RECREATE MDL statement which contains metadata for the specified component record. Refer to the documentation for more details:
-        https://developer.veevavault.com/api/23.2/#retrieve-component-record-mdl
-        
-        Args:
-        component_type_and_record_name (str): The combination of the component type name and the record name to retrieve metadata from, in the format {Componenttype}.{record_name}, for example, "Picklist.color__c".
-
-        Returns:
-        str: A RECREATE MDL statement containing metadata for the specified component record.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/mdl/components/{component_type_and_record_name}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.text
-
-    def upload_content_file(self, file_path):
-        """
-        Uploads a content file to be referenced by a component in the Vault. The file gets stored in a generic files staging area where it remains until referenced by a component. For more details, refer to the documentation: 
-        https://developer.veevavault.com/api/23.2/#upload-content-file
-        
-        Args:
-        file_path (str): The local file path of the content file to be uploaded. For example, 'C:\\Quote.pdf'.
-        
-        Returns:
-        dict: A dictionary containing details of the uploaded file including name, format, size, and sha1 checksum.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/mdl/files"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-        
-        with open(file_path, 'rb') as file:
-            files = {'file': file}
-            response = requests.post(url, headers=headers, files=files)
-            return response.json()
-
-
-    def retrieve_content_file(self, component_type_and_record_name):
-        """
-        Retrieves the content file of a specified component. For more information, refer to the API documentation: 
-        https://developer.veevavault.com/api/23.2/#retrieve-content-file
-        
-        Args:
-        component_type_and_record_name (str): The component type of the record followed by the name of the record from which to retrieve the content file. The format is {Componenttype}.{record_name}. For example, 'Formattedoutput.my_formatted_output__c'.
-        
-        Returns:
-        dict: A dictionary containing details of the retrieved content file including name, original name, format, size, and sha1 checksum.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/mdl/components/{component_type_and_record_name}/files"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-
-    #######################################################
-    # Documents
-    #######################################################
-
-    def retrieve_all_document_fields(self):
-        """
-        Retrieves all standard and custom document fields and field properties. For more information, refer to the API documentation: 
-        https://developer.veevavault.com/api/23.2/#retrieve-all-document-fields
-        
-        Returns:
-        dict: A dictionary containing all standard and custom document fields and their properties.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/v23.2/metadata/objects/documents/properties"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-    def retrieve_common_document_fields(self, doc_ids):
-        """
-        Retrieves all document fields and field properties which are common to (shared by) a specified set of documents. 
-        This allows you to determine which document fields are eligible for bulk update.
-        For more information, refer to the API documentation: 
-        https://developer.veevavault.com/api/23.2/#retrieve-common-document-fields
-
-        Parameters:
-        doc_ids (str): A comma-separated list of document id field values.
-
-        Returns:
-        dict: A dictionary containing all fields shared by the specified documents.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/v23.2/metadata/objects/documents/properties/find_common"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-
-        data = {
-            "docIds": doc_ids
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-        return response.json()
-
-    def retrieve_all_document_types(self):
-        """
-        Retrieves all document types present in the vault. These represent the top-level of the document type/subtype/classification hierarchy.
-        For more details, visit the API documentation:
-        https://developer.veevavault.com/api/23.2/#retrieve-all-document-types
-
-        Returns:
-        dict: A dictionary containing the details of all document types configured in the vault.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/v23.2/metadata/objects/documents/types"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_type(self, doc_type):
-        """
-        Retrieve all metadata from a specified document type, potentially including all of its subtypes.
-        For more details, visit the API documentation:
-        https://developer.veevavault.com/api/23.2/#retrieve-document-type
-
-        Args:
-        doc_type (str): The document type to retrieve metadata for.
-
-        Returns:
-        dict: A dictionary containing the metadata of the specified document type.
-        """
-
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/v23.2/metadata/objects/documents/types/{doc_type}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-
-    def retrieve_document_subtype(self, doc_type, doc_subtype):
-        """
-        Retrieve all metadata from a document subtype, including all of its classifications (when available).
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-subtype
-
-        :param doc_type: The document type, see Retrieve Document Types.
-        :param doc_subtype: The document subtype, see Retrieve Document Type.
-        :return: JSON response with metadata of the document subtype.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/types/{doc_type}/subtypes/{doc_subtype}"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_classification(self, doc_type, doc_subtype, classification):
-        """
-        Retrieve all metadata from a document classification.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-classification
-
-        :param doc_type: The document type, see Retrieve Document Types.
-        :param doc_subtype: The document subtype, see Retrieve Document Type.
-        :param classification: The document classification, see Retrieve Document Subtype.
-        :return: JSON response with metadata of the document classification.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/types/{doc_type}/subtypes/{doc_subtype}/classifications/{classification}"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_all_documents(self, named_filter=None, scope=None, versionscope=None, search=None, limit=None, sort=None, start=None):
-        """
-        Retrieve the latest version of documents and binders to which you have access.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-documents
-
-        :param named_filter: Filters the results based on the named filter option ('My Documents', 'Favorites', 'Recent Documents', 'Cart').
-        :param scope: Scope of the search ('contents' or 'all').
-        :param versionscope: Scope of the versions to retrieve ('all' for all versions, None for latest version).
-        :param search: Search keyword to filter documents based on searchable document fields.
-        :param limit: Limit the number of documents to display (default is up to 200 documents per page).
-        :param sort: Sort order for the documents (e.g., 'name__v DESC').
-        :param start: The starting record number (default is 0).
-        :return: JSON response with a list of documents and binders along with their fields and values.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        params = {
-            "named_filter": named_filter,
-            "scope": scope,
-            "versionscope": versionscope,
-            "search": search,
-            "limit": limit,
-            "sort": sort,
-            "start": start
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-    def retrieve_document(self, doc_id):
-        """
-        Retrieve all metadata from a document.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document
-        :param doc_id: The document id field value.
-        :return: JSON response containing document metadata.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_versions(self, doc_id):
-        """
-        Retrieve all versions of a document.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-versions
-        :param doc_id: The document id field value.
-        :return: JSON response containing all available versions of the specified document.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_version(self, doc_id, major_version, minor_version):
-        """
-        Retrieve all fields and values configured on a document version.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version
-        :param doc_id: The document id field value.
-        :param major_version: The document major version number field value.
-        :param minor_version: The document minor version number field value.
-        :return: JSON response containing all fields and values for the specified version of the document.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def download_document_file(self, doc_id, lockDocument=False):
-        """
-        Download the latest version of the source file from the document.
-        API Documentation: https://developer.veevavault.com/api/23.2/#download-document-file
-        :param doc_id: The document id field value.
-        :param lockDocument: Set to true to Check Out this document before retrieval. Default is False.
-        :return: A file with the document content.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/file"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        params = {"lockDocument": lockDocument}
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        filename = re.findall('filename="(.+)"', response.headers.get('Content-Disposition'))[0]
-        
-        with open(filename, 'wb') as file:
-            file.write(response.content)
-        
-        return filename
-
-    def download_document_version_file(self, doc_id, major_version, minor_version):
-        """
-        Download the file of a specific document version.
-        API Documentation: https://developer.veevavault.com/api/23.2/#download-document-version-file
-        :param doc_id: The document id field value.
-        :param major_version: The document major_version_number__v field value.
-        :param minor_version: The document minor_version_number__v field value.
-        :return: A file with the document content of the specified version.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/file"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        filename = re.findall('filename="(.+)"', response.headers.get('Content-Disposition'))[0]
-        
-        with open(filename, 'wb') as file:
-            file.write(response.content)
-        
-        return filename
-
-
-    #######################################################
-    # Documents
-    ## Create Documents
-    #######################################################
-
-    def create_single_document(self, file_path, name_v, type_v, lifecycle_v, subtype_v=None, classification_v=None, major_version_number_v=None, minor_version_number_v=None, external_id_v=None, product_v=None, options=None):
-        """
-        Create a single document in the Vault with various options.
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-single-document
-        
-        :param file_path: The filepath of the source document, if creating from an uploaded file. (optional)
-        :param name_v: The name of the new document.
-        :param type_v: The label of the document type to assign to the new document.
-        :param lifecycle_v: The label of the document lifecycle to assign to the new document.
-        :param subtype_v: The label of the document subtype, if applicable. (optional)
-        :param classification_v: The label of the document classification, if applicable. (optional)
-        :param major_version_number_v: The major version number to assign to the new document. (optional)
-        :param minor_version_number_v: The minor version number to assign to the new document. (optional)
-        :param external_id_v: The external id to assign to the new document. (optional)
-        :param product_v: The product id to assign to the new document. (optional)
-        :param options: A dictionary containing additional parameters for PromoMats or other types of documents. (optional)
-        :return: A dictionary containing the response details.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-        
-        data = {
-            "name__v": name_v,
-            "type__v": type_v,
-            "lifecycle__v": lifecycle_v
-        }
-        
-        if subtype_v:
-            data["subtype__v"] = subtype_v
-        if classification_v:
-            data["classification__v"] = classification_v
-        if major_version_number_v:
-            data["major_version_number__v"] = major_version_number_v
-        if minor_version_number_v:
-            data["minor_version_number__v"] = minor_version_number_v
-        if external_id_v:
-            data["external_id__v"] = external_id_v
-        if product_v:
-            data["product__v"] = product_v
-        if options:
-            data.update(options)
-        
-        files = {}
-        if file_path:
-            files['file'] = open(file_path, 'rb')
-        
-        response = requests.post(url, headers=headers, data=data, files=files)
-        return response.json()
-
-
-    def create_multiple_documents(self, csv_file_path, headers=None):
-        """
-        This method allows you to create multiple documents at once with a CSV input file. 
-        The maximum CSV input file size is 1GB and the maximum batch size is 500.
-        Note that this API does not support adding multi-value relationship fields by name.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#create-multiple-documents
-
-        Args:
-            csv_file_path (str): The path to the CSV file containing the document details.
-            headers (dict, optional): Additional headers to include in the request.
-
-        Returns:
-            dict: The response from the API.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.create_multiple_documents("path/to/your/csvfile.csv")
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch"
-        default_headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-
-        if headers:
-            default_headers.update(headers)
-
-        with open(csv_file_path, 'rb') as file:
-            response = requests.post(url, headers=default_headers, data=file)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Documents
-    ## Update Documents
-    #######################################################
-
-    def update_single_document(self, doc_id, data, headers=None):
-        """
-        This method allows you to update editable field values on the latest version of a single document. 
-        To update more than one document, it is best practice to use the bulk API.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#update-single-document
-
-        Args:
-            doc_id (int): The ID of the document to update.
-            data (dict): A dictionary containing the field values to update.
-            headers (dict, optional): Additional headers to include in the request.
-
-        Returns:
-            dict: The response from the API.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.update_single_document(534, {"language__v": "English", "product__v": 1357662840171, "audience__vs": "consumer__vs"})
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
-        default_headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-
-        if headers:
-            default_headers.update(headers)
-
-        response = requests.put(url, headers=default_headers, data=data)
-
-        return response.json()
-
-
-    def update_multiple_documents(self, data, headers=None, file_path=None):
-        """
-        This method allows you to bulk update editable field values on multiple documents. 
-        You can only update the latest version of each document.
-        
-        The maximum CSV input file size is 1GB and the maximum batch size is 1,000.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#update-single-document
-
-        Args:
-            data (dict or str): A dictionary containing name-value pairs to be updated or the path to a CSV file with the updates.
-            headers (dict, optional): Additional headers to include in the request.
-            file_path (str, optional): The path to a CSV file containing updates (if data is not a dictionary).
-
-        Returns:
-            dict: The response from the API.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.update_multiple_documents({"docIds": "771,772,773", "archive__v": "true"}, file_path="path/to/file.csv")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch"
-        
-        default_headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv" if file_path else "application/x-www-form-urlencoded",
-            "Accept": "text/csv"
-        }
-
-        if headers:
-            default_headers.update(headers)
-
-        if file_path:
-            with open(file_path, 'rb') as f:
-                response = requests.put(url, headers=default_headers, data=f)
-        else:
-            response = requests.put(url, headers=default_headers, data=data)
-
-        return response.json()
-
-
-    def reclassify_single_document(self, doc_id, type_v, lifecycle_v, reclassify=True, subtype_v=None, classification_v=None, document_number_v=None, status_v=None):
-        """
-        This method allows you to reclassify a single document, enabling the change of document type 
-        or the assignment of a document type to an unclassified document.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#reclassify-single-document
-
-        Args:
-            doc_id (str): The ID of the document to reclassify.
-            type_v (str): The name of the document type.
-            lifecycle_v (str): The name of the document lifecycle.
-            reclassify (bool): Set to true to reclassify the document. Defaults to true.
-            subtype_v (str, optional): The name of the document subtype, if applicable.
-            classification_v (str, optional): The name of the document classification, if applicable.
-            document_number_v (str, optional): The document number for the reclassified document. Use with X-VaultAPI-MigrationMode header.
-            status_v (str, optional): Specifies the lifecycle state for the reclassified document. Use with X-VaultAPI-MigrationMode header.
-
-        Returns:
-            dict: The response from the API.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.reclassify_single_document("775", "Promotional Piece", "Promotional Piece", subtype_v="Advertisement", classification_v="Web")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-
-        data = {
-            "type__v": type_v,
-            "lifecycle__v": lifecycle_v,
-            "reclassify": reclassify
-        }
-
-        if subtype_v:
-            data["subtype__v"] = subtype_v
-        if classification_v:
-            data["classification__v"] = classification_v
-        if document_number_v:
-            data["document_number__v"] = document_number_v
-            headers["X-VaultAPI-MigrationMode"] = "true"
-        if status_v:
-            data["status__v"] = status_v
-            headers["X-VaultAPI-MigrationMode"] = "true"
-
-        response = requests.put(url, headers=headers, data=data)
-
-        return response.json()
-
-
-    def reclassify_multiple_documents(self, csv_file_path):
-        """
-        This method allows you to reclassify multiple documents in bulk, enabling the change of document type 
-        or the assignment of document types to unclassified documents. The details of the documents to be reclassified 
-        should be specified in a CSV file.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#reclassify-multiple-documents
-
-        Args:
-            csv_file_path (str): The path to the CSV file containing the details of the documents to be reclassified.
-
-        Returns:
-            dict: The response from the API, including the status and IDs of the reclassified documents.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.reclassify_multiple_documents("C:\\Vault\\Documents\\reclassify_documents.csv")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch/actions/reclassify"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "text/csv"
-        }
-
-        with open(csv_file_path, 'rb') as file:
-            response = requests.put(url, headers=headers, data=file)
-
-        return response.text
-
-    def update_document_version(self, doc_id, major_version, minor_version, data):
-        """
-        This method allows you to update editable field values on a specific version of a document in the Vault.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#update-document-version
-
-        Args:
-            doc_id (int): The ID of the document to be updated.
-            major_version (int): The major version number of the document to be updated.
-            minor_version (int): The minor version number of the document to be updated.
-            data (dict): A dictionary containing the field values to be updated.
-
-        Returns:
-            dict: The response from the API, including the status and the ID of the updated document.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.update_document_version(534, 2, 0, {"language__v": "English", "product__v": "1357662840171", "audience__c": "consumer__c"})
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-
-        response = requests.put(url, headers=headers, data=data)
-
-        return response.json()
-
-
-    def create_multiple_document_versions(self, file_path, id_param=None):
-        """
-        This method allows you to create or add document versions in bulk in the Vault.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#create-multiple-document-versions
-
-        Args:
-            file_path (str): The filepath of your source files which contains details for new versions to be created.
-            id_param (str, optional): If you’re identifying documents in your input by a unique field, use this parameter to specify the field name.
-
-        Returns:
-            dict: The response from the API, including the status and details of the created document versions.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.create_multiple_document_versions("path/to/your/file.csv", id_param="external_id__v")
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/versions/batch"
-        if id_param:
-            url += f"?idParam={id_param}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json",
-            "X-VaultAPI-MigrationMode": "true"
-        }
-
-        with open(file_path, 'rb') as f:
-            response = requests.post(url, headers=headers, data=f)
-
-        return response.json()
-
-    def create_single_document_version(self, doc_id, create_draft, file_path=None, description=None, suppress_rendition=False):
-        """
-        Adds a new draft version of an existing document in the Vault. You can either use the existing source file or upload a new one.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#create-single-document-version
-
-        Args:
-            doc_id (int): The ID of the document to which a new draft version will be added.
-            create_draft (str): Specify whether to create a draft from the latest content or uploaded content.
-            file_path (str, optional): The filepath of the source document, required when createDraft is 'uploadedContent'.
-            description (str, optional): Description for the new draft version. Maximum 1500 characters.
-            suppress_rendition (bool, optional): Set to true to suppress automatic generation of the viewable rendition.
-
-        Returns:
-            dict: The response from the API, indicating the success or failure of the draft creation.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.create_single_document_version(534, "latestContent", description="Description for the new draft")
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
-        if suppress_rendition:
-            url += "?suppressRendition=true"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-
-        data = {
-            "createDraft": create_draft
-        }
-        if description:
-            data["description__v"] = description
-
-        if create_draft == "uploadedContent" and file_path:
-            with open(file_path, 'rb') as f:
-                files = {'file': f}
-                response = requests.post(url, headers=headers, data=data, files=files)
-        else:
-            response = requests.post(url, headers=headers, data=data)
-
-        return response.json()
-
-
-
-    #######################################################
-    # Documents
-    ## Delete Documents
-    #######################################################
-
-    def delete_single_document(self, document_id):
-        """
-        Deletes all versions of a specified document including all source files and viewable renditions.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document
-
-        Args:
-            document_id (int): The system-assigned ID of the document to delete.
-
-        Returns:
-            dict: The response from the API, indicating the success or failure of the deletion.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.delete_single_document(534)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-
-        return response.json()
-
-
-    def delete_multiple_documents(self, input_file_path, id_param=None):
-        """
-        Deletes all versions of multiple documents including all source files and viewable renditions.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-documents
-
-        Args:
-            input_file_path (str): The path to the CSV or JSON file containing the details of the documents to be deleted.
-            id_param (str, optional): If identifying documents by a unique field, add this parameter to specify the field name.
-
-        Returns:
-            dict: The response from the API, indicating the success or failure of the deletion.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.delete_multiple_documents("C:\\Vault\\Documents\\delete_documents.csv", id_param="external_id__v")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch"
-        if id_param:
-            url += f"?idParam={id_param}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-
-        with open(input_file_path, 'rb') as f:
-            response = requests.delete(url, headers=headers, data=f)
-
-        return response.json()
-
-
-    def delete_single_document_version(self, doc_id, major_version, minor_version):
-        """
-        Deletes a specific version of a document, including the version’s source file and viewable rendition. Other versions of the document remain unchanged.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document-version
-
-        Args:
-            doc_id (int): The document ID field value.
-            major_version (int): The document major version number field value.
-            minor_version (int): The document minor version number field value.
-
-        Returns:
-            dict: The response from the API, indicating the success or failure of the deletion.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.delete_single_document_version(534, 0, 2)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-
-        return response.json()
-
-
-    def delete_multiple_document_versions(self, input_file_path, id_param=None):
-        """
-        Deletes specific versions of multiple documents, including the versions’ source files and viewable renditions.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-document-versions
-
-        Args:
-            input_file_path (str): The path to the CSV or JSON file containing the details of the document versions to be deleted.
-            id_param (str, optional): If identifying documents in the input by a unique field, add this parameter to specify the field name. Defaults to None.
-
-        Returns:
-            dict: The response from the API, indicating the success or failure of the deletion of each document version.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.delete_multiple_document_versions("C:\\Vault\\Documents\\delete_document_versions.csv", id_param="external_id__v")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/versions/batch"
-        if id_param:
-            url += f"?idParam={id_param}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-
-        with open(input_file_path, 'rb') as f:
-            response = requests.delete(url, headers=headers, data=f)
-
-        return response.json()
-
-
-    def retrieve_deleted_document_ids(self, start_date=None, end_date=None):
-        """
-        Retrieves the IDs of documents that were deleted within the past 30 days.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-deleted-document-ids
-
-        Args:
-            start_date (str, optional): Specify a date (no more than 30 days past) after which to look for deleted documents. 
-                                        Dates must be in YYYY-MM-DDTHH:MM:SSZ format. Defaults to None.
-            end_date (str, optional): Specify a date (no more than 30 days past) before which to look for deleted documents. 
-                                    Dates must be in YYYY-MM-DDTHH:MM:SSZ format. Defaults to None.
-
-        Returns:
-            dict: The response from the API, indicating the details of deleted documents.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_deleted_document_ids("2023-08-01T00:00:00Z", "2023-08-30T23:59:59Z")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/deletions/documents"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-
-        params = {}
-        if start_date:
-            params['start_date'] = start_date
-        if end_date:
-            params['end_date'] = end_date
-        
-        response = requests.get(url, headers=headers, params=params)
-
-        return response.json()
-
-
-    #######################################################
-    # Documents
-    ## Document Locks
-    #######################################################
-
-    def retrieve_document_lock_metadata(self):
-        """
-        Retrieves the metadata of the lock attributes associated with documents.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-lock-metadata
-
-        Returns:
-            dict: The response from the API, containing metadata details of the lock attributes.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_lock_metadata()
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/lock"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-
-        return response.json()
-
-
-    def create_document_lock(self, doc_id):
-        """
-        Creates a lock on a specified document, preventing other users from locking or checking out the document. 
-        The operation is similar to checking out a document, but without the file attached in the response for download.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#create-document-lock
-
-        Args:
-            doc_id (int): The ID of the document to lock.
-
-        Returns:
-            dict: The response from the API, generally indicating the success status of the lock operation.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.create_document_lock(534)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/lock"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers)
-
-        return response.json()
-
-
-    def retrieve_document_lock(self, doc_id):
-        """
-        Retrieves the lock status of a specified document. 
-        If the document is locked, the response will include the user ID of the person who locked it and the date and time of the lock. 
-        If the document is not locked, the lock fields will not be returned in the response.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-lock
-
-        Args:
-            doc_id (int): The ID of the document to retrieve the lock status for.
-
-        Returns:
-            dict: The response from the API containing the lock details or indicating that no lock is present.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_lock(534)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/lock"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-
-        return response.json()
-
-
-    def delete_document_lock(self, doc_id):
-        """
-        Deletes the lock on a specified document, allowing other users to lock or check out the document.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-document-lock
-        
-        Args:
-            doc_id (int): The ID of the document for which the lock is to be deleted.
-
-        Returns:
-            dict: The response from the API indicating the status of the delete operation.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.delete_document_lock(534)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/lock"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.delete(url, headers=headers)
-
-        return response.json()
-
-
-    #######################################################
-    # Documents
-    ## Document Renditions
-    #######################################################
-
-    def retrieve_document_renditions(self, doc_id):
-        """
-        Retrieves the renditions of a specified document.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-renditions
-        
-        Args:
-            doc_id (int): The ID of the document for which the renditions are to be retrieved.
-
-        Returns:
-            dict: A dictionary containing the rendition types and URLs for the renditions of the specified document.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_renditions(534)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/renditions"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-
-        return response.json()
-
-
-    def retrieve_document_version_renditions(self, doc_id, major_version, minor_version):
-        """
-        Retrieves the renditions of a specified document version.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version-renditions
-        
-        Args:
-            doc_id (int): The ID of the document for which the renditions are to be retrieved.
-            major_version (int): The major version number of the document.
-            minor_version (int): The minor version number of the document.
-
-        Returns:
-            dict: A dictionary containing the rendition types and URLs for the renditions of the specified document version.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_version_renditions(534, 2, 0)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-
-        return response.json()
-
-
-    def download_document_rendition_file(self, doc_id, rendition_type, steady_state=None, protected_rendition=None):
-        """
-        Downloads the rendition file from the latest version of a document.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-document-rendition-file
-
-        Args:
-            doc_id (int): The ID of the document for which the rendition file is to be downloaded.
-            rendition_type (str): The type of the rendition file to download.
-            steady_state (bool, optional): Set to true to download a rendition from the latest steady state version of the document. Defaults to None.
-            protected_rendition (bool, optional): If your Vault is configured to use protected renditions, set to false to download the non-protected rendition. If omitted, defaults to true. Defaults to None.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.download_document_rendition_file(534, 'viewable_rendition__v', steady_state=True, protected_rendition=False)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/renditions/{rendition_type}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        params = {
-            "steadyState": steady_state,
-            "protectedRendition": protected_rendition
-        }
-
-        response = requests.get(url, headers=headers, params=params)
-
-        return response.json()
-
-
-    def download_document_version_rendition_file(self, doc_id, major_version, minor_version, rendition_type, protected_rendition=None):
-        """
-        Downloads a rendition for a specified version of a document.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-document-version-rendition-file
-
-        Args:
-            doc_id (int): The ID of the document for which the rendition file is to be downloaded.
-            major_version (int): The major version number of the document.
-            minor_version (int): The minor version number of the document.
-            rendition_type (str): The type of the rendition file to download.
-            protected_rendition (bool, optional): If your Vault is configured to use protected renditions, set to false to download the non-protected rendition. If omitted, defaults to true. Defaults to None.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.download_document_version_rendition_file(534, 2, 0, 'viewable_rendition__v', protected_rendition=False)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        params = {
-            "protectedRendition": protected_rendition
-        }
-
-        response = requests.get(url, headers=headers, params=params)
-
-        return response.json()
-
-    def add_multiple_document_renditions(self, file_path, idParam=None, largeSizeAsset=None):
-        """
-        Adds multiple document renditions in bulk. This function requires the renditions to be loaded to the file staging server first.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#add-multiple-document-renditions
-
-        Args:
-            file_path (str): The filepath of the CSV file which contains details of the renditions to be added. The CSV should be in UTF-8 encoding and comply with RFC 4180 format.
-            idParam (str, optional): If you’re identifying documents in your input by a unique field, add this parameter. Defaults to None.
-            largeSizeAsset (bool, optional): Set to true if adding renditions of the Large Size Asset type. Defaults to None.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.add_multiple_document_renditions("path/to/your/file.csv", idParam="external_id__v", largeSizeAsset=True)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/renditions/batch"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json",
-            "X-VaultAPI-MigrationMode": "true"
-        }
-
-        params = {
-            "idParam": idParam,
-            "largeSizeAsset": largeSizeAsset
-        }
-
-        with open(file_path, 'rb') as f:
-            response = requests.post(url, headers=headers, params=params, data=f)
-
-        return response.json()
-
-
-    def add_single_document_rendition(self, doc_id, rendition_type, file_path):
-        """
-        Adds a single document rendition to the vault. If you need to add more than one document rendition, consider using the bulk API.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#add-single-document-rendition
-
-        Args:
-            doc_id (str): The document ID field value.
-            rendition_type (str): The type of document rendition.
-            file_path (str): The path to the file to be uploaded.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.add_single_document_rendition("534", "imported_rendition__c", "path/to/your/CholeCap-Document.pdf")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/renditions/{rendition_type}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-
-        with open(file_path, 'rb') as f:
-            files = {'file': (os.path.basename(file_path), f)}
-            response = requests.post(url, headers=headers, files=files)
-
-        return response.json()
-
-
-    def upload_document_version_rendition(self, doc_id, major_version, minor_version, rendition_type, file_path):
-        """
-        Uploads a rendition for a specified version of a document. 
-
-        API documentation: https://developer.veevavault.com/api/23.2/#upload-document-version-rendition
-
-        Args:
-            doc_id (str): The document ID field value.
-            major_version (str): The major version number of the document.
-            minor_version (str): The minor version number of the document.
-            rendition_type (str): The type of document rendition.
-            file_path (str): The path to the file to be uploaded.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.upload_document_version_rendition("534", "1", "0", "imported_rendition__c", "path/to/your/CholeCap-Document.pdf")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-
-        with open(file_path, 'rb') as f:
-            files = {'file': (os.path.basename(file_path), f)}
-            response = requests.post(url, headers=headers, files=files)
-
-        return response.json()
-
-
-    def replace_document_rendition(self, doc_id, rendition_type, file_path):
-        """
-        Replaces a rendition of the latest version of a document.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#replace-document-rendition
-
-        Args:
-            doc_id (str): The document ID field value.
-            rendition_type (str): The type of document rendition.
-            file_path (str): The path to the file to be uploaded.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.replace_document_rendition("534", "imported_rendition__c", "path/to/your/CholeCap-Document.pdf")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/renditions/{rendition_type}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-
-        with open(file_path, 'rb') as f:
-            files = {'file': (os.path.basename(file_path), f)}
-            response = requests.put(url, headers=headers, files=files)
-
-        return response.json()
-
-
-    def replace_document_version_rendition(self, doc_id, major_version, minor_version, rendition_type, file_path):
-        """
-        Replaces a rendition of a specified version of a document.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#replace-document-version-rendition
-
-        Args:
-            doc_id (str): The document ID field value.
-            major_version (str): The document major version number.
-            minor_version (str): The document minor version number.
-            rendition_type (str): The type of document rendition.
-            file_path (str): The path to the file to be uploaded.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.replace_document_version_rendition("534", "2", "0", "imported_rendition__c", "path/to/your/CholeCap-Document.pdf")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-
-        with open(file_path, 'rb') as f:
-            files = {'file': (os.path.basename(file_path), f)}
-            response = requests.put(url, headers=headers, files=files)
-
-        return response.json()
-
-
-    def delete_multiple_document_renditions(self, csv_file_path):
-        """
-        Deletes multiple document renditions in bulk.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-document-renditions
-
-        Args:
-            csv_file_path (str): The path to the CSV file containing details of the document renditions to delete.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.delete_multiple_document_renditions("C:\\Vault\\Documents\\delete_document_renditions.csv")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/renditions/batch"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-
-        with open(csv_file_path, 'rb') as f:
-            response = requests.delete(url, headers=headers, data=f)
-
-        return response.json()
-
-
-    def delete_single_document_rendition(self, document_id, rendition_type):
-        """
-        Deletes a single document rendition. On SUCCESS, Vault deletes the rendition of specified type from the latest document version.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document-rendition
-
-        Args:
-            document_id (str): The document ID field value.
-            rendition_type (str): The document rendition type.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.delete_single_document_rendition("534", "imported_rendition__vs")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/renditions/{rendition_type}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-
-        return response.json()
-
-
-    def delete_document_version_rendition(self, doc_id, major_version, minor_version, rendition_type):
-        """
-        Deletes the rendition of the given type from the specified version of the document.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-document-version-rendition
-
-        Args:
-            doc_id (str): The document ID field value.
-            major_version (str): The document major_version_number__v field value.
-            minor_version (str): The document minor_version_number__v field value.
-            rendition_type (str): The document rendition type.
-
-        Returns:
-            Response object: The HTTP Response object.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.delete_document_version_rendition("534", "2", "0", "imported_rendition__c")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-
-        return response.json()
-
-
-
-    #######################################################
-    # Documents
-    ## Document Attachments
-    #######################################################
-
-    def determine_if_document_has_attachments(self, doc_id):
-        """
-        Determines if a document has attachments. The method sends a GET request to the specified URL and retrieves the information on any attachments associated with the specified document ID.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#determine-if-a-document-has-attachments
-
-        Args:
-            doc_id (str): The document ID field value.
-
-        Returns:
-            dict: A dictionary with details about the attachments (if any).
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.determine_if_document_has_attachments("565")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_attachments(self, doc_id):
-        """
-        Retrieves the attachments of a specified document. The method sends a GET request to the specified URL and retrieves details about the document's attachments including id, filename, format, size, MD5 checksum, version details, and the creator's details.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-attachments
-
-        Args:
-            doc_id (str): The document ID field value.
-
-        Returns:
-            dict: A dictionary containing details of the document's attachments.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_attachments("565")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_version_attachments(self, doc_id, major_version, minor_version):
-        """
-        Retrieves the attachments of a specific version of a document. Sends a GET request to the specified URL and retrieves details about the attachments including ID, filename, format, size, MD5 checksum, version details, and the creator's details.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version-attachments
-        
-        Args:
-            doc_id (str): The document ID field value.
-            major_version (str): The document major version number field value.
-            minor_version (str): The document minor version number field value.
-        
-        Returns:
-            dict: A dictionary containing details of the document version's attachments.
-        
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_version_attachments("17", "0", "1")
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_attachment_versions(self, doc_id, attachment_id):
-        """
-        Retrieves versions of a specific document attachment. Sends a GET request to the specified URL and retrieves details about the versions including version number and URL.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-attachment-versions
-        
-        Args:
-            doc_id (str): The document ID field value.
-            attachment_id (str): The attachment ID field value.
-        
-        Returns:
-            dict: A dictionary containing details of the document attachment versions.
-        
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_attachment_versions("565", "566")
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_version_attachment_versions(self, doc_id, major_version, minor_version, attachment_id, attachment_version=None):
-        """
-        Retrieves specific versions of an attachment on a specific version of a document. 
-        If attachment_version is omitted, it retrieves all versions of the specified attachment.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version-attachment-versions
-
-        Args:
-            doc_id (str): The document id field value.
-            major_version (str): The document major_version_number__v field value.
-            minor_version (str): The document minor_version_number__v field value.
-            attachment_id (str): The id of the document attachment to retrieve.
-            attachment_version (str, optional): The version of the attachment to retrieve. Defaults to None.
-
-        Returns:
-            dict: A dictionary containing details of the document version attachment versions.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_version_attachment_versions("17", "0", "1", "39", "1")
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions"
-        if attachment_version:
-            url += f"/{attachment_version}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_attachment_metadata(self, doc_id, attachment_id):
-        """
-        Retrieves the metadata of a specific document attachment. The metadata contains various details including file name, format, size, checksum and more.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-attachment-metadata
-
-        Args:
-            doc_id (str): The document id field value.
-            attachment_id (str): The attachment id field value.
-
-        Returns:
-            dict: A dictionary containing the metadata of the document attachment.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_attachment_metadata("565", "566")
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-    def retrieve_document_attachment_version_metadata(self, doc_id, attachment_id, attachment_version):
-        """
-        Retrieves the metadata of a specific version of a document attachment. This metadata contains details including file name, format, size, checksum and more.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-attachment-version-metadata
-
-        Args:
-            doc_id (str): The document id field value.
-            attachment_id (str): The attachment id field value.
-            attachment_version (str): The attachment version field value.
-
-        Returns:
-            dict: A dictionary containing the metadata of the specific version of the document attachment.
-
-        Usage:
-            >>> vv = Vv()
-            >>> vv.retrieve_document_attachment_version_metadata("565", "566", "2")
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def download_document_attachment(self, doc_id, attachment_id):
-        """
-        Downloads the latest version of the specified attachment from the document. The filename in the response can be used to name the local file.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-document-attachment
-
-        Args:
-            doc_id (str): The document id field value.
-            attachment_id (str): The attachment id field value.
-
-        Returns:
-            bytes: The content of the file as bytes.
-
-        Usage:
-            >>> vv = Vv()
-            >>> file_content = vv.download_document_attachment("565", "567")
-            >>> with open("filename_from_response.pdf", "wb") as file:
-            >>>     file.write(file_content)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/file"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-        
-        return response.content
-
-
-    def download_document_attachment_version(self, doc_id, attachment_id, attachment_version):
-        """
-        Downloads the specified version of the attachment from the document. The filename in the response can be used to name the local file.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-document-attachment-version
-
-        Args:
-            doc_id (str): The document id field value.
-            attachment_id (str): The attachment id field value.
-            attachment_version (str): The attachment version__v field value.
-
-        Returns:
-            bytes: The content of the file as bytes.
-
-        Usage:
-            >>> vv = Vv()
-            >>> file_content = vv.download_document_attachment_version("565", "567", "1")
-            >>> with open("filename_from_response.pdf", "wb") as file:
-            >>>     file.write(file_content)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}/file"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-        
-        return response.content
-
-
-    def download_document_version_attachment_version(self, doc_id, major_version, minor_version, attachment_id, attachment_version):
-        """
-        Downloads the specified attachment version from the specified document version. The filename in the response can be used to name the local file.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-document-version-attachment-version
-
-        Args:
-            doc_id (str): The document id field value.
-            major_version (str): The document major_version_number__v field value.
-            minor_version (str): The document minor_version_number__v field value.
-            attachment_id (str): The id field value of the attachment.
-            attachment_version (str): The version of the attachment.
-
-        Returns:
-            bytes: The content of the file as bytes.
-
-        Usage:
-            >>> vv = Vv()
-            >>> file_content = vv.download_document_version_attachment_version("56", "0", "1", "14", "3")
-            >>> with open("filename_from_response.pdf", "wb") as file:
-            >>>     file.write(file_content)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}/file"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-        
-        return response.content
-
-
-    def download_all_document_attachments(self, doc_id):
-        """
-        Downloads the latest version of all attachments from the specified document. The attachments are packaged in a ZIP file and the file name from the response can be used to name the local file.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-all-document-attachments
-
-        Args:
-            doc_id (str): The document id field value.
-
-        Returns:
-            bytes: The content of the zip file as bytes.
-
-        Usage:
-            >>> vv = Vv()
-            >>> zip_content = vv.download_all_document_attachments("565")
-            >>> with open("filename_from_response.zip", "wb") as file:
-            >>>     file.write(zip_content)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/file"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-        
-        return response.content
-
-
-    def download_all_document_version_attachments(self, doc_id, major_version, minor_version):
-        """
-        Downloads the latest version of all attachments from the specified version of the document. The file name from the response can be used to name the local file.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-all-document-version-attachments
-
-        Args:
-            doc_id (str): The document id field value.
-            major_version (str): The document major_version_number__v field value.
-            minor_version (str): The document minor_version_number__v field value.
-
-        Returns:
-            bytes: The content of the attachments as bytes.
-
-        Usage:
-            >>> vv = Vv()
-            >>> content = vv.download_all_document_version_attachments("56", "0", "1")
-            >>> with open("filename_from_response", "wb") as file:
-            >>>     file.write(content)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/file"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-        
-        return response.content
-
-
-    def delete_single_document_attachment(self, doc_id, attachment_id):
-        """
-        Deletes the specified attachment and all of its versions.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document-attachment
-
-        Args:
-            doc_id (str): The document id field value.
-            attachment_id (str): The attachment id field value.
-
-        Returns:
-            dict: The JSON response from the API call.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.delete_single_document_attachment("565", "567")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-        response.raise_for_status()
-        
-        return response.json()
-
-
-    def delete_single_document_attachment_version(self, doc_id, attachment_id, attachment_version):
-        """
-        Deletes the specified version of the specified attachment.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document-attachment-version
-
-        Args:
-            doc_id (str): The document id field value.
-            attachment_id (str): The attachment id field value.
-            attachment_version (str): The attachment version__v field value.
-
-        Returns:
-            dict: The JSON response from the API call.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.delete_single_document_attachment_version("565", "567", "3")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-        response.raise_for_status()
-        
-        return response.json()
-
-
-    def delete_multiple_document_attachments(self, input_file, content_type='text/csv', accept='text/csv', id_param=None):
-        """
-        Delete multiple document attachments in bulk with a JSON or CSV input file. 
-        This works for version-specific attachments and attachments at the document level.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-document-attachments
-
-        Args:
-            input_file (str): The path to the input file (CSV or JSON) with details of attachments to be deleted.
-            content_type (str): The content type of the input file, either 'application/json' or 'text/csv'. Defaults to 'text/csv'.
-            accept (str): The format of the response, either 'application/json', 'text/csv', or 'application/xml'. Defaults to 'text/csv'.
-            id_param (str, optional): If you’re identifying attachments in your input by external id, 
-                                    add this parameter with the value 'external_id__v'. Defaults to None.
-
-        Returns:
-            dict: The JSON response from the API call.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.delete_multiple_document_attachments("C:\\Vault\\Documents\\delete_attachments.csv")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/attachments/batch"
-        if id_param:
-            url += f"?idParam={id_param}"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": content_type,
-            "Accept": accept
-        }
-
-        with open(input_file, 'rb') as file:
-            response = requests.delete(url, headers=headers, data=file)
-            response.raise_for_status()
-        
-        return response.json()
-
-
-    def create_document_attachment(self, doc_id, file_path):
-        """
-        Create an attachment on the latest version of a document. If the attachment 
-        already exists, Vault uploads the attachment as a new version of the existing attachment. 
-
-        API documentation: https://developer.veevavault.com/api/23.2/#create-document-attachment
-
-        Args:
-            doc_id (str): The document id field value.
-            file_path (str): The path to the attachment file to be uploaded.
-
-        Returns:
-            dict: The JSON response from the API call.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.create_document_attachment("565", "path/to/my_attachment_file.png")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-
-        with open(file_path, 'rb') as file:
-            files = {'file': (os.path.basename(file_path), file)}
-            response = requests.post(url, headers=headers, files=files)
-            response.raise_for_status()
-        
-        return response.json()
-
-
-    def create_multiple_document_attachments(self, input_file_path):
-        """
-        Create multiple document attachments in bulk with a JSON or CSV input file. You must first load the attachments 
-        to the file staging server. This works for version-specific attachments and attachments at the document level. 
-
-        API documentation: https://developer.veevavault.com/api/23.2/#create-multiple-document-attachments
-
-        Args:
-            input_file_path (str): The file path to the CSV or JSON input file.
-
-        Returns:
-            dict: The JSON response from the API call.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.create_multiple_document_attachments("path/to/create_attachments.csv")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/attachments/batch"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "text/csv"
-        }
-
-        with open(input_file_path, 'rb') as file:
-            response = requests.post(url, headers=headers, data=file)
-            response.raise_for_status()
-        
-        return response.json()
-
-
-    def restore_document_attachment_version(self, doc_id, attachment_id, attachment_version):
-        """
-        Restores a specific version of an existing attachment to make it the latest version.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#restore-document-attachment-version
-
-        Args:
-            doc_id (str): The document id field value.
-            attachment_id (str): The attachment id field value.
-            attachment_version (str): The attachment version__v field value.
-
-        Returns:
-            dict: The JSON response from the API call.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.restore_document_attachment_version("565", "567", "2")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}?restore=true"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers)
-        response.raise_for_status()
-        
-        return response.json()
-
-
-    def update_document_attachment_description(self, doc_id, attachment_id, description):
-        """
-        Updates the description of an attachment on the latest version of a document.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#update-document-attachment-description
-
-        Args:
-            doc_id (str): The document id field value.
-            attachment_id (str): The attachment id field value.
-            description (str): The new description for the attachment, maximum character length is 1000.
-
-        Returns:
-            dict: The JSON response from the API call.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.update_document_attachment_description("565", "567", "This is my description for this attachment.")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        data = {
-            "description__v": description
-        }
-        
-        response = requests.put(url, headers=headers, data=data)
-        response.raise_for_status()
-        
-        return response.json()
-
-    def update_multiple_document_attachment_descriptions(self, input_file_path, id_param=None):
-        """
-        Updates the descriptions of multiple document attachments in bulk using a JSON or CSV input file.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#update-multiple-document-attachment-descriptions
-
-        Args:
-            input_file_path (str): The file path to the JSON or CSV input file.
-            id_param (str, optional): The parameter to identify attachments by external ID instead of regular id. 
-                                    If identifying attachments by external id, add idParam=external_id__v to the request endpoint.
-
-        Returns:
-            dict: The JSON response from the API call.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.update_multiple_document_attachment_descriptions("C:\\Vault\\Documents\\update_attachments.csv")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/attachments/batch"
-        if id_param:
-            url += f"?idParam={id_param}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-        
-        with open(input_file_path, 'rb') as file:
-            response = requests.put(url, headers=headers, data=file)
-            response.raise_for_status()
-        
-        return response.json()
-
-
-    #######################################################
-    # Documents
-    ## Document Annotations
-    #######################################################
-
-    def download_document_annotations(self, doc_id):
-        """
-        Downloads the annotations of the specified version document rendition.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-document-annotations
-
-        Args:
-            doc_id (str): The ID of the document whose annotations need to be downloaded.
-
-        Returns:
-            bytes: The PDF data containing the annotations.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.download_document_annotations("14")
-            >>> with open("annotations.pdf", "wb") as file:
-            >>>     file.write(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/annotations"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-
-        return response.content
-
-
-    def download_document_version_annotations(self, doc_id, major_version, minor_version):
-        """
-        Downloads the annotations of the specified document version.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-document-version-annotations
-
-        Args:
-            doc_id (str): The ID of the document.
-            major_version (str): The major version number of the document.
-            minor_version (str): The minor version number of the document.
-
-        Returns:
-            bytes: The PDF data containing the annotations.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.download_document_version_annotations("14", "2", "1")
-            >>> with open("version_annotations.pdf", "wb") as file:
-            >>>     file.write(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-
-        return response.content
-
-
-    def retrieve_anchor_ids(self, doc_id):
-        """
-        Retrieves all anchor IDs from a specific document.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-anchor-ids
-
-        Args:
-            doc_id (str): The ID of the document to retrieve anchor IDs from.
-
-        Returns:
-            dict: A dictionary containing the details of the retrieved anchor IDs.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.retrieve_anchor_ids("10")
-            >>> for anchor_data in response['anchorDataList']:
-            >>>     print(f"Anchor ID: {anchor_data['anchorId']}, Name: {anchor_data['anchorName']}, Author: {anchor_data['noteAuthor']}, Page: {anchor_data['pageNumber']}")
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/anchors"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-
-        return response.json()
-
-
-    def retrieve_document_version_notes_as_csv(self, doc_id, major_version, minor_version):
-        """
-        Retrieves notes in CSV format for any document that has a viewable rendition and at least one annotation. 
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version-notes-as-csv
-
-        Args:
-            doc_id (str): The document id field value.
-            major_version (str): The document major version number.
-            minor_version (str): The document minor version number.
-
-        Returns:
-            csv: A CSV containing the annotation metadata.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.retrieve_document_version_notes_as_csv("10", "1", "0")
-            >>> with open('notes.csv', 'w') as file:
-            >>>     file.write(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/doc-export-annotations-to-csv"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "text/csv"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-
-        return response.text
-
-
-    def retrieve_video_annotations(self, doc_id, major_version, minor_version):
-        """
-        Retrieves annotations on a video document.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-video-annotations
-
-        Args:
-            doc_id (str): The video document id field value.
-            major_version (str): The video document major version number.
-            minor_version (str): The video document minor version number.
-
-        Returns:
-            csv: A CSV containing the video annotation metadata including replies and ordered by time signature.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.retrieve_video_annotations("14", "2", "1")
-            >>> with open('video_annotations.csv', 'w') as file:
-            >>>     file.write(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/export-video-annotations"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "text/csv"
-        }
-
-        response = requests.get(url, headers=headers)
-        response.raise_for_status()
-
-        return response.text
-
-
-    def upload_document_annotations(self, doc_id, file_path):
-        """
-        Uploads document annotations.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#upload-document-annotations
-
-        Args:
-            doc_id (str): The document id field value.
-            file_path (str): The path to the document file that contains the annotations to be uploaded.
-
-        Returns:
-            dict: A dictionary containing details about the upload status including the number of replies, failures, and new annotations.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.upload_document_annotations("548", "path/to/document2016.pdf")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/annotations"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-        
-        with open(file_path, 'rb') as f:
-            files = {'file': (os.path.basename(file_path), f)}
-            response = requests.post(url, headers=headers, files=files)
-            response.raise_for_status()
-        
-        return response.json()
-
-
-    def upload_document_version_annotations(self, doc_id, major_version, minor_version, file_path):
-        """
-        Uploads annotations for a specific version of a document.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#upload-document-version-annotations
-
-        Args:
-            doc_id (str): The document id field value.
-            major_version (str): The document major_version_number__v field value.
-            minor_version (str): The document minor_version_number__v field value.
-            file_path (str): The path to the document file that contains the annotations to be uploaded.
-
-        Returns:
-            dict: A dictionary containing details about the upload status including the number of replies, failures, and new annotations.
-
-        Usage:
-            >>> vv = Vv()
-            >>> response = vv.upload_document_version_annotations("548", "2", "1", "path/to/document2016.pdf")
-            >>> print(response)
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-        
-        with open(file_path, 'rb') as f:
-            files = {'file': (os.path.basename(file_path), f)}
-            response = requests.post(url, headers=headers, files=files)
-            response.raise_for_status()
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Documents
-    ## Document Relationships
-    #######################################################
-
-    def retrieve_document_type_relationships(self, document_type):
-        """
-        Retrieves all relationships from a specified document type.
-        
-        API Documentation:
-        https://developer.veevavault.com/api/23.2/#retrieve-document-type-relationships
-        
-        Args:
-        document_type (str): The type of the document. See Retrieve Document Types API for the list of document types.
-        
-        Returns:
-        dict: A dictionary containing the relationship details.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/types/{document_type}/relationships"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_document_relationships(self, doc_id, major_version, minor_version):
-        """
-        Retrieves all relationships from a specific document. For more details, visit: 
-        https://developer.veevavault.com/api/23.2/#retrieve-document-relationships
-        
-        Parameters:
-        doc_id (str): The document id field value.
-        major_version (str): The document major_version_number__v field value.
-        minor_version (str): The document minor_version_number__v field value.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def create_single_document_relationship(self, document_id, major_version_number, minor_version_number, target_doc_id, relationship_type, target_major_version=None, target_minor_version=None):
-        """
-        Creates a new relationship on a document. For more details, visit:
-        https://developer.veevavault.com/api/23.2/#create-single-document-relationship
-        
-        Parameters:
-        document_id (str): The document id field value.
-        major_version_number (str): The document major_version_number__v field value.
-        minor_version_number (str): The document minor_version_number__v field value.
-        target_doc_id (str): The document id of the target document.
-        relationship_type (str): The relationship type retrieved from the Document Relationships Metadata call above.
-        target_major_version (str, optional): The major version number of the target document to which the source document will be bound.
-        target_minor_version (str, optional): The minor version number of the target document to which the source document will be bound.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/versions/{major_version_number}/{minor_version_number}/relationships"
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        data = {
-            "target_doc_id__v": target_doc_id,
-            "relationship_type__v": relationship_type
-        }
-        if target_major_version:
-            data["target_major_version__v"] = target_major_version
-        if target_minor_version:
-            data["target_minor_version__v"] = target_minor_version
-
-        response = requests.post(url, headers=headers, data=data)
-        return response.json()
-
-
-    def create_multiple_document_relationships(self, input_file_path, content_type="text/csv", accept="text/csv", id_param=None):
-        """
-        Creates new relationships on multiple documents. For more details, visit:
-        https://developer.veevavault.com/api/23.2/#create-multiple-document-relationships
-
-        Parameters:
-        input_file_path (str): The path to the input file (JSON or CSV) containing details for creating document relationships.
-        content_type (str, optional): The Content-Type header value. It can be "application/json" or "text/csv". Defaults to "text/csv".
-        accept (str, optional): The Accept header value. It can be "application/json" or "text/csv". Defaults to "text/csv".
-        id_param (str, optional): A query parameter to create relationships based on a unique field. Defaults to None.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/relationships/batch"
-        if id_param:
-            url += f"?idParam={id_param}"
-        
-        headers = {
-            "Content-Type": content_type,
-            "Accept": accept,
-            "Authorization": self.sessionId
-        }
-
-        with open(input_file_path, 'rb') as f:
-            response = requests.post(url, headers=headers, data=f)
-        
-        return response.json()
-
-
-    def retrieve_document_relationship(self, doc_id, major_version, minor_version, relationship_id):
-        """
-        Retrieves the details of a specific document relationship. For more details, visit:
-        https://developer.veevavault.com/api/23.2/#retrieve-document-relationship
-
-        Parameters:
-        doc_id (int): The document ID.
-        major_version (int): The major version number of the document.
-        minor_version (int): The minor version number of the document.
-        relationship_id (int): The ID of the relationship to be retrieved.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def delete_single_document_relationship(self, doc_id, major_version, minor_version, relationship_id):
-        """
-        Deletes a single document relationship. For more details, visit:
-        https://developer.veevavault.com/api/23.2/#delete-single-document-relationship
-
-        Parameters:
-        doc_id (int): The document ID.
-        major_version (int): The major version number of the document.
-        minor_version (int): The minor version number of the document.
-        relationship_id (int): The ID of the relationship to be deleted.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        response = requests.delete(url, headers=headers)
-        
-        return response.json()
-
-
-    def delete_multiple_document_relationships(self, file_path):
-        """
-        Deletes multiple document relationships. For more details, visit:
-        https://developer.veevavault.com/api/23.2/#delete-multiple-document-relationships
-
-        Parameters:
-        file_path (str): The file path of the CSV file containing relationship IDs to be deleted.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/relationships/batch"
-        
-        headers = {
-            "Content-Type": "text/csv",
-            "Accept": "text/csv",
-            "Authorization": self.sessionId
-        }
-        
-        with open(file_path, 'rb') as file:
-            response = requests.delete(url, headers=headers, data=file)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Documents
-    ## Export Documents
-    #######################################################
-
-    def export_documents(self, document_ids, source=True, renditions=False, allversions=False):
-        """
-        Export a set of documents to your Vault’s file staging server. For more information, refer to:
-        https://developer.veevavault.com/api/23.2/#export-documents-1
-
-        Parameters:
-        document_ids (list): List of document IDs to export.
-        source (bool, optional): To include or exclude source files. Defaults to True.
-        renditions (bool, optional): To include or exclude renditions. Defaults to False.
-        allversions (bool, optional): To include all versions or only the latest version. Defaults to False.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch/actions/fileextract"
-        url += f"?source={'true' if source else 'false'}&renditions={'true' if renditions else 'false'}&allversions={'true' if allversions else 'false'}"
-        
-        headers = {
-            "Content-Type": "application/json",
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        payload = json.dumps([{"id": str(id)} for id in document_ids])
-        
-        response = requests.post(url, headers=headers, data=payload)
-        
-        return response.json()
-
-
-    def export_document_versions(self, document_versions, source=True, renditions=False):
-        """
-        Export a specific set of document versions to your Vault’s file staging server. For more information, refer to:
-        https://developer.veevavault.com/api/23.2/#export-document-versions
-
-        Parameters:
-        document_versions (list of dict): List of dictionaries containing details of the document versions to export. Each dictionary should have keys: 'id', 'major_version_number__v', and 'minor_version_number__v'.
-        source (bool, optional): To include or exclude source files. Defaults to True.
-        renditions (bool, optional): To include or exclude renditions. Defaults to False.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/versions/batch/actions/fileextract"
-        url += f"?source={'true' if source else 'false'}&renditions={'true' if renditions else 'false'}"
-        
-        headers = {
-            "Content-Type": "application/json",
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        payload = json.dumps(document_versions)
-        
-        response = requests.post(url, headers=headers, data=payload)
-        
-        return response.json()
-
-    def retrieve_document_export_results(self, job_id):
-        """
-        Retrieve the results of a document export job from your Vault. For more information, refer to:
-        https://developer.veevavault.com/api/23.2/#retrieve-document-export-results
-
-        Parameters:
-        job_id (str): The ID of the export job to retrieve results for.
-
-        Returns:
-        dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch/actions/fileextract/{job_id}/results"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Documents
-    ## Document Events
-    #######################################################
-
-
-
-    def retrieve_document_event_types_and_subtypes(self):
-        """
-        Retrieve the types and subtypes of document events configured in your Vault. For more information, refer to:
-        https://developer.veevavault.com/api/23.2/#retrieve-document-event-types-and-subtypes
-
-        Returns:
-        dict: A dictionary containing the response data with the list of event types and subtypes.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/events"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_document_event_subtype_metadata(self, event_type, event_subtype):
-        """
-        Retrieve the metadata for a specific document event subtype in your Vault. For more information, refer to:
-        https://developer.veevavault.com/api/23.2/#retrieve-document-event-subtype-metadata
-
-        Args:
-        event_type (str): The event type (e.g., distribution__v).
-        event_subtype (str): The event subtype (e.g., approved_email__v).
-
-        Returns:
-        dict: A dictionary containing the metadata for the specified event subtype.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/events/{event_type}/types/{event_subtype}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-    def create_document_event(self, document_id, major_version, minor_version, event_type, event_subtype, classification, external_id):
-        """
-        Create a new document event in your Vault. For more information, refer to:
-        https://developer.veevavault.com/api/23.2/#create-document-event
-
-        Args:
-        document_id (int): The document id field value.
-        major_version (int): The document major version number field value.
-        minor_version (int): The document minor version number field value.
-        event_type (str): The event type (e.g., distribution__v).
-        event_subtype (str): The event subtype (e.g., approved_email__v).
-        classification (str): The event classification (e.g., download__v).
-        external_id (str): The external id for the event.
-
-        Returns:
-        dict: A dictionary containing the response status of the event creation.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/versions/{major_version}/{minor_version}/events"
-
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        
-        data = {
-            "event_type__v": event_type,
-            "event_subtype__v": event_subtype,
-            "classification__v": classification,
-            "external_id__v": external_id
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-    def retrieve_document_events(self, document_id):
-        """
-        Retrieve the events associated with a specific document in the vault. For more details, refer to:
-        https://developer.veevavault.com/api/23.2/#retrieve-document-events
-
-        Args:
-        document_id (int): The ID of the document to retrieve events for.
-
-        Returns:
-        dict: A dictionary containing the response status and the list of event objects.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/events"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    #######################################################
-    # Documents
-    ## Document Templates
-    #######################################################
-
-    def retrieve_document_template_metadata(self):
-        """
-        Retrieve the metadata which defines the shape of document templates in your Vault. 
-        For more details, refer to: 
-        https://developer.veevavault.com/api/23.2/#retrieve-document-template-metadata
-
-        Returns:
-        dict: A dictionary containing the response status and the metadata details of document templates.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/templates"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_document_template_collection(self):
-        """
-        Retrieve all document templates present in the Vault. 
-        For more information, refer to:
-        https://developer.veevavault.com/api/23.2/#retrieve-document-template-collection
-
-        Returns:
-        dict: A dictionary containing the response status and details of all document templates in the Vault.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_document_template_attributes(self, template_name):
-        """
-        Retrieve the attributes from a specific document template in the Vault. 
-        For more information, refer to: 
-        https://developer.veevavault.com/api/23.2/#retrieve-document-template-attributes
-
-        Args:
-        template_name (str): The name__v field value of the document template.
-
-        Returns:
-        dict: A dictionary containing the response status and attributes of the specified document template.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates/{template_name}"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-    def download_document_template_file(self, template_name):
-        """
-        Download the file of a specific document template.
-        For more information, refer to: 
-        https://developer.veevavault.com/api/23.2/#download-document-template-file
-
-        Args:
-        template_name (str): The name__v field value of the document template.
-
-        Returns:
-        Response object: A Response object containing the file stream of the specified document template.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates/{template_name}/file"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-
-        response = requests.get(url, headers=headers, stream=True)
-        
-        with open(f"{template_name}.pdf", 'wb') as file:
-            for chunk in response.iter_content(chunk_size=8192):
-                file.write(chunk)
-
-        return response.json()
-
-
-    def create_single_document_template(self, label__v, type__v, active__v, file_path, subtype__v=None, classification__v=None, is_controlled__v=None, template_doc_id__v=None):
-        """
-        Create one document template in the Vault.
-        For more information, refer to:
-        https://developer.veevavault.com/api/23.2/#create-single-document-template
-
-        Args:
-        label__v (str): The label of the new document template. This is the name users will see among the available templates in the UI.
-        type__v (str): The name of the document type to which the template will be associated.
-        active__v (bool): Set to true or false to indicate whether the new document template should be set to active.
-        file_path (str): The file path of the document template to be uploaded. Maximum allowed size is 4GB.
-        subtype__v (str, optional): The name of the document subtype to which the template will be associated. This is only required if associating the template with a document subtype.
-        classification__v (str, optional): The name of the document classification to which the template will be associated. This is only required if associating the template with a document classification.
-        is_controlled__v (bool, optional): Set to true to indicate this template is a controlled document template.
-        template_doc_id__v (str, optional): The document id value to use as the Template Document for this controlled document template.
-
-        Returns:
-        Response object: A Response object containing the API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json",
-            "Content-Type": "multipart/form-data"
-        }
-
-        data = {
-            "label__v": label__v,
-            "type__v": type__v,
-            "active__v": active__v
-        }
-        if subtype__v:
-            data["subtype__v"] = subtype__v
-        if classification__v:
-            data["classification__v"] = classification__v
-        if is_controlled__v is not None:
-            data["is_controlled__v"] = is_controlled__v
-        if template_doc_id__v:
-            data["template_doc_id__v"] = template_doc_id__v
-
-        files = {'file': open(file_path, 'rb')}
-        
-        response = requests.post(url, headers=headers, data=data, files=files)
-
-        return response.json()
-
-
-    def update_multiple_document_templates(self, file_path):
-        """
-        Update up to 500 document templates in the Vault.
-        For more details, visit:
-        https://developer.veevavault.com/api/23.2/#update-multiple-document-templates
-
-        Args:
-        file_path (str): The path to the input file (CSV or JSON) containing details of the document templates to be updated.
-
-        Returns:
-        dict: A dictionary containing the API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-
-        with open(file_path, 'rb') as f:
-            response = requests.put(url, headers=headers, data=f)
-
-        return response.json()
-
-
-    def delete_basic_document_template(self, template_name):
-        """
-        Delete a basic document template from the Vault. Controlled document templates cannot be deleted using this API endpoint.
-        For more details, visit:
-        https://developer.veevavault.com/api/23.2/#delete-basic-document-template
-
-        Args:
-        template_name (str): The name__v field value of the document template to be deleted.
-
-        Returns:
-        dict: A dictionary containing the API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates/{template_name}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-
-        return response.json()
-
-
-    #######################################################
-    # Documents
-    ## Document Tokens
-    #######################################################
-
-    def document_tokens(self, doc_ids, expiry_date_offset=None, download_option=None, channel=None, token_group=None, steady_state=None):
-        """
-        Generates document access tokens needed by the external viewer to view documents outside of Vault.
-        For more details, visit:
-        https://developer.veevavault.com/api/23.2/#document-tokens
-
-        Args:
-        doc_ids (str): A comma-separated string of document id values for which to generate tokens.
-        expiry_date_offset (int, optional): The number of days after which the tokens will expire. Defaults to 10 years if not specified.
-        download_option (str, optional): Set to 'PDF', 'source', 'both', or 'none' to specify download options in the external viewer. Defaults to document settings if not specified.
-        channel (str, optional): The website object record id value that corresponds to the distribution channel. Defaults to 'Approved Email' if not specified.
-        token_group (str, optional): A string to group together generated tokens for multiple documents to display in the same viewer. Can be up to 255 characters in length.
-        steady_state (bool, optional): If true, generates a token for the latest steady state version of a document. Defaults to false.
-
-        Returns:
-        dict: A dictionary containing the API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/tokens"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        data = {
-            "docIds": doc_ids,
-            "expiryDateOffset": expiry_date_offset,
-            "downloadOption": download_option,
-            "channel": channel,
-            "tokenGroup": token_group,
-            "steadyState": steady_state
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-
-        return response.json()
-
-
-    #######################################################
-    # Binders
-    #######################################################
-
-    #######################################################
-    # Binders
-    ## Retrieve Binders
-    #######################################################
-
-    def retrieve_all_binders(self):
-        """
-        Retrieve a list of all binders in the Vault. Binders are a kind of document and can be distinguished from regular documents using the 'binder__v' field set to true or false.
-        For more details, visit: https://developer.veevavault.com/api/23.2/#retrieve-all-binders
-
-        Returns:
-        dict: A dictionary containing the API response with details of all binders.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-    def retrieve_binder(self, binder_id, depth='root'):
-        """
-        Use this endpoint to retrieve all fields and values configured on a specific binder in your Vault (using the binder ID).
-        The response includes the "first level" of the binder section node structure. To retrieve additional levels in the 
-        binder section node structure, use one of the depth parameters described in the documentation.
-        Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder
-        
-        Parameters:
-        binder_id (str): The binder id field value.
-        depth (str): To retrieve all information in all levels of the binder, set this to 'all'. 
-                    By default, only one level ('root') is returned.
-        
-        Returns:
-        dict: A dictionary containing the details of the binder.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
-        headers = {
-            'Authorization': self.sessionId,
-            'Accept': 'application/json'
-        }
-        params = {'depth': depth}
-        response = requests.get(url, headers=headers, params=params)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def retrieve_all_binder_versions(self, binder_id):
-        """
-        Retrieve all versions of a binder. 
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-binder-versions
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :return: A list of available versions for the specified binder.
-        :rtype: list
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions"
-        headers = {'Accept': 'application/json', 'Authorization': self.sessionId}
-        
-        response = requests.get(url, headers=headers)
-        if response.status_code == 200:
-            return response.json().get('versions')
-        else:
-            return response.json().get('responseStatus')
-
-
-    def retrieve_binder_version(self, binder_id, major_version, minor_version):
-        """
-        Retrieve the fields and values configured on a specific version of a specific binder.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-version
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param major_version: The binder major_version_number__v field value.
-        :type major_version: str
-        :param minor_version: The binder minor_version_number__v field value.
-        :type minor_version: str
-        :return: Fields and values of the specified binder version.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
-        headers = {'Accept': 'application/json', 'Authorization': self.sessionId}
-        
-        response = requests.get(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-    #######################################################
-    # Binders
-    ## Create Binders
-    #######################################################
-
-    def create_binder(self, binder_data, async_indexing=False):
-        """
-        Use this request to create a new binder in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder
-
-        :param binder_data: A dictionary containing binder data with keys matching the API's field names (e.g., name__v, type__v).
-        :type binder_data: dict
-        :param async_indexing: To process the indexing asynchronously, set to True. Default is False.
-        :type async_indexing: bool
-        :return: Response from the API, contains status and created binder ID.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders"
-        if async_indexing:
-            url += "?async=true"
-
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-
-        response = requests.post(url, data=binder_data, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-    def create_binder_from_template(self, template_name, binder_data):
-        """
-        Use this request to create a new binder in your Vault from a template.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-from-template
-
-        :param template_name: The name of the template to use for creating the binder, as returned from the document metadata.
-        :type template_name: str
-        :param binder_data: A dictionary containing binder data with keys matching the API's field names (e.g., name__v, type__v).
-        :type binder_data: dict
-        :return: Response from the API, contains status and created binder ID.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders"
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-        
-        binder_data['fromTemplate'] = template_name
-        
-        response = requests.post(url, data=binder_data, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-    def create_binder_version(self, binder_id):
-        """
-        Use this method to create a new version of a binder in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-version
-
-        :param binder_id: The ID of the binder for which a new version will be created.
-        :type binder_id: str or int
-        :return: Response from the API, contains status and version details.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-
-        response = requests.post(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-
-    #######################################################
-    # Binders
-    ## Update Binders
-    #######################################################
-
-    def update_binder(self, binder_id, data):
-        """
-        Use this method to update the details of a binder in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder
-
-        :param binder_id: The ID of the binder to be updated.
-        :type binder_id: str or int
-        :param data: A dictionary containing the data fields to be updated in the binder.
-        :type data: dict
-        :return: Response from the API, contains status and ID of the updated binder.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-
-        response = requests.put(url, headers=headers, data=data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-    def reclassify_binder(self, binder_id, reclassify_data):
-        """
-        Use this method to reclassify an existing binder in your Vault. Reclassification allows changing the document type 
-        of an existing binder. You can only reclassify the latest version of a specified binder and one binder at a time.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#reclassify-binder
-
-        :param binder_id: The ID of the binder to be reclassified.
-        :type binder_id: str or int
-        :param reclassify_data: A dictionary containing the reclassify parameters and other editable fields.
-        :type reclassify_data: dict
-        :return: Response from the API, contains status and ID of the reclassified binder.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-
-        response = requests.put(url, headers=headers, data=reclassify_data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-    def update_binder_version(self, binder_id, major_version, minor_version, update_data):
-        """
-        This method is used to update a specific version of a binder in your Vault. The necessary parameters 
-        are the binder ID and the major and minor version numbers.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-version
-
-        :param binder_id: The ID of the binder to be updated.
-        :type binder_id: str or int
-        :param major_version: The major version number of the binder.
-        :type major_version: str or int
-        :param minor_version: The minor version number of the binder.
-        :type minor_version: str or int
-        :param update_data: A dictionary containing the parameters to update.
-        :type update_data: dict
-        :return: Response from the API, contains status and ID of the updated binder.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-
-        response = requests.put(url, headers=headers, data=update_data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-    def refresh_binder_auto_filing(self, binder_id):
-        """
-        This method triggers auto-filing for a specific binder. It is only available in eTMF Vaults on binders
-        configured with the TMF Reference Models. It mimics the Refresh Auto-Filing action available in the UI.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#refresh-binder-auto-filing
-
-        :param binder_id: The ID of the binder to refresh auto-filing.
-        :type binder_id: str or int
-        :return: Response from the API, indicates the success of the operation.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/actions"
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-        data = {
-            'action': 'refresh_auto_filing'
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-
-    #######################################################
-    # Binders
-    ## Delete Binders
-    #######################################################
-
-    def delete_binder(self, binder_id):
-        """
-        This method allows you to delete a specified binder from the vault. The method sends a DELETE request to the Vault API
-        to remove the binder identified by the binder_id parameter.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder
-
-        :param binder_id: The ID of the binder to be deleted.
-        :type binder_id: str or int
-        :return: Response from the API, indicating the status of the delete operation.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-
-        response = requests.delete(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-    def delete_binder_version(self, binder_id, major_version, minor_version):
-        """
-        This method enables the deletion of a specific version of a binder. The binder is identified using binder_id, 
-        major_version, and minor_version parameters.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder-version
-
-        :param binder_id: The ID of the binder to be modified.
-        :type binder_id: str or int
-        :param major_version: The major version number of the binder.
-        :type major_version: str or int
-        :param minor_version: The minor version number of the binder.
-        :type minor_version: str or int
-        :return: Response from the API, denoting the status of the deletion process.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-
-        response = requests.delete(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-
-
-    #######################################################
-    # Binders
-    ## Export Binders
-    #######################################################
-
-    def export_binder(self, binder_id, major_version=None, minor_version=None, source=True, renditiontype=None, docversion=None, attachments=None, fields=None, docfield=True):
-        """
-        This method allows you to export a binder from the Vault. You can specify various parameters to control
-        the details of the exported content, such as whether to include source files, specific rendition types,
-        document versions, attachments, and specific field values. 
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#export-binder
-
-        :param binder_id: The ID of the binder to be exported.
-        :type binder_id: str or int
-        :param major_version: (Optional) The major version number of the binder. If not specified, the latest version is exported.
-        :type major_version: str or int, optional
-        :param minor_version: (Optional) The minor version number of the binder. This parameter is used in conjunction with the major_version parameter.
-        :type minor_version: str or int, optional
-        :param source: (Optional) Whether to include source files in the export. Default is True.
-        :type source: bool, optional
-        :param renditiontype: (Optional) The type of renditions to be included in the export.
-        :type renditiontype: str, optional
-        :param docversion: (Optional) Specify the versions of the documents to be included in the export.
-        :type docversion: str, optional
-        :param attachments: (Optional) Specify whether to include binder attachments in the export, and which versions to include.
-        :type attachments: str, optional
-        :param fields: (Optional) A comma-separated list of document field values to be included in the export.
-        :type fields: str, optional
-        :param docfield: (Optional) Whether to include document metadata in the export. Default is True.
-        :type docfield: bool, optional
-        :return: Response from the API, containing details of the export job initiated.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        params = {}
-        if not source:
-            params['source'] = 'false'
-        if renditiontype:
-            params['renditiontype'] = renditiontype
-        if docversion:
-            params['docversion'] = docversion
-        if attachments:
-            params['attachments'] = attachments
-        if fields:
-            params['fields'] = fields
-        if not docfield:
-            params['docfield'] = 'false'
-
-        endpoint = f"/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
-        if major_version is not None and minor_version is not None:
-            endpoint += f"/versions/{major_version}/{minor_version}"
-        endpoint += "/actions/export"
-        url = f"{self.vaultURL}{endpoint}"
-
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId
-        }
-
-        response = requests.post(url, headers=headers, params=params)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-    def export_binder_sections(self, binder_id, major_version, minor_version, node_ids, input_file_format='csv'):
-        """
-        This method allows you to export specific sections and documents from a binder in your Vault. You need to provide a list of node IDs (section or document IDs) to specify which parts of the binder to export. This method will initiate an export job in the Vault, and you can later check the status of this job using the URL and job ID provided in the response.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#export-binder-sections
-
-        :param binder_id: The ID of the binder to export sections from.
-        :type binder_id: str or int
-        :param major_version: The major version number of the binder.
-        :type major_version: str or int
-        :param minor_version: The minor version number of the binder.
-        :type minor_version: str or int
-        :param node_ids: A list of node IDs specifying the sections and documents to export.
-        :type node_ids: list of str or int
-        :param input_file_format: Format of the input file, either 'csv' or 'json'. Default is 'csv'.
-        :type input_file_format: str, optional
-        :return: Response from the API, containing details of the export job initiated.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export"
-
-        headers = {
-            'Authorization': self.sessionId,
-            'Accept': 'application/json'
-        }
-
-        if input_file_format.lower() == 'csv':
-            headers['Content-Type'] = 'text/csv'
-            data = '\n'.join(map(str, node_ids))
-        else: # input_file_format is 'json'
-            headers['Content-Type'] = 'application/json'
-            data = json.dumps({'id': node_ids})
-
-        response = requests.post(url, headers=headers, data=data)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-    def retrieve_binder_export_results(self, job_id):
-        """
-        This method retrieves the results of a previously initiated binder export job. You need to provide the job ID of the export job to get the results. The method returns details of the export including the path to the exported binder file.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-export-results
-
-        :param job_id: The ID of the export job whose results are to be retrieved.
-        :type job_id: str or int
-        :return: Response from the API, containing details of the exported binder.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/actions/export/{job_id}/results"
-
-        headers = {
-            'Authorization': self.sessionId,
-            'Accept': 'application/json'
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.json().get('responseStatus')
-
-
-    def download_exported_binder_files(self, file_path):
-        """
-        This method allows you to download the exported binder files from the file staging server. Ensure that the export job has been completed successfully and the API user has the necessary permissions to access the file staging server.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#download-exported-binder-files-via-file-staging-server
-
-        :param file_path: The path/location of the downloaded binder ZIP file retrieved from the export results.
-        :type file_path: str
-        :return: None
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}{file_path}"
-
-        headers = {
-            'Authorization': self.sessionId,
-        }
-
-        response = requests.get(url, headers=headers)
-
-        if response.status_code == 200:
-            with open('downloaded_binder.zip', 'wb') as file:
-                file.write(response.content)
-        else:
-            print(f"Failed to download the file. Status code: {response.status_code}")
-
-
-
-    #######################################################
-    # Binders
-    ## Binder Relationships
-    #######################################################
-
-    def retrieve_binder_relationship(self, binder_id, major_version, minor_version, relationship_id):
-        """
-        Retrieve information about a specific binder relationship using its ID. This method returns details such as the source document ID, relationship type, creation date, etc.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-relationship
-
-        :param binder_id: The ID of the binder.
-        :type binder_id: str
-        :param major_version: The major version number of the binder.
-        :type major_version: int
-        :param minor_version: The minor version number of the binder.
-        :type minor_version: int
-        :param relationship_id: The ID of the binder relationship.
-        :type relationship_id: int
-        :return: Response JSON containing the details of the binder relationship.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
-        
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to retrieve binder relationship. Status code: {response.status_code}"}
-
-    def create_binder_relationship(self, binder_id, major_version, minor_version, target_doc_id, relationship_type, target_major_version=None, target_minor_version=None):
-        """
-        Create a relationship between a binder and a target document in the Vault. You can specify the versions of the target document to create a relationship with a specific version.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-relationship
-
-        :param binder_id: The ID of the binder.
-        :type binder_id: str
-        :param major_version: The major version number of the binder.
-        :type major_version: int
-        :param minor_version: The minor version number of the binder.
-        :type minor_version: int
-        :param target_doc_id: The document ID of the target document.
-        :type target_doc_id: int
-        :param relationship_type: The relationship type for creating the binder relationship.
-        :type relationship_type: str
-        :param target_major_version: The major version number of the target document (optional).
-        :type target_major_version: int, optional
-        :param target_minor_version: The minor version number of the target document (optional).
-        :type target_minor_version: int, optional
-        :return: Response JSON containing the status of the creation operation and the ID of the created relationship.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships"
-        
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-        
-        data = {
-            'target_doc_id__v': target_doc_id,
-            'relationship_type__v': relationship_type,
-        }
-        
-        if target_major_version is not None:
-            data['target_major_version__v'] = target_major_version
-        
-        if target_minor_version is not None:
-            data['target_minor_version__v'] = target_minor_version
-
-        response = requests.post(url, headers=headers, data=data)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to create binder relationship. Status code: {response.status_code}"}
-
-
-    def delete_binder_relationship(self, binder_id, major_version, minor_version, relationship_id):
-        """
-        Deletes a specified relationship from a binder in the Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder-relationship
-
-        :param binder_id: The ID of the binder.
-        :type binder_id: str
-        :param major_version: The major version number of the binder.
-        :type major_version: int
-        :param minor_version: The minor version number of the binder.
-        :type minor_version: int
-        :param relationship_id: The ID of the relationship to be deleted.
-        :type relationship_id: int
-        :return: Response JSON containing the status of the deletion operation and the ID of the deleted relationship.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
-        
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-        
-        response = requests.delete(url, headers=headers)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to delete binder relationship. Status code: {response.status_code}"} 
-
-
-    #######################################################
-    # Binders
-    ## Binder Sections
-    #######################################################
-    def retrieve_binder_sections(self, binder_id, section_id=None):
-        """
-        Retrieve all sections (documents and subsections) in a binder's top-level root node or sub-level node.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-sections
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param section_id: Optional: The section id to retrieve sections from a sub-level node. If not included, all sections from the binder’s top-level root node will be returned.
-        :type section_id: str, optional
-        :return: Response JSON containing details of all sections (documents and subsections) in a binder's top-level root node or sub-level node.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections"
-        if section_id:
-            url += f"/{section_id}"
-
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to retrieve binder sections. Status code: {response.status_code}"} 
-
-
-    def retrieve_binder_version_section(self, binder_id, major_version, minor_version, section_id=None):
-        """
-        For a specific version, retrieve all sections (documents and subsection) in a binder’s top-level root node or sub-level node.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-version-section
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param major_version: The binder major version number field value.
-        :type major_version: str
-        :param minor_version: The binder minor version number field value.
-        :type minor_version: str
-        :param section_id: Optional: The section id to retrieve sections from a sub-level node. If not included, all sections from the binder’s top-level root node will be returned.
-        :type section_id: str, optional
-        :return: Response JSON containing details of all sections (documents and subsections) in a binder's top-level root node or sub-level node for the specified version.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/sections"
-        if section_id:
-            url += f"/{section_id}"
-        
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to retrieve binder version section. Status code: {response.status_code}"} 
-
-    def create_binder_section(self, binder_id, name, section_number=None, parent_id=None, order=None):
-        """
-        Create a new section in a binder.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-section
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param name: Specify a name for the new section.
-        :type name: str
-        :param section_number: Optional: Enter a numerical value for the new section.
-        :type section_number: str, optional
-        :param parent_id: Optional: If the new section is going to be a subsection, enter the Node ID of the parent section. If left blank, the new section will become a top-level section in the binder. 
-        :type parent_id: str, optional
-        :param order: Optional: Enter a number reflecting the position of the section within the binder or parent section.
-        :type order: int, optional
-        :return: Response JSON containing the Node ID of the newly created section.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections"
-
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        data = {
-            'name__v': name,
-        }
-        if section_number:
-            data['section_number__v'] = section_number
-        if parent_id:
-            data['parent_id__v'] = parent_id
-        if order:
-            data['order__v'] = order
-
-        response = requests.post(url, headers=headers, data=data)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to create binder section. Status code: {response.status_code}"} 
-
-    def update_binder_section(self, binder_id, node_id, name=None, section_number=None, order=None, parent_id=None):
-        """
-        Update a section in a binder.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-section
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param node_id: The binder node id of the section.
-        :type node_id: str
-        :param name: Optional: Change the name of the binder section.
-        :type name: str, optional
-        :param section_number: Optional: Update the section number value.
-        :type section_number: str, optional
-        :param order: Optional: Enter a number reflecting the position of the section within the binder or parent section.
-        :type order: int, optional
-        :param parent_id: Optional: To move the section to a different section in the binder, include the value of the parent node where it will be moved.
-        :type parent_id: str, optional
-        :return: Response JSON containing the Node ID of the updated section.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections/{node_id}"
-        
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-        
-        data = {}
-        if name:
-            data['name__v'] = name
-        if section_number:
-            data['section_number__v'] = section_number
-        if order:
-            data['order__v'] = order
-        if parent_id:
-            data['parent_id__v'] = parent_id
-
-        response = requests.put(url, headers=headers, data=data)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to update binder section. Status code: {response.status_code}"}
-
-
-    def delete_binder_section(self, binder_id, section_id):
-        """
-        Delete a section from a binder.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder-section
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param section_id: The binder node id field value.
-        :type section_id: str
-        :return: Response JSON containing the Node ID of the deleted section.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections/{section_id}"
-        
-        headers = {
-            'Content-Type': 'application/json',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-        
-        response = requests.delete(url, headers=headers)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to delete binder section. Status code: {response.status_code}"}
-
-
-
-    #######################################################
-    # Binders
-    ## Binder Documents
-    #######################################################
-
-    def add_document_to_binder(self, binder_id, document_id, parent_id=None, order=None, binding_rule=None, major_version_number=None, minor_version_number=None):
-        """
-        Add a document to a binder.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#add-document-to-binder
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param document_id: ID of the document being added to the binder.
-        :type document_id: str
-        :param parent_id: Section ID of the parent section (optional).
-        :type parent_id: str, optional
-        :param order: Position of the document within the binder or section (optional).
-        :type order: int, optional
-        :param binding_rule: The binding rule indicating which version of the document will be linked to the binder (optional).
-        :type binding_rule: str, optional
-        :param major_version_number: Major version of the document to be linked (optional).
-        :type major_version_number: int, optional
-        :param minor_version_number: Minor version of the document to be linked (optional).
-        :type minor_version_number: int, optional
-        :return: Response JSON containing the Node ID of the added document.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/documents"
-        
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-        
-        data = {
-            'document_id__v': document_id,
-            'parent_id__v': parent_id,
-            'order__v': order,
-            'binding_rule__v': binding_rule,
-            'major_version_number__v': major_version_number,
-            'minor_version_number__v': minor_version_number,
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to add document to binder. Status code: {response.status_code}"}
-
-
-    def move_document_in_binder(self, binder_id, section_id, order=None, parent_id=None):
-        """
-        Move a document to a different position within a binder.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#move-document-in-binder
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param section_id: The binder node id field value.
-        :type section_id: str
-        :param order: A number reflecting the new position of the document within the binder or section (optional).
-        :type order: int, optional
-        :param parent_id: Value of the new parent node to move the document to a different section or to the binder's root node (optional).
-        :type parent_id: str, optional
-        :return: Response JSON containing the new node ID of the document.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/documents/{section_id}"
-
-        headers = {
-            'Content-Type': 'application/x-www-form-urlencoded',
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        data = {
-            'order__v': order,
-            'parent_id__v': parent_id,
-        }
-
-        response = requests.put(url, headers=headers, data=data)
-
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to move document in binder. Status code: {response.status_code}"}
-
-
-    def remove_document_from_binder(self, binder_id, section_id):
-        """
-        Remove a document from a binder.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#remove-document-from-binder
-
-        :param binder_id: The binder id field value.
-        :type binder_id: str
-        :param section_id: The binder node id field value.
-        :type section_id: str
-        :return: Response JSON containing the Node ID of the deleted document.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/documents/{section_id}"
-
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        response = requests.delete(url, headers=headers)
-
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to remove document from binder. Status code: {response.status_code}"}
-
-
-
-
-    #######################################################
-    # Binders
-    ## Binder Templates
-    #######################################################
-
-    def retrieve_binder_template_metadata(self):
-        """
-        Retrieve the metadata which defines the shape of binder templates in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-metadata
-
-        :return: Response JSON containing metadata of binder templates.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/binders/templates"
-
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        response = requests.get(url, headers=headers)
-
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to retrieve binder template metadata. Status code: {response.status_code}"}
-
-    def retrieve_binder_template_node_metadata(self):
-        """
-        Retrieve the metadata which defines the shape of binder template nodes in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-node-metadata
-
-        :return: Response JSON containing metadata of binder template nodes.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/binders/templates/bindernodes"
-
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        response = requests.get(url, headers=headers)
-
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to retrieve binder template node metadata. Status code: {response.status_code}"} 
-
-    def retrieve_binder_template_collection(self):
-        """
-        Retrieve the collection of all binder templates in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-collection
-
-        :return: Response JSON containing the collection of binder templates.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates"
-
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        response = requests.get(url, headers=headers)
-
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to retrieve binder template collection. Status code: {response.status_code}"} 
-
-
-    def retrieve_binder_template_attributes(self, template_name):
-        """
-        Retrieve the attributes of a specific binder template in your Vault.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-attributes
-
-        :param template_name: The binder template name__v field value.
-        :type template_name: str
-        :return: Response JSON containing the attributes of the specified binder template.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}"
-
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': self.sessionId,
-        }
-
-        response = requests.get(url, headers=headers)
-
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return {'error': f"Failed to retrieve binder template attributes. Status code: {response.status_code}"}
-
-
-    def retrieve_binder_template_node_attributes(self, template_name):
-        """
-        Retrieves the attributes of each node (folder/section) of a specific binder template in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-node-attributes
-
-        :param template_name: The binder template name__v field value.
-        :return: A JSON object containing the attributes of each node of a specific binder template in the Vault.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}/bindernodes"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def create_binder_template(self, label_v, type_v, active_v, name_v=None, subtype_v=None, classification_v=None):
-        """
-        Create a new binder template in your Vault.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-template
-        
-        Parameters:
-        label_v (str): The label of the new binder template. This is the name users will see among the available binder templates in the UI.
-        type_v (str): The name of the document type to which the template will be associated.
-        active_v (bool): Set to true or false to indicate whether or not the new binder template should be set to active, i.e., available for selection when creating a binder.
-        name_v (str, optional): The name of the new binder template. If not included, Vault will use the specified label_v value to generate a value for the name_v field.
-        subtype_v (str, optional): The name of the document subtype to which the template will be associated. This is only required if associating the template with a document subtype.
-        classification_v (str, optional): The name of the document classification to which the template will be associated. This is only required if associating the template with a document classification.
-        
-        Returns:
-        response (dict): The response from the API call.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        data = {
-            "label__v": label_v,
-            "type__v": type_v,
-            "active__v": str(active_v).lower()
-        }
-        
-        if name_v:
-            data["name__v"] = name_v
-        if subtype_v:
-            data["subtype__v"] = subtype_v
-        if classification_v:
-            data["classification__v"] = classification_v
-        
-        response = requests.post(url, headers=headers, data=data).json()
-        
-        return response.json()
-
-    def bulk_create_binder_templates(self, file_path):
-        """
-        Bulk create from 1-500 new binder templates in your Vault.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#bulk-create-binder-templates
-        
-        Parameters:
-        file_path (str): The path to the CSV file containing the data of the binder templates to be created.
-        
-        Returns:
-        response (dict): The response from the API call.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-        
-        with open(file_path, 'rb') as file:
-            response = requests.post(url, headers=headers, data=file).json()
-        
-        return response.json()
-
-
-    def create_binder_template_node(self, template_name, file_path):
-        """
-        Create nodes in an existing binder template.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-template-node
-        
-        Parameters:
-        template_name (str): The binder template name__v field value.
-        file_path (str): The path to the CSV file containing the data of the binder nodes to be created.
-        
-        Returns:
-        response (dict): The response from the API call.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}/bindernodes"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-        
-        with open(file_path, 'rb') as file:
-            response = requests.post(url, headers=headers, data=file).json()
-        
-        return response.json()
-
-
-    def update_binder_template(self, template_name, payload):
-        """
-        Update an existing binder template in your Vault.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-template
-        
-        Parameters:
-        template_name (str): The binder template name__v field value.
-        payload (dict): The data containing the fields to update. 
-        
-        Returns:
-        response (str): The response from the API call in text/csv format.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "text/csv"
-        }
-        
-        response = requests.put(url, headers=headers, data=payload).text
-        
-        return response.json()
-
-
-    def bulk_update_binder_templates(self, file_path):
-        """
-        Bulk update from 1-500 binder templates in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#bulk-update-binder-templates
-        
-        Parameters:
-        file_path (str): The path to the CSV input file with details of binder templates to be updated.
-        
-        Returns:
-        response (json): The response from the API call, which includes the status and details of each update.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "text/csv",
-            "Accept": "text/csv"
-        }
-        
-        with open(file_path, 'rb') as f:
-            response = requests.put(url, headers=headers, data=f).json()
-        
-        return response.json()
-
-
-    def replace_binder_template_nodes(self, template_name, input_data):
-        """
-        Replace all binder nodes in an existing binder template. This action removes all existing nodes and replaces them with those specified in the input.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#replace-binder-template-nodes
-        
-        Parameters:
-        template_name (str): The binder template name__v field value.
-        input_data (str or dict): The input data in JSON format or the path to the CSV file containing the nodes to be replaced.
-        
-        Returns:
-        response (json): The response from the API call, which indicates the success or failure of the operation.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}/bindernodes"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        if isinstance(input_data, dict):
-            response = requests.put(url, headers=headers, json=input_data).json()
-        else:
-            with open(input_data, 'rb') as f:
-                headers["Content-Type"] = "text/csv"
-                response = requests.put(url, headers=headers, data=f).json()
-        
-        return response.json()
-
-
-    def delete_binder_template(self, template_name):
-        """
-        Delete an existing binder template from your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder-template
-        
-        Parameters:
-        template_name (str): The binder template name__v field value.
-        
-        Returns:
-        response (json): The response from the API call, which indicates the success or failure of the operation.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.delete(url, headers=headers).json()
-        
-        return response.json()
-
-
-    #######################################################
-    # Binders
-    ## Binding Rules
-    #######################################################
-
-    def update_binding_rule(self, binder_id, binding_rule__v=None, binding_rule_override__v=None):
-        """
-        Update a binding rule in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-binding-rule
-
-        Parameters:
-        binder_id (str): The binder id field value.
-        binding_rule__v (str): Optional. Indicates which binding rule to apply. Options are: 'default', 'steady-state', or 'current'.
-        binding_rule_override__v (bool): Optional. Indicates if the specified binding rule should override documents or sections which already have binding rules set.
-
-        Returns:
-        response (json): The response from the API call, which indicates the success or failure of the operation.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/binding_rule"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        data = {
-            "binding_rule__v": binding_rule__v,
-            "binding_rule_override__v": binding_rule_override__v
-        }
-        
-        response = requests.put(url, headers=headers, data=data).json()
-        
-        return response.json()
-
-
-    def update_binder_section_binding_rule(self, binder_id, node_id, binding_rule__v=None, binding_rule_override__v=None):
-        """
-        Update a binding rule for a specific section in a binder in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-section-binding-rule
-
-        Parameters:
-        binder_id (str): The binder id field value.
-        node_id (str): The binder node id field value.
-        binding_rule__v (str): Optional. Indicates which binding rule to apply. Options are: 'default', 'steady-state', or 'current'.
-        binding_rule_override__v (bool): Optional. Indicates if the specified binding rule should override documents or sections which already have binding rules set.
-
-        Returns:
-        response (json): The response from the API call, which indicates the success or failure of the operation, along with the Node ID of the updated section.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections/{node_id}/binding_rule"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        data = {
-            "binding_rule__v": binding_rule__v,
-            "binding_rule_override__v": binding_rule_override__v
-        }
-        
-        response = requests.put(url, headers=headers, data=data).json()
-        
-        return response.json()
-
-
-    def update_binder_document_binding_rule(self, binder_id, node_id, binding_rule__v=None, major_version_number__v=None, minor_version_number__v=None):
-        """
-        Update the binding rule for a document node within a binder in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-document-binding-rule
-
-        Parameters:
-        binder_id (str): The binder id field value.
-        node_id (str): The binder node id field value.
-        binding_rule__v (str): Optional. Indicates which binding rule to apply. Options are: 'default', 'steady-state', 'current', or 'specific'.
-        major_version_number__v (int): Optional. Required if binding_rule is 'specific'. Indicates the major version of the document to be linked.
-        minor_version_number__v (int): Optional. Required if binding_rule is 'specific'. Indicates the minor version of the document to be linked.
-
-        Returns:
-        response (json): The response from the API call, which indicates the success or failure of the operation, along with the Node ID of the updated document node within the binder.
-        """
-        
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/documents/{node_id}/binding_rule"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        data = {
-            "binding_rule__v": binding_rule__v,
-            "major_version_number__v": major_version_number__v,
-            "minor_version_number__v": minor_version_number__v
-        }
-        
-        response = requests.put(url, headers=headers, data=data).json()
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Vault Objects
-    #######################################################
-
-
-    def retrieve_object_metadata(self, object_name, loc=False):
-        """
-        Retrieve all metadata configured on a standard or custom Vault Object.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-metadata
-        
-        Parameters:
-        object_name (str): The object name__v field value. For example, product__v, country__v, custom_object__c.
-        loc (bool): Set to true to retrieve the localized_data array, which contains the localized (translated) strings 
-                    for the label and label_plural object fields. If omitted, defaults to false and localized Strings are not included.
-                    
-        Returns:
-        dict: Response data containing metadata information.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}"
-        headers = {
-            'Accept': 'application/json',
-            'Authorization': f"{self.sessionId}"
-        }
-        
-        params = {
-            'loc': loc
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-    def retrieve_object_field_metadata(self, object_name, object_field_name, loc=False):
-        """
-        Retrieves metadata for a specified field of a specified object in the vault. 
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-field-metadata
-        
-        Parameters:
-            object_name (str): The object name__v field value (e.g., product__v, country__v, custom_object__c).
-            object_field_name (str): The object field name value (e.g., id, name__v, external_id__v).
-            loc (bool): Set to true to retrieve the localized_data array. Defaults to false.
-            
-        Returns:
-            dict: A dictionary containing the metadata of the specified object field.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}/fields/{object_field_name}"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {
-            "loc": loc
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            response.raise_for_status()
-
-
-    def retrieve_object_collection(self, loc=False):
-        """
-        Retrieve all Vault objects in the authenticated Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-collection
-        
-        Parameters:
-            loc (bool): Set to true to retrieve localized (translated) strings for the label and label_plural object fields. Defaults to false.
-        
-        Returns:
-            dict: A dictionary containing a summary of key information for all standard and custom Vault Objects configured in your Vault.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects"
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {
-            "loc": loc
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        if response.status_code == 200:
-            return response.json()
-        else:
-            response.raise_for_status()
-
-
-    def retrieve_object_record_collection(self, object_name, fields=None, limit=None, offset=None, sort=None):
-        """
-        Retrieves all records for a specific Vault Object.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-collection
-        
-        Args:
-            object_name (str): The object name__v field value. For example, product__v, country__v, custom_object__c.
-            fields (str, optional): To specify fields to retrieve, include the parameter fields={FIELD_NAMES}. Defaults to None.
-            limit (int, optional): The number of records to return per page, maximum 200. Defaults to None.
-            offset (int, optional): The starting point for the return of the records. Defaults to None.
-            sort (str, optional): The sorting parameter in the format "field_name order". For example, "name__v desc". Defaults to None.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}"
-        
-        params = {}
-        if fields:
-            params['fields'] = fields
-        if limit:
-            params['limit'] = limit
-        if offset:
-            params['offset'] = offset
-        if sort:
-            params['sort'] = sort
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_object_record(self, object_name, object_record_id):
-        """
-        Retrieves metadata configured on a specific object record in your Vault.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record
-        
-        Args:
-            object_name (str): The object name__v field value (product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def create_object_records(self, object_name, data, content_type='text/csv', accept='text/csv', additional_headers=None):
-        """
-        Create Vault object records in bulk using the specified endpoint. For detailed documentation refer to:
-        https://developer.veevavault.com/api/23.2/#create-object-records
-        
-        Args:
-            object_name (str): The name of the object (e.g., product__v).
-            data (str): The data to be sent in the request body (file path or JSON).
-            content_type (str, optional): The content type of the request. Defaults to 'text/csv'.
-            accept (str, optional): The accept header specifying the response format. Defaults to 'text/csv'.
-            additional_headers (dict, optional): Additional headers to be included in the request. Defaults to None.
-        
-        Returns:
-            dict: The response data in dictionary format.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": content_type,
-            "Accept": accept,
-        }
-        
-        if additional_headers:
-            headers.update(additional_headers)
-        
-        with open(data, 'rb') as f:
-            response = requests.post(url, headers=headers, data=f)
-        
-        return response.json()
-
-
-    def update_object_records(self, object_name, data, id_param=None, migration_mode=None):
-        """
-        Updates object records in bulk. You can use this method to update user records (user__sys).
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-object-records
-
-        Args:
-            object_name (str): The name of the object, for example, product__v.
-            data (dict): The data to update in either JSON or CSV format.
-            id_param (str, optional): To identify objects in your input by a unique field, add idParam={field_name} to the request endpoint. Defaults to None.
-            migration_mode (bool, optional): If set to true, Vault bypasses entry criteria, entry actions, validation rules, and reference constraints when updating object records. Defaults to None.
-
-        Returns:
-            dict: The response from the API.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        if migration_mode is not None:
-            headers["X-VaultAPI-MigrationMode"] = str(migration_mode)
-        
-        response = requests.put(url, headers=headers, json=data)
-        if id_param:
-            url += f"?idParam={id_param}"
-            response = requests.put(url, headers=headers, json=data)
-        
-        return response.json()
-
-
-    def delete_object_records(self, object_name, data, id_param=None):
-        """
-        Deletes object records in bulk. This method cannot be used to delete user__sys records. 
-        Use the update_object_records method to set the status__v field to inactive for user__sys records.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-object-records
-
-        Args:
-            object_name (str): The name of the object, e.g., product__v.
-            data (dict): The data to delete in either JSON or CSV format, containing ids or external_ids.
-            id_param (str, optional): If you’re identifying objects in your input by a unique field, add this parameter. Defaults to None.
-
-        Returns:
-            dict: The response from the API.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        if id_param:
-            url += f"?idParam={id_param}"
-        
-        response = requests.delete(url, headers=headers, json=data)
-        
-        return response.json()
-
-    def cascade_delete_object_record(self, object_name, object_record_id):
-        """
-        This asynchronous method deletes a single parent object record and all related children and grandchildren.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#cascade-delete-object-record
-
-        Args:
-            object_name (str): The name of the object to delete.
-            object_record_id (str): The ID of the specific object record to delete.
-
-        Returns:
-            dict: The response from the API, including job ID and URL to track the status of the deletion.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions/cascadedelete"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_cascade_delete_results(self, object_name, job_status, job_id):
-        """
-        This method retrieves the results of a cascade delete job. Before submitting this request:
-        - You must have previously requested a cascade delete job (via the API) which is no longer active.
-        - You must have a valid job_id value, retrieved from the response of the cascade delete request.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-results-of-cascade-delete-job
-
-        Args:
-            object_name (str): The name of the object which was deleted.
-            job_status (str): Possible values are 'success' or 'failure'. It is used to determine the job status.
-            job_id (str): The ID of the job, retrieved from the response of the job request.
-
-        Returns:
-            Response: The response from the API with the details of the deleted records.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/cascadedelete/results/{object_name}/{job_status}/{job_id}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "text/csv"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.text
-
-
-
-    #######################################################
-    # Vault Objects
-    ## Object Types
-    #######################################################
-
-    def retrieve_details_from_all_object_types(self):
-        """
-        This method retrieves details from all object types. It lists all object types and all fields configured on each object type.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-details-from-all-object-types
-
-        Returns:
-            Response: The response from the API with the details of all object types and fields configured on each type.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/Objecttype"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_details_from_specific_object(self, object_name_and_object_type):
-        """
-        This method retrieves details from a specific object. It lists all object types and all fields configured on each object type for the specified object.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-details-from-a-specific-object
-
-        Args:
-            object_name_and_object_type (str): The object name followed by the object type in the format Objecttype.{object_name}.{object_type}. 
-
-        Returns:
-            Response: The response from the API listing all object types and fields configured on the specific object.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/{object_name_and_object_type}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-    def change_object_type(self, object_name, payload):
-        """
-        This method is used to change the object types assigned to object records. Field values which exist on both the original and new object type will carry over to the new type. All other field values will be removed as only fields on the new type are valid. You can set field values on the new object type in the payload input.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#change-object-type
-
-        Args:
-            object_name (str): The name of the object.
-            payload (dict): A dictionary containing at least the "id" and "object_type__v" keys. The "id" key should map to the ID of the object record and the "object_type__v" key should map to the ID of the new object type.
-
-        Returns:
-            Response: The response from the API after attempting to change the object type.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/actions/changetype"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers, json=payload)
-        
-        return response.json()
-
-
-
-
-
-    #######################################################
-    # Vault Objects
-    ## Object Roles
-    #######################################################
-
-
-
-
-    def retrieve_object_record_roles(self, object_name, record_id, role_name=None):
-        """
-        This method is used to retrieve manually assigned roles on an object record along with the users and groups assigned to those roles.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-roles
-
-        Args:
-            object_name (str): The name of the object.
-            record_id (str): The ID of the document, binder, or object record.
-            role_name (str, optional): Role name to filter for a specific role, e.g., owner__v. Defaults to None.
-
-        Returns:
-            Response: The response from the API containing the roles and their details.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        role_name_path = f"/{role_name}" if role_name else ""
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{record_id}/roles{role_name_path}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def assign_users_groups_to_roles_on_object_records(self, object_name, request_body):
-        """
-        This method allows to assign users and groups to roles on an object record in bulk.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#assign-users-amp-groups-to-roles-on-object-records
-
-        Args:
-            object_name (str): The name of the object where you want to update records.
-            request_body (str or dict): JSON or CSV input file as string or dictionary. User and group assignments are 
-                                        ignored if they are invalid, inactive, or already exist.
-        
-        Returns:
-            Response: The response from the API, which includes the object record ID on success.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/roles"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers, data=json.dumps(request_body))
-        
-        return response.json()
-
-
-    def remove_users_groups_from_roles_on_object_records(self, object_name, request_body):
-        """
-        This method allows to remove users and groups from roles on an object record in bulk.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#remove-users-amp-groups-from-roles-on-object-records
-
-        Args:
-            object_name (str): The name of the object where you want to remove roles.
-            request_body (str or dict): JSON or CSV input file as string or dictionary. Users and groups are ignored if they are 
-                                        invalid or inactive.
-        
-        Returns:
-            Response: The response from the API, which includes the object record ID on success.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/roles"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        response = requests.delete(url, headers=headers, data=json.dumps(request_body))
-        
-        return response.json()
-
-
-
-
-
-    #######################################################
-    # Vault Objects
-    ## Object Record Attachments
-    #######################################################
-
-    def determine_if_attachments_are_enabled_on_an_object(self, object_name):
-        """
-        This method helps to determine if attachments are enabled on a specific object.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#determine-if-attachments-are-enabled-on-an-object
-
-        Args:
-            object_name (str): The value of object name__v field (like product__v, country__v, custom_object__c, etc.).
-        
-        Returns:
-            Response: API response which includes details such as if "allow_attachments" is set to true and other object metadata.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_object_record_attachments(self, object_name, object_record_id):
-        """
-        Retrieve a list of all attachments on a specific object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-attachments
-
-        Args:
-            object_name (str): The value of object name__v field (like product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-
-        Returns:
-            Response: API response which includes details such as a list of attachments along with their respective details and versions.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_object_record_attachment_metadata(self, object_name, object_record_id, attachment_id):
-        """
-        Retrieve the metadata of a specific attachment on a specific object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-attachment-metadata
-
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-
-        Returns:
-            Response: API response which includes metadata details of the specified attachment.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_object_record_attachment_versions(self, object_name, object_record_id, attachment_id):
-        """
-        Retrieve all versions of a specific attachment on a specific object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-attachment-versions
-
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-
-        Returns:
-            Response: API response which includes version details of the specified attachment.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_object_record_attachment_version_metadata(self, object_name, object_record_id, attachment_id, attachment_version):
-        """
-        Retrieve the metadata of a specific version of an attachment on a specific object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-attachment-version-metadata
-
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-            attachment_version (str): The attachment version__v field value.
-
-        Returns:
-            Response: API response which includes metadata of the specified attachment version.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-    def download_object_record_attachment_file(self, object_name, object_record_id, attachment_id):
-        """
-        Download the file of a specific attachment on a specific object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#download-object-record-attachment-file
-
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-
-        Returns:
-            Response: The API response containing the attachment file.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/file"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers, stream=True)
-        
-        with open('downloaded_attachment_file', 'wb') as file:
-            for chunk in response.iter_content(chunk_size=8192):
-                file.write(chunk)
-        
-        return "File downloaded successfully"
-
-
-    def download_object_record_attachment_version_file(self, object_name, object_record_id, attachment_id, attachment_version):
-        """
-        Downloads a specific version of an attachment file from a specific object record.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#download-object-record-attachment-version-file
-        
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-            attachment_version (str): The attachment version__v field value.
-
-        Returns:
-            str: Message indicating the success of the file download.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}/file"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers, stream=True)
-        
-        with open('downloaded_attachment_version_file', 'wb') as file:
-            for chunk in response.iter_content(chunk_size=8192):
-                file.write(chunk)
-        
-        return "File downloaded successfully"
-
-
-    def download_all_object_record_attachment_files(self, object_name, object_record_id):
-        """
-        Downloads the latest version of all attachment files from a specific object record, packaged in a ZIP file.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#download-all-object-record-attachment-files
-        
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-
-        Returns:
-            str: Message indicating the success of the file download.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/file"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers, stream=True)
-        
-        with open('downloaded_all_attachment_files.zip', 'wb') as file:
-            for chunk in response.iter_content(chunk_size=8192):
-                file.write(chunk)
-        
-        return "File downloaded successfully"
-
-
-    def create_object_record_attachment(self, object_name, object_record_id, file_path):
-        """
-        Creates a single object record attachment. If the attachment already exists, Vault uploads the attachment 
-        as a new version of the existing attachment. The maximum allowed file size is 4GB.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-object-record-attachment
-        
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-            file_path (str): The path to the file to be uploaded.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        files = {'file': open(file_path, 'rb')}
-        
-        response = requests.post(url, headers=headers, files=files)
-        
-        return response.json()
-
-
-
-    def create_multiple_object_record_attachments(self, object_name, input_file_path, content_type='text/csv', accept='application/json'):
-        """
-        Creates multiple object record attachments in bulk using a JSON or CSV input file. The attachments are first 
-        loaded to the file staging server. The maximum input file size is 1GB, and the maximum batch size is 500.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-multiple-object-record-attachments
-
-        Args:
-            object_name (str): The value of the object name__v field (like veterinary_patient__c, product__v, etc.).
-            input_file_path (str): The path to the input file (CSV or JSON) containing details of attachments to be created.
-            content_type (str): The content type of the input file, either 'application/json' or 'text/csv'. Defaults to 'text/csv'.
-            accept (str): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/attachments/batch"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": content_type,
-            "Accept": accept
-        }
-        
-        with open(input_file_path, 'rb') as input_file:
-            data = input_file.read()
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-    def restore_object_record_attachment_version(self, object_name, object_record_id, attachment_id, attachment_version):
-        """
-        Restores a specific version of an attachment on an object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#restore-object-record-attachment-version
-
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-            attachment_version (str): The attachment version__v field value.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}?restore=true"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers)
-        
-        return response.json()
-
-    def update_object_record_attachment_description(self, object_name, object_record_id, attachment_id, description):
-        """
-        Updates the description of a specific attachment on an object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-object-record-attachment-description
-
-        Args:
-            object_name (str): The value of the object name__v field (like product__v, country__v, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-            description (str): The new description for the attachment. The maximum length is 1000 characters.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        data = {
-            "description__v": description
-        }
-        
-        response = requests.put(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-
-    def update_multiple_object_record_attachment_descriptions(self, object_name, input_file_path, content_type='text/csv', accept='application/json'):
-        """
-        Update multiple object record attachment descriptions in bulk using a JSON or CSV input file.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-multiple-object-record-attachment-descriptions
-
-        Args:
-            object_name (str): The object name__v field value (e.g., veterinary_patient__c).
-            input_file_path (str): The path to the input CSV or JSON file.
-            content_type (str, optional): The content type of the input file, either 'application/json' or 'text/csv'. Defaults to 'text/csv'.
-            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/attachments/batch"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": content_type,
-            "Accept": accept
-        }
-
-        with open(input_file_path, 'rb') as f:
-            response = requests.put(url, headers=headers, data=f)
-
-        return response.json()
-
-
-    def delete_object_record_attachment(self, object_name, object_record_id, attachment_id, accept='application/json'):
-        """
-        Deletes a single object record attachment.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-object-record-attachment
-
-        Args:
-            object_name (str): The object name__v field value (e.g., product__v, country__v, custom_object__c, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": accept
-        }
-
-        response = requests.delete(url, headers=headers)
-        
-        return response.json()
-
-
-    def delete_multiple_object_record_attachments(self, object_name, attachments_data, content_type='application/json', accept='application/json', id_param=None):
-        """
-        Deletes multiple object record attachments in bulk with a JSON or CSV input file. 
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-object-record-attachments
-
-        Args:
-            object_name (str): The object name__v field value (e.g., veterinary_patient__c, product__v, etc.).
-            attachments_data (str): JSON or CSV formatted string containing details of the attachments to be deleted.
-            content_type (str, optional): The format of the input data, either 'application/json' or 'text/csv'. Defaults to 'application/json'.
-            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
-            id_param (str, optional): If identifying attachments by external id, add idParam=external_id__v to the request endpoint. Defaults to None.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/attachments/batch"
-        if id_param:
-            url += f"?idParam={id_param}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": accept,
-            "Content-Type": content_type
-        }
-
-        response = requests.delete(url, headers=headers, data=attachments_data)
-        
-        return response.json()
-
-
-    def delete_object_record_attachment_version(self, object_name, object_record_id, attachment_id, attachment_version, accept='application/json'):
-        """
-        Deletes a specific version of an object record attachment.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-object-record-attachment-version
-
-        Args:
-            object_name (str): The object name__v field value (e.g., product__v, country__v, etc.).
-            object_record_id (str): The object record id field value.
-            attachment_id (str): The attachment id field value.
-            attachment_version (str): The attachment version__v field value.
-            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": accept
-        }
-
-        response = requests.delete(url, headers=headers)
-        
-        return response.json()
-
-
-
-
-
-
-    #######################################################
-    # Vault Objects
-    ## Object Page Layouts
-    #######################################################
-
-    def retrieve_page_layouts(self, object_name, accept='application/json'):
-        """
-        Retrieves all page layouts associated with the specified object.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-page-layouts
-
-        Args:
-            object_name (str): The name of the object from which to retrieve page layouts.
-            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}/page_layouts"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": accept
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_page_layout_metadata(self, object_name, layout_name, accept='application/json'):
-        """
-        Retrieves the metadata for the specified page layout.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-page-layout-metadata
-
-        Args:
-            object_name (str): The name of the object from which to retrieve page layout metadata.
-            layout_name (str): The name of the page layout from which to retrieve metadata.
-            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}/page_layouts/{layout_name}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": accept
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-    async def retrieve_all_page_layout_metadata_for_object(self, object_name):
-        """
-        Asynchronously retrieves all page layout metadata for a specified object.
-
-        This function performs the following steps:
-        1. Retrieves all page layouts for the specified object.
-        2. Converts the retrieved page layouts data to a pandas DataFrame.
-        3. Retrieves the metadata for each page layout asynchronously.
-        4. Converts the retrieved page layout metadata to a pandas DataFrame.
-        
-        Args:
-            object_name (str): The name of the object for which to retrieve the page layout metadata.
-
-        Returns:
-            pd.DataFrame: A DataFrame containing the page layout metadata for the specified object.
-
-        Usage:
-            >>> page_layouts_df = asyncio.run(retrieve_all_page_layout_metadata_for_object('my_object_name'))
-        """
-        page_layouts = self.retrieve_page_layouts(object_name)['data']
-        page_layouts_df = pd.DataFrame(page_layouts)
-        
-        async_retrieve_page_layout_metadata = async_wrap(self.retrieve_page_layout_metadata)
-        
-        page_layout_names = page_layouts_df['name'].tolist()
-        
-        page_layout_metadata = await asyncio.gather(*[async_retrieve_page_layout_metadata(object_name, page_layout_name) for page_layout_name in page_layout_names])
-        page_layout_metadata = [x['data'] for x in page_layout_metadata]
-        
-        page_layouts_df = pd.DataFrame(page_layout_metadata)
-        
-        return page_layouts_df
-
-
-
-    #######################################################
-    # Vault Objects
-    ## Deep Copy Object Record
-    #######################################################
-
-    def deep_copy_object_record(self, object_name, object_record_ID, override_fields=None, content_type='application/json', accept='application/json'):
-        """
-        Performs a deep copy of an object record, including all of its related child and grandchild records.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#deep-copy-object-record
-
-        Args:
-            object_name (str): The name of the parent object to copy (e.g., product__v).
-            object_record_ID (str): The ID of the specific object record to copy.
-            override_fields (dict, optional): A dictionary with field names to override field values in the source record. Defaults to None.
-            content_type (str, optional): The content type of the request, either 'application/json' or 'text/csv'. Defaults to 'application/json'.
-            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
-
-        Returns:
-            dict: The API response as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_ID}/actions/deepcopy"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": content_type,
-            "Accept": accept
-        }
-
-        response = requests.post(url, headers=headers, json=override_fields)
-        
-        return response.json()
-
-    def retrieve_deep_copy_job_results(self, object_name, job_id, job_status, accept='text/csv'):
-        """
-        Retrieves the results of a deep copy job request. The function can query Vault to determine 
-        the results of a deep copy request.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-results-of-deep-copy-job
-
-        Args:
-            object_name (str): The name of the deep copied object.
-            job_id (str): The ID of the job, retrieved from the response of the job request.
-            job_status (str): The status of the job, possible values are 'success' or 'failure'.
-            accept (str, optional): The response format, defaults to 'text/csv'.
-
-        Returns:
-            Response: The API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/deepcopy/results/{object_name}/{job_status}/{job_id}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": accept
-        }
-
-        response = requests.post(url, headers=headers)
-        
-        return response.json()
-
-
-
-
-
-    #######################################################
-    # Vault Objects
-    ## Retrieve
-    #######################################################
-
-    def retrieve_deleted_object_record_id(self, object_name, start_date=None, end_date=None, limit=1000, offset=0):
-        """
-        Retrieves the IDs of object records that have been deleted from the Vault within the past 30 days. The IDs remain 
-        retrievable for 30 days post-deletion. The results can be narrowed down to a specific date and time range 
-        within the past 30 days using optional parameters.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-deleted-object-record-id
-
-        Args:
-            object_name (str): The object name__v field value (e.g., product__v, country__v, custom_object__c, etc.).
-            start_date (str, optional): A date (within the past 30 days) post which the API looks for deleted records. 
-                Dates must be formatted as YYYY-MM-DDTHH:MM:SSZ. Defaults to None.
-            end_date (str, optional): A date (within the past 30 days) before which the API looks for deleted records. 
-                Dates must be formatted as YYYY-MM-DDTHH:MM:SSZ. Defaults to None.
-            limit (int, optional): The maximum number of records per page in the response (between 1 and 1000). 
-                Defaults to 1000.
-            offset (int, optional): The offset for pagination, determining the starting point of the records 
-                in the response. Defaults to 0.
-
-        Returns:
-            Response: The API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/deletions/vobjects/{object_name}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        params = {
-            "start_date": start_date,
-            "end_date": end_date,
-            "limit": limit,
-            "offset": offset
-        }
-
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_limits_on_objects(self):
-        """
-        Retrieves the limitations imposed on the number of object records that can be created for each object 
-        (product__v, study__v, custom_object__c, etc.) in the Vault. Additionally, it retrieves the limit on the 
-        number of custom objects that can be created in the Vault and the remaining number available for creation.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-limits-on-objects
-
-        Returns:
-            Response: The API response containing details about the limits on objects.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/limits"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # Vault Objects
-    ## Update Corporate Currency Fields
-    #######################################################
-
-
-    def update_corporate_currency_fields(self, object_name, record_id=None):
-        """
-        Updates the corporate currency fields of an object record based on the rate of the currency denoted by
-        the local_currency__sys field of the specified record. It handles scenarios like when admins change 
-        the Corporate Currency setting for the vault or update the Rate setting for the local currency used by a record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-corporate-currency-fields
-
-        Args:
-            object_name (str): The object name__v field value (for example, product__v).
-            record_id (str, optional): The object record id field value. If not provided, Vault updates corporate fields of 
-                                    all records for the object.
-
-        Returns:
-            Response: The API response containing details about the job initiated for updating the corporate currency fields.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/actions/updatecorporatecurrency"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        payload = {}
-        if record_id:
-            payload['id'] = record_id
-
-        response = requests.put(url, headers=headers, json=payload)
-        
-        return response.json()
-
-
-    #######################################################
-    # Document Roles
-    #######################################################
-
-
-    def retrieve_roles(self, doc_or_binder, id, role_name=None):
-        """
-        Retrieve all available roles on a document or binder along with the users and groups assigned to them.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-roles
-
-        Args:
-            doc_or_binder (str): Specify whether to retrieve values for "documents" or "binders".
-            id (int): The id of the document, binder, or object record.
-            role_name (str, optional): Include a role name to filter for a specific role, e.g., "owner__v".
-
-        Returns:
-            Response: The API response containing the details of the roles assigned to the specified document or binder.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        role_name_endpoint = f"/{role_name}" if role_name else ""
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{doc_or_binder}/{id}/roles{role_name_endpoint}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def assign_users_and_groups_to_roles(self, document_id, roles_data):
-        """
-        Assign users and groups to roles on a single document or binder.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#assign-users-amp-groups-to-roles-on-a-single-document
-
-        Args:
-            document_id (int): The document or binder id field value.
-            roles_data (dict): A dictionary with name-value pairs of all users or groups with their corresponding roles 
-                            in the form {Role_name}.{USERS or GROUPS}: "ID1,ID2,ID3". 
-                            For example, {'reviewer__v.users': "3003,4005"}.
-
-        Returns:
-            Response: The API response containing details of users and groups successfully assigned to roles on the document or binder.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/roles"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers, data=roles_data)
-        
-        return response.json()
-
-
-    def assign_users_and_groups_to_roles_bulk(self, csv_file_path):
-        """
-        Assign users and groups to roles on multiple documents or binders in bulk.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#assign-users-amp-groups-to-roles-on-multiple-documents
-
-        Args:
-            csv_file_path (str): The path to the CSV file containing the assignment data.
-
-        Returns:
-            Response: The API response containing details of users and groups successfully assigned to roles on multiple documents or binders.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/roles/batch"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "text/csv",
-            "Accept": "text/csv"
-        }
-
-        with open(csv_file_path, 'rb') as f:
-            response = requests.post(url, headers=headers, data=f)
-
-        return response.json()
-
-
-    def remove_users_and_groups_from_role(self, doc_id, role_name_and_user_or_group, user_or_group_id):
-        """
-        Remove users and groups from roles on a single document or binder.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#remove-users-amp-groups-from-roles-on-a-single-document
-
-        Args:
-            doc_id (str): The ID value of the document or binder from which to remove roles.
-            role_name_and_user_or_group (str): The name of the role and user or group from which to remove. The format is {role_name}.{user_or_group}.
-            user_or_group_id (str): The ID value of the user or group to remove from the role.
-
-        Returns:
-            Response: The API response containing the status and details of the removal process.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/roles/{role_name_and_user_or_group}/{user_or_group_id}"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-        
-        return response.json()
-
-
-    def remove_users_and_groups_from_roles_on_multiple_documents(self, csv_file_path):
-        """
-        Remove users and groups from roles on a document or binder in bulk.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#remove-users-and-groups-from-roles-on-multiple-documents
-
-        Args:
-            csv_file_path (str): The path to the CSV file containing the details of the users and groups to be removed.
-
-        Returns:
-            Response: The API response containing the status and details of the removal process.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/roles/batch"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "text/csv",
-            "Accept": "text/csv"
-        }
-
-        with open(csv_file_path, 'rb') as f:
-            response = requests.delete(url, headers=headers, data=f)
-        
-        return response.json()
-
-
-
-
-
-
-    #######################################################
-    # Workflows
-    #######################################################
-
-
-    def retrieve_workflows(self, object_v=None, record_id_v=None, participant=None, status_v=None, offset=None, page_size=None, loc=None):
-        """
-        Retrieve all workflow instances for a specific object and object record or from a specific workflow participant.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflows
-
-        Args:
-            object_v (str, optional): To retrieve all workflows configured on an object, include the Vault object name__v. Required when the participant parameter is not used.
-            record_id_v (str, optional): To retrieve all workflows configured on an object, include the object record id field value. Required when the participant parameter is not used.
-            participant (str, optional): To retrieve all workflows available to a particular user, include the user id field value. Required when the object__v and record_id__v parameters are not used.
-            status_v (str, optional): To retrieve all workflows with specific statuses, include one or more status name__v field values.
-            offset (int, optional): Used to paginate the results, specifying the amount of offset from the first record returned.
-            page_size (int, optional): Used to paginate the results, specifying the number of records to display per page.
-            loc (bool, optional): When localized strings are available, set to true to retrieve them.
-
-        Returns:
-            Response: The API response containing details of the workflows matching the query parameters.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        params = {
-            "object__v": object_v,
-            "record_id__v": record_id_v,
-            "participant": participant,
-            "status__v": status_v,
-            "offset": offset,
-            "page_size": page_size,
-            "loc": loc
-        }
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-
-    def retrieve_workflow_details(self, workflow_id, loc=None):
-        """
-        Retrieve the details for a specific workflow.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-details
-
-        Args:
-            workflow_id (int): The ID of the workflow to retrieve details for.
-            loc (bool, optional): When localized (translated) strings are available, set to true to retrieve them.
-
-        Returns:
-            Response: The API response containing details of the specified workflow.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/{workflow_id}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        params = {
-            "loc": loc
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_workflow_actions(self, workflow_id, loc=None):
-        """
-        Retrieve all available workflow actions that can be initiated on a specific workflow.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-actions
-
-        Args:
-            workflow_id (int): The ID of the workflow to retrieve actions for.
-            loc (bool, optional): When localized (translated) strings are available, set to true to retrieve them.
-
-        Returns:
-            Response: The API response containing a list of available actions for the specified workflow.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/{workflow_id}/actions"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        params = {
-            "loc": loc
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_workflow_action_details(self, workflow_id, workflow_action):
-        """
-        Retrieve details about a specific workflow action, including any prompts necessary to complete the action.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-action-details
-
-        Args:
-            workflow_id (int): The ID of the workflow.
-            workflow_action (str): The name of the workflow action.
-
-        Returns:
-            Response: The API response containing details about the specified workflow action.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/{workflow_id}/actions/{workflow_action}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def initiate_workflow_action(self, workflow_id, workflow_action, body_parameters):
-        """
-        Initiate a specific action on a particular workflow. The necessary parameters should be specified in the body_parameters dictionary.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-workflow-action
-
-        Args:
-            workflow_id (int): The ID of the workflow.
-            workflow_action (str): The name of the workflow action.
-            body_parameters (dict): A dictionary containing the necessary parameters to initiate the workflow action.
-
-        Returns:
-            Response: The API response indicating the status of the action initiation.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/{workflow_id}/actions/{workflow_action}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers, json=body_parameters)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # Workflows
-    ## Workflow Tasks
-    #######################################################
-
-
-    def retrieve_workflow_tasks(self, query_parameters):
-        """
-        Retrieve all available workflow tasks based on the specified query parameters.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-tasks
-
-        Args:
-            query_parameters (dict): A dictionary containing the query parameters to filter the tasks.
-
-        Returns:
-            Response: The API response containing the list of available workflow tasks.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers, params=query_parameters)
-        
-        return response.json()
-
-
-    def retrieve_workflow_task_details(self, task_id, loc=None):
-        """
-        Retrieve the details of a specific workflow task.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-task-details
-
-        Args:
-            task_id (int): The ID of the workflow task to retrieve details for.
-            loc (bool, optional): Set to true to retrieve localized strings if available. Defaults to None.
-
-        Returns:
-            Response: The API response containing the details of the specified workflow task.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks/{task_id}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        params = {}
-        if loc is not None:
-            params['loc'] = loc
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_workflow_task_actions(self, task_id):
-        """
-        Retrieve all available actions that can be initiated on a given workflow task.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-task-actions
-
-        Args:
-            task_id (int): The ID of the workflow task to retrieve actions for.
-
-        Returns:
-            Response: The API response containing the available actions for the specified workflow task.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks/{task_id}/actions"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_workflow_task_action_details(self, task_id, task_action):
-        """
-        Retrieve the details of a specific workflow task action. The response lists the details of the task action, including all fields required to initiate the action.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-task-action-details
-
-        Args:
-            task_id (int): The task ID field value.
-            task_action (str): The name of the task action retrieved from Retrieve Workflow Task Actions.
-
-        Returns:
-            Response: The API response containing the details of the specified workflow task action.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks/{task_id}/actions/{task_action}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def initiate_workflow_task_action(self, task_id, task_action, data):
-        """
-        Initiate a workflow task action. Note that the API does not support initiating task actions requiring eSignatures.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-workflow-task-action
-
-        Args:
-            task_id (int): The task ID field value.
-            task_action (str): The name of the task action retrieved from Retrieve Workflow Task Actions.
-            data (dict): A dictionary containing the required parameters depending on the action being initiated.
-                        The keys should represent parameter names such as "verdict", "reason", "capacity", etc., 
-                        and the values should be the respective values for those parameters.
-
-        Returns:
-            Response: The API response indicating the status of the initiated action.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks/{task_id}/actions/{task_action}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # Workflows
-    ## Bulk Active Workflow Actions
-    #######################################################
-
-    def retrieve_bulk_workflow_actions(self):
-        """
-        Retrieve all available workflow actions that can be initiated on a workflow which the authenticated user has permissions to view or initiate and can be initiated through the API.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-bulk-workflow-actions
-
-        Returns:
-            Response: The API response containing a list of available workflow actions for a Vault.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/object/workflow/actions"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_bulk_workflow_action_details(self, action_name):
-        """
-        Once you’ve retrieved the available workflow actions, use this method to retrieve the details for a specific workflow action.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-bulk-workflow-action-details
-
-        Args:
-            action_name (str): The name of the workflow action retrieved from Retrieve Bulk Workflow Actions.
-
-        Returns:
-            Response: The API response containing the details for the specified workflow action.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/object/workflow/actions/{action_name}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def initiate_workflow_actions_on_multiple_workflows(self, action, workflow_ids, cancellation_comment=None, current_task_assignee=None, new_task_assignee=None, user_ids=None, task_ids=None, new_workflow_owner=None, current_workflow_owner=None):
-        """
-        Use this method to initiate a workflow action on multiple workflows. This starts an asynchronous job whose status you can check with the Retrieve Job Status endpoint.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-workflow-actions-on-multiple-workflows
-
-        Args:
-            action (str): The name of the workflow action. Retrieved from Retrieve Bulk Workflow Actions.
-            workflow_ids (str): A comma-separated list of workflow_id__v field values (Maximum 500 workflows). Required for cancelworkflows action.
-            cancellation_comment (str, optional): Comment for cancellation. Only applicable for cancelworkflows action.
-            current_task_assignee (str, optional): The user ID of the user whose tasks you wish to reassign. Required for reassigntasks action.
-            new_task_assignee (str, optional): The user ID of the user who will receive the newly assigned tasks. Required for reassigntasks action.
-            user_ids (str, optional): A comma-separated list of user IDs to cancel tasks by user ID. Applicable for canceltasks action.
-            task_ids (str, optional): A comma-separated list of task IDs to cancel tasks by task ID. Applicable for canceltasks action.
-            new_workflow_owner (str, optional): The ID of the user who will become the new workflow owner. Required for replaceworkflowowner action.
-            current_workflow_owner (str, optional): The ID of the current workflow owner. Required for replaceworkflowowner action.
-
-        Returns:
-            Response: The API response containing the job_id for the initiated action.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/object/workflow/actions/{action}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        data = {
-            "workflow_ids": workflow_ids,
-            "cancellation_comment": cancellation_comment,
-            "current_task_assignee": current_task_assignee,
-            "new_task_assignee": new_task_assignee,
-            "user_ids": user_ids,
-            "task_ids": task_ids,
-            "new_workflow_owner": new_workflow_owner,
-            "current_workflow_owner": current_workflow_owner
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Document Lifecycle & Workflows
-    #######################################################
-
-    #######################################################
-    # Document Lifecycle & Workflows
-    ## Document & Binder User Actions
-    #######################################################
-
-    def retrieve_user_actions(self, documents_or_binders, id, major_version, minor_version):
-        """
-        Retrieve all available user actions on a specific version of a document or binder based on the conditions mentioned in the API documentation. The method returns the available user actions that the authenticated user has permissions to view or initiate, can be initiated through the API, and are not currently in an active workflow.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-user-actions
-
-        Args:
-            documents_or_binders (str): Specify whether to retrieve values for "documents" or "binders".
-            id (int): The ID of the document or binder.
-            major_version (int): The major version number of the document or binder.
-            minor_version (int): The minor version number of the document or binder.
-
-        Returns:
-            Response: The API response containing the list of available user actions (lifecycle_actions__v) that can be initiated on the specified version of the document or binder.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{documents_or_binders}/{id}/versions/{major_version}/{minor_version}/lifecycle_actions"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_user_actions_multiple_documents_or_binders(self, documents_or_binders, doc_ids):
-        """
-        Retrieve all available user actions on specific versions of multiple documents or binders based on the criteria mentioned in the API documentation. The method returns the list of available lifecycle actions that can be initiated on the specified versions of multiple documents or binders, except those that are currently in an active workflow.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-user-actions-on-multiple-documents-or-binders
-
-        Args:
-            documents_or_binders (str): Specify whether to retrieve values for "documents" or "binders".
-            doc_ids (str): A comma-separated list of document or binder IDs and their major and minor version numbers in the format {doc_id:major_version:minor_version}. For example, "22:0:1,21:1:0,20:1:0".
-
-        Returns:
-            Response: The API response containing the list of available lifecycle actions (lifecycle_actions__v) that can be initiated on the specified versions of multiple documents or binders.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{documents_or_binders}/lifecycle_actions"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-
-        data = {
-            "docIds": doc_ids
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-
-        return response.json()
-
-
-    def retrieve_entry_criteria(self, documents_or_binders, id, major_version, minor_version, name_v):
-        """
-        Retrieves the entry criteria for a specific user action on documents or binders. 
-        Entry criteria are the conditions that must be met before initiating a certain action.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-entry-criteria
-
-        Parameters:
-        documents_or_binders (str): Choose to retrieve values for documents or binders.
-        id (int): The ID of the document or binder to retrieve user actions from.
-        major_version (int): The major version number of the document or binder.
-        minor_version (int): The minor version number of the document or binder.
-        name_v (str): The lifecycle name__v field value to retrieve entry criteria from.
-
-        Returns:
-        dict: A dictionary containing the response details of the API call.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{documents_or_binders}/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name_v}/entry_requirements"
-        headers = {"Authorization": f"{self.sessionId}", "Accept": "application/json"}
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-
-    def initiate_user_action(self, documents_or_binders, id, major_version, minor_version, name_v, data=None):
-        """
-        Initiates a user action on documents or binders in the vault. Before initiating, 
-        the applicable entry criteria for the action should be retrieved.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-user-action
-
-        Parameters:
-        documents_or_binders (str): Choose to initiate an action on documents or binders.
-        id (int): The ID of the document or binder to initiate the user action on.
-        major_version (int): The major version number of the document or binder.
-        minor_version (int): The minor version number of the document or binder.
-        name_v (str): The name__v field value representing the action to initiate.
-        data (dict, optional): Additional parameters to add to the request as name-value pairs, default is None.
-
-        Returns:
-        dict: A dictionary containing the response details of the API call.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{documents_or_binders}/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name_v}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        response = requests.put(url, headers=headers, data=data)
-        return response.json()
-
-
-    def download_controlled_copy_job_results(self, lifecycle_and_state_and_action, job_id):
-        """
-        Downloads the results of a controlled copy job as a file stream. This endpoint is intended 
-        for use by integrations requesting and routing controlled copies of content as a system 
-        integrations account on behalf of users.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#download-controlled-copy-job-results
-        
-        Parameters:
-        lifecycle_and_state_and_action (str): The name__v values for the lifecycle, state, 
-        and action in the format {lifecycle_name}.{state_name}.{action_name}. Retrieve this value 
-        from the job status using the href under "rel": "artifacts".
-        
-        job_id (str): The ID of the job, returned from the original job request. Find this ID in 
-        the Initiate User Action response.
-        
-        Returns:
-        file: A file stream of the controlled copy job results.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/actions/{lifecycle_and_state_and_action}/{job_id}/results"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.get(url, headers=headers, stream=True)
-        with open(f"Download Issued Batch Record - {datetime.utcnow().strftime('%Y-%m-%dT%H-%M-%S.%fZ')}.zip", "wb") as file:
-            for chunk in response.iter_content(chunk_size=8192):
-                file.write(chunk)
-        return "File downloaded successfully"
-
-
-    def initiate_bulk_user_actions(self, docIds, lifecycle, state, user_action_name):
-        """
-        Initiates bulk user actions on multiple documents or binders. Only a single workflow will start 
-        for all selected and valid documents.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-bulk-user-actions
-        
-        Parameters:
-        docIds (str): A comma-separated list of document or binder IDs along with major and minor version 
-                    numbers (e.g., "222:0:1,223:0:1,224:0:1").
-        lifecycle (str): The name of the document or binder lifecycle.
-        state (str): The current state of the documents or binders.
-        user_action_name (str): The name__v field value of the user action. This can be found using the 
-                            Retrieve User Actions on Multiple Documents or Binders endpoint.
-        
-        Returns:
-        json: The response from the API in JSON format.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/lifecycle_actions/{user_action_name}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        data = {
-            "docIds": docIds,
-            "lifecycle": lifecycle,
-            "state": state
-        }
-        response = requests.put(url, headers=headers, data=data)
-        return response.json()
-
-
-
-
-
-
-    #######################################################
-    # Document Lifecycle & Workflows
-    ## Lifecycle Role Assignment Rules
-    #######################################################
-
-
-    def retrieve_lifecycle_role_assignment_rules(self, lifecycle_v=None, role_v=None, product_v=None, country_v=None, study_v=None, study_country_v=None):
-        """
-        Retrieve lifecycle role assignment rules (default and override) from the specified parameters. If no parameters are
-        specified, it retrieves a list of all lifecycle role assignment rules from all roles in all lifecycles in your Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-lifecycle-role-assignment-rules-default-amp-override
-
-        Parameters:
-        lifecycle_v (str, optional): Name of the lifecycle to retrieve information from. Example: "general_lifecycle__c".
-        role_v (str, optional): Name of the role to retrieve information from. Example: "editor__c".
-        product_v (str, optional): ID/name of a specific product to see product-based override rules. Example: "0PR0011001" or "CholeCap".
-        country_v (str, optional): ID/name of a specific country to see country-based override rules. Example: "0CR0022002" or "United States".
-        study_v (str, optional): ID/name of a specific study to see study-based override rules (eTMF Vaults only). Example: "0ST0021J01" or "CholeCap Study".
-        study_country_v (str, optional): ID/name of a specific study country to see study country-based override rules (eTMF Vaults only). Example: "0SC0001001" or "Germany".
-
-        Returns:
-        json: The response from the API in JSON format.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/role_assignment_rule"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        params = {
-            "lifecycle__v": lifecycle_v,
-            "role__v": role_v,
-            "product__v": product_v,
-            "country__v": country_v,
-            "study__v": study_v,
-            "study_country__v": study_country_v
-        }
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-    def create_lifecycle_role_assignment_override_rules(self, input_file_path):
-        """
-        Creates lifecycle role assignment override rules in the Vault.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-lifecycle-role-assignment-override-rules
-        
-        :param input_file_path: The path to the JSON or CSV file containing the override rules data.
-        :type input_file_path: str
-        :return: A dictionary containing the API response.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/role_assignment_rule"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        with open(input_file_path, 'rb') as file:
-            data = file.read()
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-    def update_lifecycle_role_assignment_rules(self, input_file_path, content_type='text/csv', accept='application/json'):
-        """
-        Updates lifecycle role assignment rules (default & override) in the Vault.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-lifecycle-role-assignment-rules-default-amp-override
-        
-        :param input_file_path: The path to the JSON or CSV file containing the rules data to be updated.
-        :type input_file_path: str
-        :param content_type: The content type of the input file, either 'application/json' or 'text/csv'. Default is 'text/csv'.
-        :type content_type: str
-        :param accept: The format of the response, can be 'application/json' (default), 'application/xml' or 'text/csv'.
-        :type accept: str
-        :return: A dictionary containing the API response.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/role_assignment_rule"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": content_type,
-            "Accept": accept
-        }
-        
-        with open(input_file_path, 'rb') as file:
-            data = file.read()
-        
-        response = requests.put(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-
-
-    def delete_lifecycle_role_assignment_override_rules(self, lifecycle_v, role_v, object_name=None, object_name_value=None):
-        """
-        Deletes lifecycle role assignment override rules in the Vault.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-lifecycle-role-assignment-override-rules
-
-        :param lifecycle_v: The name of the lifecycle from which to delete override rules.
-        :type lifecycle_v: str
-        :param role_v: The name of the role from which to delete override rules.
-        :type role_v: str
-        :param object_name: Optional: The name of the object by ID to specify the override to delete.
-        :type object_name: str, optional
-        :param object_name_value: Optional: The name value of the object to specify the override to delete.
-        :type object_name_value: str, optional
-        :return: A dictionary containing the API response.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/role_assignment_rule"
-        params = {
-            "lifecycle__v": lifecycle_v,
-            "role__v": role_v
-        }
-        if object_name:
-            params[object_name] = object_name_value
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.delete(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-
-
-
-
-    #######################################################
-    # Document Lifecycle & Workflows
-    ## Document Workflows
-    #######################################################
-
-
-
-    def retrieve_all_document_workflows(self, loc=None):
-        """
-        Retrieves all available document workflows that the authenticated user has permissions to view or initiate 
-        and that can be initiated through the API.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-document-workflows
-
-        :param loc: Optional: When localized (translated) strings are available, retrieve them by setting loc to true.
-        :type loc: bool, optional
-        :return: A dictionary containing the API response with details of available workflows.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/actions"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        params = {}
-        if loc is not None:
-            params['loc'] = loc
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_document_workflow_details(self, workflow_name, loc=None):
-        """
-        Retrieves the details for a specific document workflow.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-workflow-details
-
-        :param workflow_name: The name of the document workflow to retrieve details for.
-        :type workflow_name: str
-        :param loc: Optional: When localized (translated) strings are available, retrieve them by setting loc to true.
-        :type loc: bool, optional
-        :return: A dictionary containing the API response with details of the specified document workflow.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/actions/{workflow_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        params = {}
-        if loc is not None:
-            params['loc'] = loc
-
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def initiate_document_workflow(self, workflow_name, contents_sys, description_sys):
-        """
-        Initiates a document workflow on a set of documents.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-document-workflow
-
-        :param workflow_name: The name of the document workflow to initiate.
-        :type workflow_name: str
-        :param contents_sys: A comma-separated list of document id field values (maximum 100 documents).
-        :type contents_sys: str
-        :param description_sys: Description of the workflow (maximum 128 characters).
-        :type description_sys: str
-        :return: A dictionary containing the API response which includes details of the initiated workflow or error messages.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/actions/{workflow_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        data = {
-            "contents__sys": contents_sys,
-            "description__sys": description_sys
-        }
-        
-        response = requests.post(url, headers=headers, json=data)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # Object Lifecycle & Workflows
-    #######################################################
-
-    #######################################################
-    # Object Lifecycle & Workflows
-    ## Retrieve Object Record User Actions
-    #######################################################
-
-
-    def retrieve_object_record_user_actions(self, object_name, object_record_id, loc=None):
-        """
-        Retrieve all available user actions that can be initiated on a specific object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-user-actions
-
-        :param object_name: The name of the object (name__v field value).
-        :type object_name: str
-        :param object_record_id: The id of the object record.
-        :type object_record_id: str
-        :param loc: Optional parameter to retrieve localized (translated) strings for the label, default is None.
-        :type loc: bool, optional
-        :return: A dictionary containing the API response which includes a list of available user actions or error messages.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        params = {}
-        if loc is not None:
-            params["loc"] = loc
-
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_object_user_action_details(self, object_name, object_record_id, action_name):
-        """
-        Retrieves the details for a specific user action.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-user-action-details
-
-        :param object_name: The object name__v field value.
-        :type object_name: str
-        :param object_record_id: The object record id value from which to retrieve user action details.
-        :type object_record_id: str
-        :param action_name: Either the name of the Objectaction or Objectlifecyclestateuseraction to initiate. This is obtained from the Retrieve User Actions request.
-        :type action_name: str
-        :return: A dictionary containing the API response which includes metadata for the specified object action or error messages.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions/{action_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def initiate_object_action_single_record(self, object_name, object_record_id, action_name, body_params):
-        """
-        Initiates an action on a specific object record.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-object-action-on-a-single-record
-
-        :param object_name: The object name__v field value.
-        :type object_name: str
-        :param object_record_id: The object record id field value from which to retrieve user actions.
-        :type object_record_id: str
-        :param action_name: The name of the Objectaction or Objectlifecyclestateuseraction to initiate.
-        :type action_name: str
-        :param body_params: A dictionary containing name-value pairs of any parameters required to initiate the action.
-        :type body_params: dict
-        :return: A dictionary containing the API response which includes the status of the action initiation or error messages.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions/{action_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers, data=body_params)
-        
-        return response.json()
-
-
-    def initiate_object_action_multiple_records(self, object_name, action_name, ids_list, body_params=None):
-        """
-        Initiates an object user action on multiple records, with a maximum of 500 records per batch.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-object-action-on-multiple-records
-
-        :param object_name: The object name__v field value.
-        :type object_name: str
-        :param action_name: Either the name of the Objectaction or Objectlifecyclestateuseraction to initiate.
-        :type action_name: str
-        :param ids_list: A list of object record IDs on which to initiate the action.
-        :type ids_list: list of str
-        :param body_params: (Optional) A dictionary containing name-value pairs of any other parameters required to initiate the action.
-        :type body_params: dict, optional
-        :return: A dictionary containing the API response which includes the status of the action initiation or error messages for each record ID.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/actions/{action_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        body_params = body_params or {}
-        body_params['ids'] = ', '.join(ids_list)
-        
-        response = requests.post(url, headers=headers, data=body_params)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # Object Lifecycle & Workflows
-    ## Multi-Record Workflows
-    #######################################################
-
-    def retrieve_all_multi_record_workflows(self):
-        """
-        Retrieves all available multi-record workflows which the authenticated user has permissions to view or initiate and can be initiated through the API.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-multi-record-workflows
-
-        :return: A dictionary containing the API response which includes details of all available multi-record workflows.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/actions"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_multi_record_workflow_details(self, workflow_name):
-        """
-        Retrieves the fields required to initiate a specific multi-record workflow. It provides details about the necessary controls and configurations required for initiating the workflow.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-multi-record-workflow-details
-
-        :param workflow_name: The name of the multi-record workflow to retrieve details for.
-        :type workflow_name: str
-        :return: A dictionary containing the API response which includes details of the specified multi-record workflow.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/actions/{workflow_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def initiate_multi_record_workflow(self, workflow_name, contents_sys, description_sys, additional_parameters=None):
-        """
-        Initiate a multi-record workflow on a set of records. This API call initiates the specified workflow with the necessary parameters.
-
-        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-multi-record-workflow
-
-        :param workflow_name: The name of the workflow to initiate.
-        :type workflow_name: str
-        :param contents_sys: A comma-separated list of records in the format Object:{objectname}.{record_ID}.
-        :type contents_sys: str
-        :param description_sys: Description of the workflow, maximum of 128 characters.
-        :type description_sys: str
-        :param additional_parameters: Additional parameters as required by the Admin to start the workflow, if any.
-        :type additional_parameters: dict, optional
-        :return: A dictionary containing the API response which includes details like record_id and workflow_id of the initiated workflow.
-        :rtype: dict
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/actions/{workflow_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        
-        body = {
-            "contents__sys": contents_sys,
-            "description__sys": description_sys
-        }
-        
-        if additional_parameters:
-            body.update(additional_parameters)
-        
-        response = requests.post(url, headers=headers, data=body)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # Users
-    #######################################################
-
-
-    def retrieve_user_metadata(self):
-        """
-        Retrieves user metadata from the Veeva Vault API.
-        
-        API documentation URL: https://developer.veevavault.com/api/23.2/#retrieve-user-metadata
-        
-        Returns:
-            pd.DataFrame: A DataFrame containing the retrieved user metadata.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/users"
-        r = requests.get(url, headers={"Authorization": f"{self.sessionId}"}).json()['properties']
-        return pd.DataFrame(r)
-
-
-
-    def retrieve_all_users(self, vaults=None, exclude_vault_membership=None, exclude_app_licensing=None, limit=None, start=None, sort=None):
-        """
-        This method retrieves user records at the domain level. Beginning in v18.1, Admins create and manage users with 
-        user__sys object records. We strongly recommend using the Retrieve Object Record Collection endpoint to retrieve 
-        user__sys records. More information can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-users
-        
-        Parameters:
-        vaults (str): Optional parameter to specify the vaults to retrieve users from. It accepts values like 'all', '-1', 
-                    or a comma-separated list of Vault IDs e.g., '3003,4004,5005'.
-        exclude_vault_membership (bool): Optional parameter to include or exclude vault_membership fields in the response.
-        exclude_app_licensing (bool): Optional parameter to include or exclude app_licensing fields in the response.
-        limit (int): Optional parameter to specify the size of the result set in the page. Default is 200.
-        start (int): Optional parameter to specify the starting record number. Default is 0.
-        sort (str): Optional parameter to specify the sort order for the result set (e.g., 'id asc').
-        
-        Returns:
-        response: A JSON response containing the user records data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users"
-        
-        params = {
-            "vaults": vaults,
-            "exclude_vault_membership": exclude_vault_membership,
-            "exclude_app_licensing": exclude_app_licensing,
-            "limit": limit,
-            "start": start,
-            "sort": sort
-        }
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-    def retrieve_user(self, user_id, exclude_vault_membership=None, exclude_app_licensing=None):
-        """
-        This method retrieves information for one user at the domain level. Beginning in v18.1, Admins create and manage 
-        users with user__sys object records. It is strongly recommended to use the Retrieve Object Record endpoint to 
-        retrieve a user__sys record. More details can be found at: https://developer.veevavault.com/api/23.2/#retrieve-user
-
-        Parameters:
-        user_id (int): The ID of the user to be retrieved.
-        exclude_vault_membership (bool): Optional parameter to include or exclude vault_membership fields in the response. 
-                                        Including these fields may decrease performance.
-        exclude_app_licensing (bool): Optional parameter to include or exclude app_licensing fields in the response. 
-                                    Including these fields may decrease performance.
-
-        Returns:
-        response: A JSON response containing the information of the specified user.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}"
-        
-        params = {
-            "exclude_vault_membership": exclude_vault_membership,
-            "exclude_app_licensing": exclude_app_licensing
-        }
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-    def create_single_user(self, user_details, domain=None, file_path=None):
-        """
-        This method creates a single user in the Veeva Vault. Admins create and manage users with user__sys object records 
-        from version v18.1. It is strongly recommended to use the Create Object Records endpoint to create new users, 
-        unless creating cross-domain users or adding users to a domain without assigning Vault membership.
-        Detailed documentation about this endpoint can be found at: https://developer.veevavault.com/api/23.2/#create-single-user
-        
-        Parameters:
-        user_details (dict): A dictionary containing the details of the user to be created. It must include the following keys:
-                            - user_name__v (required): The user's Vault username (login credential).
-                            - user_first_name__v (required): The user's first name.
-                            - user_last_name__v (required): The user's last name.
-                            - user_email__v (required): The user's email address.
-                            - user_timezone__v (required): The user's time zone.
-                            - user_locale__v (required): The user's locale.
-                            - security_policy_id__v (required): The user's security policy ID.
-                            - user_language__v (required): The user's preferred language.
-                            It can optionally include:
-                            - security_profile__v: The user's security profile. Default is 'document_user__v' if omitted.
-                            - license_type__v: The user's license type. Default is 'full__v' if omitted.
-        domain (bool): When set to true, the user will not be assigned to a Vault.
-        file_path (str): The file path to upload a profile picture (JPG, PNG, or GIF, less than 10MB).
-        
-        Returns:
-        response: A JSON response indicating the status of the user creation.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users"
-
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "multipart/form-data",
-            "Accept": "application/json"
-        }
-
-        data = user_details
-        if domain is not None:
-            data["domain"] = domain
-
-        files = {}
-        if file_path:
-            files['file'] = open(file_path, 'rb')
-
-        response = requests.post(url, headers=headers, data=data, files=files)
-        return response.json()
-
-
-    def create_multiple_users(self, user_data, file_path=None, operation=None, idParam=None):
-        """
-        Creates multiple users in the vault. You can also add multiple existing users as cross-domain users.
-        API documentation: https://developer.veevavault.com/api/23.2/#create-multiple-users
-        
-        Args:
-        user_data (list of dict): List containing dictionaries where each dictionary contains details for a user.
-        file_path (str, optional): Path to the CSV file containing user data. The values in the file must be UTF-8 encoded and follow RFC 4180 format.
-        operation (str, optional): Operation type for upsert functionality. It can be "upsert".
-        idParam (str, optional): Parameter for upsert functionality. It can be either "id" or "user_name__v".
-        
-        Returns:
-        dict: Response from the API.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users"
-        
-        if file_path:
-            with open(file_path, 'r') as f:
-                data = f.read()
-        else:
-            data = user_data
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        params = {}
-        if operation:
-            params["operation"] = operation
-        if idParam:
-            params["idParam"] = idParam
-        
-        response = requests.post(url, headers=headers, json=data, params=params)
-        
-        return response.json()
-
-
-    def update_single_user(self, user_id, payload):
-        """
-        Updates the information of a single user in the vault. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#update-single-user
-        
-        Args:
-            user_id (str): The ID of the user to be updated.
-            payload (dict): A dictionary containing the fields and values to be updated.
-            
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}"
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.put(url, headers=headers, data=payload)
-        
-        return response.json()
-
-
-    def update_my_user(self, payload):
-        """
-        Updates the information of the currently authenticated user in the vault. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#update-my-user
-        
-        Args:
-            payload (dict): A dictionary containing the fields and values to be updated.
-            
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/me"
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.put(url, headers=headers, data=payload)
-        
-        return response.json()
-
-
-
-    def update_multiple_users(self, file_path, content_type="text/csv", accept="text/csv"):
-        """
-        Updates the information of multiple users in the vault. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#update-multiple-users
-        
-        Args:
-            file_path (str): The path to the input file (CSV or JSON) containing the user data to be updated.
-            content_type (str, optional): The content type of the input file. Defaults to "text/csv".
-            accept (str, optional): The format in which to receive the response. Defaults to "text/csv".
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users"
-        headers = {
-            "Content-Type": content_type,
-            "Accept": accept,
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        with open(file_path, 'rb') as f:
-            response = requests.put(url, headers=headers, data=f)
-        
-        return response.json()
-
-
-    def disable_user(self, user_id, domain=False):
-        """
-        Disables a user in a specific vault or in all vaults in the domain. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#disable-user
-
-        Args:
-            user_id (int): The ID of the user to disable.
-            domain (bool, optional): When set to True, disables the user account in all vaults in the domain. Defaults to False.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}"
-        if domain:
-            url += "?domain=true"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.delete(url, headers=headers)
-        
-        return response.json()
-
-
-    def change_my_password(self, current_password, new_password):
-        """
-        Changes the password for the currently authenticated user. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#change-my-password
-        
-        Args:
-            current_password (str): The current password of the authenticated user.
-            new_password (str): The new password to set for the authenticated user. It must be different from the current password and meet the minimum requirements configured by the Vault Admin.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/me/password"
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        body = {
-            "password__v": current_password,
-            "new_password__v": new_password
-        }
-        
-        response = requests.post(url, headers=headers, data=body)
-        
-        return response.json()
-
-
-
-    def update_vault_membership(self, user_id, vault_id, active=None, security_profile=None, license_type=None):
-        """
-        Updates the vault membership details of a specific user in a particular vault. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#update-vault-membership
-        
-        Args:
-            user_id (str): The ID of the user to update.
-            vault_id (str): The ID of the vault where the update will take place.
-            active (bool, optional): Sets the user status to active (true) or inactive (false). Defaults to None.
-            security_profile (str, optional): Assigns the user a specific security profile in the vault. Defaults to None.
-            license_type (str, optional): Assigns the user a specific license type in the vault. Defaults to None.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}/vault_membership/{vault_id}"
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        body = {}
-        if active is not None:
-            body["active__v"] = str(active).lower()
-        if security_profile:
-            body["security_profile__v"] = security_profile
-        if license_type:
-            body["license_type__v"] = license_type
-        
-        response = requests.put(url, headers=headers, data=body)
-        
-        return response.json()
-
-
-    def retrieve_user_permissions(self, user_id, permission_name=None):
-        """
-        Retrieves the permissions assigned to a specific user. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-user-permissions
-
-        Args:
-            user_id (str): The ID of the user. Use 'me' to retrieve permissions for the currently authenticated user.
-            permission_name (str, optional): The name of the permission to filter the results. Should be in the format object.{object name}.{object or field}_actions. Defaults to None.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}/permissions"
-        
-        if permission_name:
-            url += f"?filter=name__v::{permission_name}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_my_user_permissions(self, permission_name=None):
-        """
-        Retrieves all object and object field permissions (Read, Edit, Create, Delete) assigned to the currently authenticated user. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-my-user-permissions
-
-        Args:
-            permission_name (str, optional): The name of the permission to filter the results. Should be in the format object.{object name}.{object or field}_actions. Defaults to None.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/me/permissions"
-        
-        if permission_name:
-            url += f"?filter=name__v::{permission_name}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # SCIM
-    #######################################################
-
-    #######################################################
-    # SCIM
-    ## Discovery Endpoints
-    #######################################################
-
-
-    def retrieve_scim_provider(self):
-        """
-        Retrieves a JSON that describes the SCIM specification features available on the currently authenticated Vault. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-scim-provider
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/ServiceProviderConfig"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_all_scim_schema_information(self):
-        """
-        Retrieves information about all SCIM schema specifications supported by a Vault SCIM service provider. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-all-scim-schema-information
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Schemas"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_single_scim_schema_information(self, schema_id):
-        """
-        Retrieves information about a single SCIM schema specification supported by a Vault SCIM service provider. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-single-scim-schema-information
-        
-        Args:
-            schema_id (str): The ID of a specific schema. For example, urn:ietf:params:scim:schemas:extension:veevavault:2.0:User.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Schemas/{schema_id}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_all_scim_resource_types(self):
-        """
-        Retrieves the types of SCIM resources available. Each resource type defines the endpoints, the core schema URI that defines the resource, and any supported schema extensions. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-all-scim-resource-types
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/ResourceTypes"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_single_scim_resource_type(self, type):
-        """
-        Retrieves a single SCIM resource type. Defines the endpoints, the core schema URI which defines this resource, and any supported schema extensions. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-single-scim-resource-type
-
-        Args:
-            type (str): A specific resource type. You can retrieve all available types from the Retrieve All SCIM Resource Types endpoint, where the value for this parameter is the id value.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/ResourceTypes/{type}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # SCIM
-    ## Users
-    #######################################################
-
-
-    def retrieve_all_users_with_scim(self, filter=None, attributes=None, excludedAttributes=None, sortBy=None, sortOrder=None, count=None, startIndex=None):
-        """
-        Retrieve all users with SCIM. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-all-users-with-scim
-
-        Args:
-            filter (str, optional): Filter for a specific attribute value, in the format {attribute} eq "{value}".
-            attributes (str, optional): Include specified attributes only in a comma separated list.
-            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma separated list.
-            sortBy (str, optional): Specify an attribute or sub-attribute to order the response.
-            sortOrder (str, optional): Specify the order in which the sortBy parameter is applied. Allowed values are "ascending" or "descending".
-            count (int, optional): Specify the number of query results per page.
-            startIndex (int, optional): Specify the index of the first result.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Users"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {
-            "filter": filter,
-            "attributes": attributes,
-            "excludedAttributes": excludedAttributes,
-            "sortBy": sortBy,
-            "sortOrder": sortOrder,
-            "count": count,
-            "startIndex": startIndex
-        }
-
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_single_user_with_scim(self, user_id, filter=None, attributes=None, excludedAttributes=None):
-        """
-        Retrieve a specific user with SCIM. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-single-user-with-scim
-
-        Args:
-            user_id (str): The ID of a specific user.
-            filter (str, optional): Filter for a specific attribute value, in the format {attribute} eq "{value}".
-            attributes (str, optional): Include specified attributes only in a comma separated list.
-            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma separated list.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Users/{user_id}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {
-            "filter": filter,
-            "attributes": attributes,
-            "excludedAttributes": excludedAttributes
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-
-    def retrieve_current_user_with_scim(self, attributes=None, excludedAttributes=None):
-        """
-        Retrieve the currently authenticated user with SCIM. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#retrieve-current-user-with-scim
-
-        Args:
-            attributes (str, optional): Include specified attributes only in a comma separated list.
-            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma separated list.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Me"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {
-            "attributes": attributes,
-            "excludedAttributes": excludedAttributes
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def update_current_user_with_scim(self, body_data, attributes=None, excludedAttributes=None):
-        """
-        Update the currently authenticated user with SCIM. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#update-current-user-with-scim
-
-        Args:
-            body_data (dict): A dictionary containing the data to update.
-            attributes (str, optional): Include specified attributes only in a comma separated list.
-            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma separated list.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Me"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {
-            "attributes": attributes,
-            "excludedAttributes": excludedAttributes
-        }
-        
-        response = requests.put(url, headers=headers, params=params, json=body_data)
-        
-        return response.json()
-
-
-    def create_user_with_scim(self, user_data):
-        """
-        Create a user with SCIM. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#create-user-with-scim
-
-        Args:
-            user_data (dict): A dictionary containing the required information to create a new user.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Users"
-        
-        headers = {
-            "Accept": "application/json",
-            "Content-Type": "application/scim+json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.post(url, headers=headers, json=user_data)
-        
-        return response.json()
-
-
-
-    def update_user_with_scim(self, user_id, user_data):
-        """
-        Update fields values on a single user with SCIM. You can find the API documentation here:
-        https://developer.veevavault.com/api/23.2/#update-user-with-scim
-
-        Args:
-            user_id (str): The ID of the user you wish to update.
-            user_data (dict): A dictionary containing the information to update for the user.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Users/{user_id}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Content-Type": "application/scim+json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.put(url, headers=headers, json=user_data)
-        
-        return response.json()
-
-
-    def retrieve_scim_resources(self, resource_type, filter=None, attributes=None, excludedAttributes=None, sortBy=None, sortOrder=None, count=None, startIndex=None):
-        """
-        Retrieve a single SCIM resource type. The function defines the endpoints, the core schema URI which defines this resource, and any supported schema extensions.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-scim-resources
-
-        Args:
-            resource_type (str): The resource type to retrieve. 
-            filter (str, optional): Filter for a specific attribute value. Defaults to None.
-            attributes (str, optional): Include specified attributes only. Defaults to None.
-            excludedAttributes (str, optional): Exclude specific attributes from the response. Defaults to None.
-            sortBy (str, optional): Specify an attribute or sub-attribute to order the response. Defaults to None.
-            sortOrder (str, optional): Specify the order in which the sortBy parameter is applied. Defaults to None.
-            count (int, optional): Specify the number of query results per page. Defaults to None.
-            startIndex (int, optional): Specify the index of the first result. Defaults to None.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/{resource_type}"
-
-        params = {
-            "filter": filter,
-            "attributes": attributes,
-            "excludedAttributes": excludedAttributes,
-            "sortBy": sortBy,
-            "sortOrder": sortOrder,
-            "count": count,
-            "startIndex": startIndex
-        }
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_single_scim_resource(self, resource_type, resource_id, attributes=None, excludedAttributes=None):
-        """
-        Retrieve a single SCIM resource from the Veeva Vault. 
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-single-scim-resource
-
-        Args:
-            resource_type (str): The type of the resource to retrieve.
-            resource_id (str): The ID of the resource to retrieve.
-            attributes (str, optional): Include specified attributes only in a comma-separated list. Defaults to None.
-            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma-separated list. Defaults to None.
-
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/{resource_type}/{resource_id}"
-        
-        params = {
-            "attributes": attributes,
-            "excludedAttributes": excludedAttributes
-        }
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-
-
-
-    #######################################################
-    # Groups
-    #######################################################
-
-
-    def retrieve_group_metadata(self):
-        """
-        Retrieve metadata of groups in the Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-group-metadata
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/groups"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_all_groups(self, include_implied=None):
-        """
-        Retrieve all groups except Auto Managed groups in the Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-groups
-        
-        Args:
-            include_implied (bool, optional): When true, the response includes the implied_members__v field.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {}
-        if include_implied is not None:
-            params['includeImplied'] = include_implied
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_auto_managed_groups(self, limit=1000, offset=0):
-        """
-        Retrieve all Auto Managed groups from the Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-auto-managed-groups
-        
-        Args:
-            limit (int, optional): The maximum number of records per page in the response. Defaults to 1000.
-            offset (int, optional): The offset from the entry returned to paginate the results displayed per page. Defaults to 0.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups/auto"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {
-            'limit': limit,
-            'offset': offset
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def retrieve_group(self, group_id, include_implied=None):
-        """
-        Retrieve details of a specific group using the group id from the Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-group
-        
-        Args:
-            group_id (int): The ID of the group to retrieve.
-            include_implied (bool, optional): When true, includes the implied_members__v field in the response. Defaults to None.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups/{group_id}"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        params = {}
-        if include_implied is not None:
-            params['includeImplied'] = include_implied
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def create_group(self, label, members=None, security_profiles=None, active=True, group_description=None, allow_delegation_among_members=False):
-        """
-        Create a new group in the Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#create-group
-        
-        Args:
-            label (str): The label for the new group. This is used to create the group name__v value.
-            members (str, optional): A comma-separated list of user IDs to assign to the group. Defaults to None.
-            security_profiles (str, optional): A comma-separated list of security profiles to assign to the group. Defaults to None.
-            active (bool, optional): Set to false to create the group as inactive. Defaults to True.
-            group_description (str, optional): A description of the group. Defaults to None.
-            allow_delegation_among_members (bool, optional): Set to true to allow members to delegate access to other members of the same group. Defaults to False.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups"
-
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        data = {
-            "label__v": label,
-            "active__v": active,
-            "allow_delegation_among_members__v": allow_delegation_among_members
-        }
-
-        if members:
-            data["members__v"] = members
-        if security_profiles:
-            data["security_profiles__v"] = security_profiles
-        if group_description:
-            data["group_description__v"] = group_description
-
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-
-    def update_group(self, group_id, label=None, members=None, security_profiles=None, active=None, group_description=None, allow_delegation_among_members=None):
-        """
-        Update group field values or add/remove members and security profiles in the Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#update-group
-        
-        Args:
-            group_id (str): The ID of the group to be updated.
-            label (str, optional): The new label for the group. Defaults to None.
-            members (str, optional): A comma-separated list of user IDs or a command to add/remove users (e.g., "add (userID1, userID2)" or "delete (userID1, userID2)"). Defaults to None.
-            security_profiles (str, optional): A comma-separated list of security profiles. Defaults to None.
-            active (bool, optional): Set to false to make the group inactive. Defaults to None.
-            group_description (str, optional): The new description of the group. Defaults to None.
-            allow_delegation_among_members (bool, optional): Set to true to allow members to delegate access only to other members of the same group. Defaults to None.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups/{group_id}"
-
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        data = {}
-        
-        if label is not None:
-            data["label__v"] = label
-        if members is not None:
-            data["members__v"] = members
-        if security_profiles is not None:
-            data["security_profiles__v"] = security_profiles
-        if active is not None:
-            data["active__v"] = active
-        if group_description is not None:
-            data["group_description__v"] = group_description
-        if allow_delegation_among_members is not None:
-            data["allow_delegation_among_members__v"] = allow_delegation_among_members
-
-        response = requests.put(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-    def delete_group(self, group_id):
-        """
-        Delete a user-defined group in the Veeva Vault. Note that system-managed groups cannot be deleted.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#delete-group
-        
-        Args:
-            group_id (str): The ID of the group to be deleted.
-        
-        Returns:
-            dict: A dictionary containing the response data.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups/{group_id}"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.delete(url, headers=headers)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Picklists
-    #######################################################
-
-
-    def retrieve_all_picklists(self):
-        """
-        Retrieve all picklists available in the Veeva Vault. This method provides metadata about each picklist including its name, label, kind, and where it is used.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-picklists
-        
-        Returns:
-            dict: A dictionary containing the response data including details about each picklist.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_picklist_values(self, picklist_name):
-        """
-        Retrieve all the values configured for a specified picklist in Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-picklist-values
-
-        Args:
-            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
-
-        Returns:
-            dict: A dictionary containing the response data with details about each picklist value.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}"
-
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-
-        return response.json()
-
-
-
-    def create_picklist_values(self, picklist_name, values_dict):
-        """
-        Create new values in a specified picklist in Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#create-picklist-values
-
-        Args:
-            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
-            values_dict (dict): A dictionary with keys as "value_1", "value_2", etc. and values as the new picklist value labels.
-
-        Returns:
-            dict: A dictionary containing the response data with details about the created picklist values.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}"
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.post(url, headers=headers, data=values_dict)
-
-        return response.json()
-
-
-
-    def update_picklist_value_label(self, picklist_name, label_updates_dict):
-        """
-        Update the label of existing picklist values in Veeva Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#update-picklist-value-label
-
-        Args:
-            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
-            label_updates_dict (dict): A dictionary where keys are existing picklist value names and values are the new labels.
-
-        Returns:
-            dict: A dictionary containing the response data with details about the updated picklist values.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}"
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.put(url, headers=headers, data=label_updates_dict)
-
-        return response.json()
-
-
-    def update_picklist_value(self, picklist_name, picklist_value_name, new_name=None, status=None):
-        """
-        Update the name or status of a picklist value in Veeva Vault. Be cautious as it may affect existing documents and objects.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#update-picklist-value
-
-        Args:
-            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
-            picklist_value_name (str): The current name of the picklist value to be updated.
-            new_name (str, optional): The new name for the picklist value. Defaults to None.
-            status (str, optional): The new status for the picklist value, either "active" or "inactive". Defaults to None.
-
-        Returns:
-            dict: A dictionary containing the response data with status of the update operation.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}/{picklist_value_name}"
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        data = {}
-        if new_name:
-            data['name'] = new_name
-        if status:
-            data['status'] = status
-
-        response = requests.put(url, headers=headers, data=data)
-
-        return response.json()
-
-
-    def inactivate_picklist_value(self, picklist_name, picklist_value_name):
-        """
-        Inactivates a picklist value in Veeva Vault. It does not affect picklist values that are already in use.
-        Best practice is to use the update_picklist_value method to inactivate a picklist value.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#inactivate-picklist-value
-
-        Args:
-            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
-            picklist_value_name (str): The name of the picklist value to be inactivated.
-
-        Returns:
-            dict: A dictionary containing the response data with the status of the inactivation operation.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}/{picklist_value_name}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.delete(url, headers=headers)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # Expected Document Lists
-    #######################################################
-
-
-
-    def create_placeholder_from_edl_item(self, edl_item_ids):
-        """
-        Creates a placeholder from an EDL item. Learn more about working with Content Placeholders in Vault Help.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#create-a-placeholder-from-an-edl-item
-
-        Args:
-            edl_item_ids (str): A comma-separated string of EDL Item IDs on which to initiate the action.
-
-        Returns:
-            dict: A dictionary containing the response data, including job_id and URL to check the job status.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/edl_item__v/actions/createplaceholder"
-
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        data = {
-            "edlItemIds": edl_item_ids
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-    def retrieve_all_root_nodes(self, edl_hierarchy_or_template):
-        """
-        Retrieves all root EDL nodes and node metadata. Learn more about EDL hierarchies in Vault Help.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-root-nodes
-
-        Args:
-            edl_hierarchy_or_template (str): Specifies whether to retrieve nodes for either edl_hierarchy__v or edl_template__v.
-
-        Returns:
-            dict: A dictionary containing the response data with details of all root nodes.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/composites/trees/{edl_hierarchy_or_template}"
-
-        headers = {
-            "Content-Type": "application/json",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_specific_root_nodes(self, edl_hierarchy_or_template, ref_ids):
-        """
-        Retrieves the root node ID for the given EDL record IDs.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-specific-root-nodes
-
-        Args:
-            edl_hierarchy_or_template (str): Specifies whether to retrieve nodes for either edl_hierarchy__v or edl_template__v.
-            ref_ids (list): A list of dictionaries where each dictionary contains a key 'ref_id__v' and the corresponding EDL record ID as value.
-
-        Returns:
-            dict: A dictionary containing the response data with the root node ID for the specified EDL record IDs.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/composites/trees/{edl_hierarchy_or_template}/actions/listnodes"
-        
-        headers = {
-            "Content-Type": "application/json",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.post(url, headers=headers, json=ref_ids)
-        
-        return response.json()
-
-
-
-    def retrieve_node_children(self, edl_hierarchy_or_template, parent_node_id):
-        """
-        Given an EDL node ID, retrieves immediate children (not grandchildren) of that node.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-a-node-39-s-children
-        
-        Args:
-            edl_hierarchy_or_template (str): Specifies whether to retrieve node children for either edl_hierarchy__v or edl_template__v.
-            parent_node_id (str): The ID of a parent node in the hierarchy.
-
-        Returns:
-            dict: A dictionary containing the response data with the immediate children of the specified parent node ID.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/composites/trees/{edl_hierarchy_or_template}/{parent_node_id}/children"
-        
-        headers = {
-            "Content-Type": "application/json",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def update_node_order(self, edl_hierarchy_or_template, parent_node_id, node_id, new_order):
-        """
-        Given an EDL parent node, updates the order of its children.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#update-node-order
-        
-        Args:
-            edl_hierarchy_or_template (str): Specifies whether to update node order for either edl_hierarchy__v or edl_template__v.
-            parent_node_id (str): The ID of a parent node in the hierarchy.
-            node_id (str): The ID of the child node to update.
-            new_order (str): The new order for the node in the hierarchy, such as “1”, “2”, etc.
-
-        Returns:
-            dict: A dictionary containing the response data after updating the node order.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/composites/trees/{edl_hierarchy_or_template}/{parent_node_id}/children"
-
-        headers = {
-            "Content-Type": "application/json",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        payload = {
-            "id": node_id,
-            "order__v": new_order
-        }
-
-        response = requests.put(url, headers=headers, json=payload)
-        
-        return response.json()
-
-
-    def add_edl_matched_documents(self, matched_documents):
-        """
-        Adds matched documents to EDL Items. You must have a security profile that grants the Application: EDL Matching: Edit Document Matches permission, and EDL Matched Document APIs must be enabled in your Vault. To enable this feature, contact Veeva Support.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#add-edl-matched-documents
-
-        Args:
-            matched_documents (list of dict): List of dictionaries where each dictionary contains the details of an EDL item-document match with keys - id, document_id, major_version_number__v (optional), minor_version_number__v (optional), lock (optional).
-
-        Returns:
-            dict: A dictionary containing the response data after adding the EDL matched documents.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/edl_matched_documents/batch/actions/add"
-
-        headers = {
-            "Content-Type": "application/json",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.post(url, headers=headers, json=matched_documents)
-        
-        return response.json()
-
-
-    def remove_edl_matched_documents(self, matched_documents):
-        """
-        Removes manually matched documents from EDL Items. You must have a security profile that grants the Application: EDL Matching: Edit Document Matches permission, and EDL Matched Document APIs must be enabled in your Vault. To enable this feature, contact Veeva Support.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#remove-edl-matched-documents
-
-        Args:
-            matched_documents (list of dict): List of dictionaries where each dictionary contains the details of an EDL item-document match to remove with keys - id, document_id, major_version_number__v (optional), minor_version_number__v (optional), remove_locked (optional).
-
-        Returns:
-            dict: A dictionary containing the response data after removing the EDL matched documents.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/edl_matched_documents/batch/actions/remove"
-
-        headers = {
-            "Content-Type": "application/json",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.post(url, headers=headers, json=matched_documents)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Security Policies
-    #######################################################
-
-
-    def retrieve_security_policy_metadata(self):
-        """
-        Retrieve the metadata associated with the security policy object. 
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-security-policy-metadata
-        
-        Returns:
-            dict: A dictionary containing the metadata associated with the security policy object.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/securitypolicies"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_all_security_policies(self):
-        """
-        Retrieve a list of all security policies in the Vault. 
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-security-policies
-        
-        Returns:
-            dict: A dictionary containing a list of all security policies in the Vault.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/securitypolicies"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_security_policy(self, security_policy_name):
-        """
-        Retrieve the details of a specific security policy in the Vault.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-security-policy
-        
-        Args:
-            security_policy_name (str): The name__v field value of the security policy to retrieve. This is typically a numeric value.
-            
-        Returns:
-            dict: A dictionary containing the details of the specified security policy.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/securitypolicies/{security_policy_name}"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Configuration Migration
-    #######################################################
-
-
-    def export_package(self, package_name):
-        """
-        Export a package from the Vault. The API will initiate an export job and respond with the details of the job including a job ID which can be used to check the status of the export job.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#export-package
-        
-        Args:
-            package_name (str): The name of the Outbound Package you would like to export.
-            
-        Returns:
-            dict: A dictionary containing the URL to check the job status and the job ID.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/package"
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        data = {
-            "packageName": package_name
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-
-    def import_package(self, file_path):
-        """
-        Import and validate a VPK package in the Vault. The API initiates an asynchronous import job and responds with the job details including a job ID which can be used to check the status of the import job.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#import-package
-        
-        Args:
-            file_path (str): The path to the .vpk file that you want to import.
-            
-        Returns:
-            dict: A dictionary containing the URL to check the job status and the job ID.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/package"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        files = {
-            'file': open(file_path, 'rb')
-        }
-        
-        response = requests.put(url, headers=headers, files=files)
-        
-        return response.json()
-
-
-
-
-    def deploy_package(self, package_id):
-        """
-        Deploy a package in the Vault. This method initiates a deployment job and responds with the job details including a job ID which can be used to retrieve the status and results of the request.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#deploy-package
-        
-        Args:
-            package_id (str): The ID of the vault_package__v object record that you want to deploy.
-            
-        Returns:
-            dict: A dictionary containing the URL to check the job status and the job ID.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobject/vault_package__v/{package_id}/actions/deploy"
-        
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.post(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_package_deploy_results(self, package_id):
-        """
-        Retrieve the results of a completed package deployment in the Vault. After Vault completes the deploy job, use this method to get detailed information about the deployment results.
-        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-package-deploy-results
-        
-        Args:
-            package_id (str): The ID of the vault_package__v object record used for deployment.
-            
-        Returns:
-            dict: A dictionary containing the results and details of the package deployment.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobject/vault_package__v/{package_id}/actions/deploy/results"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def retrieve_outbound_package_dependencies(self, package_id):
-        """
-        Retrieve the dependencies of an outbound package in the Vault. This API method allows you to identify all outstanding component dependencies for an outbound package and gives you the ability to add these missing dependencies to the package through another API call.
-        The API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-outbound-package-dependencies
-
-        Args:
-            package_id (str): The ID of the outbound_package__v record for which to retrieve dependencies.
-
-        Returns:
-            dict: A dictionary containing details about the package dependencies, including total number of dependencies, target vault ID, package name, package ID, description, and URL for adding missing dependencies.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/outbound_package__v/{package_id}/dependencies"
-        
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-
-
-    def vault_compare(self, vault_id, results_type="differences", details_type="simple", include_doc_binder_templates=True, include_vault_settings=True, component_types=None, generate_outbound_packages=False):
-        """
-        Compare the configuration of two different Vaults. The Vault where the request is made serves as the source Vault, and the target Vault for the comparison is specified in the request body. This function allows you to initiate a comparison between configurations and view the differences or complete configurations depending on the parameters specified.
-        The API documentation can be found at: https://developer.veevavault.com/api/23.2/#vault-compare
-
-        Args:
-            vault_id (str): The target Vault ID for the comparison.
-            results_type (str, optional): Specify 'complete' to include all configuration values or 'differences' to only see the differences between Vaults. Defaults to 'differences'.
-            details_type (str, optional): Specify the level of details in the comparison. Can be 'none' for component level details only, 'simple' for simple attribute-level details, or 'complex' for all attribute-level details. Defaults to 'simple'.
-            include_doc_binder_templates (bool, optional): Include or exclude Document and Binder Templates for comparison. Defaults to True.
-            include_vault_settings (bool, optional): Include or exclude Vault Settings for comparison. Defaults to True.
-            component_types (str, optional): A comma-separated list of component types to include or 'none' to exclude all component types. Defaults to None (includes all components).
-            generate_outbound_packages (bool, optional): If True, Vault automatically generates an Outbound Package based on the differences between the source and target Vault. Defaults to False.
-
-        Returns:
-            dict: A dictionary containing the response status, URL, and job ID for the comparison report job initiated. Use the URL and job ID to track the status and retrieve the comparison report once generated.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/vault/actions/compare"
-
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        data = {
-            "vault_id": vault_id,
-            "results_type": results_type,
-            "details_type": details_type,
-            "include_doc_binder_templates": include_doc_binder_templates,
-            "include_vault_settings": include_vault_settings,
-            "component_types": component_types,
-            "generate_outbound_packages": generate_outbound_packages
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-
-        return response.json()
-
-
-
-    def vault_configuration_report(self, include_vault_settings=True, include_inactive_components=False, include_components_modified_since=None, include_doc_binder_templates=True, suppress_empty_results=False, component_types=None, output_format="Excel_Macro_Enabled"):
-        """
-        Generates an Excel™ report containing configuration information for a Vault. Users need to have the Vault Configuration Report permission to use this API. The detailed API documentation can be accessed at: https://developer.veevavault.com/api/23.2/#vault-configuration-report
-
-        Args:
-            include_vault_settings (bool, optional): Determines whether to include Vault Settings in the report. Defaults to True.
-            include_inactive_components (bool, optional): Decides whether to include inactive components and subcomponents in the report. Defaults to False.
-            include_components_modified_since (str, optional): To include components modified since the specified date. The date should be in the format 'yyyy-mm-dd'. Defaults to None.
-            include_doc_binder_templates (bool, optional): Determines whether to include document and binder templates in the report. Defaults to True.
-            suppress_empty_results (bool, optional): If True, Vault will exclude tabs with only header rows from the report. Defaults to False.
-            component_types (str, optional): A comma-separated list of component types to include in the report. Defaults to None, which includes all components.
-            output_format (str, optional): Specifies the output format for the report, either 'XSLX' or 'XLSM'. Defaults to 'Excel_Macro_Enabled'.
-
-        Returns:
-            dict: The response dictionary containing the status of the request, the URL, and the job ID for the new Configuration Report job. You can use the URL and job ID to track the status and retrieve the report once generated.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/vault/actions/configreport"
-
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        data = {
-            "include_vault_settings": include_vault_settings,
-            "include_inactive_components": include_inactive_components,
-            "include_components_modified_since": include_components_modified_since,
-            "include_doc_binder_templates": include_doc_binder_templates,
-            "suppress_empty_results": suppress_empty_results,
-            "component_types": component_types,
-            "output_format": output_format
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-
-        return response.json()
-
-
-    def validate_package(self, file_path):
-        """
-        Validates a VPK package attached to this request. The validation response includes information on dependent components, similar to the validation logs generated through the UI. This method does not import your package. For detailed information, refer to the API documentation: https://developer.veevavault.com/api/23.2/#validate-package
-
-        Args:
-            file_path (str): The path to the VPK file to be validated.
-
-        Returns:
-            dict: The response dictionary containing the status of the validation and details of the package validation response.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/package/actions/validate"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        with open(file_path, 'rb') as f:
-            files = {'file': f}
-            response = requests.post(url, headers=headers, files=files)
-
-        return response.json()
-
-
-
-    def validate_inbound_package(self, package_id):
-        """
-        Validates an imported VPK package before deploying it to your Vault. The validation response includes information on dependent components and whether they exist in the package or in your Vault. You can add missing dependencies to the package in the source Vault before re-importing and deploying it to your target Vault. For more details, refer to the API documentation: https://developer.veevavault.com/api/23.2/#validate-inbound-package
-
-        Args:
-            package_id (str): The id field value of the vault_package__v object record to validate.
-
-        Returns:
-            dict: The response dictionary containing the status of the validation and details of the package validation response.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/vobject/vault_package__v/{package_id}/actions/validate"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.post(url, headers=headers)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Sandbox Vaults
-    #######################################################
-
-    def retrieve_sandboxes(self):
-        """
-        Retrieve information about the sandbox Vaults for the authenticated Vault.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-sandboxes
-        
-        Usage:
-            vv_instance = Vv()
-            sandboxes_info = vv_instance.retrieve_sandboxes()
-
-        Returns:
-            dict: A dictionary containing the details of the sandboxes.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def retrieve_sandbox_details_by_id(self, vault_id):
-        """
-        Retrieve information about the sandbox for the given Vault ID.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-sandbox-details-by-id
-        
-        Usage:
-            vv_instance = Vv()
-            sandbox_details = vv_instance.retrieve_sandbox_details_by_id(vault_id='56219')
-
-        Args:
-            vault_id (str): The Vault ID of the sandbox.
-
-        Returns:
-            dict: A dictionary containing the details of the sandbox specified by the Vault ID.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/{vault_id}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def recheck_sandbox_usage_limit(self):
-        """
-        Recalculate the usage values of the sandbox Vaults for the authenticated Vault. This action can be initiated up to three times in a 24-hour period.
-        API Documentation: https://developer.veevavault.com/api/23.2/#recheck-sandbox-usage-limit
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.recheck_sandbox_usage_limit()
-
-        Returns:
-            dict: A dictionary containing the response status of the action.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/actions/recheckusage"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json",
-            "Content-Type": "application/x-www-form-urlencoded"
-        }
-        
-        response = requests.post(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def change_sandbox_size(self, sandbox_details):
-        """
-        Change the size of a sandbox Vault for the authenticated Vault. You can initiate this action if there are sufficient allowances and the current sandbox meets the data and user limits of the requested size.
-        API Documentation: https://developer.veevavault.com/api/23.2/#change-sandbox-size
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.change_sandbox_size(sandbox_details=[{"name": "SandboxA", "size": "Full"}])
-
-        Args:
-            sandbox_details (list of dict): A list of dictionaries containing details of the sandboxes to change the size. Each dictionary should have "name" and "size" keys.
-
-        Returns:
-            dict: A dictionary containing the response status of the action.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/batch/changesize"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json",
-            "Content-Type": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers, json=sandbox_details)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def set_sandbox_entitlements(self, name, size, allowance, grant, temporary_allowance=None):
-        """
-        Set new sandbox entitlements, including granting and revoking allowances, for the given sandbox name.
-        API Documentation: https://developer.veevavault.com/api/23.2/#set-sandbox-entitlements
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.set_sandbox_entitlements(name="Sandbox0", size="Large", allowance=1, grant=True, temporary_allowance=None)
-
-        Args:
-            name (str): The name of the sandbox Vault.
-            size (str): The size of the sandbox: Small, Large, or Full.
-            allowance (int): The number of entitlements to grant or revoke.
-            grant (bool): True grants allowances and false revokes them.
-            temporary_allowance (int, optional): The number of temporary sandbox allowances to grant or revoke.
-
-        Returns:
-            dict: A dictionary containing the response status and the updated entitlement details.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/entitlements/set"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json",
-            "Content-Type": "application/x-www-form-urlencoded"
-        }
-        data = {
-            "name": name,
-            "size": size,
-            "allowance": allowance,
-            "grant": grant,
-            "temporary_allowance": temporary_allowance
-        }
-        response = requests.post(url, headers=headers, data=data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def create_or_refresh_sandbox(self, size, domain, name, source=None, source_snapshot=None, type=None, add_requester=None, release=None):
-        """
-        Create a new sandbox or refresh an existing sandbox for the currently authenticated Vault.
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-or-refresh-sandbox
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.create_or_refresh_sandbox(size="Small", domain="veepharm.com", name="Sandbox", source=None, source_snapshot=None, type=None, add_requester=None, release=None)
-        
-        Args:
-            size (str): The size of the sandbox: Small, Large, or Full.
-            domain (str): The domain to use for the new sandbox.
-            name (str): The name of the sandbox Vault.
-            source (str, optional): The source to refresh the sandbox from: vault or snapshot.
-            source_snapshot (str, optional): The api_name of the snapshot to create the sandbox from, if the source is a snapshot.
-            type (str, optional): The type of sandbox, such as config.
-            add_requester (bool, optional): Adds the currently authenticated user as a Vault Owner in the new sandbox, defaults to True.
-            release (str, optional): The type of release: general, limited, or prerelease, defaults to the release level of the source Vault.
-
-        Returns:
-            dict: A dictionary containing the response status and the job ID and URL to check the status of the sandbox creation request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json",
-            "Content-Type": "application/x-www-form-urlencoded"
-        }
-        data = {
-            "size": size,
-            "domain": domain,
-            "name": name,
-            "source": source,
-            "source_snapshot": source_snapshot,
-            "type": type,
-            "add_requester": add_requester,
-            "release": release
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def refresh_sandbox_from_snapshot(self, vault_id, source_snapshot):
-        """
-        Refresh a sandbox Vault in the currently authenticated Vault from an existing snapshot.
-        API Documentation: https://developer.veevavault.com/api/23.2/#refresh-sandbox-from-snapshot
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.refresh_sandbox_from_snapshot(vault_id=1001055, source_snapshot="Sandbox1 Snapshot")
-        
-        Args:
-            vault_id (int): The Vault ID of the sandbox to be refreshed.
-            source_snapshot (str): The api_name of the snapshot to refresh the sandbox from.
-
-        Returns:
-            dict: A dictionary containing the response status and the job ID and URL to check the status of the sandbox refresh request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/{vault_id}/actions/refresh"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json",
-            "Content-Type": "application/x-www-form-urlencoded"
-        }
-        data = {
-            "source_snapshot": source_snapshot
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def delete_sandbox(self, sandbox_name):
-        """
-        Delete a sandbox Vault. How often you can delete a Vault depends on its size.
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-sandbox
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.delete_sandbox(sandbox_name="My Configuration Sandbox")
-
-        Args:
-            sandbox_name (str): The name of the sandbox Vault to delete. This is the name which appears on the My Vaults page.
-
-        Returns:
-            dict: A dictionary containing the response status and a message about the deletion process.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/{sandbox_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.delete(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-
-
-
-    #######################################################
-    # Sandbox Vaults
-    ## Sandbox Snapshots
-    #######################################################
-
-    def create_sandbox_snapshot(self, source_sandbox, snapshot_name, description=None, include_data=False):
-        """
-        Create a new sandbox snapshot for the indicated sandbox Vault.
-        API Documentation: https://developer.veevavault.com/api/23.2/#create-sandbox-snapshot
-
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.create_sandbox_snapshot(source_sandbox="Sandbox1", snapshot_name="Snapshot1", description="First snapshot of a sandbox.", include_data=False)
-
-        Args:
-            source_sandbox (str): The name of the sandbox Vault to take a snapshot of.
-            snapshot_name (str): The name of the new snapshot.
-            description (str, optional): The description of the new snapshot. Defaults to None.
-            include_data (bool, optional): Set to true to include data as part of the snapshot. Set to false to include only configuration. Defaults to False.
-
-        Returns:
-            dict: A dictionary containing the job ID and URL to retrieve the current status of the snapshot creation request.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot"
-        headers = {
-            "Authorization": self.sessionId,
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        data = {
-            "source_sandbox": source_sandbox,
-            "name": snapshot_name,
-            "description": description,
-            "include_data": str(include_data).lower()
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def retrieve_sandbox_snapshots(self):
-        """
-        Retrieve information about sandbox snapshots managed by the authenticated Vault.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-sandbox-snapshots
-
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.retrieve_sandbox_snapshots()
-
-        Returns:
-            dict: A dictionary containing the details of the sandbox snapshots managed by the authenticated Vault.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def delete_sandbox_snapshot(self, api_name):
-        """
-        Delete a sandbox snapshot managed by the authenticated Vault. Deleted snapshots cannot be recovered.
-        API Documentation: https://developer.veevavault.com/api/23.2/#delete-sandbox-snapshot
-
-        Parameters:
-            api_name (str): The API name of the snapshot to delete.
-
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.delete_sandbox_snapshot(api_name="sandbox_a_snapshot__c")
-
-        Returns:
-            dict: A dictionary containing the response status of the delete request.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot/{api_name}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-
-    def update_sandbox_snapshot(self, api_name):
-        """
-        Recreate a sandbox snapshot for the same source sandbox Vault. This request replaces the existing snapshot with the newly created one.
-        API Documentation: https://developer.veevavault.com/api/23.2/#update-sandbox-snapshot
-
-        Parameters:
-            api_name (str): The API name of the snapshot to update.
-
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.update_sandbox_snapshot(api_name="veepharm_snapshot__c")
-
-        Returns:
-            dict: A dictionary containing the response status and job details of the update request.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot/{api_name}/actions/update"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.post(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def upgrade_sandbox_snapshot(self, api_name):
-        """
-        Upgrade a sandbox snapshot to match the release version of the source sandbox Vault. The request to upgrade a snapshot is only valid if the upgrade_status is "Upgrade Available" or "Upgrade Required".
-        API Documentation: https://developer.veevavault.com/api/23.2/#upgrade-sandbox-snapshot
-
-        Parameters:
-            api_name (str): The API name of the snapshot obtained from the Retrieve Sandbox Snapshots request.
-
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.upgrade_sandbox_snapshot(api_name="veepharm_snapshot__c")
-
-        Returns:
-            dict: A dictionary containing the response status and job details of the upgrade request.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot/{api_name}/actions/upgrade"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-
-        response = requests.post(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def build_production_vault(self, source):
-        """
-        Given a pre-production Vault, this method allows you to build a production Vault. This is analogous to the Build action in the Vault UI. It is possible to build or rebuild the source Vault for a given pre-production Vault no more than three times in a 24-hour period.
-        API Documentation: https://developer.veevavault.com/api/23.2/#build-production-vault
-        
-        Parameters:
-            source (str): The name of the source Vault to build. This can be the current pre-production Vault or a sandbox Vault. Sandboxes must be active and match the release type (General or Limited) of the pre-production Vault.
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.build_production_vault(source="UAT")
-        
-        Returns:
-            dict: A dictionary containing the response status and job details of the build request.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/actions/buildproduction"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json",
-            "Content-Type": "application/x-www-form-urlencoded"
-        }
-        data = {
-            "source": source
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def promote_to_production(self, name):
-        """
-        Given a built pre-production Vault, this method allows you to promote it to a production Vault. This action is analogous to the Promote action in the Vault UI. Note that you must build your pre-production Vault before you can promote it to production.
-        API Documentation: https://developer.veevavault.com/api/23.2/#promote-to-production
-        
-        Parameters:
-            name (str): The name of the pre-production Vault to promote.
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.promote_to_production(name="VeePharm")
-        
-        Returns:
-            dict: A dictionary containing the response status of the promotion request.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/actions/promoteproduction"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json",
-            "Content-Type": "application/x-www-form-urlencoded"
-        }
-        data = {
-            "name": name
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-
-
-
-
-    #######################################################
-    # Logs
-    #######################################################
-
-
-    def retrieve_audit_types(self):
-        """
-        This method retrieves all available audit types that the user has permission to access.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-audit-types
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.retrieve_audit_types()
-        
-        Returns:
-            dict: A dictionary containing the response status and a list of available audit types.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/audittrail"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def retrieve_audit_metadata(self, audit_trail_type):
-        """
-        This method retrieves all fields and their metadata for a specified audit trail or log type.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-audit-metadata
-        
-        Args:
-            audit_trail_type (str): The name of the specified audit type (document_audit_trail, object_audit_trail, etc).
-        
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.retrieve_audit_metadata(audit_trail_type='document_audit_trail')
-        
-        Returns:
-            dict: A dictionary containing the response status and the metadata for the specified audit trail type.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/audittrail/{audit_trail_type}"
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def retrieve_audit_details(self, audit_trail_type, start_date=None, end_date=None, all_dates=None, format_result=None, limit=None, offset=None, objects=None, events=None):
-        """
-        This method retrieves all audit details for a specific audit type. This request supports optional parameters to narrow the results to a specified date and time within the past 30 days.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-audit-details
-
-        Args:
-            audit_trail_type (str): The name of the specified audit type. Use the Retrieve Audit Types API to retrieve types available in your Vault.
-            start_date (str, optional): The start date in YYYY-MM-DDTHH:MM:SSZ format to retrieve audit information.
-            end_date (str, optional): The end date in YYYY-MM-DDTHH:MM:SSZ format to retrieve audit information.
-            all_dates (bool, optional): Set to true to request audit information for all dates.
-            format_result (str, optional): To request a downloadable CSV file of your audit details, use 'csv'.
-            limit (int, optional): Specifies the maximum number of histories per page in the response.
-            offset (int, optional): Specifies the amount of offset from the entry returned.
-            objects (str, optional): A comma-separated list of one or more object names to retrieve their audit details.
-            events (str, optional): A comma-separated list of one or more audit events to retrieve their audit details.
-
-        Usage:
-            vv_instance = Vv()
-            response = vv_instance.retrieve_audit_details(audit_trail_type='login_audit_trail', start_date='2023-08-01T00:00:00Z', end_date='2023-08-31T00:00:00Z')
-
-        Returns:
-            dict: A dictionary containing the response details and data for the specified audit trail type.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/audittrail/{audit_trail_type}"
-        
-        headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        params = {
-            "start_date": start_date,
-            "end_date": end_date,
-            "all_dates": all_dates,
-            "format_result": format_result,
-            "limit": limit,
-            "offset": offset,
-            "objects": objects,
-            "events": events
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        if response.status_code == 200:
-            return response.json()
-        else:
-            return response.status_code, response.reason
-
-
-    def retrieve_complete_audit_history(self, doc_id, start_date=None, end_date=None, format_result=None, limit=None, offset=None, events=None):
-        """
-        Retrieve complete audit history for a single document.
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-complete-audit-history-for-a-single-document
-
-        Args:
-        doc_id (str): The document ID for which to retrieve audit history.
-        start_date (str): Specify a start date to retrieve audit history in YYYY-MM-DDTHH:MM:SSZ format. Defaults to the Vault’s creation date if omitted.
-        end_date (str): Specify an end date to retrieve audit history in YYYY-MM-DDTHH:MM:SSZ format. Defaults to today’s date if omitted.
-        format_result (str): To request a CSV file of the audit history, use 'csv'. Ignores start_date and end_date if used.
-        limit (int): Paginate the results by specifying the maximum number of histories per page in the response. Can be any value between 1 and 1000. Defaults to 200 if omitted.
-        offset (int): Paginate the results displayed per page by specifying the offset from the entry returned. Defaults to 0 if omitted.
-        events (str): Provide a comma-separated list of one or more audit events to retrieve their audit history. Defaults to all audit events if omitted.
-
-        Returns:
-        response (dict): A dictionary containing the response data from the API call.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/audittrail"
-        params = {
-            'start_date': start_date,
-            'end_date': end_date,
-            'format_result': format_result,
-            'limit': limit,
-            'offset': offset,
-            'events': events
-        }
-        headers = {
-            'Authorization': self.sessionId,
-            'Accept': 'application/json'
-        }
-        response = requests.get(url, headers=headers, params=params).json()
-        return response.json()
-
-
-    def retrieve_audit_history_single_object_record(self, object_name, object_record_id, start_date=None, end_date=None, format_result=None, limit=None, offset=None, events=None):
-        """
-        Retrieve complete audit history for a single object record.
-        
-        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-complete-audit-history-for-a-single-object-record
-        
-        Parameters:
-        object_name (str): The name__v of the object for which to retrieve audit history.
-        object_record_id (str): The object record ID for which to retrieve audit history.
-        start_date (str, optional): Specify a start date to retrieve audit history in YYYY-MM-DDTHH:MM:SSZ format. Defaults to Vault’s creation date if omitted.
-        end_date (str, optional): Specify an end date to retrieve audit history in YYYY-MM-DDTHH:MM:SSZ format. Defaults to today’s date if omitted.
-        format_result (str, optional): To request a CSV file of your audit history, use 'csv'. Defaults to None.
-        limit (int, optional): Paginate the results by specifying the maximum number of histories per page in the response, between 1 and 1000. Defaults to 200 if omitted.
-        offset (int, optional): Paginate the results displayed per page by specifying the amount of offset from the entry returned. Defaults to 0 if omitted.
-        events (str, optional): Provide a comma-separated list of one or more audit events to retrieve their audit history. Defaults to all audit events if omitted.
-        
-        Returns:
-        dict: The response data containing the audit history details.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/audittrail"
-        params = {
-            "start_date": start_date,
-            "end_date": end_date,
-            "format_result": format_result,
-            "limit": limit,
-            "offset": offset,
-            "events": events
-        }
-        headers = {
-            "Accept": "application/json",
-            "Authorization": self.sessionId
-        }
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-    def retrieve_email_notification_histories(self, start_date=None, end_date=None, all_dates=None, format_result=None, limit=200, offset=0):
-        """
-        Retrieves details about the email notifications sent by Vault. Details include the notification date, recipient, subject, and delivery status. 
-        Learn more at: https://developer.veevavault.com/api/23.2/#retrieve-email-notification-histories
-
-        Args:
-        start_date (str): Specify a start date to retrieve notification history in YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Defaults to None.
-        end_date (str): Specify an end date to retrieve notification history in YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Defaults to None.
-        all_dates (bool): Set to true to request notification history for all dates. Defaults to None.
-        format_result (str): To request a downloadable CSV file, set this parameter to 'csv'. Defaults to None.
-        limit (int): Specify the maximum number of histories per page in the response, between 1 and 1000. Defaults to 200.
-        offset (int): Specify the amount of offset from the entry returned. Defaults to 0.
-
-        Returns:
-        dict: The response from the API call.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/notifications/histories"
-        
-        params = {
-            'start_date': start_date,
-            'end_date': end_date,
-            'all_dates': all_dates,
-            'format_result': format_result,
-            'limit': limit,
-            'offset': offset
-        }
-        
-        response = requests.get(url, headers=self.APIheaders, params=params)
-        return response.json()
-
-
-    def download_daily_api_usage(self, date, log_format='csv'):
-        """
-        Retrieve the API Usage Log for a single day, up to 30 days in the past. The log contains information such as user name, user ID, remaining burst limit, and the endpoint called. 
-        API documentation: https://developer.veevavault.com/api/23.2/#download-daily-api-usage
-
-        :param date: The day to retrieve the API Usage log in 'YYYY-MM-DD' format. Date cannot be more than 30 days in the past.
-        :param log_format: Optional parameter to specify the format to download. Possible values are 'csv' or 'logfile'. If omitted, defaults to 'csv'.
-        
-        :return: The response containing the log as a .ZIP file.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/logs/api_usage"
-        params = {
-            "date": date,
-            "log_format": log_format
-        }
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        with open('response.zip', 'wb') as file:
-            file.write(response.content)
-        
-        return response.json()
-
-
-    def download_sdk_runtime_log(self, date, log_format='csv'):
-        """
-        Retrieve the Runtime Log for a single day, up to 30 days in the past. Users with the Admin: Logs: Vault Java SDK Logs permission can access these logs.
-        API documentation: https://developer.veevavault.com/api/23.2/#download-sdk-runtime-log
-
-        :param date: The day to retrieve the runtime log in 'YYYY-MM-DD' format. Date cannot be more than 30 days in the past.
-        :param log_format: Optional parameter to specify the format to download. Possible values are 'csv' or 'logfile'. If omitted, defaults to 'csv'.
-        
-        :return: The response containing the log as a .ZIP file.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/logs/code/runtime"
-        params = {
-            "date": date,
-            "log_format": log_format
-        }
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        with open(f'{date}-SdkLog.zip', 'wb') as file:
-            file.write(response.content)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # File Staging
-    #######################################################
-
-
-    def list_items_at_path(self, item, recursive=False, limit=1000, format_result=None):
-        """
-        Return a list of files and folders for the specified path. Paths are different for Admin users (Vault Owners and System Admins) and non-Admin users. 
-        API documentation: https://developer.veevavault.com/api/23.2/#list-items-at-a-path
-
-        :param item: The absolute path to a file or folder. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
-        :param recursive: If true, the response will contain the contents of all subfolders. If not specified, the default value is false.
-        :param limit: The maximum number of items per page in the response. This can be any value between 1 and 1000. If omitted, the default value is 1000.
-        :param format_result: If set to csv, the response includes a job_id. Use the Job ID value to retrieve the status and results of the request.
-
-        :return: The response containing the list of items at the specified path.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items/{item}"
-        params = {
-            "recursive": recursive,
-            "limit": limit,
-            "format_result": format_result
-        }
-        headers = {
-            "Accept": "application/json",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-    def download_item_content(self, item, byte_range=None):
-        """
-        Retrieve the content of a specified file from the file staging server. Use the Range header to create resumable downloads for large files, or to continue downloading a file if your session is interrupted.
-        API documentation: https://developer.veevavault.com/api/23.2/#download-item-content
-
-        :param item: The absolute path to a file. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
-        :param byte_range: Optional: Specifies a partial range of bytes to include in the download.
-
-        :return: The content of the specified file.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items/content/{item}"
-        headers = {
-            "Authorization": f"{self.sessionId}"
-        }
-        if byte_range:
-            headers["Range"] = f"bytes={byte_range}"
-
-        response = requests.get(url, headers=headers)
-        return response.content
-
-    def create_folder_or_file(self, kind, path, overwrite=None, file_content=None):
-        """
-        Upload files or folders up to 50MB to the File Staging Server. You can only create one file or folder per request.
-        API documentation: https://developer.veevavault.com/api/23.2/#create-folder-or-file
-        
-        :param kind: The kind of item to create. This can be either file or folder.
-        :param path: The absolute path, including file or folder name, to place the item in the file staging server. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
-        :param overwrite: Optional: If set to true, Vault will overwrite any existing files with the same name at the specified destination. For folders, this is always false.
-        :param file_content: To upload a file, use the multi-part attachment with the file component. The maximum allowed file size is 50MB.
-        
-        :return: Response from the API as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json",
-            "Content-Type": "multipart/form-data"
-        }
-        data = {
-            "kind": kind,
-            "path": path
-        }
-        if overwrite is not None:
-            data["overwrite"] = overwrite
-        if file_content:
-            data["file"] = file_content
-
-        response = requests.post(url, headers=headers, data=data)
-        return response.json()
-
-
-    def update_folder_or_file(self, item, parent=None, name=None):
-        """
-        Move or rename a folder or file on the file staging server. You can move and rename an item in the same request.
-        API documentation: https://developer.veevavault.com/api/23.2/#update-folder-or-file
-        
-        :param item: The absolute path to a file or folder. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
-        :param parent: Conditional: When moving a file or folder, specifies the absolute path to the parent directory in which to place the file.
-        :param name: Conditional: When renaming a file or folder, specifies the new name.
-        
-        :return: Response from the API as a dictionary containing job ID and URL to check the job status.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items/{item}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        data = {}
-        if parent:
-            data["parent"] = parent
-        if name:
-            data["name"] = name
-
-        response = requests.put(url, headers=headers, data=data)
-        return response.json()
-
-
-
-    def delete_file_or_folder(self, item, recursive=False):
-        """
-        Delete an individual file or folder from the file staging server.
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-file-or-folder
-        
-        :param item: The absolute path to the file or folder to delete. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
-        :param recursive: Applicable to deleting folders only. If true, the request will delete the contents of a folder and all subfolders. The default is false.
-        
-        :return: Response from the API as a dictionary containing job ID and URL to check the job status.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items/{item}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        params = {
-            "recursive": recursive
-        }
-        
-        response = requests.delete(url, headers=headers, params=params)
-        return response.json()
-
-
-
-    #######################################################
-    # File Staging
-    ## Resumable Upload Sessions
-    #######################################################
-
-    def create_resumable_upload_session(self, path, size, overwrite=False):
-        """
-        Initiate a multipart upload session and return an upload session ID.
-        API documentation: https://developer.veevavault.com/api/23.2/#create-resumable-upload-session
-        
-        :param path: The absolute path, including file name, to place the file in the staging server. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
-        :param size: The size of the file in bytes. The maximum file size is 500GB.
-        :param overwrite: If set to true, Vault will overwrite any existing files with the same name at the specified destination. Default is False.
-        
-        :return: Response from the API as a dictionary containing details about the created upload session.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json",
-            "Content-Type": "application/x-www-form-urlencoded"
-        }
-        data = {
-            'path': path,
-            'size': size,
-            'overwrite': overwrite
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        return response.json()
-
-
-    def upload_to_session(self, upload_session_id, file_part, part_number, content_length, content_md5=None):
-        """
-        The session owner can upload parts of a file to an active upload session.
-        API documentation: https://developer.veevavault.com/api/23.2/#upload-to-a-session
-        
-        :param upload_session_id: The upload session ID.
-        :param file_part: The file part to be uploaded as binary data.
-        :param part_number: The part number, which uniquely identifies a file part and defines its position within the file as a whole.
-        :param content_length: The size of the file part in bytes. Parts must be at least 5MB in size, except for the last part uploaded in a session.
-        :param content_md5: Optional: The MD5 checksum of the file part being uploaded.
-        
-        :return: Response from the API as a dictionary containing details about the uploaded file part.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json",
-            "Content-Type": "application/octet-stream",
-            "Content-Length": str(content_length),
-            "X-VaultAPI-FilePartNumber": str(part_number)
-        }
-        if content_md5:
-            headers["Content-MD5"] = content_md5
-        
-        response = requests.put(url, headers=headers, data=file_part)
-        return response.json()
-
-
-
-    def commit_upload_session(self, upload_session_id):
-        """
-        Mark an upload session as complete and assemble all previously uploaded parts to create a file.
-        API documentation: https://developer.veevavault.com/api/23.2/#commit-upload-session
-        
-        :param upload_session_id: The upload session ID.
-        
-        :return: Response from the API as a dictionary containing job_id for the commit.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json",
-            "Content-Type": "application/json"
-        }
-        
-        response = requests.post(url, headers=headers)
-        return response.json()
-
-
-    def list_upload_sessions(self):
-        """
-        Return a list of active upload sessions.
-        API documentation: https://developer.veevavault.com/api/23.2/#list-upload-sessions
-        
-        :return: Response from the API as a dictionary containing details of all active upload sessions.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-
-    def get_upload_session_details(self, upload_session_id):
-        """
-        Retrieve the details of an active upload session. Admin users can get details for all sessions, while non-Admin users can only get details for sessions if they are the owner.
-        API documentation: https://developer.veevavault.com/api/23.2/#get-upload-session-details
-        
-        :param upload_session_id: The ID of the upload session to retrieve details for.
-        :return: Response from the API as a dictionary containing the details of the specified upload session.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def list_file_parts_uploaded_to_session(self, upload_session_id, limit=1000):
-        """
-        Return a list of parts uploaded in a session. You must be an Admin user or the session owner.
-        API documentation: https://developer.veevavault.com/api/23.2/#list-file-parts-uploaded-to-session
-        
-        :param upload_session_id: The ID of the upload session to retrieve the uploaded file parts for.
-        :param limit: Optional parameter to specify the maximum number of items per page in the response, default is 1000.
-        :return: Response from the API as a dictionary containing the list of uploaded file parts and pagination details.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}/parts"
-        params = {"limit": limit}
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-    def abort_upload_session(self, upload_session_id):
-        """
-        Abort an active upload session and purge all uploaded file parts. Admin users can see and abort all upload sessions, while non-Admin users can only see and abort sessions where they are the owner.
-        API documentation: https://developer.veevavault.com/api/23.2/#abort-upload-session
-        
-        :param upload_session_id: The ID of the upload session to be aborted.
-        :return: Response from the API as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.delete(url, headers=headers)
-        return response.json()
-
-
-
-
-    #######################################################
-    # Vault Loader
-    #######################################################
-
-    #######################################################
-    # Vault Loader
-    ## Multi-File Extract
-    #######################################################
-
-
-    def extract_data_files(self, data_objects, sendNotification=False):
-        """
-        Create a Loader job to extract one or more data files.
-        API documentation: https://developer.veevavault.com/api/23.2/#extract-data-files
-        
-        :param data_objects: List of dictionaries representing the data objects to extract.
-        :param sendNotification: Whether to send a Vault notification when the job completes. Defaults to False.
-        :return: Response from the API as a dictionary.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/extract"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        params = {
-            "sendNotification": sendNotification
-        }
-        
-        response = requests.post(url, headers=headers, params=params, json=data_objects)
-        return response.json()
-
-
-    def retrieve_loader_extract_results(self, job_id, task_id):
-        """
-        Retrieve the results of a specified job task after submitting a request to extract object types from your Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-loader-extract-results
-
-        :param job_id: The ID value of the requested extract job.
-        :param task_id: The ID value of the requested extract task.
-        :return: Response from the API as a string (CSV format).
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/{job_id}/tasks/{task_id}/results"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "text/csv"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.text
-
-
-    def retrieve_loader_extract_renditions_results(self, job_id, task_id):
-        """
-        Retrieve the results of a specified job task that includes renditions requested with documents from your Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-loader-extract-renditions-results
-
-        :param job_id: The ID value of the requested extract job.
-        :param task_id: The ID value of the requested extract task.
-        :return: Response from the API as a string (CSV format).
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/{job_id}/tasks/{task_id}/results/renditions"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "text/csv"
-        }
-        
-        response = requests.get(url, headers=headers)
-        return response.text
-
-
-
-
-
-
-
-    #######################################################
-    # Vault Loader
-    ## Multi-File Load
-    #######################################################
-
-    def load_data_objects(self, data_objects, send_notification=False):
-        """
-        Create a loader job and load a set of data files in the Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#load-data-objects
-
-        :param data_objects: A list of dictionaries representing data objects to load. 
-        :param send_notification: Boolean indicating whether to send a Vault notification when the job completes.
-        :return: Response from the API in JSON format.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/load"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        params = {
-            "sendNotification": send_notification
-        }
-        response = requests.post(url, headers=headers, json=data_objects, params=params)
-        return response.json()
-
-
-    def retrieve_load_success_log_results(self, job_id, task_id):
-        """
-        Retrieve success logs of the loader results from the Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-load-success-log-results
-
-        :param job_id: The ID value of the requested extract job.
-        :param task_id: The ID value of the requested extract task.
-        :return: CSV file that includes the success log of the loader results.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/{job_id}/tasks/{task_id}/successlog"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "text/csv"
-        }
-        response = requests.get(url, headers=headers)
-        return response.content
-
-
-    def retrieve_load_failure_log_results(self, job_id, task_id):
-        """
-        Retrieve failure logs of the loader results from the Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-load-failure-log-results
-
-        :param job_id: The ID value of the requested extract job.
-        :param task_id: The ID value of the requested extract task.
-        :return: CSV file that includes the failure log of the loader results.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/{job_id}/tasks/{task_id}/failurelog"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "text/csv"
-        }
-        response = requests.get(url, headers=headers)
-        return response.content
-
-
-
-
-    #######################################################
-    # Jobs
-    #######################################################
-
-
-    def retrieve_job_status(self, job_id):
-        """
-        Retrieve the status of a job previously requested through the API from the Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-job-status
-
-        :param job_id: The ID of the job, returned from the original job request.
-        :return: JSON object containing details about the job status.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/{job_id}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_job_tasks(self, job_id):
-        """
-        Retrieve the tasks associated with an SDK job in the Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-job-tasks
-
-        :param job_id: The ID of the job, returned from the original job request.
-        :return: JSON object containing details about the job tasks.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/{job_id}/tasks"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-    def retrieve_job_histories(self, start_date=None, end_date=None, status=None, limit=None, offset=None):
-        """
-        Retrieve a history of all completed jobs in the authenticated Vault. 
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-job-histories
-
-        :param start_date: Sets the date to start retrieving completed jobs, in the format YYYY-MM-DDTHH:MM:SSZ. Optional.
-        :param end_date: Sets the date to end retrieving completed jobs, in the format YYYY-MM-DDTHH:MM:SSZ. Optional.
-        :param status: Filter to only retrieve jobs in a certain status. Optional.
-        :param limit: Paginate the results by specifying the maximum number of histories per page in the response. Optional.
-        :param offset: Paginate the results displayed per page by specifying the amount of offset from the first job history returned. Optional.
-        :return: JSON object containing details about the job histories.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/histories"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        params = {
-            "start_date": start_date,
-            "end_date": end_date,
-            "status": status,
-            "limit": limit,
-            "offset": offset
-        }
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-    def retrieve_job_monitors(self, start_date=None, end_date=None, status=None, limit=None, offset=None):
-        """
-        Retrieve monitors for jobs which have not yet completed in the authenticated Vault. 
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-job-monitors
-
-        :param start_date: Sets the date to start retrieving uncompleted jobs, based on the date and time the job instance was created. Optional.
-        :param end_date: Sets the date to end retrieving uncompleted jobs, based on the date and time the job instance was created. Optional.
-        :param status: Filter to only retrieve jobs in a certain status. Optional.
-        :param limit: Paginate the results by specifying the maximum number of jobs per page in the response. Optional.
-        :param offset: Paginate the results displayed per page by specifying the amount of offset from the first job instance returned. Optional.
-        :return: JSON object containing details about the job monitors.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/monitors"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        params = {
-            "start_date": start_date,
-            "end_date": end_date,
-            "status": status,
-            "limit": limit,
-            "offset": offset
-        }
-        response = requests.get(url, headers=headers, params=params)
-        return response.json()
-
-
-
-    def start_job(self, job_id):
-        """
-        Moves up a scheduled job instance to start immediately. Each time a user calls this API, Vault cancels the next scheduled instance of the specified job. 
-        API documentation: https://developer.veevavault.com/api/23.2/#start-job
-
-        :param job_id: The ID of the scheduled job instance to start.
-        :return: JSON object containing the response details.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/start_now/{job_id}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.post(url, headers=headers)
-        return response.json()
-
-
-
-    #######################################################
-    # Managing Vault Java SDK
-    #######################################################
-
-
-    def retrieve_single_source_code_file(self, class_name):
-        """
-        Retrieve a single source code file from the currently authenticated Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-single-source-code-file
-        
-        :param class_name: The fully qualified class name of your file.
-        :return: The source code file content.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/code/{class_name}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.get(url, headers=headers)
-        return response.text
-
-
-    def enable_or_disable_vault_extension(self, class_name, action):
-        """
-        Enable or disable a deployed Vault extension in the currently authenticated Vault. 
-        Only available on entry-point classes, such as triggers and actions.
-        API documentation: https://developer.veevavault.com/api/23.2/#enable-or-disable-vault-extension
-
-        :param class_name: The fully qualified class name of your file.
-        :param action: The action to be performed - either 'enable' or 'disable'.
-        :return: API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/code/{class_name}/{action}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json",
-            "Content-Type": "multipart/form-data"
-        }
-        response = requests.put(url, headers=headers)
-        return response.json()
-
-
-    def add_or_replace_single_source_code_file(self, file_path):
-        """
-        Add or replace a single .java file in the currently authenticated Vault. If the given file does not already exist in the Vault, it is added. If the file already exists in the Vault, the file is updated. It is not recommended to use this endpoint to deploy code as it may introduce code that breaks existing deployed code. For best practices, use the VPK Deploy method.
-        API documentation: https://developer.veevavault.com/api/23.2/#add-or-replace-single-source-code-file
-
-        :param file_path: The path to the .java file you wish to add or replace.
-        :return: API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/code"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json",
-            "Content-Type": "multipart/form-data"
-        }
-        with open(file_path, 'rb') as file:
-            response = requests.put(url, headers=headers, files={'file': file})
-        return response.json()
-
-
-    def delete_single_source_code_file(self, class_name):
-        """
-        Delete a single source code file from the currently authenticated Vault. This endpoint is not recommended for use as it may delete code that breaks existing deployed code. For best practices, use the VPK Deploy method. Note that you cannot delete a code component currently in use.
-        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-source-code-file
-
-        :param class_name: The fully qualified class name of the file to be deleted.
-        :return: API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/code/{class_name}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.delete(url, headers=headers)
-        return response.json()
-
-
-    def validate_imported_package(self, package_id):
-        """
-        Validate a previously imported VPK package with Vault Java SDK code. Note that this endpoint does not validate component dependencies for Configuration Migration packages.
-        API documentation: https://developer.veevavault.com/api/23.2/#validate-imported-package
-
-        :param package_id: The ID of the package to validate, which can be found in the API response of a package import or in the URL of the package in the Vault UI.
-        :return: API response.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/vobject/vault_package__v/{package_id}/actions/validate"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.post(url, headers=headers)
-        return response.json()
-
-
-    def retrieve_signing_certificate(self, cert_id):
-        """
-        Allows you to retrieve a signing certificate included in a Spark message header to verify that the received message came from Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-signing-certificate
-
-        :param cert_id: The cert_id is provided in each Spark message in the X-VaultAPISignature-CertificateId header.
-        :return: The public key certificate (.pem) file used for message verification.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/certificate/{cert_id}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.get(url, headers=headers)
-        return response.text
-
-
-    def retrieve_all_queues(self):
-        """
-        Retrieve all queues in a Vault.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-queues
-        
-        :return: A list of all available queues and their operational statuses.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-
-    def retrieve_queue_status(self, queue_name):
-        """
-        Retrieve the status of a specific queue.
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-queue-status
-        
-        :param queue_name: The name of a specific queue. For example, queue__c.
-        :return: The status of the specified queue including delivery status, number of messages in the queue, and details of the last message delivered.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues/{queue_name}"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.get(url, headers=headers)
-        return response.json()
-
-
-    def disable_delivery(self, queue_name):
-        """
-        Disable the delivery of messages in an outbound Spark messaging queue or an SDK job queue.
-        API documentation: https://developer.veevavault.com/api/23.2/#disable-delivery
-        
-        :param queue_name: The name of a specific queue.
-        :return: Response status of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues/{queue_name}/actions/disable_delivery"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.put(url, headers=headers)
-        return response.json()
-
-
-    def enable_delivery(self, queue_name):
-        """
-        Enable the delivery of messages in an outbound Spark messaging queue or an SDK job queue.
-        API documentation: https://developer.veevavault.com/api/23.2/#enable-delivery
-        
-        :param queue_name: The name of a specific queue.
-        :return: Response status of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues/{queue_name}/actions/enable_delivery"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.put(url, headers=headers)
-        return response.json()
-
-    def reset_queue(self, queue_name):
-        """
-        Delete all messages in a specific queue. This action is final and cannot be undone.
-        API documentation: https://developer.veevavault.com/api/23.2/#reset-queue
-        
-        :param queue_name: The name of a specific queue.
-        :return: Response status and message of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues/{queue_name}/actions/reset"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        response = requests.put(url, headers=headers)
-        return response.json()
-
-
-
-
-
-
-    #######################################################
-    # Clinical Operations
-    #######################################################
-
-    def create_edls(self, study_id, file_content, content_type='text/csv', accept='text/csv', apply_where_edl_items_exist=None):
-        """
-        Create a new Expected Document List.
-        API documentation: https://developer.veevavault.com/api/23.2/#create-edls
-        
-        :param study_id: The ID of the study.
-        :param file_content: The content of the file to be uploaded in text/csv format.
-        :param content_type: The content type of the request, defaults to 'text/csv'.
-        :param accept: The format in which to receive the response, defaults to 'text/csv'.
-        :param apply_where_edl_items_exist: Optional parameter to apply the Create EDL job to existing EDLs.
-        :return: Response status and job details of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/study__v/{study_id}/actions/etmfcreateedl"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": content_type,
-            "Accept": accept
-        }
-        params = {
-            "applyWhereEdlItemsExist": apply_where_edl_items_exist
-        }
-        response = requests.post(url, headers=headers, data=file_content, params=params)
-        return response.json()
-
-
-    def recalculate_milestone_document_field(self, file_content):
-        """
-        Recalculate the milestone__v field on a specified set of documents.
-        API documentation: https://developer.veevavault.com/api/23.2/#recalculate-milestone-document-field
-        
-        :param file_content: The content of the CSV file to be uploaded, which contains document id values in an id column.
-        :return: Response status and message of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/recalculatemilestones/batch"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-        response = requests.post(url, headers=headers, data=file_content)
-        return response.json()
-
-
-    def apply_edl_template_to_milestone(self, milestone_id, edl_id):
-        """
-        Apply an EDL template to a Milestone object record.
-        API documentation: https://developer.veevavault.com/api/23.2/#apply-edl-template-to-a-milestone
-
-        :param milestone_id: The ID of the milestone.
-        :param edl_id: The ID of the EDL template to apply to this milestone.
-        :return: Response status and job details of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/milestone__v/{milestone_id}/actions/etmfcreateedl"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        data = {
-            "edl_id": edl_id
-        }
-        response = requests.post(url, headers=headers, data=data)
-        return response.json()
-
-
-    def create_milestones_from_template(self, object_name, object_record_id):
-        """
-        Use this request to initiate the Create Milestones from Template user action on a study, study country, or site.
-        API documentation: https://developer.veevavault.com/api/23.2/#create-milestones-from-template
-
-        :param object_name: The object name__v field value. This endpoint only works with the study__v, study_country__v, or site__v objects.
-        :param object_record_id: The object record ID field value.
-        :return: Response status and job details of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions/createmilestones"
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-        response = requests.post(url, headers=headers)
-        return response.json()
-
-
-
-    def execute_milestone_story_events(self, object_name, csv_file_path, id_param=None):
-        """
-        Use this request to create Milestones based on specific Story Events for multiple studies, study countries, or sites.
-        API documentation: https://developer.veevavault.com/api/23.2/#execute-milestone-story-events
-
-        :param object_name: The object name__v field value. This endpoint only works with the study__v, study_country__v, or site__v objects.
-        :param csv_file_path: Path to the CSV input file containing details to create milestones.
-        :param id_param: (Optional) Unique field name to identify objects in the CSV input, if not using id.
-        :return: Response details containing job IDs or errors.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/clinical/milestone/{object_name}/actions/applytemplate"
-        if id_param:
-            url += f"?idParam={id_param}"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-
-        with open(csv_file_path, 'rb') as f:
-            response = requests.post(url, headers=headers, data=f)
-        
-        return response.json()
-
-
-
-    def veeva_site_connect_distribute_to_sites(self, distribution_id):
-        """
-        This API allows sponsors and CROs to send Safety reports and letters to Sites. 
-        API documentation: https://developer.veevavault.com/api/23.2/#veeva-site-connect-distribute-to-sites
-
-        :param distribution_id: The record ID of the Safety Distribution record to send. Must be in a Ready or Distributed state.
-        :return: Response details containing job ID and message.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/clinical/safety_distributions/{distribution_id}/actions/send"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-
-        response = requests.post(url, headers=headers)
-        
-        return response.json()
-
-
-
-    def populate_site_fee_definitions(self, target_study, source_study=None, source_template=None):
-        """
-        Given an existing study with Site Fee Definitions or an eligible Site Fee Template, 
-        automatically generate Site Fee Definitions for a new target study. 
-        This endpoint is only available in CTMS Vaults with the Vault Payments add-on.
-        API documentation: https://developer.veevavault.com/api/23.2/#populate-site-fee-definitions
-
-        :param target_study: The new study to populate with Site Fee Definitions.
-        :param source_study: (Optional) To copy the Site Fee Definitions from studies, include an array with the study IDs.
-        :param source_template: (Optional) To copy the Site Fee Definitions from Site Fee Templates, include an array with the template IDs.
-        :return: Response details containing status and other information.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/clinical/payments/populate-site-fee-definitions"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-
-        data = {
-            "target_study": target_study,
-        }
-        if source_study:
-            data["source_study"] = source_study
-        if source_template:
-            data["source_template"] = source_template
-
-        response = requests.post(url, headers=headers, json=data)
-        
-        return response.json()
-
-
-
-
-    #######################################################
-    # PromoMats
-    #######################################################
-
-    def create_document_update_job(self):
-        """
-        Vault owners can update documents with a Global Content Type of 'Not Specified' to a mapped value. 
-        Learn more about Configuring PromoMats Standard Metrics in Vault Help.
-        API documentation: https://developer.veevavault.com/api/23.2/#standard-metrics-create-document-update-job
-
-        :return: Response details containing jobInstanceId and any errors encountered.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/standardMetrics/createDocumentUpdateJob"
-
-        headers = {
-            "Authorization": f"{self.sessionId}"
-        }
-
-        response = requests.post(url, headers=headers)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # QualityDocs
-    #######################################################
-
-    def document_role_check_for_document_change_control(self, object_record_id, application_role):
-        """
-        Check if any document added to a Document Change Control (DCC) record has one or more users in a specified 
-        Application Role. This API only checks documents added to the standard Documents to be Released and Documents 
-        to be Made Obsolete sections.
-        API documentation: https://developer.veevavault.com/api/23.2/#document-role-check-for-document-change-control
-
-        :param object_record_id: The ID field value of the document_change_control__v object record.
-        :param application_role: The name of the application_role__v.
-        :return: Response details including the Boolean check_result field.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/document_change_control__v/{object_record_id}/actions/documentrolecheck"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-
-        data = {
-            "application_role": application_role
-        }
-
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # QMS
-    #######################################################
-
-
-    def update_quality_team_members(self, object_name, csv_file_path):
-        """
-        Manage Quality Team members on existing records. This endpoint does not support initial Quality Team record 
-        migrations or the creation of new Quality Teams on existing process records. Vault performs updates to Quality 
-        Team assignments asynchronously on behalf of the user.
-        API documentation: https://developer.veevavault.com/api/23.2/#update-quality-team-members
-
-        :param object_name: The object name__v field value for the team-enabled object. 
-                            For example, risk_event__v, investigation__qdm, quality_event__qdm.
-        :param csv_file_path: The path to the CSV file containing the necessary parameters.
-        :return: Response details including the job_id for the action.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/quality/qms/teams/vobjects/{object_name}/actions/manageassignments"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "text/csv"
-        }
-
-        with open(csv_file_path, 'rb') as f:
-            response = requests.post(url, headers=headers, data=f)
-        
-        return response.json()
-
-
-
-
-
-    #######################################################
-    # RIM Submissions Archive
-    #######################################################
-
-    def import_submission(self, submission_id, file_path):
-        """
-        Import a submission into your Vault. Before executing this request, ensure you have the necessary permissions, 
-        created the required object records in your Vault, and uploaded a valid submission import file or folder to your 
-        file staging server following the proper structure.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#import-submission
-
-        :param submission_id: The id field value of the submission__v object record.
-        :param file_path: The path to the submission folder or ZIP file relative to the file staging server root 
-                        or to the path to your user file staging folder.
-        :return: Response details including the job_id and the URL to check the current status of the import request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/import"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Accept": "application/json"
-        }
-
-        data = {
-            "file": file_path
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-    def retrieve_submission_import_results(self, submission_id, job_id):
-        """
-        Retrieve the results of a completed submission import job. Before executing this request, ensure 
-        you have the necessary permissions and that the submission import job is completed (no longer active).
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-submission-import-results
-
-        :param submission_id: The id field value of the submission__v object record.
-        :param job_id: The jobId field value returned from the Import Submission request.
-        :return: Response details including the id, major_version_number__v, and minor_version_number__v of the created submission binder.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/import/{job_id}/results"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-
-    def retrieve_submission_metadata_mapping(self, submission_id):
-        """
-        Retrieve the metadata mapping values of an eCTD submission package. Before executing this request, 
-        make sure you have the necessary permissions.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-submission-metadata-mapping
-
-        :param submission_id: The id field value of the submission__v object record.
-        :return: Response details including metadata mapping records and relevant details such as name__v, 
-                external_id__v, xml_id and possible mappings like clinical_site__v, clinical_study__v, etc.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/ectdmapping"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.get(url, headers=headers)
-
-        return response.json()
-
-
-
-    def update_submission_metadata_mapping(self, submission_id, mapping_values):
-        """
-        Update the mapping values of a submission. Note that XML identifiers are read-only and cannot be updated via the API. 
-
-        API documentation: https://developer.veevavault.com/api/23.2/#update-submission-metadata-mapping
-
-        :param submission_id: The id field value of the submission__v object record.
-        :param mapping_values: A list of dictionaries containing mapping values to be updated.
-        :return: Response details including success status and details of updated mapping values.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/ectdmapping"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-
-        response = requests.put(url, headers=headers, json=mapping_values)
-
-        return response.json()
-
-
-
-    def remove_submission(self, submission_id):
-        """
-        Delete a previously imported submission from your Vault. By removing a submission, you delete any sections created in the archive binder as part of the submission import. This action also removes any documents in the submission from the archive binder but does not delete the documents from Vault.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#remove-submission
-
-        :param submission_id: The id field value of the submission__v object record.
-        :return: Response details including job ID and URL to check the job status.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/import"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        response = requests.delete(url, headers=headers)
-
-        return response.json()
-
-
-
-    def cancel_submission(self, submission_id):
-        """
-        Cancel an ongoing submission import or removal process. Depending on the current archive status of the submission, this action will have different outcomes as described in the API documentation. To proceed with a new import, the submission must be removed first if it was in the import or removal process.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#cancel-submission
-
-        :param submission_id: The id field value of the submission__v object record.
-        :return: Response details including the status of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/import"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        params = {
-            "cancel": "true"
-        }
-
-        response = requests.post(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-
-    def export_submission(self, binder_id, submission_id, major_version=None, minor_version=None):
-        """
-        Export a submission, allowing to either export the most recent version or a specific version of a Submissions Archive binder. The function supports two types of requests based on whether the major_version and minor_version are provided or not.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#export-submission
-
-        :param binder_id: The id field value of the binder.
-        :param submission_id: The id field value of the submission__v object record.
-        :param major_version: (Optional) The major_version_number__v field value of the binder.
-        :param minor_version: (Optional) The minor_version_number__v field value of the binder.
-        :return: Response details including the URL to check the status of the export job and the job_id.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        if major_version is not None and minor_version is not None:
-            url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export"
-        else:
-            url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/actions/export"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-
-        params = {
-            "submission": submission_id
-        }
-
-        response = requests.post(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-    def export_partial_submission(self, binder_id, submission_id, major_version, minor_version, file_path):
-        """
-        Exports specific sections and documents from a submissions binder in Vault. Depending on the major_version and minor_version parameters, it can either export from the latest version or a specific version of the submissions binder.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#export-partial-submission
-
-        :param binder_id: The id field value of the binder.
-        :param submission_id: The id field value of the submission__v object record.
-        :param major_version: The major_version_number__v field value of the binder.
-        :param minor_version: The minor_version_number__v field value of the binder.
-        :param file_path: The path to the CSV or JSON file containing the id values of the binder sections and/or documents to be exported.
-        :return: Response details including the URL to check the status of the export job and the job_id.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export"
-
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "text/csv",
-            "Accept": "application/json"
-        }
-
-        params = {
-            "submission": submission_id
-        }
-
-        with open(file_path, 'rb') as f:
-            response = requests.post(url, headers=headers, params=params, data=f)
-        
-        return response.json()
-
-
-    def download_exported_submission_files(self, job_id):
-        """
-        Downloads the files of a successfully completed submission export job from the file staging server. The files are packaged in a ZIP file on the file staging server.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#download-exported-submission-files-via-file-staging-server
-
-        :param job_id: The job ID of the successfully completed submission export job.
-        :return: A message indicating the status of the download operation.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/jobs/{job_id}/files"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        response = requests.get(url, headers=headers)
-        
-        return response.json()
-
-    def copy_into_content_plan(self, source_id, target_id, order, copy_documents):
-        """
-        Copies a content plan section or item to reuse existing content and prevent duplicate work. This operation can be used to copy a clinical study or quality section and its matched documents for a similar submission to a different application.
-
-        API documentation: https://developer.veevavault.com/api/23.2/#copy-into-content-plan
-
-        :param source_id: The ID of the content plan or content plan item to copy.
-        :param target_id: The ID of the parent content plan where the source content plan will be copied under. The target content plan cannot be inactive.
-        :param order: An integer indicating the position in the target content plan where the source content plan will be copied. A value of 1 indicates the first position in the target content plan.
-        :param copy_documents: A boolean value indicating whether matched documents are included in the copy. If false, matched documents are not included in the copy. This parameter cannot be omitted.
-        :return: A JSON response containing the job ID of the asynchronous copy operation or the record ID of the newly copied content plan item.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/rim/content_plans/actions/copyinto"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "application/json",
-            "Accept": "application/json"
-        }
-        
-        body = {
-            "source_id": source_id,
-            "target_id": target_id,
-            "order": order,
-            "copy_documents": copy_documents
-        }
-        
-        response = requests.post(url, headers=headers, json=body)
-        
-        return response.json()
-
-
-
-    #######################################################
-    # Safety
-    #######################################################
-
-    #######################################################
-    # Safety
-    ## Intake
-    #######################################################
-
-
-
-    def intake_inbox_item(self, file_path, origin_organization, format, organization, transmission_profile=None):
-        """
-        Imports an Inbox Item from an E2B (R2) or E2B (R3) file containing one or more Individual Case Safety Reports (ICSRs).
-
-        API documentation: https://developer.veevavault.com/api/23.2/#intake-inbox-item
-
-        :param file_path: The file path of the E2B file to be imported.
-        :param origin_organization: (Optional) The Vault API Name for the organization sending the E2B file. If not provided, the Origin Organization is left blank.
-        :param format: The format of the file being imported, which must match the Vault API Name of the Inbound Transmission Format picklist value. It should be an E2B format.
-        :param organization: (Optional) To specify which organization to send the Case to, enter the Vault API Name for the Organization record. If not provided, the Organization is set to vault_customer__v. Note that the Organization record type must be Sponsor.
-        :param transmission_profile: (Optional) The Vault API Name of the Transmission Profile to be used for E2B Intake. This parameter is necessary for Narrative Template Override and Inbox Item Auto-Promotion. If not provided, Vault uses parameters on the general_api_profile__v.
-        
-        :return: A JSON response containing the URL to retrieve the current status of the import request and the intake ID of the E2B import.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/intake/inbox-item"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data"
-        }
-        
-        data = {
-            'file': ('file', open(file_path, 'rb')),
-            'origin-organization': origin_organization,
-            'format': format,
-            'organization': organization
-        }
-        
-        if transmission_profile:
-            data['transmission-profile'] = transmission_profile
-        
-        response = requests.post(url, headers=headers, files=data)
-        
-        return response.json()
-
-
-    def intake_imported_case(self, file_path, format, organization, origin_organization=None):
-        """
-        Imports an Imported Case from an E2B (R2) or E2B (R3) file containing one or more Individual Case Safety Reports (ICSRs).
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#intake-imported-case
-
-        :param file_path: The file path of the E2B file to be imported.
-        :param format: The format of the file being imported, which must match the Vault API Name of the Inbound Transmission Format picklist value. Must be an E2B format or other__v.
-        :param organization: (Optional) To specify which organization to send the Case to, enter the Vault API Name for the Organization record. If not provided, the Organization is set to vault_customer__v.
-        :param origin_organization: (Optional) The Vault API Name for the organization sending the E2B file. If not provided, the Origin Organization is left blank.
-        
-        :return: A JSON response containing the URL to retrieve the current status of the import request and the intake ID of the E2B import.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/intake/imported-case"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Content-Type": "multipart/form-data"
-        }
-        
-        data = {
-            'file': ('file', open(file_path, 'rb')),
-            'format': format,
-            'organization': organization
-        }
-        
-        if origin_organization:
-            data['origin-organization'] = origin_organization
-        
-        response = requests.post(url, headers=headers, files=data)
-        
-        return response.json()
-
-
-
-
-    def retrieve_intake_status(self, inbound_id):
-        """
-        Retrieve the status of an intake API call using the inbound transmission ID for the ICSR intake job.
-        
-        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-intake-status
-
-        :param inbound_id: The Inbound Transmission ID for the ICSR intake job.
-        
-        :return: A JSON response containing details about the status of the intake job including processing status, ACK retrieval URL, inbound transmission and document IDs, number of cases and their statuses.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/intake/status"
-        
-        headers = {
-            "Authorization": f"{self.sessionId}",
-            "Accept": "application/json"
-        }
-        
-        params = {
-            'inbound_id': inbound_id
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        return response.json()
-
-
-
-    def retrieve_ack(self, inbound_id):
-        """
-        Retrieve the E2B acknowledgement message (ACK) after sending an intake call.
-        API Documentation URL: https://developer.veevavault.com/api/23.2/#retrieve-ack
-        
-        Args:
-            inbound_id (str): The Inbound Transmission ID for the ICSR intake job.
-            
-        Returns:
-            str: The response containing the ACK XML or a failure message.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/intake/ack"
-        params = {'inbound_id': inbound_id}
-        headers = {
-            'Authorization': f"{self.sessionId}",
-            'Accept': 'application/json'
-        }
-        
-        response = requests.get(url, headers=headers, params=params)
-        
-        if response.status_code == 200:
-            return response.text
-        else:
-            return response.json()
-
-
-
-
-
-
-    #######################################################
-    # Safety
-    ## Intake JSON
-    #######################################################
-
-    def intake_json(self, api_name, intake_json, intake_form=None):
-        """
-        Use this endpoint to send JSON to Vault Safety, which will be imported to a single Inbox Item.
-        API Documentation URL: https://developer.veevavault.com/api/23.2/#intake-json
-        
-        Args:
-            api_name (str): The Vault API Name for the Organization record.
-            intake_json (str): The filepath for the JSON intake file, or the raw JSON text.
-            intake_form (str, optional): The filepath for a source intake document.
-            
-        Returns:
-            dict: The response containing job details or a failure message.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/ai/intake?API_Name={api_name}"
-        
-        headers = {
-            'Authorization': f"{self.sessionId}",
-            'Content-Type': 'application/json' if intake_form is None else 'multipart/form-data'
-        }
-        
-        data = {
-            'intake_json': intake_json,
-            'intake_form': intake_form
-        }
-        
-        response = requests.post(url, headers=headers, data=data)
-        
-        return response.json()
-
-
-    #######################################################
-    # Safety
-    ## Import Narrative
-    #######################################################
-
-    def import_narrative(self, case_id, narrative_type, narrative_language, narrative_text, link_translation_to_primary=False):
-        """
-        Use this endpoint to import narrative text into a Case narrative.
-        API Documentation URL: https://developer.veevavault.com/api/23.2/#import-narrative
-
-        Args:
-            case_id (str): Destination Case or Adverse Event Report ID.
-            narrative_type (str): Type of narrative - 'primary' or 'translation'.
-            narrative_language (str): Three-letter ISO 639-2 language code.
-            narrative_text (str): Narrative text to be imported, limited to 100000 characters.
-            link_translation_to_primary (bool): Set to true to add the localized narrative document as a supporting document to the global (English) narrative document. Defaults to False.
-
-        Returns:
-            dict: The response containing status of the request.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/import-narrative"
-
-        headers = {
-            'Authorization': f"{self.sessionId}",
-            'caseId': case_id,
-            'narrativeType': narrative_type,
-            'narrativeLanguage': narrative_language,
-            'Content-Type': 'text/plain',
-            'link_translation_to_primary': str(link_translation_to_primary).lower()
-        }
-
-        response = requests.post(url, headers=headers, data=narrative_text)
-
-        return response.json()
-
-
-    def bulk_import_narrative(self, narratives_file_path, integrity_check=False, migration_mode=False, archive_document=None):
-        """
-        Use this endpoint to bulk import case narratives into Vault Safety.
-        API Documentation URL: https://developer.veevavault.com/api/23.2/#bulk-import-narrative
-
-        Args:
-            narratives_file_path (str): The file path of the CSV containing the narratives to be imported.
-            integrity_check (bool): Optional: Set to true to perform additional integrity checks on the CSV file. Defaults to false.
-            migration_mode (bool): Optional: Set to true to perform additional verifications on the localizedCaseId. Defaults to false.
-            archive_document (bool): Optional: Set to true to send the imported narrative documents directly to the document archive, or false to create the imported documents as active narratives. Defaults to None.
-
-        Returns:
-            dict: The response containing the status of the request and details of the import operation.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/import-narrative/batch/"
-
-        headers = {
-            'Content-Type': 'multipart/form-data',
-            'Accept': 'text/csv',
-            'Authorization': f"{self.sessionId}",
-            'X-VaultAPI-IntegrityCheck': str(integrity_check).lower(),
-            'X-VaultAPI-MigrationMode': str(migration_mode).lower()
-        }
-
-        if archive_document is not None:
-            headers['X-VaultAPI-ArchiveDocument'] = str(archive_document).lower()
-
-        with open(narratives_file_path, 'rb') as f:
-            files = {'narratives': f}
-            response = requests.post(url, headers=headers, files=files)
-
-        return response.json()
-
-
-    def retrieve_bulk_import_status(self, import_id):
-        """
-        Use this endpoint to retrieve the status of a bulk narrative import.
-        API Documentation URL: https://developer.veevavault.com/api/23.2/#retrieve-bulk-import-status
-
-        Args:
-            import_id (str): The import_id of the bulk narrative import job, retrieved from the job request response details.
-
-        Returns:
-            dict: The response containing the status and details of the bulk narrative import job.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/import-narrative/batch/{import_id}"
-
-        headers = {
-            'Authorization': f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-
-        return response.json()
-
-
-
-    #######################################################
-    # SiteVault
-    #######################################################
-
-    def retrieve_documents_and_signatories(self, participant_id):
-        """
-        Retrieve the valid blank ICFs and signatories for a participant.
-        API Documentation URL: https://developer.veevavault.com/api/23.2/#retrieve-documents-and-signatories
-
-        Args:
-            participant_id (str): The SiteVault ID of the participant. Use the /query REST interface to query the Participant (subject__v) object for the participant ID.
-
-        Returns:
-            list: The response listing the valid blank ICFs and signatories for the participant.
-        """
-        self.LatestAPIversion = 'v23.2'
-
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/sitevault/econsent/participant/{participant_id}"
-
-        headers = {
-            'Authorization': f"{self.sessionId}"
-        }
-
-        response = requests.get(url, headers=headers)
-
-        return response.json()
-
-    def send_documents_to_signatories(self, documents_version_id, signatory_id, signatory_role, subject_id):
-        """
-        Send documents to signatories for signature.
-        API Documentation URL: https://developer.veevavault.com/api/23.2/#send-documents-to-signatories
-
-        Args:
-            documents_version_id (str): The ID of the blank ICF.
-            signatory_id (str): The ID of the signatory.
-            signatory_role (str): The role of the signatory.
-            subject_id (str): The ID of the participant.
-
-        Returns:
-            dict: The response listing the participant, the blank ICF, any signatories, and a job ID.
-        """
-        self.LatestAPIversion = 'v23.2'
-        
-        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/sitevault/econsent/send"
-        
-        headers = {
-            'Authorization': f"{self.sessionId}",
-            'Content-Type': 'application/json'
-        }
-        
-        payload = {
-            "documents.version_id__v": documents_version_id,
-            "signatory__v.id": signatory_id,
-            "signatory__v.role__v": signatory_role,
-            "subject__v.id": subject_id
-        }
-        
-        response = requests.post(url, headers=headers, json=payload)
-        
-        return response.json()
-
-
-    #######################################################
-    ## Custom Functions
-    #######################################################
-    
-    
-    def call_url(self, url, method='GET', data=None, headers=None, params=None):
-        
-        default_headers = {
-            "Authorization": self.sessionId,
-            "Accept": "application/json"
-        }
-        
-        headers = default_headers if headers is None else headers
-        url = self.vaultURL + url
-        
-        if method == 'GET':
-            response = requests.get(url, headers=headers, params=params)
-        elif method == 'POST':
-            response = requests.post(url, headers=headers, data=data)
-        elif method == 'PUT':
-            response = requests.put(url, headers=headers, data=data)
-        elif method == 'DELETE':
-            response = requests.delete(url, headers=headers)
-        else:
-            raise Exception(f"Invalid method: {method}")
-        
-        return response.json()
-    
-
-    async def retrieve_and_download_config_report(self):
-        """
-        Kicks off a config report job, monitors its status, and downloads the report file once the job is successful.
-
-        Args:
-            self: The Veeva Vault client instance.
-
-        Returns:
-            None
-        """
-        # Step 1: Kick off the config report job
-        result = self.vault_configuration_report()
-        job_id = result.get('job_id')
-        
-        if not job_id:
-            print("Failed to initiate the job.")
-            return
-
-        # Step 2: Check the job status every 10 seconds
-        while True:
-            time.sleep(10)
-            status_result = self.retrieve_job_status(str(job_id))
-            job_status = status_result.get('data', {}).get('status')
-            
-            if job_status == 'SUCCESS':
-                print("Job completed successfully.")
-                break
-            else:
-                print("Job still executing... Checking again in 10 seconds.")
-
-        # Step 3: Download the file if the job was successful
-        artifact_url = status_result.get('data', {}).get('links', [])[1].get('href')
-        headers = {
-            "Content-Type": "application/x-www-form-urlencoded",
-            "Authorization": f"{self.sessionId}"
-        }
-
-        vaultId = self.vaultId
-        iso_datetime = datetime.now().isoformat(timespec='seconds').replace(':', '-')
-        response = requests.get(artifact_url, headers=headers)
-        if response.status_code == 200:
-            with open(f'{iso_datetime}_vault_{vaultId}_config_report.zip', 'wb') as file:
-                file.write(response.content)
-            print("File downloaded successfully")
-        else:
-            print(f"Failed to download the file. HTTP Status Code: {response.status_code}")
+from sys import platform
+import requests
+import pandas as pd
+import os
+import json
+from urllib.parse import urlparse
+from typing import List
+import time
+from datetime import datetime
+import re
+
+# Async
+import asyncio
+from functools import wraps, partial
+from utilities.async_utils import async_wrap
+
+
+
+
+class Vv:
+    def __init__(self):
+        self.vaultURL = None
+        self.vaultUserName = None
+        self.vaultPassword = None
+        self.vaultConnection = None
+        self.sessionId = None
+        self.vaultId: str = None
+        self.vaultDNS: str = None
+        self.APIheaders = None
+        self.APIversionList = []
+        self.LatestAPIversion = 'v21.3'
+#         self.vaultObjects = None
+#         self.all_references_metadata = None
+#         self.all_references_names = None
+#         self.vault_references_all = None
+
+
+
+    def authenticate(self, 
+                     vaultURL=None, 
+                     vaultUserName=None, 
+                     vaultPassword=None, 
+                     sessionId=None,
+                     vaultId=None,
+                     if_return=False, *args, **kwargs):
+        """
+        TODO: Docs
+        """
+
+        self.LatestAPIversion = 'v21.3'
+        
+        self.vaultURL = self.vaultURL if vaultURL is None else vaultURL
+        self.vaultUserName = self.vaultUserName if vaultUserName is None else vaultUserName
+        self.vaultPassword = self.vaultPassword if vaultPassword is None else vaultPassword
+        self.sessionId = self.sessionId if sessionId is None else sessionId
+        self.vaultId = self.vaultId if vaultId is None else vaultId
+        
+        url_parse = urlparse(self.vaultURL)
+        if len(url_parse.scheme) == 0:
+            self.network_protocol = 'https'
+            if len(url_parse.path) > 0:
+                self.vaultDNS = url_parse.path
+                self.vaultURL = self.network_protocol + '://' + url_parse.path
+
+        if len(url_parse.scheme) > 0:
+            self.network_protocol = url_parse.scheme
+            if len(url_parse.netloc) > 0:
+                self.vaultDNS = url_parse.netloc
+                self.vaultURL = url_parse.scheme + '://' + url_parse.netloc
+
+        if (self.vaultURL is None) or (len(self.vaultURL) == 0):
+            raise Exception('vaultURL is required')
+        
+        if (self.vaultUserName and self.vaultPassword and self.vaultURL):
+            pload = {'username': self.vaultUserName,'password': self.vaultPassword}
+            self.vaultConnection = requests.post(f'{self.vaultURL}/api/{self.LatestAPIversion}/auth',data = pload)
+            if self.vaultConnection.json()['responseStatus'] == 'FAILURE':
+                exceptionMessage = ""
+                exceptionMessage += "Error: " + self.vaultConnection.json()['responseMessage'] + "\n"
+                exceptionMessage += self.vaultConnection.json()['errorType'] + "\n"
+                for error in self.vaultConnection.json()['errors']:
+                    exceptionMessage += error['type'] + ": " + error['message'] + "\n"
+                raise Exception(exceptionMessage)
+            
+            self.sessionId = self.vaultConnection.json()['sessionId']
+            self.vaultId = self.vaultConnection.json()['vaultId']
+            
+        self.APIheaders = {'Authorization': self.sessionId}
+        self.APIversionList = []
+        
+        # Error checking whether the required parameters are passed in
+        # The check happens here because this is where all the self assignments has completed
+        if (not (self.vaultId and self.sessionId and self.vaultURL)) and (not (self.vaultUserName and self.vaultPassword and  self.vaultURL)):
+            raise Exception("Please provide either vaultId, sessionId and vaultURL or vaultUserName, vaultPassword and vaultURL")
+        
+        for API in requests.get(self.vaultURL +'/api', headers=self.APIheaders).json()['values'].keys():
+            self.APIversionList.append(float(API.replace("v", "")))
+        self.APIversionList.sort()
+        self.LatestAPIversion = "v" + str(self.APIversionList[-1])
+        
+        if if_return:
+            return {'vaultURL':self.vaultURL, 
+                    'vaultUserName':self.vaultUserName, 
+                    'vaultPassword':self.vaultPassword, 
+                    'vaultConnection':self.vaultConnection, 
+                    'sessionId':self.sessionId, 
+                    'APIheaders':self.APIheaders, 
+                    'APIversionList':self.APIversionList, 
+                    'LatestAPIversion':self.LatestAPIversion}
+
+
+        
+    def query(self, query):
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/query"
+        
+        self.LatestAPIversion = 'v21.3'
+        
+        h = {
+        "X-VaultAPI-DescribeQuery":"true",
+        "Content-Type":"application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        params = {
+        "q":query
+        }
+
+        r = requests.get(url, headers=h, params=params).json()
+
+        if r['responseStatus'] == 'FAILURE':
+            raise Exception(r['errors'])
+        else:
+            r = pd.DataFrame(r['data'])
+        
+        return r
+    
+    def bulk_query(self, query):
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/query"
+        
+        self.LatestAPIversion = 'v21.3'
+        
+        h = {
+        "X-VaultAPI-DescribeQuery":"true",
+        "Content-Type":"application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        params = {
+        "q":query
+        }
+
+        r = requests.get(url, headers=h, params=params).json()
+
+        if r['responseStatus'] == 'FAILURE':
+            raise Exception(r['errors'])
+        
+        output = pd.DataFrame(r['data'])
+        
+        try:
+            next_page_url = r['responseDetails']['next_page'][:-4]
+            more_pages = True
+            page_count = 1000
+            
+            while more_pages:
+                r = pd.DataFrame(requests.get(f"{self.vaultURL}"+ next_page_url+ str(page_count), headers=h).json()['data'])
+                if len(r) == 0:
+                    more_pages = False
+                else:
+                    output = pd.concat([output,r],ignore_index=True).copy()
+                    page_count += 1000
+        except:
+            pass
+        
+        return output
+    
+    def object_field_metadata(self, object_api_name):
+        
+        self.LatestAPIversion = 'v21.3'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_api_name}"
+        r = requests.get(url, headers = self.APIheaders).json()['object']['fields']
+        return pd.DataFrame(r)
+    
+    def describe_objects(self):
+        
+        self.LatestAPIversion = 'v21.3'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects"
+        r = requests.get(url, headers = self.APIheaders).json()['objects']
+        return pd.DataFrame(r).sort_values(by='name')
+    
+    def retrieve_picklist_values(self, picklist_name):
+        """
+        Note: This is not the picklist field's API name, but the picklist (to which the picklist field looks up to) API name.
+        For example, the picklist field "specialty_1__v", "specialty_2__v" and "specialty_3__v" all look up to the picklist "specialty__v".
+        """
+        
+        self.LatestAPIversion = 'v21.3'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}"
+        r = requests.get(url, headers = self.APIheaders).json()
+        if r['responseStatus'] == 'SUCCESS':
+            if 'picklistValues' in r.keys():
+                result = pd.DataFrame(r['picklistValues'])
+                result['picklist_api_name'] = picklist_name
+                return result
+            else:
+                print(f"Warning: Picklist {picklist_name} does not contain any values.")
+                result = pd.DataFrame(columns=['name','label','picklist_api_name'])
+                return result
+        else:
+            raise Exception(r['errors'][0]['type'] + ": " + r['errors'][0]['message'])
+    
+    
+    ###############################################################
+    # Async Functions
+    ###############################################################
+    
+    async def async_bulk_retrieve_picklist_values(self, queries: List[str]) -> pd.DataFrame:
+        """_summary_: This function is the async version of the retrieve_picklist_values function. It is used to retrieve multiple picklist values in parallel.
+
+        Args:
+            queries (List[str]): List of picklist API names
+
+        Returns:
+            _type_: pd.DataFrame
+        """
+        async_queries = async_wrap(self.retrieve_picklist_values)
+        result_list = await asyncio.gather(*[async_queries(query) for query in queries])
+        result_length = 0
+        for result in result_list:
+            result_length += len(result)
+        
+        if result_length > 0:
+            result = pd.concat(result_list, ignore_index=True)
+        else:
+            result = pd.DataFrame(columns=['name','label','picklist_api_name'])
+            
+        return result
+    
+
+    ###############################################################
+    # Authentication
+    ###############################################################
+    
+    
+    # Untested
+    def authenticate_with_username_password(self, username, password, vaultDNS=None):
+        """
+        Authenticate your account using your Vault user name and password to obtain Vault Session ID.
+        
+        Documentation URL: https://developer.veevavault.com/api/23.2/#user-name-and-password
+        
+        :param username: Your Vault user name assigned by your administrator.
+        :param password: Your Vault password associated with your assigned Vault user name.
+        :param vaultDNS: The DNS of the Vault for which you want to generate a session. Optional.
+        :return: JSON response containing session ID and related details.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/auth"
+        
+        data = {
+            "username": username,
+            "password": password
+        }
+        
+        if vaultDNS:
+            data["vaultDNS"] = vaultDNS
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, data=data, headers=headers).json()
+        
+        if response.get('responseStatus') == "SUCCESS":
+            self.sessionId = response.get('sessionId')
+            self.vaultId = str(response.get('vaultId'))
+        
+        return response.json()
+
+    # Untested
+    def authenticate_with_oauth_openid_connect(self, oath_oidc_profile_id, vaultDNS=None, client_id=None, access_token=None):
+        """
+        Authenticate your account using OAuth 2.0 / Open ID Connect token to obtain a Vault Session ID.
+        API Documentation: https://developer.veevavault.com/api/23.2/#oauth-2-0-openid-connect
+
+        Parameters:
+        oath_oidc_profile_id (str): The ID of your OAuth2.0 / Open ID Connect profile.
+        vaultDNS (str, optional): The DNS of the Vault for which you want to generate a session. Defaults to None.
+        client_id (str, optional): The ID of the client application at the Authorization server. Defaults to None.
+        access_token (str): The access token for authorization.
+
+        Returns:
+        dict: Response from the API call
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        url = f"https://login.veevavault.com/auth/oauth/session/{oath_oidc_profile_id}"
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Authorization": f"Bearer {access_token}",
+            "Accept": "application/json"
+        }
+        
+        data = {}
+        if vaultDNS:
+            data["vaultDNS"] = vaultDNS
+        if client_id:
+            data["client_id"] = client_id
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        if response.status_code == 200:
+            self.sessionId = response.json().get('sessionId')
+            self.vaultId = str(response.json().get('vaultId'))
+        
+        return response.json()
+
+    # Untested
+    def retrieve_api_version(self):
+        """
+        Retrieve all supported versions of the Vault REST API.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-api-versions
+
+        Returns:
+        dict: Response from the API call containing the available API versions
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        if response.status_code == 200:
+            self.APIversionList = list(response.json().get('values').keys())
+        
+        return response.json()
+
+    # Untested
+    def authentication_type_discovery(self, username, client_id=None):
+        """
+        Discover the authentication type of a user. This API allows applications to dynamically adjust the login requirements per user, 
+        and support either username/password or OAuth2.0 / OpenID Connect authentication schemes.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-api-versions
+
+        Args:
+        username (str): The user’s Vault user name.
+        client_id (str, optional): The user’s mapped Authorization Server client_id. Applies only to the SSO and OAuth / OpenID Connect Profiles auth_type.
+
+        Returns:
+        dict: Response from the API call containing information about the user's authentication type and profiles (if any).
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"https://login.veevavault.com/auth/discovery"
+        params = {
+            "username": username,
+            "client_id": client_id
+        }
+        
+        headers = {
+            "Accept": "application/json",
+            "X-VaultAPI-AuthIncludeMsal": "true"
+        }
+        
+        response = requests.post(url, headers=headers, params=params)
+        return response.json()
+
+    # Untested
+    def authentication_type_discovery(self, username, client_id=None):
+        """
+        Discover the authentication type of a user. This API allows applications to dynamically adjust the login requirements per user, 
+        and support either username/password or OAuth2.0 / OpenID Connect authentication schemes.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-api-versions
+
+        Args:
+        username (str): The user’s Vault user name.
+        client_id (str, optional): The user’s mapped Authorization Server client_id. Applies only to the SSO and OAuth / OpenID Connect Profiles auth_type.
+
+        Returns:
+        dict: Response from the API call containing information about the user's authentication type and profiles (if any).
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"https://login.veevavault.com/auth/discovery"
+        params = {
+            "username": username,
+            "client_id": client_id
+        }
+        
+        headers = {
+            "Accept": "application/json",
+            "X-VaultAPI-AuthIncludeMsal": "true"
+        }
+        
+        response = requests.post(url, headers=headers, params=params)
+        return response.json()
+    
+    # Untested
+    def session_keep_alive(self):
+        """
+        Given an active sessionId, keep the session active by refreshing the session duration.
+        A Vault session remains active as long as some activity (either through the UI or API) happens within the 
+        maximum inactive session duration defined by your Vault Admin.
+        API Documentation: https://developer.veevavault.com/api/23.2/#session-keep-alive
+        
+        Returns:
+        dict: Response from the API call indicating the success status.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/keep-alive"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        response = requests.post(url, headers=headers)
+        return response.json()
+
+    # Untested
+    def validate_session_user(self, exclude_vault_membership=False, exclude_app_licensing=False):
+        """
+        Given a valid session ID, this request returns information for the currently authenticated user.
+        In case of an invalid session ID, it returns an INVALID_SESSION_ID error. This method acts similar to a whoami request.
+        API Documentation: https://developer.veevavault.com/api/23.2/#validate-session-user
+        
+        Parameters:
+        exclude_vault_membership (bool): If set to true, vault_membership fields are omitted from the response. Defaults to False.
+        exclude_app_licensing (bool): If set to true, app_licensing fields are omitted from the response. Defaults to False.
+        
+        Returns:
+        dict: Information of the currently authenticated user or an error message for invalid session ID.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/me"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        params = {
+            "exclude_vault_membership": exclude_vault_membership,
+            "exclude_app_licensing": exclude_app_licensing
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+    
+    # Untested
+    def salesforce_delegated_requests(self, sfdc_session_token, my_sfdc_domain, vault_endpoint, auth=None, ext_url=None, ext_ns=None):
+        """
+        Makes a request to the Vault API using Salesforce™ session token, following Salesforce™ Delegated Authentication procedure. 
+        Learn more at: https://developer.veevavault.com/api/23.2/#salesforce-trade-delegated-requests
+        
+        Prerequisites:
+        - A valid Vault user with a Security Policy enabled for Salesforce.com™ Delegated Authentication must exist.
+        - The trusted 18-character Salesforce.com™ Org ID must be provided.
+        - A user with a matching username in Salesforce.com™ Org ID must exist.
+        
+        Parameters:
+        sfdc_session_token (str): Salesforce™ session token.
+        my_sfdc_domain (str): Salesforce™ URL used to validate the session token.
+        vault_endpoint (str): The Vault endpoint to make the request to.
+        auth (str, optional): Salesforce™ session token, can be used as an alternative to setting in headers. Defaults to None.
+        ext_url (str, optional): Salesforce™ URL for validation, alternative to setting in headers. Defaults to None.
+        ext_ns (str, optional): Set to 'sfdc' to indicate Salesforce™ as the authorization provider, alternative to setting in headers. Defaults to None.
+        
+        Returns:
+        Response: API Response object.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/{vault_endpoint}"
+        
+        headers = {
+            "Authorization": sfdc_session_token,
+            "X-Auth-Provider": "sfdc",
+            "X-Auth-Host": my_sfdc_domain
+        }
+        
+        params = {
+            "auth": auth,
+            "ext_url": ext_url,
+            "ext_ns": ext_ns
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+    # Untested
+    def retrieve_delegations(self):
+        """
+        Retrieves the vaults where the currently authenticated user has delegate access. 
+        This information can be used to initiate a delegated session. Learn more about the feature at: 
+        https://developer.veevavault.com/api/23.2/#delegated-access
+        
+        Returns:
+        dict: A dictionary containing details of the vaults the user has delegate access to, if any.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/delegation/vaults"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+    ###############################################################
+    # Domain Information
+    ###############################################################
+
+    def retrieve_domain_information(self, include_application=True):
+        """
+        Allows domain admins to retrieve a list of all Vaults present in their domain. 
+        More details can be found at: 
+        https://developer.veevavault.com/api/23.2/#retrieve-domain-information
+
+        Args:
+        include_application (bool): If set to true, the response includes information about 
+        the Vault application type. Defaults to true.
+
+        Returns:
+        dict: A dictionary containing the response details with information about the domain and vaults.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/domain"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        params = {
+            "include_application": include_application
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+    def retrieve_domains(self):
+        """
+        Allows non-domain admins to retrieve a list of all their domains, including the domain of the current Vault. This data can be used as a valid domain value when creating a sandbox Vault. More details can be found at:
+        https://developer.veevavault.com/api/23.2/#retrieve-domains
+
+        Returns:
+        dict: A dictionary containing the response details with information about the domains.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/domains"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+    #######################################################
+    # Vault Query Language (VQL)
+    #######################################################
+
+    def submit_query(self, query, describe_query=True, record_properties=None):
+        """
+        Allows an application to invoke a query call where it passes in a Vault Query Language (VQL) statement to specify the object to query, the fields to retrieve, and any optional filters to narrow down the results. Further information can be found at:
+        https://developer.veevavault.com/api/23.2/#submitting-a-query
+        
+        Args:
+        query (str): A VQL statement specifying the object to query, the fields to retrieve, and any optional filters.
+        describe_query (bool, optional): Set to true to include static field metadata in the response for the data record. Defaults to True.
+        record_properties (str, optional): Optionally include the record properties object in the response. Possible values are "all", "hidden", "redacted", and "weblink". Defaults to None.
+
+        Returns:
+        dict: A dictionary containing the response from the query call including details about the fields retrieved and data records found.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/query"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "X-VaultAPI-DescribeQuery": str(describe_query).lower()
+        }
+        
+        if record_properties:
+            headers["X-VaultAPI-RecordProperties"] = record_properties
+        
+        data = {
+            "q": query
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        return response.json()
+
+
+
+    #######################################################
+    # Metadata Definition Language (MDL)
+    #######################################################
+
+    def execute_mdl_script(self, mdl_script):
+        """
+        Executes the given MDL script on a Vault. This synchronous endpoint allows various operations like CREATE, RECREATE, RENAME, ALTER, and DROP to be performed through MDL scripts. More details can be found at:
+        https://developer.veevavault.com/api/23.2/#execute-mdl-script
+        
+        Args:
+        mdl_script (str): The MDL script to be executed as a raw string. The script should start with one of the valid MDL commands (CREATE, RECREATE, RENAME, ALTER, DROP).
+        
+        Returns:
+        dict: A dictionary containing the response details from the execution of the MDL script.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/mdl/execute"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+
+        response = requests.post(url, headers=headers, data=mdl_script)
+        return response.json()
+
+    def execute_mdl_script_async(self, mdl_script):
+        """
+        Executes the given MDL script on a Vault asynchronously. This endpoint is used particularly when operating on 10,000+ high volume object records and performing certain operations as mentioned in the documentation. The method returns details of the initiated job which can be used to track the execution status. Refer to the documentation for more details:
+        https://developer.veevavault.com/api/23.2/#execute-mdl-script-asynchronously
+        
+        Args:
+        mdl_script (str): The MDL script to be executed as a raw string. The script should start with one of the valid MDL commands (CREATE, RECREATE, RENAME, ALTER, DROP).
+        
+        Returns:
+        dict: A dictionary containing the response details from the execution of the MDL script, including job_id and url to check the status of the execution.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/mdl/execute_async"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+
+        response = requests.post(url, headers=headers, data=mdl_script)
+        return response.json()
+
+
+    def retrieve_async_mdl_script_results(self, job_id):
+        """
+        Retrieves the results of an asynchronously executed MDL script. This method can be used to query Vault to determine the results of the MDL script execution request, including any errors. Refer to the documentation for more details:
+        https://developer.veevavault.com/api/23.2/#retrieve-asynchronous-mdl-script-results
+        
+        Args:
+        job_id (int): The job_id field value that was returned from the Execute MDL Script Asynchronously request.
+        
+        Returns:
+        dict: A dictionary containing the response details from the executed MDL script, which includes details of script execution and statement execution.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/mdl/execute_async/{job_id}/results"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+    def cancel_hvo_deployment(self, job_id):
+        """
+        Cancels a high volume object (HVO) deployment in the Vault. The deployment can only be cancelled if it has not begun execution. Refer to the documentation for more details:
+        https://developer.veevavault.com/api/23.2/#cancel-hvo-deployment
+        
+        Args:
+        job_id (int): The job ID obtained from the response of initiating an HVO deployment or executing an MDL script asynchronously.
+        
+        Returns:
+        dict: A dictionary containing the response details of the cancel request.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/mdl/execute_async/{job_id}/cancel"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.post(url, headers=headers)
+        return response.json()
+
+    def retrieve_all_component_metadata(self):
+        """
+        Retrieves the metadata of all component types in the Vault. The method returns a list of dictionaries with details for each component type in the currently authenticated Vault. Refer to the documentation for more details:
+        https://developer.veevavault.com/api/23.2/#retrieve-all-component-metadata
+        
+        Returns:
+        list: A list of dictionaries containing metadata details for each component type.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/components"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_component_type_metadata(self, component_type):
+        """
+        Retrieves the metadata of a specific component type in the Vault. The method returns a dictionary containing detailed metadata for the specified component type. Refer to the documentation for more details:
+        https://developer.veevavault.com/api/23.2/#retrieve-component-type-metadata
+        
+        Args:
+        component_type (str): The name of the component type (e.g., "Picklist", "Docfield", "Doctype", etc.).
+        
+        Returns:
+        dict: A dictionary containing detailed metadata for the specified component type.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/components/{component_type}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_component_record_collection(self, component_type):
+        """
+        Retrieves all records for a specific component type in the Vault. This method returns a list of dictionaries containing details for each record of the specified component type. Refer to the documentation for more details:
+        https://developer.veevavault.com/api/23.2/#component-record-collection
+        
+        Args:
+        component_type (str): The name of the component type (e.g., "Picklist", "Docfield", "Doctype", etc.).
+        
+        Returns:
+        list: A list of dictionaries containing details of each record for the specified component type.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/{component_type}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+    def retrieve_component_record(self, component_type_and_record_name):
+        """
+        Retrieves the metadata of a specific component record either in JSON or XML format. This method returns a dictionary containing detailed information about the specified component record. Refer to the documentation for more details:
+        https://developer.veevavault.com/api/23.2/#retrieve-component-record-xml-json
+        
+        Args:
+        component_type_and_record_name (str): The combination of the component type name and the record name to retrieve the metadata from. The format is {Componenttype}.{record_name}, for example, "Picklist.color__c".
+        
+        Returns:
+        dict: A dictionary containing details of the specified component record.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/{component_type_and_record_name}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+    def retrieve_component_record_mdl(self, component_type_and_record_name):
+        """
+        Retrieves metadata of a specific component record as MDL format. This method returns the RECREATE MDL statement which contains metadata for the specified component record. Refer to the documentation for more details:
+        https://developer.veevavault.com/api/23.2/#retrieve-component-record-mdl
+        
+        Args:
+        component_type_and_record_name (str): The combination of the component type name and the record name to retrieve metadata from, in the format {Componenttype}.{record_name}, for example, "Picklist.color__c".
+
+        Returns:
+        str: A RECREATE MDL statement containing metadata for the specified component record.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/mdl/components/{component_type_and_record_name}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.text
+
+    def upload_content_file(self, file_path):
+        """
+        Uploads a content file to be referenced by a component in the Vault. The file gets stored in a generic files staging area where it remains until referenced by a component. For more details, refer to the documentation: 
+        https://developer.veevavault.com/api/23.2/#upload-content-file
+        
+        Args:
+        file_path (str): The local file path of the content file to be uploaded. For example, 'C:\\Quote.pdf'.
+        
+        Returns:
+        dict: A dictionary containing details of the uploaded file including name, format, size, and sha1 checksum.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/mdl/files"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+        
+        with open(file_path, 'rb') as file:
+            files = {'file': file}
+            response = requests.post(url, headers=headers, files=files)
+            return response.json()
+
+
+    def retrieve_content_file(self, component_type_and_record_name):
+        """
+        Retrieves the content file of a specified component. For more information, refer to the API documentation: 
+        https://developer.veevavault.com/api/23.2/#retrieve-content-file
+        
+        Args:
+        component_type_and_record_name (str): The component type of the record followed by the name of the record from which to retrieve the content file. The format is {Componenttype}.{record_name}. For example, 'Formattedoutput.my_formatted_output__c'.
+        
+        Returns:
+        dict: A dictionary containing details of the retrieved content file including name, original name, format, size, and sha1 checksum.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/mdl/components/{component_type_and_record_name}/files"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+
+    #######################################################
+    # Documents
+    #######################################################
+
+    def retrieve_all_document_fields(self):
+        """
+        Retrieves all standard and custom document fields and field properties. For more information, refer to the API documentation: 
+        https://developer.veevavault.com/api/23.2/#retrieve-all-document-fields
+        
+        Returns:
+        dict: A dictionary containing all standard and custom document fields and their properties.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/v23.2/metadata/objects/documents/properties"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+    def retrieve_common_document_fields(self, doc_ids):
+        """
+        Retrieves all document fields and field properties which are common to (shared by) a specified set of documents. 
+        This allows you to determine which document fields are eligible for bulk update.
+        For more information, refer to the API documentation: 
+        https://developer.veevavault.com/api/23.2/#retrieve-common-document-fields
+
+        Parameters:
+        doc_ids (str): A comma-separated list of document id field values.
+
+        Returns:
+        dict: A dictionary containing all fields shared by the specified documents.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/v23.2/metadata/objects/documents/properties/find_common"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+
+        data = {
+            "docIds": doc_ids
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+        return response.json()
+
+    def retrieve_all_document_types(self):
+        """
+        Retrieves all document types present in the vault. These represent the top-level of the document type/subtype/classification hierarchy.
+        For more details, visit the API documentation:
+        https://developer.veevavault.com/api/23.2/#retrieve-all-document-types
+
+        Returns:
+        dict: A dictionary containing the details of all document types configured in the vault.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/v23.2/metadata/objects/documents/types"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_type(self, doc_type):
+        """
+        Retrieve all metadata from a specified document type, potentially including all of its subtypes.
+        For more details, visit the API documentation:
+        https://developer.veevavault.com/api/23.2/#retrieve-document-type
+
+        Args:
+        doc_type (str): The document type to retrieve metadata for.
+
+        Returns:
+        dict: A dictionary containing the metadata of the specified document type.
+        """
+
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/v23.2/metadata/objects/documents/types/{doc_type}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+
+    def retrieve_document_subtype(self, doc_type, doc_subtype):
+        """
+        Retrieve all metadata from a document subtype, including all of its classifications (when available).
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-subtype
+
+        :param doc_type: The document type, see Retrieve Document Types.
+        :param doc_subtype: The document subtype, see Retrieve Document Type.
+        :return: JSON response with metadata of the document subtype.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/types/{doc_type}/subtypes/{doc_subtype}"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_classification(self, doc_type, doc_subtype, classification):
+        """
+        Retrieve all metadata from a document classification.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-classification
+
+        :param doc_type: The document type, see Retrieve Document Types.
+        :param doc_subtype: The document subtype, see Retrieve Document Type.
+        :param classification: The document classification, see Retrieve Document Subtype.
+        :return: JSON response with metadata of the document classification.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/types/{doc_type}/subtypes/{doc_subtype}/classifications/{classification}"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_all_documents(self, named_filter=None, scope=None, versionscope=None, search=None, limit=None, sort=None, start=None):
+        """
+        Retrieve the latest version of documents and binders to which you have access.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-documents
+
+        :param named_filter: Filters the results based on the named filter option ('My Documents', 'Favorites', 'Recent Documents', 'Cart').
+        :param scope: Scope of the search ('contents' or 'all').
+        :param versionscope: Scope of the versions to retrieve ('all' for all versions, None for latest version).
+        :param search: Search keyword to filter documents based on searchable document fields.
+        :param limit: Limit the number of documents to display (default is up to 200 documents per page).
+        :param sort: Sort order for the documents (e.g., 'name__v DESC').
+        :param start: The starting record number (default is 0).
+        :return: JSON response with a list of documents and binders along with their fields and values.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        params = {
+            "named_filter": named_filter,
+            "scope": scope,
+            "versionscope": versionscope,
+            "search": search,
+            "limit": limit,
+            "sort": sort,
+            "start": start
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+    def retrieve_document(self, doc_id):
+        """
+        Retrieve all metadata from a document.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document
+        :param doc_id: The document id field value.
+        :return: JSON response containing document metadata.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_versions(self, doc_id):
+        """
+        Retrieve all versions of a document.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-versions
+        :param doc_id: The document id field value.
+        :return: JSON response containing all available versions of the specified document.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_version(self, doc_id, major_version, minor_version):
+        """
+        Retrieve all fields and values configured on a document version.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version
+        :param doc_id: The document id field value.
+        :param major_version: The document major version number field value.
+        :param minor_version: The document minor version number field value.
+        :return: JSON response containing all fields and values for the specified version of the document.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def download_document_file(self, doc_id, lockDocument=False):
+        """
+        Download the latest version of the source file from the document.
+        API Documentation: https://developer.veevavault.com/api/23.2/#download-document-file
+        :param doc_id: The document id field value.
+        :param lockDocument: Set to true to Check Out this document before retrieval. Default is False.
+        :return: A file with the document content.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/file"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        params = {"lockDocument": lockDocument}
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        filename = re.findall('filename="(.+)"', response.headers.get('Content-Disposition'))[0]
+        
+        with open(filename, 'wb') as file:
+            file.write(response.content)
+        
+        return filename
+
+    def download_document_version_file(self, doc_id, major_version, minor_version):
+        """
+        Download the file of a specific document version.
+        API Documentation: https://developer.veevavault.com/api/23.2/#download-document-version-file
+        :param doc_id: The document id field value.
+        :param major_version: The document major_version_number__v field value.
+        :param minor_version: The document minor_version_number__v field value.
+        :return: A file with the document content of the specified version.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/file"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        filename = re.findall('filename="(.+)"', response.headers.get('Content-Disposition'))[0]
+        
+        with open(filename, 'wb') as file:
+            file.write(response.content)
+        
+        return filename
+
+
+    #######################################################
+    # Documents
+    ## Create Documents
+    #######################################################
+
+    def create_single_document(self, file_path, name_v, type_v, lifecycle_v, subtype_v=None, classification_v=None, major_version_number_v=None, minor_version_number_v=None, external_id_v=None, product_v=None, options=None):
+        """
+        Create a single document in the Vault with various options.
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-single-document
+        
+        :param file_path: The filepath of the source document, if creating from an uploaded file. (optional)
+        :param name_v: The name of the new document.
+        :param type_v: The label of the document type to assign to the new document.
+        :param lifecycle_v: The label of the document lifecycle to assign to the new document.
+        :param subtype_v: The label of the document subtype, if applicable. (optional)
+        :param classification_v: The label of the document classification, if applicable. (optional)
+        :param major_version_number_v: The major version number to assign to the new document. (optional)
+        :param minor_version_number_v: The minor version number to assign to the new document. (optional)
+        :param external_id_v: The external id to assign to the new document. (optional)
+        :param product_v: The product id to assign to the new document. (optional)
+        :param options: A dictionary containing additional parameters for PromoMats or other types of documents. (optional)
+        :return: A dictionary containing the response details.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+        
+        data = {
+            "name__v": name_v,
+            "type__v": type_v,
+            "lifecycle__v": lifecycle_v
+        }
+        
+        if subtype_v:
+            data["subtype__v"] = subtype_v
+        if classification_v:
+            data["classification__v"] = classification_v
+        if major_version_number_v:
+            data["major_version_number__v"] = major_version_number_v
+        if minor_version_number_v:
+            data["minor_version_number__v"] = minor_version_number_v
+        if external_id_v:
+            data["external_id__v"] = external_id_v
+        if product_v:
+            data["product__v"] = product_v
+        if options:
+            data.update(options)
+        
+        files = {}
+        if file_path:
+            files['file'] = open(file_path, 'rb')
+        
+        response = requests.post(url, headers=headers, data=data, files=files)
+        return response.json()
+
+
+    def create_multiple_documents(self, csv_file_path, headers=None):
+        """
+        This method allows you to create multiple documents at once with a CSV input file. 
+        The maximum CSV input file size is 1GB and the maximum batch size is 500.
+        Note that this API does not support adding multi-value relationship fields by name.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#create-multiple-documents
+
+        Args:
+            csv_file_path (str): The path to the CSV file containing the document details.
+            headers (dict, optional): Additional headers to include in the request.
+
+        Returns:
+            dict: The response from the API.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.create_multiple_documents("path/to/your/csvfile.csv")
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch"
+        default_headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+
+        if headers:
+            default_headers.update(headers)
+
+        with open(csv_file_path, 'rb') as file:
+            response = requests.post(url, headers=default_headers, data=file)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Documents
+    ## Update Documents
+    #######################################################
+
+    def update_single_document(self, doc_id, data, headers=None):
+        """
+        This method allows you to update editable field values on the latest version of a single document. 
+        To update more than one document, it is best practice to use the bulk API.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#update-single-document
+
+        Args:
+            doc_id (int): The ID of the document to update.
+            data (dict): A dictionary containing the field values to update.
+            headers (dict, optional): Additional headers to include in the request.
+
+        Returns:
+            dict: The response from the API.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.update_single_document(534, {"language__v": "English", "product__v": 1357662840171, "audience__vs": "consumer__vs"})
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
+        default_headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+
+        if headers:
+            default_headers.update(headers)
+
+        response = requests.put(url, headers=default_headers, data=data)
+
+        return response.json()
+
+
+    def update_multiple_documents(self, data, headers=None, file_path=None):
+        """
+        This method allows you to bulk update editable field values on multiple documents. 
+        You can only update the latest version of each document.
+        
+        The maximum CSV input file size is 1GB and the maximum batch size is 1,000.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#update-single-document
+
+        Args:
+            data (dict or str): A dictionary containing name-value pairs to be updated or the path to a CSV file with the updates.
+            headers (dict, optional): Additional headers to include in the request.
+            file_path (str, optional): The path to a CSV file containing updates (if data is not a dictionary).
+
+        Returns:
+            dict: The response from the API.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.update_multiple_documents({"docIds": "771,772,773", "archive__v": "true"}, file_path="path/to/file.csv")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch"
+        
+        default_headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv" if file_path else "application/x-www-form-urlencoded",
+            "Accept": "text/csv"
+        }
+
+        if headers:
+            default_headers.update(headers)
+
+        if file_path:
+            with open(file_path, 'rb') as f:
+                response = requests.put(url, headers=default_headers, data=f)
+        else:
+            response = requests.put(url, headers=default_headers, data=data)
+
+        return response.json()
+
+
+    def reclassify_single_document(self, doc_id, type_v, lifecycle_v, reclassify=True, subtype_v=None, classification_v=None, document_number_v=None, status_v=None):
+        """
+        This method allows you to reclassify a single document, enabling the change of document type 
+        or the assignment of a document type to an unclassified document.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#reclassify-single-document
+
+        Args:
+            doc_id (str): The ID of the document to reclassify.
+            type_v (str): The name of the document type.
+            lifecycle_v (str): The name of the document lifecycle.
+            reclassify (bool): Set to true to reclassify the document. Defaults to true.
+            subtype_v (str, optional): The name of the document subtype, if applicable.
+            classification_v (str, optional): The name of the document classification, if applicable.
+            document_number_v (str, optional): The document number for the reclassified document. Use with X-VaultAPI-MigrationMode header.
+            status_v (str, optional): Specifies the lifecycle state for the reclassified document. Use with X-VaultAPI-MigrationMode header.
+
+        Returns:
+            dict: The response from the API.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.reclassify_single_document("775", "Promotional Piece", "Promotional Piece", subtype_v="Advertisement", classification_v="Web")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+
+        data = {
+            "type__v": type_v,
+            "lifecycle__v": lifecycle_v,
+            "reclassify": reclassify
+        }
+
+        if subtype_v:
+            data["subtype__v"] = subtype_v
+        if classification_v:
+            data["classification__v"] = classification_v
+        if document_number_v:
+            data["document_number__v"] = document_number_v
+            headers["X-VaultAPI-MigrationMode"] = "true"
+        if status_v:
+            data["status__v"] = status_v
+            headers["X-VaultAPI-MigrationMode"] = "true"
+
+        response = requests.put(url, headers=headers, data=data)
+
+        return response.json()
+
+
+    def reclassify_multiple_documents(self, csv_file_path):
+        """
+        This method allows you to reclassify multiple documents in bulk, enabling the change of document type 
+        or the assignment of document types to unclassified documents. The details of the documents to be reclassified 
+        should be specified in a CSV file.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#reclassify-multiple-documents
+
+        Args:
+            csv_file_path (str): The path to the CSV file containing the details of the documents to be reclassified.
+
+        Returns:
+            dict: The response from the API, including the status and IDs of the reclassified documents.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.reclassify_multiple_documents("C:\\Vault\\Documents\\reclassify_documents.csv")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch/actions/reclassify"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "text/csv"
+        }
+
+        with open(csv_file_path, 'rb') as file:
+            response = requests.put(url, headers=headers, data=file)
+
+        return response.text
+
+    def update_document_version(self, doc_id, major_version, minor_version, data):
+        """
+        This method allows you to update editable field values on a specific version of a document in the Vault.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#update-document-version
+
+        Args:
+            doc_id (int): The ID of the document to be updated.
+            major_version (int): The major version number of the document to be updated.
+            minor_version (int): The minor version number of the document to be updated.
+            data (dict): A dictionary containing the field values to be updated.
+
+        Returns:
+            dict: The response from the API, including the status and the ID of the updated document.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.update_document_version(534, 2, 0, {"language__v": "English", "product__v": "1357662840171", "audience__c": "consumer__c"})
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+
+        response = requests.put(url, headers=headers, data=data)
+
+        return response.json()
+
+
+    def create_multiple_document_versions(self, file_path, id_param=None):
+        """
+        This method allows you to create or add document versions in bulk in the Vault.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#create-multiple-document-versions
+
+        Args:
+            file_path (str): The filepath of your source files which contains details for new versions to be created.
+            id_param (str, optional): If you’re identifying documents in your input by a unique field, use this parameter to specify the field name.
+
+        Returns:
+            dict: The response from the API, including the status and details of the created document versions.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.create_multiple_document_versions("path/to/your/file.csv", id_param="external_id__v")
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/versions/batch"
+        if id_param:
+            url += f"?idParam={id_param}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json",
+            "X-VaultAPI-MigrationMode": "true"
+        }
+
+        with open(file_path, 'rb') as f:
+            response = requests.post(url, headers=headers, data=f)
+
+        return response.json()
+
+    def create_single_document_version(self, doc_id, create_draft, file_path=None, description=None, suppress_rendition=False):
+        """
+        Adds a new draft version of an existing document in the Vault. You can either use the existing source file or upload a new one.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#create-single-document-version
+
+        Args:
+            doc_id (int): The ID of the document to which a new draft version will be added.
+            create_draft (str): Specify whether to create a draft from the latest content or uploaded content.
+            file_path (str, optional): The filepath of the source document, required when createDraft is 'uploadedContent'.
+            description (str, optional): Description for the new draft version. Maximum 1500 characters.
+            suppress_rendition (bool, optional): Set to true to suppress automatic generation of the viewable rendition.
+
+        Returns:
+            dict: The response from the API, indicating the success or failure of the draft creation.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.create_single_document_version(534, "latestContent", description="Description for the new draft")
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
+        if suppress_rendition:
+            url += "?suppressRendition=true"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+
+        data = {
+            "createDraft": create_draft
+        }
+        if description:
+            data["description__v"] = description
+
+        if create_draft == "uploadedContent" and file_path:
+            with open(file_path, 'rb') as f:
+                files = {'file': f}
+                response = requests.post(url, headers=headers, data=data, files=files)
+        else:
+            response = requests.post(url, headers=headers, data=data)
+
+        return response.json()
+
+
+
+    #######################################################
+    # Documents
+    ## Delete Documents
+    #######################################################
+
+    def delete_single_document(self, document_id):
+        """
+        Deletes all versions of a specified document including all source files and viewable renditions.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document
+
+        Args:
+            document_id (int): The system-assigned ID of the document to delete.
+
+        Returns:
+            dict: The response from the API, indicating the success or failure of the deletion.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.delete_single_document(534)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+
+        return response.json()
+
+
+    def delete_multiple_documents(self, input_file_path, id_param=None):
+        """
+        Deletes all versions of multiple documents including all source files and viewable renditions.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-documents
+
+        Args:
+            input_file_path (str): The path to the CSV or JSON file containing the details of the documents to be deleted.
+            id_param (str, optional): If identifying documents by a unique field, add this parameter to specify the field name.
+
+        Returns:
+            dict: The response from the API, indicating the success or failure of the deletion.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.delete_multiple_documents("C:\\Vault\\Documents\\delete_documents.csv", id_param="external_id__v")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch"
+        if id_param:
+            url += f"?idParam={id_param}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+
+        with open(input_file_path, 'rb') as f:
+            response = requests.delete(url, headers=headers, data=f)
+
+        return response.json()
+
+
+    def delete_single_document_version(self, doc_id, major_version, minor_version):
+        """
+        Deletes a specific version of a document, including the version’s source file and viewable rendition. Other versions of the document remain unchanged.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document-version
+
+        Args:
+            doc_id (int): The document ID field value.
+            major_version (int): The document major version number field value.
+            minor_version (int): The document minor version number field value.
+
+        Returns:
+            dict: The response from the API, indicating the success or failure of the deletion.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.delete_single_document_version(534, 0, 2)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+
+        return response.json()
+
+
+    def delete_multiple_document_versions(self, input_file_path, id_param=None):
+        """
+        Deletes specific versions of multiple documents, including the versions’ source files and viewable renditions.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-document-versions
+
+        Args:
+            input_file_path (str): The path to the CSV or JSON file containing the details of the document versions to be deleted.
+            id_param (str, optional): If identifying documents in the input by a unique field, add this parameter to specify the field name. Defaults to None.
+
+        Returns:
+            dict: The response from the API, indicating the success or failure of the deletion of each document version.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.delete_multiple_document_versions("C:\\Vault\\Documents\\delete_document_versions.csv", id_param="external_id__v")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/versions/batch"
+        if id_param:
+            url += f"?idParam={id_param}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+
+        with open(input_file_path, 'rb') as f:
+            response = requests.delete(url, headers=headers, data=f)
+
+        return response.json()
+
+
+    def retrieve_deleted_document_ids(self, start_date=None, end_date=None):
+        """
+        Retrieves the IDs of documents that were deleted within the past 30 days.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-deleted-document-ids
+
+        Args:
+            start_date (str, optional): Specify a date (no more than 30 days past) after which to look for deleted documents. 
+                                        Dates must be in YYYY-MM-DDTHH:MM:SSZ format. Defaults to None.
+            end_date (str, optional): Specify a date (no more than 30 days past) before which to look for deleted documents. 
+                                    Dates must be in YYYY-MM-DDTHH:MM:SSZ format. Defaults to None.
+
+        Returns:
+            dict: The response from the API, indicating the details of deleted documents.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_deleted_document_ids("2023-08-01T00:00:00Z", "2023-08-30T23:59:59Z")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/deletions/documents"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+
+        params = {}
+        if start_date:
+            params['start_date'] = start_date
+        if end_date:
+            params['end_date'] = end_date
+        
+        response = requests.get(url, headers=headers, params=params)
+
+        return response.json()
+
+
+    #######################################################
+    # Documents
+    ## Document Locks
+    #######################################################
+
+    def retrieve_document_lock_metadata(self):
+        """
+        Retrieves the metadata of the lock attributes associated with documents.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-lock-metadata
+
+        Returns:
+            dict: The response from the API, containing metadata details of the lock attributes.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_lock_metadata()
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/lock"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+
+        return response.json()
+
+
+    def create_document_lock(self, doc_id):
+        """
+        Creates a lock on a specified document, preventing other users from locking or checking out the document. 
+        The operation is similar to checking out a document, but without the file attached in the response for download.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#create-document-lock
+
+        Args:
+            doc_id (int): The ID of the document to lock.
+
+        Returns:
+            dict: The response from the API, generally indicating the success status of the lock operation.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.create_document_lock(534)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/lock"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers)
+
+        return response.json()
+
+
+    def retrieve_document_lock(self, doc_id):
+        """
+        Retrieves the lock status of a specified document. 
+        If the document is locked, the response will include the user ID of the person who locked it and the date and time of the lock. 
+        If the document is not locked, the lock fields will not be returned in the response.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-lock
+
+        Args:
+            doc_id (int): The ID of the document to retrieve the lock status for.
+
+        Returns:
+            dict: The response from the API containing the lock details or indicating that no lock is present.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_lock(534)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/lock"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+
+        return response.json()
+
+
+    def delete_document_lock(self, doc_id):
+        """
+        Deletes the lock on a specified document, allowing other users to lock or check out the document.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-document-lock
+        
+        Args:
+            doc_id (int): The ID of the document for which the lock is to be deleted.
+
+        Returns:
+            dict: The response from the API indicating the status of the delete operation.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.delete_document_lock(534)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/lock"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.delete(url, headers=headers)
+
+        return response.json()
+
+
+    #######################################################
+    # Documents
+    ## Document Renditions
+    #######################################################
+
+    def retrieve_document_renditions(self, doc_id):
+        """
+        Retrieves the renditions of a specified document.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-renditions
+        
+        Args:
+            doc_id (int): The ID of the document for which the renditions are to be retrieved.
+
+        Returns:
+            dict: A dictionary containing the rendition types and URLs for the renditions of the specified document.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_renditions(534)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/renditions"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+
+        return response.json()
+
+
+    def retrieve_document_version_renditions(self, doc_id, major_version, minor_version):
+        """
+        Retrieves the renditions of a specified document version.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version-renditions
+        
+        Args:
+            doc_id (int): The ID of the document for which the renditions are to be retrieved.
+            major_version (int): The major version number of the document.
+            minor_version (int): The minor version number of the document.
+
+        Returns:
+            dict: A dictionary containing the rendition types and URLs for the renditions of the specified document version.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_version_renditions(534, 2, 0)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+
+        return response.json()
+
+
+    def download_document_rendition_file(self, doc_id, rendition_type, steady_state=None, protected_rendition=None):
+        """
+        Downloads the rendition file from the latest version of a document.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-document-rendition-file
+
+        Args:
+            doc_id (int): The ID of the document for which the rendition file is to be downloaded.
+            rendition_type (str): The type of the rendition file to download.
+            steady_state (bool, optional): Set to true to download a rendition from the latest steady state version of the document. Defaults to None.
+            protected_rendition (bool, optional): If your Vault is configured to use protected renditions, set to false to download the non-protected rendition. If omitted, defaults to true. Defaults to None.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.download_document_rendition_file(534, 'viewable_rendition__v', steady_state=True, protected_rendition=False)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/renditions/{rendition_type}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        params = {
+            "steadyState": steady_state,
+            "protectedRendition": protected_rendition
+        }
+
+        response = requests.get(url, headers=headers, params=params)
+
+        return response.json()
+
+
+    def download_document_version_rendition_file(self, doc_id, major_version, minor_version, rendition_type, protected_rendition=None):
+        """
+        Downloads a rendition for a specified version of a document.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-document-version-rendition-file
+
+        Args:
+            doc_id (int): The ID of the document for which the rendition file is to be downloaded.
+            major_version (int): The major version number of the document.
+            minor_version (int): The minor version number of the document.
+            rendition_type (str): The type of the rendition file to download.
+            protected_rendition (bool, optional): If your Vault is configured to use protected renditions, set to false to download the non-protected rendition. If omitted, defaults to true. Defaults to None.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.download_document_version_rendition_file(534, 2, 0, 'viewable_rendition__v', protected_rendition=False)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        params = {
+            "protectedRendition": protected_rendition
+        }
+
+        response = requests.get(url, headers=headers, params=params)
+
+        return response.json()
+
+    def add_multiple_document_renditions(self, file_path, idParam=None, largeSizeAsset=None):
+        """
+        Adds multiple document renditions in bulk. This function requires the renditions to be loaded to the file staging server first.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#add-multiple-document-renditions
+
+        Args:
+            file_path (str): The filepath of the CSV file which contains details of the renditions to be added. The CSV should be in UTF-8 encoding and comply with RFC 4180 format.
+            idParam (str, optional): If you’re identifying documents in your input by a unique field, add this parameter. Defaults to None.
+            largeSizeAsset (bool, optional): Set to true if adding renditions of the Large Size Asset type. Defaults to None.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.add_multiple_document_renditions("path/to/your/file.csv", idParam="external_id__v", largeSizeAsset=True)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/renditions/batch"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json",
+            "X-VaultAPI-MigrationMode": "true"
+        }
+
+        params = {
+            "idParam": idParam,
+            "largeSizeAsset": largeSizeAsset
+        }
+
+        with open(file_path, 'rb') as f:
+            response = requests.post(url, headers=headers, params=params, data=f)
+
+        return response.json()
+
+
+    def add_single_document_rendition(self, doc_id, rendition_type, file_path):
+        """
+        Adds a single document rendition to the vault. If you need to add more than one document rendition, consider using the bulk API.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#add-single-document-rendition
+
+        Args:
+            doc_id (str): The document ID field value.
+            rendition_type (str): The type of document rendition.
+            file_path (str): The path to the file to be uploaded.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.add_single_document_rendition("534", "imported_rendition__c", "path/to/your/CholeCap-Document.pdf")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/renditions/{rendition_type}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+
+        with open(file_path, 'rb') as f:
+            files = {'file': (os.path.basename(file_path), f)}
+            response = requests.post(url, headers=headers, files=files)
+
+        return response.json()
+
+
+    def upload_document_version_rendition(self, doc_id, major_version, minor_version, rendition_type, file_path):
+        """
+        Uploads a rendition for a specified version of a document. 
+
+        API documentation: https://developer.veevavault.com/api/23.2/#upload-document-version-rendition
+
+        Args:
+            doc_id (str): The document ID field value.
+            major_version (str): The major version number of the document.
+            minor_version (str): The minor version number of the document.
+            rendition_type (str): The type of document rendition.
+            file_path (str): The path to the file to be uploaded.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.upload_document_version_rendition("534", "1", "0", "imported_rendition__c", "path/to/your/CholeCap-Document.pdf")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+
+        with open(file_path, 'rb') as f:
+            files = {'file': (os.path.basename(file_path), f)}
+            response = requests.post(url, headers=headers, files=files)
+
+        return response.json()
+
+
+    def replace_document_rendition(self, doc_id, rendition_type, file_path):
+        """
+        Replaces a rendition of the latest version of a document.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#replace-document-rendition
+
+        Args:
+            doc_id (str): The document ID field value.
+            rendition_type (str): The type of document rendition.
+            file_path (str): The path to the file to be uploaded.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.replace_document_rendition("534", "imported_rendition__c", "path/to/your/CholeCap-Document.pdf")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/renditions/{rendition_type}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+
+        with open(file_path, 'rb') as f:
+            files = {'file': (os.path.basename(file_path), f)}
+            response = requests.put(url, headers=headers, files=files)
+
+        return response.json()
+
+
+    def replace_document_version_rendition(self, doc_id, major_version, minor_version, rendition_type, file_path):
+        """
+        Replaces a rendition of a specified version of a document.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#replace-document-version-rendition
+
+        Args:
+            doc_id (str): The document ID field value.
+            major_version (str): The document major version number.
+            minor_version (str): The document minor version number.
+            rendition_type (str): The type of document rendition.
+            file_path (str): The path to the file to be uploaded.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.replace_document_version_rendition("534", "2", "0", "imported_rendition__c", "path/to/your/CholeCap-Document.pdf")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+
+        with open(file_path, 'rb') as f:
+            files = {'file': (os.path.basename(file_path), f)}
+            response = requests.put(url, headers=headers, files=files)
+
+        return response.json()
+
+
+    def delete_multiple_document_renditions(self, csv_file_path):
+        """
+        Deletes multiple document renditions in bulk.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-document-renditions
+
+        Args:
+            csv_file_path (str): The path to the CSV file containing details of the document renditions to delete.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.delete_multiple_document_renditions("C:\\Vault\\Documents\\delete_document_renditions.csv")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/renditions/batch"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+
+        with open(csv_file_path, 'rb') as f:
+            response = requests.delete(url, headers=headers, data=f)
+
+        return response.json()
+
+
+    def delete_single_document_rendition(self, document_id, rendition_type):
+        """
+        Deletes a single document rendition. On SUCCESS, Vault deletes the rendition of specified type from the latest document version.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document-rendition
+
+        Args:
+            document_id (str): The document ID field value.
+            rendition_type (str): The document rendition type.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.delete_single_document_rendition("534", "imported_rendition__vs")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/renditions/{rendition_type}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+
+        return response.json()
+
+
+    def delete_document_version_rendition(self, doc_id, major_version, minor_version, rendition_type):
+        """
+        Deletes the rendition of the given type from the specified version of the document.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-document-version-rendition
+
+        Args:
+            doc_id (str): The document ID field value.
+            major_version (str): The document major_version_number__v field value.
+            minor_version (str): The document minor_version_number__v field value.
+            rendition_type (str): The document rendition type.
+
+        Returns:
+            Response object: The HTTP Response object.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.delete_document_version_rendition("534", "2", "0", "imported_rendition__c")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+
+        return response.json()
+
+
+
+    #######################################################
+    # Documents
+    ## Document Attachments
+    #######################################################
+
+    def determine_if_document_has_attachments(self, doc_id):
+        """
+        Determines if a document has attachments. The method sends a GET request to the specified URL and retrieves the information on any attachments associated with the specified document ID.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#determine-if-a-document-has-attachments
+
+        Args:
+            doc_id (str): The document ID field value.
+
+        Returns:
+            dict: A dictionary with details about the attachments (if any).
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.determine_if_document_has_attachments("565")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_attachments(self, doc_id):
+        """
+        Retrieves the attachments of a specified document. The method sends a GET request to the specified URL and retrieves details about the document's attachments including id, filename, format, size, MD5 checksum, version details, and the creator's details.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-attachments
+
+        Args:
+            doc_id (str): The document ID field value.
+
+        Returns:
+            dict: A dictionary containing details of the document's attachments.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_attachments("565")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_version_attachments(self, doc_id, major_version, minor_version):
+        """
+        Retrieves the attachments of a specific version of a document. Sends a GET request to the specified URL and retrieves details about the attachments including ID, filename, format, size, MD5 checksum, version details, and the creator's details.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version-attachments
+        
+        Args:
+            doc_id (str): The document ID field value.
+            major_version (str): The document major version number field value.
+            minor_version (str): The document minor version number field value.
+        
+        Returns:
+            dict: A dictionary containing details of the document version's attachments.
+        
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_version_attachments("17", "0", "1")
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_attachment_versions(self, doc_id, attachment_id):
+        """
+        Retrieves versions of a specific document attachment. Sends a GET request to the specified URL and retrieves details about the versions including version number and URL.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-attachment-versions
+        
+        Args:
+            doc_id (str): The document ID field value.
+            attachment_id (str): The attachment ID field value.
+        
+        Returns:
+            dict: A dictionary containing details of the document attachment versions.
+        
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_attachment_versions("565", "566")
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_version_attachment_versions(self, doc_id, major_version, minor_version, attachment_id, attachment_version=None):
+        """
+        Retrieves specific versions of an attachment on a specific version of a document. 
+        If attachment_version is omitted, it retrieves all versions of the specified attachment.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version-attachment-versions
+
+        Args:
+            doc_id (str): The document id field value.
+            major_version (str): The document major_version_number__v field value.
+            minor_version (str): The document minor_version_number__v field value.
+            attachment_id (str): The id of the document attachment to retrieve.
+            attachment_version (str, optional): The version of the attachment to retrieve. Defaults to None.
+
+        Returns:
+            dict: A dictionary containing details of the document version attachment versions.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_version_attachment_versions("17", "0", "1", "39", "1")
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions"
+        if attachment_version:
+            url += f"/{attachment_version}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_attachment_metadata(self, doc_id, attachment_id):
+        """
+        Retrieves the metadata of a specific document attachment. The metadata contains various details including file name, format, size, checksum and more.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-attachment-metadata
+
+        Args:
+            doc_id (str): The document id field value.
+            attachment_id (str): The attachment id field value.
+
+        Returns:
+            dict: A dictionary containing the metadata of the document attachment.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_attachment_metadata("565", "566")
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+    def retrieve_document_attachment_version_metadata(self, doc_id, attachment_id, attachment_version):
+        """
+        Retrieves the metadata of a specific version of a document attachment. This metadata contains details including file name, format, size, checksum and more.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-attachment-version-metadata
+
+        Args:
+            doc_id (str): The document id field value.
+            attachment_id (str): The attachment id field value.
+            attachment_version (str): The attachment version field value.
+
+        Returns:
+            dict: A dictionary containing the metadata of the specific version of the document attachment.
+
+        Usage:
+            >>> vv = Vv()
+            >>> vv.retrieve_document_attachment_version_metadata("565", "566", "2")
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def download_document_attachment(self, doc_id, attachment_id):
+        """
+        Downloads the latest version of the specified attachment from the document. The filename in the response can be used to name the local file.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-document-attachment
+
+        Args:
+            doc_id (str): The document id field value.
+            attachment_id (str): The attachment id field value.
+
+        Returns:
+            bytes: The content of the file as bytes.
+
+        Usage:
+            >>> vv = Vv()
+            >>> file_content = vv.download_document_attachment("565", "567")
+            >>> with open("filename_from_response.pdf", "wb") as file:
+            >>>     file.write(file_content)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/file"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+        
+        return response.content
+
+
+    def download_document_attachment_version(self, doc_id, attachment_id, attachment_version):
+        """
+        Downloads the specified version of the attachment from the document. The filename in the response can be used to name the local file.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-document-attachment-version
+
+        Args:
+            doc_id (str): The document id field value.
+            attachment_id (str): The attachment id field value.
+            attachment_version (str): The attachment version__v field value.
+
+        Returns:
+            bytes: The content of the file as bytes.
+
+        Usage:
+            >>> vv = Vv()
+            >>> file_content = vv.download_document_attachment_version("565", "567", "1")
+            >>> with open("filename_from_response.pdf", "wb") as file:
+            >>>     file.write(file_content)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}/file"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+        
+        return response.content
+
+
+    def download_document_version_attachment_version(self, doc_id, major_version, minor_version, attachment_id, attachment_version):
+        """
+        Downloads the specified attachment version from the specified document version. The filename in the response can be used to name the local file.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-document-version-attachment-version
+
+        Args:
+            doc_id (str): The document id field value.
+            major_version (str): The document major_version_number__v field value.
+            minor_version (str): The document minor_version_number__v field value.
+            attachment_id (str): The id field value of the attachment.
+            attachment_version (str): The version of the attachment.
+
+        Returns:
+            bytes: The content of the file as bytes.
+
+        Usage:
+            >>> vv = Vv()
+            >>> file_content = vv.download_document_version_attachment_version("56", "0", "1", "14", "3")
+            >>> with open("filename_from_response.pdf", "wb") as file:
+            >>>     file.write(file_content)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}/file"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+        
+        return response.content
+
+
+    def download_all_document_attachments(self, doc_id):
+        """
+        Downloads the latest version of all attachments from the specified document. The attachments are packaged in a ZIP file and the file name from the response can be used to name the local file.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-all-document-attachments
+
+        Args:
+            doc_id (str): The document id field value.
+
+        Returns:
+            bytes: The content of the zip file as bytes.
+
+        Usage:
+            >>> vv = Vv()
+            >>> zip_content = vv.download_all_document_attachments("565")
+            >>> with open("filename_from_response.zip", "wb") as file:
+            >>>     file.write(zip_content)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/file"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+        
+        return response.content
+
+
+    def download_all_document_version_attachments(self, doc_id, major_version, minor_version):
+        """
+        Downloads the latest version of all attachments from the specified version of the document. The file name from the response can be used to name the local file.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-all-document-version-attachments
+
+        Args:
+            doc_id (str): The document id field value.
+            major_version (str): The document major_version_number__v field value.
+            minor_version (str): The document minor_version_number__v field value.
+
+        Returns:
+            bytes: The content of the attachments as bytes.
+
+        Usage:
+            >>> vv = Vv()
+            >>> content = vv.download_all_document_version_attachments("56", "0", "1")
+            >>> with open("filename_from_response", "wb") as file:
+            >>>     file.write(content)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/file"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+        
+        return response.content
+
+
+    def delete_single_document_attachment(self, doc_id, attachment_id):
+        """
+        Deletes the specified attachment and all of its versions.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document-attachment
+
+        Args:
+            doc_id (str): The document id field value.
+            attachment_id (str): The attachment id field value.
+
+        Returns:
+            dict: The JSON response from the API call.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.delete_single_document_attachment("565", "567")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+        response.raise_for_status()
+        
+        return response.json()
+
+
+    def delete_single_document_attachment_version(self, doc_id, attachment_id, attachment_version):
+        """
+        Deletes the specified version of the specified attachment.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-document-attachment-version
+
+        Args:
+            doc_id (str): The document id field value.
+            attachment_id (str): The attachment id field value.
+            attachment_version (str): The attachment version__v field value.
+
+        Returns:
+            dict: The JSON response from the API call.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.delete_single_document_attachment_version("565", "567", "3")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+        response.raise_for_status()
+        
+        return response.json()
+
+
+    def delete_multiple_document_attachments(self, input_file, content_type='text/csv', accept='text/csv', id_param=None):
+        """
+        Delete multiple document attachments in bulk with a JSON or CSV input file. 
+        This works for version-specific attachments and attachments at the document level.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-document-attachments
+
+        Args:
+            input_file (str): The path to the input file (CSV or JSON) with details of attachments to be deleted.
+            content_type (str): The content type of the input file, either 'application/json' or 'text/csv'. Defaults to 'text/csv'.
+            accept (str): The format of the response, either 'application/json', 'text/csv', or 'application/xml'. Defaults to 'text/csv'.
+            id_param (str, optional): If you’re identifying attachments in your input by external id, 
+                                    add this parameter with the value 'external_id__v'. Defaults to None.
+
+        Returns:
+            dict: The JSON response from the API call.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.delete_multiple_document_attachments("C:\\Vault\\Documents\\delete_attachments.csv")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/attachments/batch"
+        if id_param:
+            url += f"?idParam={id_param}"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": content_type,
+            "Accept": accept
+        }
+
+        with open(input_file, 'rb') as file:
+            response = requests.delete(url, headers=headers, data=file)
+            response.raise_for_status()
+        
+        return response.json()
+
+
+    def create_document_attachment(self, doc_id, file_path):
+        """
+        Create an attachment on the latest version of a document. If the attachment 
+        already exists, Vault uploads the attachment as a new version of the existing attachment. 
+
+        API documentation: https://developer.veevavault.com/api/23.2/#create-document-attachment
+
+        Args:
+            doc_id (str): The document id field value.
+            file_path (str): The path to the attachment file to be uploaded.
+
+        Returns:
+            dict: The JSON response from the API call.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.create_document_attachment("565", "path/to/my_attachment_file.png")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+
+        with open(file_path, 'rb') as file:
+            files = {'file': (os.path.basename(file_path), file)}
+            response = requests.post(url, headers=headers, files=files)
+            response.raise_for_status()
+        
+        return response.json()
+
+
+    def create_multiple_document_attachments(self, input_file_path):
+        """
+        Create multiple document attachments in bulk with a JSON or CSV input file. You must first load the attachments 
+        to the file staging server. This works for version-specific attachments and attachments at the document level. 
+
+        API documentation: https://developer.veevavault.com/api/23.2/#create-multiple-document-attachments
+
+        Args:
+            input_file_path (str): The file path to the CSV or JSON input file.
+
+        Returns:
+            dict: The JSON response from the API call.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.create_multiple_document_attachments("path/to/create_attachments.csv")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/attachments/batch"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "text/csv"
+        }
+
+        with open(input_file_path, 'rb') as file:
+            response = requests.post(url, headers=headers, data=file)
+            response.raise_for_status()
+        
+        return response.json()
+
+
+    def restore_document_attachment_version(self, doc_id, attachment_id, attachment_version):
+        """
+        Restores a specific version of an existing attachment to make it the latest version.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#restore-document-attachment-version
+
+        Args:
+            doc_id (str): The document id field value.
+            attachment_id (str): The attachment id field value.
+            attachment_version (str): The attachment version__v field value.
+
+        Returns:
+            dict: The JSON response from the API call.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.restore_document_attachment_version("565", "567", "2")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}?restore=true"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers)
+        response.raise_for_status()
+        
+        return response.json()
+
+
+    def update_document_attachment_description(self, doc_id, attachment_id, description):
+        """
+        Updates the description of an attachment on the latest version of a document.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#update-document-attachment-description
+
+        Args:
+            doc_id (str): The document id field value.
+            attachment_id (str): The attachment id field value.
+            description (str): The new description for the attachment, maximum character length is 1000.
+
+        Returns:
+            dict: The JSON response from the API call.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.update_document_attachment_description("565", "567", "This is my description for this attachment.")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/attachments/{attachment_id}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        data = {
+            "description__v": description
+        }
+        
+        response = requests.put(url, headers=headers, data=data)
+        response.raise_for_status()
+        
+        return response.json()
+
+    def update_multiple_document_attachment_descriptions(self, input_file_path, id_param=None):
+        """
+        Updates the descriptions of multiple document attachments in bulk using a JSON or CSV input file.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#update-multiple-document-attachment-descriptions
+
+        Args:
+            input_file_path (str): The file path to the JSON or CSV input file.
+            id_param (str, optional): The parameter to identify attachments by external ID instead of regular id. 
+                                    If identifying attachments by external id, add idParam=external_id__v to the request endpoint.
+
+        Returns:
+            dict: The JSON response from the API call.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.update_multiple_document_attachment_descriptions("C:\\Vault\\Documents\\update_attachments.csv")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/attachments/batch"
+        if id_param:
+            url += f"?idParam={id_param}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+        
+        with open(input_file_path, 'rb') as file:
+            response = requests.put(url, headers=headers, data=file)
+            response.raise_for_status()
+        
+        return response.json()
+
+
+    #######################################################
+    # Documents
+    ## Document Annotations
+    #######################################################
+
+    def download_document_annotations(self, doc_id):
+        """
+        Downloads the annotations of the specified version document rendition.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-document-annotations
+
+        Args:
+            doc_id (str): The ID of the document whose annotations need to be downloaded.
+
+        Returns:
+            bytes: The PDF data containing the annotations.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.download_document_annotations("14")
+            >>> with open("annotations.pdf", "wb") as file:
+            >>>     file.write(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/annotations"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+
+        return response.content
+
+
+    def download_document_version_annotations(self, doc_id, major_version, minor_version):
+        """
+        Downloads the annotations of the specified document version.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-document-version-annotations
+
+        Args:
+            doc_id (str): The ID of the document.
+            major_version (str): The major version number of the document.
+            minor_version (str): The minor version number of the document.
+
+        Returns:
+            bytes: The PDF data containing the annotations.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.download_document_version_annotations("14", "2", "1")
+            >>> with open("version_annotations.pdf", "wb") as file:
+            >>>     file.write(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+
+        return response.content
+
+
+    def retrieve_anchor_ids(self, doc_id):
+        """
+        Retrieves all anchor IDs from a specific document.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-anchor-ids
+
+        Args:
+            doc_id (str): The ID of the document to retrieve anchor IDs from.
+
+        Returns:
+            dict: A dictionary containing the details of the retrieved anchor IDs.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.retrieve_anchor_ids("10")
+            >>> for anchor_data in response['anchorDataList']:
+            >>>     print(f"Anchor ID: {anchor_data['anchorId']}, Name: {anchor_data['anchorName']}, Author: {anchor_data['noteAuthor']}, Page: {anchor_data['pageNumber']}")
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/anchors"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+
+        return response.json()
+
+
+    def retrieve_document_version_notes_as_csv(self, doc_id, major_version, minor_version):
+        """
+        Retrieves notes in CSV format for any document that has a viewable rendition and at least one annotation. 
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-version-notes-as-csv
+
+        Args:
+            doc_id (str): The document id field value.
+            major_version (str): The document major version number.
+            minor_version (str): The document minor version number.
+
+        Returns:
+            csv: A CSV containing the annotation metadata.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.retrieve_document_version_notes_as_csv("10", "1", "0")
+            >>> with open('notes.csv', 'w') as file:
+            >>>     file.write(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/doc-export-annotations-to-csv"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "text/csv"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+
+        return response.text
+
+
+    def retrieve_video_annotations(self, doc_id, major_version, minor_version):
+        """
+        Retrieves annotations on a video document.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-video-annotations
+
+        Args:
+            doc_id (str): The video document id field value.
+            major_version (str): The video document major version number.
+            minor_version (str): The video document minor version number.
+
+        Returns:
+            csv: A CSV containing the video annotation metadata including replies and ordered by time signature.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.retrieve_video_annotations("14", "2", "1")
+            >>> with open('video_annotations.csv', 'w') as file:
+            >>>     file.write(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/export-video-annotations"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "text/csv"
+        }
+
+        response = requests.get(url, headers=headers)
+        response.raise_for_status()
+
+        return response.text
+
+
+    def upload_document_annotations(self, doc_id, file_path):
+        """
+        Uploads document annotations.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#upload-document-annotations
+
+        Args:
+            doc_id (str): The document id field value.
+            file_path (str): The path to the document file that contains the annotations to be uploaded.
+
+        Returns:
+            dict: A dictionary containing details about the upload status including the number of replies, failures, and new annotations.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.upload_document_annotations("548", "path/to/document2016.pdf")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/annotations"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+        
+        with open(file_path, 'rb') as f:
+            files = {'file': (os.path.basename(file_path), f)}
+            response = requests.post(url, headers=headers, files=files)
+            response.raise_for_status()
+        
+        return response.json()
+
+
+    def upload_document_version_annotations(self, doc_id, major_version, minor_version, file_path):
+        """
+        Uploads annotations for a specific version of a document.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#upload-document-version-annotations
+
+        Args:
+            doc_id (str): The document id field value.
+            major_version (str): The document major_version_number__v field value.
+            minor_version (str): The document minor_version_number__v field value.
+            file_path (str): The path to the document file that contains the annotations to be uploaded.
+
+        Returns:
+            dict: A dictionary containing details about the upload status including the number of replies, failures, and new annotations.
+
+        Usage:
+            >>> vv = Vv()
+            >>> response = vv.upload_document_version_annotations("548", "2", "1", "path/to/document2016.pdf")
+            >>> print(response)
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+        
+        with open(file_path, 'rb') as f:
+            files = {'file': (os.path.basename(file_path), f)}
+            response = requests.post(url, headers=headers, files=files)
+            response.raise_for_status()
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Documents
+    ## Document Relationships
+    #######################################################
+
+    def retrieve_document_type_relationships(self, document_type):
+        """
+        Retrieves all relationships from a specified document type.
+        
+        API Documentation:
+        https://developer.veevavault.com/api/23.2/#retrieve-document-type-relationships
+        
+        Args:
+        document_type (str): The type of the document. See Retrieve Document Types API for the list of document types.
+        
+        Returns:
+        dict: A dictionary containing the relationship details.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/types/{document_type}/relationships"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_document_relationships(self, doc_id, major_version, minor_version):
+        """
+        Retrieves all relationships from a specific document. For more details, visit: 
+        https://developer.veevavault.com/api/23.2/#retrieve-document-relationships
+        
+        Parameters:
+        doc_id (str): The document id field value.
+        major_version (str): The document major_version_number__v field value.
+        minor_version (str): The document minor_version_number__v field value.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def create_single_document_relationship(self, document_id, major_version_number, minor_version_number, target_doc_id, relationship_type, target_major_version=None, target_minor_version=None):
+        """
+        Creates a new relationship on a document. For more details, visit:
+        https://developer.veevavault.com/api/23.2/#create-single-document-relationship
+        
+        Parameters:
+        document_id (str): The document id field value.
+        major_version_number (str): The document major_version_number__v field value.
+        minor_version_number (str): The document minor_version_number__v field value.
+        target_doc_id (str): The document id of the target document.
+        relationship_type (str): The relationship type retrieved from the Document Relationships Metadata call above.
+        target_major_version (str, optional): The major version number of the target document to which the source document will be bound.
+        target_minor_version (str, optional): The minor version number of the target document to which the source document will be bound.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/versions/{major_version_number}/{minor_version_number}/relationships"
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        data = {
+            "target_doc_id__v": target_doc_id,
+            "relationship_type__v": relationship_type
+        }
+        if target_major_version:
+            data["target_major_version__v"] = target_major_version
+        if target_minor_version:
+            data["target_minor_version__v"] = target_minor_version
+
+        response = requests.post(url, headers=headers, data=data)
+        return response.json()
+
+
+    def create_multiple_document_relationships(self, input_file_path, content_type="text/csv", accept="text/csv", id_param=None):
+        """
+        Creates new relationships on multiple documents. For more details, visit:
+        https://developer.veevavault.com/api/23.2/#create-multiple-document-relationships
+
+        Parameters:
+        input_file_path (str): The path to the input file (JSON or CSV) containing details for creating document relationships.
+        content_type (str, optional): The Content-Type header value. It can be "application/json" or "text/csv". Defaults to "text/csv".
+        accept (str, optional): The Accept header value. It can be "application/json" or "text/csv". Defaults to "text/csv".
+        id_param (str, optional): A query parameter to create relationships based on a unique field. Defaults to None.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/relationships/batch"
+        if id_param:
+            url += f"?idParam={id_param}"
+        
+        headers = {
+            "Content-Type": content_type,
+            "Accept": accept,
+            "Authorization": self.sessionId
+        }
+
+        with open(input_file_path, 'rb') as f:
+            response = requests.post(url, headers=headers, data=f)
+        
+        return response.json()
+
+
+    def retrieve_document_relationship(self, doc_id, major_version, minor_version, relationship_id):
+        """
+        Retrieves the details of a specific document relationship. For more details, visit:
+        https://developer.veevavault.com/api/23.2/#retrieve-document-relationship
+
+        Parameters:
+        doc_id (int): The document ID.
+        major_version (int): The major version number of the document.
+        minor_version (int): The minor version number of the document.
+        relationship_id (int): The ID of the relationship to be retrieved.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def delete_single_document_relationship(self, doc_id, major_version, minor_version, relationship_id):
+        """
+        Deletes a single document relationship. For more details, visit:
+        https://developer.veevavault.com/api/23.2/#delete-single-document-relationship
+
+        Parameters:
+        doc_id (int): The document ID.
+        major_version (int): The major version number of the document.
+        minor_version (int): The minor version number of the document.
+        relationship_id (int): The ID of the relationship to be deleted.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        response = requests.delete(url, headers=headers)
+        
+        return response.json()
+
+
+    def delete_multiple_document_relationships(self, file_path):
+        """
+        Deletes multiple document relationships. For more details, visit:
+        https://developer.veevavault.com/api/23.2/#delete-multiple-document-relationships
+
+        Parameters:
+        file_path (str): The file path of the CSV file containing relationship IDs to be deleted.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/relationships/batch"
+        
+        headers = {
+            "Content-Type": "text/csv",
+            "Accept": "text/csv",
+            "Authorization": self.sessionId
+        }
+        
+        with open(file_path, 'rb') as file:
+            response = requests.delete(url, headers=headers, data=file)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Documents
+    ## Export Documents
+    #######################################################
+
+    def export_documents(self, document_ids, source=True, renditions=False, allversions=False):
+        """
+        Export a set of documents to your Vault’s file staging server. For more information, refer to:
+        https://developer.veevavault.com/api/23.2/#export-documents-1
+
+        Parameters:
+        document_ids (list): List of document IDs to export.
+        source (bool, optional): To include or exclude source files. Defaults to True.
+        renditions (bool, optional): To include or exclude renditions. Defaults to False.
+        allversions (bool, optional): To include all versions or only the latest version. Defaults to False.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch/actions/fileextract"
+        url += f"?source={'true' if source else 'false'}&renditions={'true' if renditions else 'false'}&allversions={'true' if allversions else 'false'}"
+        
+        headers = {
+            "Content-Type": "application/json",
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        payload = json.dumps([{"id": str(id)} for id in document_ids])
+        
+        response = requests.post(url, headers=headers, data=payload)
+        
+        return response.json()
+
+
+    def export_document_versions(self, document_versions, source=True, renditions=False):
+        """
+        Export a specific set of document versions to your Vault’s file staging server. For more information, refer to:
+        https://developer.veevavault.com/api/23.2/#export-document-versions
+
+        Parameters:
+        document_versions (list of dict): List of dictionaries containing details of the document versions to export. Each dictionary should have keys: 'id', 'major_version_number__v', and 'minor_version_number__v'.
+        source (bool, optional): To include or exclude source files. Defaults to True.
+        renditions (bool, optional): To include or exclude renditions. Defaults to False.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/versions/batch/actions/fileextract"
+        url += f"?source={'true' if source else 'false'}&renditions={'true' if renditions else 'false'}"
+        
+        headers = {
+            "Content-Type": "application/json",
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        payload = json.dumps(document_versions)
+        
+        response = requests.post(url, headers=headers, data=payload)
+        
+        return response.json()
+
+    def retrieve_document_export_results(self, job_id):
+        """
+        Retrieve the results of a document export job from your Vault. For more information, refer to:
+        https://developer.veevavault.com/api/23.2/#retrieve-document-export-results
+
+        Parameters:
+        job_id (str): The ID of the export job to retrieve results for.
+
+        Returns:
+        dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/batch/actions/fileextract/{job_id}/results"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Documents
+    ## Document Events
+    #######################################################
+
+
+
+    def retrieve_document_event_types_and_subtypes(self):
+        """
+        Retrieve the types and subtypes of document events configured in your Vault. For more information, refer to:
+        https://developer.veevavault.com/api/23.2/#retrieve-document-event-types-and-subtypes
+
+        Returns:
+        dict: A dictionary containing the response data with the list of event types and subtypes.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/events"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_document_event_subtype_metadata(self, event_type, event_subtype):
+        """
+        Retrieve the metadata for a specific document event subtype in your Vault. For more information, refer to:
+        https://developer.veevavault.com/api/23.2/#retrieve-document-event-subtype-metadata
+
+        Args:
+        event_type (str): The event type (e.g., distribution__v).
+        event_subtype (str): The event subtype (e.g., approved_email__v).
+
+        Returns:
+        dict: A dictionary containing the metadata for the specified event subtype.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/events/{event_type}/types/{event_subtype}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+    def create_document_event(self, document_id, major_version, minor_version, event_type, event_subtype, classification, external_id):
+        """
+        Create a new document event in your Vault. For more information, refer to:
+        https://developer.veevavault.com/api/23.2/#create-document-event
+
+        Args:
+        document_id (int): The document id field value.
+        major_version (int): The document major version number field value.
+        minor_version (int): The document minor version number field value.
+        event_type (str): The event type (e.g., distribution__v).
+        event_subtype (str): The event subtype (e.g., approved_email__v).
+        classification (str): The event classification (e.g., download__v).
+        external_id (str): The external id for the event.
+
+        Returns:
+        dict: A dictionary containing the response status of the event creation.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/versions/{major_version}/{minor_version}/events"
+
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        
+        data = {
+            "event_type__v": event_type,
+            "event_subtype__v": event_subtype,
+            "classification__v": classification,
+            "external_id__v": external_id
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+    def retrieve_document_events(self, document_id):
+        """
+        Retrieve the events associated with a specific document in the vault. For more details, refer to:
+        https://developer.veevavault.com/api/23.2/#retrieve-document-events
+
+        Args:
+        document_id (int): The ID of the document to retrieve events for.
+
+        Returns:
+        dict: A dictionary containing the response status and the list of event objects.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/events"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    #######################################################
+    # Documents
+    ## Document Templates
+    #######################################################
+
+    def retrieve_document_template_metadata(self):
+        """
+        Retrieve the metadata which defines the shape of document templates in your Vault. 
+        For more details, refer to: 
+        https://developer.veevavault.com/api/23.2/#retrieve-document-template-metadata
+
+        Returns:
+        dict: A dictionary containing the response status and the metadata details of document templates.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/documents/templates"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_document_template_collection(self):
+        """
+        Retrieve all document templates present in the Vault. 
+        For more information, refer to:
+        https://developer.veevavault.com/api/23.2/#retrieve-document-template-collection
+
+        Returns:
+        dict: A dictionary containing the response status and details of all document templates in the Vault.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_document_template_attributes(self, template_name):
+        """
+        Retrieve the attributes from a specific document template in the Vault. 
+        For more information, refer to: 
+        https://developer.veevavault.com/api/23.2/#retrieve-document-template-attributes
+
+        Args:
+        template_name (str): The name__v field value of the document template.
+
+        Returns:
+        dict: A dictionary containing the response status and attributes of the specified document template.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates/{template_name}"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+    def download_document_template_file(self, template_name):
+        """
+        Download the file of a specific document template.
+        For more information, refer to: 
+        https://developer.veevavault.com/api/23.2/#download-document-template-file
+
+        Args:
+        template_name (str): The name__v field value of the document template.
+
+        Returns:
+        Response object: A Response object containing the file stream of the specified document template.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates/{template_name}/file"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+
+        response = requests.get(url, headers=headers, stream=True)
+        
+        with open(f"{template_name}.pdf", 'wb') as file:
+            for chunk in response.iter_content(chunk_size=8192):
+                file.write(chunk)
+
+        return response.json()
+
+
+    def create_single_document_template(self, label__v, type__v, active__v, file_path, subtype__v=None, classification__v=None, is_controlled__v=None, template_doc_id__v=None):
+        """
+        Create one document template in the Vault.
+        For more information, refer to:
+        https://developer.veevavault.com/api/23.2/#create-single-document-template
+
+        Args:
+        label__v (str): The label of the new document template. This is the name users will see among the available templates in the UI.
+        type__v (str): The name of the document type to which the template will be associated.
+        active__v (bool): Set to true or false to indicate whether the new document template should be set to active.
+        file_path (str): The file path of the document template to be uploaded. Maximum allowed size is 4GB.
+        subtype__v (str, optional): The name of the document subtype to which the template will be associated. This is only required if associating the template with a document subtype.
+        classification__v (str, optional): The name of the document classification to which the template will be associated. This is only required if associating the template with a document classification.
+        is_controlled__v (bool, optional): Set to true to indicate this template is a controlled document template.
+        template_doc_id__v (str, optional): The document id value to use as the Template Document for this controlled document template.
+
+        Returns:
+        Response object: A Response object containing the API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json",
+            "Content-Type": "multipart/form-data"
+        }
+
+        data = {
+            "label__v": label__v,
+            "type__v": type__v,
+            "active__v": active__v
+        }
+        if subtype__v:
+            data["subtype__v"] = subtype__v
+        if classification__v:
+            data["classification__v"] = classification__v
+        if is_controlled__v is not None:
+            data["is_controlled__v"] = is_controlled__v
+        if template_doc_id__v:
+            data["template_doc_id__v"] = template_doc_id__v
+
+        files = {'file': open(file_path, 'rb')}
+        
+        response = requests.post(url, headers=headers, data=data, files=files)
+
+        return response.json()
+
+
+    def update_multiple_document_templates(self, file_path):
+        """
+        Update up to 500 document templates in the Vault.
+        For more details, visit:
+        https://developer.veevavault.com/api/23.2/#update-multiple-document-templates
+
+        Args:
+        file_path (str): The path to the input file (CSV or JSON) containing details of the document templates to be updated.
+
+        Returns:
+        dict: A dictionary containing the API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+
+        with open(file_path, 'rb') as f:
+            response = requests.put(url, headers=headers, data=f)
+
+        return response.json()
+
+
+    def delete_basic_document_template(self, template_name):
+        """
+        Delete a basic document template from the Vault. Controlled document templates cannot be deleted using this API endpoint.
+        For more details, visit:
+        https://developer.veevavault.com/api/23.2/#delete-basic-document-template
+
+        Args:
+        template_name (str): The name__v field value of the document template to be deleted.
+
+        Returns:
+        dict: A dictionary containing the API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/templates/{template_name}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+
+        return response.json()
+
+
+    #######################################################
+    # Documents
+    ## Document Tokens
+    #######################################################
+
+    def document_tokens(self, doc_ids, expiry_date_offset=None, download_option=None, channel=None, token_group=None, steady_state=None):
+        """
+        Generates document access tokens needed by the external viewer to view documents outside of Vault.
+        For more details, visit:
+        https://developer.veevavault.com/api/23.2/#document-tokens
+
+        Args:
+        doc_ids (str): A comma-separated string of document id values for which to generate tokens.
+        expiry_date_offset (int, optional): The number of days after which the tokens will expire. Defaults to 10 years if not specified.
+        download_option (str, optional): Set to 'PDF', 'source', 'both', or 'none' to specify download options in the external viewer. Defaults to document settings if not specified.
+        channel (str, optional): The website object record id value that corresponds to the distribution channel. Defaults to 'Approved Email' if not specified.
+        token_group (str, optional): A string to group together generated tokens for multiple documents to display in the same viewer. Can be up to 255 characters in length.
+        steady_state (bool, optional): If true, generates a token for the latest steady state version of a document. Defaults to false.
+
+        Returns:
+        dict: A dictionary containing the API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/tokens"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        data = {
+            "docIds": doc_ids,
+            "expiryDateOffset": expiry_date_offset,
+            "downloadOption": download_option,
+            "channel": channel,
+            "tokenGroup": token_group,
+            "steadyState": steady_state
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+
+        return response.json()
+
+
+    #######################################################
+    # Binders
+    #######################################################
+
+    #######################################################
+    # Binders
+    ## Retrieve Binders
+    #######################################################
+
+    def retrieve_all_binders(self):
+        """
+        Retrieve a list of all binders in the Vault. Binders are a kind of document and can be distinguished from regular documents using the 'binder__v' field set to true or false.
+        For more details, visit: https://developer.veevavault.com/api/23.2/#retrieve-all-binders
+
+        Returns:
+        dict: A dictionary containing the API response with details of all binders.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+    def retrieve_binder(self, binder_id, depth='root'):
+        """
+        Use this endpoint to retrieve all fields and values configured on a specific binder in your Vault (using the binder ID).
+        The response includes the "first level" of the binder section node structure. To retrieve additional levels in the 
+        binder section node structure, use one of the depth parameters described in the documentation.
+        Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder
+        
+        Parameters:
+        binder_id (str): The binder id field value.
+        depth (str): To retrieve all information in all levels of the binder, set this to 'all'. 
+                    By default, only one level ('root') is returned.
+        
+        Returns:
+        dict: A dictionary containing the details of the binder.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
+        headers = {
+            'Authorization': self.sessionId,
+            'Accept': 'application/json'
+        }
+        params = {'depth': depth}
+        response = requests.get(url, headers=headers, params=params)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def retrieve_all_binder_versions(self, binder_id):
+        """
+        Retrieve all versions of a binder. 
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-binder-versions
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :return: A list of available versions for the specified binder.
+        :rtype: list
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions"
+        headers = {'Accept': 'application/json', 'Authorization': self.sessionId}
+        
+        response = requests.get(url, headers=headers)
+        if response.status_code == 200:
+            return response.json().get('versions')
+        else:
+            return response.json().get('responseStatus')
+
+
+    def retrieve_binder_version(self, binder_id, major_version, minor_version):
+        """
+        Retrieve the fields and values configured on a specific version of a specific binder.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-version
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param major_version: The binder major_version_number__v field value.
+        :type major_version: str
+        :param minor_version: The binder minor_version_number__v field value.
+        :type minor_version: str
+        :return: Fields and values of the specified binder version.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
+        headers = {'Accept': 'application/json', 'Authorization': self.sessionId}
+        
+        response = requests.get(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+    #######################################################
+    # Binders
+    ## Create Binders
+    #######################################################
+
+    def create_binder(self, binder_data, async_indexing=False):
+        """
+        Use this request to create a new binder in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder
+
+        :param binder_data: A dictionary containing binder data with keys matching the API's field names (e.g., name__v, type__v).
+        :type binder_data: dict
+        :param async_indexing: To process the indexing asynchronously, set to True. Default is False.
+        :type async_indexing: bool
+        :return: Response from the API, contains status and created binder ID.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders"
+        if async_indexing:
+            url += "?async=true"
+
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+
+        response = requests.post(url, data=binder_data, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+    def create_binder_from_template(self, template_name, binder_data):
+        """
+        Use this request to create a new binder in your Vault from a template.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-from-template
+
+        :param template_name: The name of the template to use for creating the binder, as returned from the document metadata.
+        :type template_name: str
+        :param binder_data: A dictionary containing binder data with keys matching the API's field names (e.g., name__v, type__v).
+        :type binder_data: dict
+        :return: Response from the API, contains status and created binder ID.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders"
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+        
+        binder_data['fromTemplate'] = template_name
+        
+        response = requests.post(url, data=binder_data, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+    def create_binder_version(self, binder_id):
+        """
+        Use this method to create a new version of a binder in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-version
+
+        :param binder_id: The ID of the binder for which a new version will be created.
+        :type binder_id: str or int
+        :return: Response from the API, contains status and version details.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+
+        response = requests.post(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+
+    #######################################################
+    # Binders
+    ## Update Binders
+    #######################################################
+
+    def update_binder(self, binder_id, data):
+        """
+        Use this method to update the details of a binder in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder
+
+        :param binder_id: The ID of the binder to be updated.
+        :type binder_id: str or int
+        :param data: A dictionary containing the data fields to be updated in the binder.
+        :type data: dict
+        :return: Response from the API, contains status and ID of the updated binder.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+
+        response = requests.put(url, headers=headers, data=data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+    def reclassify_binder(self, binder_id, reclassify_data):
+        """
+        Use this method to reclassify an existing binder in your Vault. Reclassification allows changing the document type 
+        of an existing binder. You can only reclassify the latest version of a specified binder and one binder at a time.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#reclassify-binder
+
+        :param binder_id: The ID of the binder to be reclassified.
+        :type binder_id: str or int
+        :param reclassify_data: A dictionary containing the reclassify parameters and other editable fields.
+        :type reclassify_data: dict
+        :return: Response from the API, contains status and ID of the reclassified binder.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+
+        response = requests.put(url, headers=headers, data=reclassify_data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+    def update_binder_version(self, binder_id, major_version, minor_version, update_data):
+        """
+        This method is used to update a specific version of a binder in your Vault. The necessary parameters 
+        are the binder ID and the major and minor version numbers.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-version
+
+        :param binder_id: The ID of the binder to be updated.
+        :type binder_id: str or int
+        :param major_version: The major version number of the binder.
+        :type major_version: str or int
+        :param minor_version: The minor version number of the binder.
+        :type minor_version: str or int
+        :param update_data: A dictionary containing the parameters to update.
+        :type update_data: dict
+        :return: Response from the API, contains status and ID of the updated binder.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+
+        response = requests.put(url, headers=headers, data=update_data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+    def refresh_binder_auto_filing(self, binder_id):
+        """
+        This method triggers auto-filing for a specific binder. It is only available in eTMF Vaults on binders
+        configured with the TMF Reference Models. It mimics the Refresh Auto-Filing action available in the UI.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#refresh-binder-auto-filing
+
+        :param binder_id: The ID of the binder to refresh auto-filing.
+        :type binder_id: str or int
+        :return: Response from the API, indicates the success of the operation.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/actions"
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+        data = {
+            'action': 'refresh_auto_filing'
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+
+    #######################################################
+    # Binders
+    ## Delete Binders
+    #######################################################
+
+    def delete_binder(self, binder_id):
+        """
+        This method allows you to delete a specified binder from the vault. The method sends a DELETE request to the Vault API
+        to remove the binder identified by the binder_id parameter.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder
+
+        :param binder_id: The ID of the binder to be deleted.
+        :type binder_id: str or int
+        :return: Response from the API, indicating the status of the delete operation.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+
+        response = requests.delete(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+    def delete_binder_version(self, binder_id, major_version, minor_version):
+        """
+        This method enables the deletion of a specific version of a binder. The binder is identified using binder_id, 
+        major_version, and minor_version parameters.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder-version
+
+        :param binder_id: The ID of the binder to be modified.
+        :type binder_id: str or int
+        :param major_version: The major version number of the binder.
+        :type major_version: str or int
+        :param minor_version: The minor version number of the binder.
+        :type minor_version: str or int
+        :return: Response from the API, denoting the status of the deletion process.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+
+        response = requests.delete(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+
+
+    #######################################################
+    # Binders
+    ## Export Binders
+    #######################################################
+
+    def export_binder(self, binder_id, major_version=None, minor_version=None, source=True, renditiontype=None, docversion=None, attachments=None, fields=None, docfield=True):
+        """
+        This method allows you to export a binder from the Vault. You can specify various parameters to control
+        the details of the exported content, such as whether to include source files, specific rendition types,
+        document versions, attachments, and specific field values. 
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#export-binder
+
+        :param binder_id: The ID of the binder to be exported.
+        :type binder_id: str or int
+        :param major_version: (Optional) The major version number of the binder. If not specified, the latest version is exported.
+        :type major_version: str or int, optional
+        :param minor_version: (Optional) The minor version number of the binder. This parameter is used in conjunction with the major_version parameter.
+        :type minor_version: str or int, optional
+        :param source: (Optional) Whether to include source files in the export. Default is True.
+        :type source: bool, optional
+        :param renditiontype: (Optional) The type of renditions to be included in the export.
+        :type renditiontype: str, optional
+        :param docversion: (Optional) Specify the versions of the documents to be included in the export.
+        :type docversion: str, optional
+        :param attachments: (Optional) Specify whether to include binder attachments in the export, and which versions to include.
+        :type attachments: str, optional
+        :param fields: (Optional) A comma-separated list of document field values to be included in the export.
+        :type fields: str, optional
+        :param docfield: (Optional) Whether to include document metadata in the export. Default is True.
+        :type docfield: bool, optional
+        :return: Response from the API, containing details of the export job initiated.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        params = {}
+        if not source:
+            params['source'] = 'false'
+        if renditiontype:
+            params['renditiontype'] = renditiontype
+        if docversion:
+            params['docversion'] = docversion
+        if attachments:
+            params['attachments'] = attachments
+        if fields:
+            params['fields'] = fields
+        if not docfield:
+            params['docfield'] = 'false'
+
+        endpoint = f"/api/{self.LatestAPIversion}/objects/binders/{binder_id}"
+        if major_version is not None and minor_version is not None:
+            endpoint += f"/versions/{major_version}/{minor_version}"
+        endpoint += "/actions/export"
+        url = f"{self.vaultURL}{endpoint}"
+
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId
+        }
+
+        response = requests.post(url, headers=headers, params=params)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+    def export_binder_sections(self, binder_id, major_version, minor_version, node_ids, input_file_format='csv'):
+        """
+        This method allows you to export specific sections and documents from a binder in your Vault. You need to provide a list of node IDs (section or document IDs) to specify which parts of the binder to export. This method will initiate an export job in the Vault, and you can later check the status of this job using the URL and job ID provided in the response.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#export-binder-sections
+
+        :param binder_id: The ID of the binder to export sections from.
+        :type binder_id: str or int
+        :param major_version: The major version number of the binder.
+        :type major_version: str or int
+        :param minor_version: The minor version number of the binder.
+        :type minor_version: str or int
+        :param node_ids: A list of node IDs specifying the sections and documents to export.
+        :type node_ids: list of str or int
+        :param input_file_format: Format of the input file, either 'csv' or 'json'. Default is 'csv'.
+        :type input_file_format: str, optional
+        :return: Response from the API, containing details of the export job initiated.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export"
+
+        headers = {
+            'Authorization': self.sessionId,
+            'Accept': 'application/json'
+        }
+
+        if input_file_format.lower() == 'csv':
+            headers['Content-Type'] = 'text/csv'
+            data = '\n'.join(map(str, node_ids))
+        else: # input_file_format is 'json'
+            headers['Content-Type'] = 'application/json'
+            data = json.dumps({'id': node_ids})
+
+        response = requests.post(url, headers=headers, data=data)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+    def retrieve_binder_export_results(self, job_id):
+        """
+        This method retrieves the results of a previously initiated binder export job. You need to provide the job ID of the export job to get the results. The method returns details of the export including the path to the exported binder file.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-export-results
+
+        :param job_id: The ID of the export job whose results are to be retrieved.
+        :type job_id: str or int
+        :return: Response from the API, containing details of the exported binder.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/actions/export/{job_id}/results"
+
+        headers = {
+            'Authorization': self.sessionId,
+            'Accept': 'application/json'
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.json().get('responseStatus')
+
+
+    def download_exported_binder_files(self, file_path):
+        """
+        This method allows you to download the exported binder files from the file staging server. Ensure that the export job has been completed successfully and the API user has the necessary permissions to access the file staging server.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#download-exported-binder-files-via-file-staging-server
+
+        :param file_path: The path/location of the downloaded binder ZIP file retrieved from the export results.
+        :type file_path: str
+        :return: None
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}{file_path}"
+
+        headers = {
+            'Authorization': self.sessionId,
+        }
+
+        response = requests.get(url, headers=headers)
+
+        if response.status_code == 200:
+            with open('downloaded_binder.zip', 'wb') as file:
+                file.write(response.content)
+        else:
+            print(f"Failed to download the file. Status code: {response.status_code}")
+
+
+
+    #######################################################
+    # Binders
+    ## Binder Relationships
+    #######################################################
+
+    def retrieve_binder_relationship(self, binder_id, major_version, minor_version, relationship_id):
+        """
+        Retrieve information about a specific binder relationship using its ID. This method returns details such as the source document ID, relationship type, creation date, etc.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-relationship
+
+        :param binder_id: The ID of the binder.
+        :type binder_id: str
+        :param major_version: The major version number of the binder.
+        :type major_version: int
+        :param minor_version: The minor version number of the binder.
+        :type minor_version: int
+        :param relationship_id: The ID of the binder relationship.
+        :type relationship_id: int
+        :return: Response JSON containing the details of the binder relationship.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
+        
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to retrieve binder relationship. Status code: {response.status_code}"}
+
+    def create_binder_relationship(self, binder_id, major_version, minor_version, target_doc_id, relationship_type, target_major_version=None, target_minor_version=None):
+        """
+        Create a relationship between a binder and a target document in the Vault. You can specify the versions of the target document to create a relationship with a specific version.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-relationship
+
+        :param binder_id: The ID of the binder.
+        :type binder_id: str
+        :param major_version: The major version number of the binder.
+        :type major_version: int
+        :param minor_version: The minor version number of the binder.
+        :type minor_version: int
+        :param target_doc_id: The document ID of the target document.
+        :type target_doc_id: int
+        :param relationship_type: The relationship type for creating the binder relationship.
+        :type relationship_type: str
+        :param target_major_version: The major version number of the target document (optional).
+        :type target_major_version: int, optional
+        :param target_minor_version: The minor version number of the target document (optional).
+        :type target_minor_version: int, optional
+        :return: Response JSON containing the status of the creation operation and the ID of the created relationship.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships"
+        
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+        
+        data = {
+            'target_doc_id__v': target_doc_id,
+            'relationship_type__v': relationship_type,
+        }
+        
+        if target_major_version is not None:
+            data['target_major_version__v'] = target_major_version
+        
+        if target_minor_version is not None:
+            data['target_minor_version__v'] = target_minor_version
+
+        response = requests.post(url, headers=headers, data=data)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to create binder relationship. Status code: {response.status_code}"}
+
+
+    def delete_binder_relationship(self, binder_id, major_version, minor_version, relationship_id):
+        """
+        Deletes a specified relationship from a binder in the Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder-relationship
+
+        :param binder_id: The ID of the binder.
+        :type binder_id: str
+        :param major_version: The major version number of the binder.
+        :type major_version: int
+        :param minor_version: The minor version number of the binder.
+        :type minor_version: int
+        :param relationship_id: The ID of the relationship to be deleted.
+        :type relationship_id: int
+        :return: Response JSON containing the status of the deletion operation and the ID of the deleted relationship.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
+        
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+        
+        response = requests.delete(url, headers=headers)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to delete binder relationship. Status code: {response.status_code}"} 
+
+
+    #######################################################
+    # Binders
+    ## Binder Sections
+    #######################################################
+    def retrieve_binder_sections(self, binder_id, section_id=None):
+        """
+        Retrieve all sections (documents and subsections) in a binder's top-level root node or sub-level node.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-sections
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param section_id: Optional: The section id to retrieve sections from a sub-level node. If not included, all sections from the binder’s top-level root node will be returned.
+        :type section_id: str, optional
+        :return: Response JSON containing details of all sections (documents and subsections) in a binder's top-level root node or sub-level node.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections"
+        if section_id:
+            url += f"/{section_id}"
+
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to retrieve binder sections. Status code: {response.status_code}"} 
+
+
+    def retrieve_binder_version_section(self, binder_id, major_version, minor_version, section_id=None):
+        """
+        For a specific version, retrieve all sections (documents and subsection) in a binder’s top-level root node or sub-level node.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-version-section
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param major_version: The binder major version number field value.
+        :type major_version: str
+        :param minor_version: The binder minor version number field value.
+        :type minor_version: str
+        :param section_id: Optional: The section id to retrieve sections from a sub-level node. If not included, all sections from the binder’s top-level root node will be returned.
+        :type section_id: str, optional
+        :return: Response JSON containing details of all sections (documents and subsections) in a binder's top-level root node or sub-level node for the specified version.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/sections"
+        if section_id:
+            url += f"/{section_id}"
+        
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to retrieve binder version section. Status code: {response.status_code}"} 
+
+    def create_binder_section(self, binder_id, name, section_number=None, parent_id=None, order=None):
+        """
+        Create a new section in a binder.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-section
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param name: Specify a name for the new section.
+        :type name: str
+        :param section_number: Optional: Enter a numerical value for the new section.
+        :type section_number: str, optional
+        :param parent_id: Optional: If the new section is going to be a subsection, enter the Node ID of the parent section. If left blank, the new section will become a top-level section in the binder. 
+        :type parent_id: str, optional
+        :param order: Optional: Enter a number reflecting the position of the section within the binder or parent section.
+        :type order: int, optional
+        :return: Response JSON containing the Node ID of the newly created section.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections"
+
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        data = {
+            'name__v': name,
+        }
+        if section_number:
+            data['section_number__v'] = section_number
+        if parent_id:
+            data['parent_id__v'] = parent_id
+        if order:
+            data['order__v'] = order
+
+        response = requests.post(url, headers=headers, data=data)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to create binder section. Status code: {response.status_code}"} 
+
+    def update_binder_section(self, binder_id, node_id, name=None, section_number=None, order=None, parent_id=None):
+        """
+        Update a section in a binder.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-section
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param node_id: The binder node id of the section.
+        :type node_id: str
+        :param name: Optional: Change the name of the binder section.
+        :type name: str, optional
+        :param section_number: Optional: Update the section number value.
+        :type section_number: str, optional
+        :param order: Optional: Enter a number reflecting the position of the section within the binder or parent section.
+        :type order: int, optional
+        :param parent_id: Optional: To move the section to a different section in the binder, include the value of the parent node where it will be moved.
+        :type parent_id: str, optional
+        :return: Response JSON containing the Node ID of the updated section.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections/{node_id}"
+        
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+        
+        data = {}
+        if name:
+            data['name__v'] = name
+        if section_number:
+            data['section_number__v'] = section_number
+        if order:
+            data['order__v'] = order
+        if parent_id:
+            data['parent_id__v'] = parent_id
+
+        response = requests.put(url, headers=headers, data=data)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to update binder section. Status code: {response.status_code}"}
+
+
+    def delete_binder_section(self, binder_id, section_id):
+        """
+        Delete a section from a binder.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder-section
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param section_id: The binder node id field value.
+        :type section_id: str
+        :return: Response JSON containing the Node ID of the deleted section.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections/{section_id}"
+        
+        headers = {
+            'Content-Type': 'application/json',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+        
+        response = requests.delete(url, headers=headers)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to delete binder section. Status code: {response.status_code}"}
+
+
+
+    #######################################################
+    # Binders
+    ## Binder Documents
+    #######################################################
+
+    def add_document_to_binder(self, binder_id, document_id, parent_id=None, order=None, binding_rule=None, major_version_number=None, minor_version_number=None):
+        """
+        Add a document to a binder.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#add-document-to-binder
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param document_id: ID of the document being added to the binder.
+        :type document_id: str
+        :param parent_id: Section ID of the parent section (optional).
+        :type parent_id: str, optional
+        :param order: Position of the document within the binder or section (optional).
+        :type order: int, optional
+        :param binding_rule: The binding rule indicating which version of the document will be linked to the binder (optional).
+        :type binding_rule: str, optional
+        :param major_version_number: Major version of the document to be linked (optional).
+        :type major_version_number: int, optional
+        :param minor_version_number: Minor version of the document to be linked (optional).
+        :type minor_version_number: int, optional
+        :return: Response JSON containing the Node ID of the added document.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/documents"
+        
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+        
+        data = {
+            'document_id__v': document_id,
+            'parent_id__v': parent_id,
+            'order__v': order,
+            'binding_rule__v': binding_rule,
+            'major_version_number__v': major_version_number,
+            'minor_version_number__v': minor_version_number,
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to add document to binder. Status code: {response.status_code}"}
+
+
+    def move_document_in_binder(self, binder_id, section_id, order=None, parent_id=None):
+        """
+        Move a document to a different position within a binder.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#move-document-in-binder
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param section_id: The binder node id field value.
+        :type section_id: str
+        :param order: A number reflecting the new position of the document within the binder or section (optional).
+        :type order: int, optional
+        :param parent_id: Value of the new parent node to move the document to a different section or to the binder's root node (optional).
+        :type parent_id: str, optional
+        :return: Response JSON containing the new node ID of the document.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/documents/{section_id}"
+
+        headers = {
+            'Content-Type': 'application/x-www-form-urlencoded',
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        data = {
+            'order__v': order,
+            'parent_id__v': parent_id,
+        }
+
+        response = requests.put(url, headers=headers, data=data)
+
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to move document in binder. Status code: {response.status_code}"}
+
+
+    def remove_document_from_binder(self, binder_id, section_id):
+        """
+        Remove a document from a binder.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#remove-document-from-binder
+
+        :param binder_id: The binder id field value.
+        :type binder_id: str
+        :param section_id: The binder node id field value.
+        :type section_id: str
+        :return: Response JSON containing the Node ID of the deleted document.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/documents/{section_id}"
+
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        response = requests.delete(url, headers=headers)
+
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to remove document from binder. Status code: {response.status_code}"}
+
+
+
+
+    #######################################################
+    # Binders
+    ## Binder Templates
+    #######################################################
+
+    def retrieve_binder_template_metadata(self):
+        """
+        Retrieve the metadata which defines the shape of binder templates in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-metadata
+
+        :return: Response JSON containing metadata of binder templates.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/binders/templates"
+
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        response = requests.get(url, headers=headers)
+
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to retrieve binder template metadata. Status code: {response.status_code}"}
+
+    def retrieve_binder_template_node_metadata(self):
+        """
+        Retrieve the metadata which defines the shape of binder template nodes in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-node-metadata
+
+        :return: Response JSON containing metadata of binder template nodes.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/binders/templates/bindernodes"
+
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        response = requests.get(url, headers=headers)
+
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to retrieve binder template node metadata. Status code: {response.status_code}"} 
+
+    def retrieve_binder_template_collection(self):
+        """
+        Retrieve the collection of all binder templates in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-collection
+
+        :return: Response JSON containing the collection of binder templates.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates"
+
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        response = requests.get(url, headers=headers)
+
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to retrieve binder template collection. Status code: {response.status_code}"} 
+
+
+    def retrieve_binder_template_attributes(self, template_name):
+        """
+        Retrieve the attributes of a specific binder template in your Vault.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-attributes
+
+        :param template_name: The binder template name__v field value.
+        :type template_name: str
+        :return: Response JSON containing the attributes of the specified binder template.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}"
+
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': self.sessionId,
+        }
+
+        response = requests.get(url, headers=headers)
+
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return {'error': f"Failed to retrieve binder template attributes. Status code: {response.status_code}"}
+
+
+    def retrieve_binder_template_node_attributes(self, template_name):
+        """
+        Retrieves the attributes of each node (folder/section) of a specific binder template in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-binder-template-node-attributes
+
+        :param template_name: The binder template name__v field value.
+        :return: A JSON object containing the attributes of each node of a specific binder template in the Vault.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}/bindernodes"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def create_binder_template(self, label_v, type_v, active_v, name_v=None, subtype_v=None, classification_v=None):
+        """
+        Create a new binder template in your Vault.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-template
+        
+        Parameters:
+        label_v (str): The label of the new binder template. This is the name users will see among the available binder templates in the UI.
+        type_v (str): The name of the document type to which the template will be associated.
+        active_v (bool): Set to true or false to indicate whether or not the new binder template should be set to active, i.e., available for selection when creating a binder.
+        name_v (str, optional): The name of the new binder template. If not included, Vault will use the specified label_v value to generate a value for the name_v field.
+        subtype_v (str, optional): The name of the document subtype to which the template will be associated. This is only required if associating the template with a document subtype.
+        classification_v (str, optional): The name of the document classification to which the template will be associated. This is only required if associating the template with a document classification.
+        
+        Returns:
+        response (dict): The response from the API call.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        data = {
+            "label__v": label_v,
+            "type__v": type_v,
+            "active__v": str(active_v).lower()
+        }
+        
+        if name_v:
+            data["name__v"] = name_v
+        if subtype_v:
+            data["subtype__v"] = subtype_v
+        if classification_v:
+            data["classification__v"] = classification_v
+        
+        response = requests.post(url, headers=headers, data=data).json()
+        
+        return response.json()
+
+    def bulk_create_binder_templates(self, file_path):
+        """
+        Bulk create from 1-500 new binder templates in your Vault.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#bulk-create-binder-templates
+        
+        Parameters:
+        file_path (str): The path to the CSV file containing the data of the binder templates to be created.
+        
+        Returns:
+        response (dict): The response from the API call.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+        
+        with open(file_path, 'rb') as file:
+            response = requests.post(url, headers=headers, data=file).json()
+        
+        return response.json()
+
+
+    def create_binder_template_node(self, template_name, file_path):
+        """
+        Create nodes in an existing binder template.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-binder-template-node
+        
+        Parameters:
+        template_name (str): The binder template name__v field value.
+        file_path (str): The path to the CSV file containing the data of the binder nodes to be created.
+        
+        Returns:
+        response (dict): The response from the API call.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}/bindernodes"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+        
+        with open(file_path, 'rb') as file:
+            response = requests.post(url, headers=headers, data=file).json()
+        
+        return response.json()
+
+
+    def update_binder_template(self, template_name, payload):
+        """
+        Update an existing binder template in your Vault.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-template
+        
+        Parameters:
+        template_name (str): The binder template name__v field value.
+        payload (dict): The data containing the fields to update. 
+        
+        Returns:
+        response (str): The response from the API call in text/csv format.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "text/csv"
+        }
+        
+        response = requests.put(url, headers=headers, data=payload).text
+        
+        return response.json()
+
+
+    def bulk_update_binder_templates(self, file_path):
+        """
+        Bulk update from 1-500 binder templates in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#bulk-update-binder-templates
+        
+        Parameters:
+        file_path (str): The path to the CSV input file with details of binder templates to be updated.
+        
+        Returns:
+        response (json): The response from the API call, which includes the status and details of each update.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "text/csv",
+            "Accept": "text/csv"
+        }
+        
+        with open(file_path, 'rb') as f:
+            response = requests.put(url, headers=headers, data=f).json()
+        
+        return response.json()
+
+
+    def replace_binder_template_nodes(self, template_name, input_data):
+        """
+        Replace all binder nodes in an existing binder template. This action removes all existing nodes and replaces them with those specified in the input.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#replace-binder-template-nodes
+        
+        Parameters:
+        template_name (str): The binder template name__v field value.
+        input_data (str or dict): The input data in JSON format or the path to the CSV file containing the nodes to be replaced.
+        
+        Returns:
+        response (json): The response from the API call, which indicates the success or failure of the operation.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}/bindernodes"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        if isinstance(input_data, dict):
+            response = requests.put(url, headers=headers, json=input_data).json()
+        else:
+            with open(input_data, 'rb') as f:
+                headers["Content-Type"] = "text/csv"
+                response = requests.put(url, headers=headers, data=f).json()
+        
+        return response.json()
+
+
+    def delete_binder_template(self, template_name):
+        """
+        Delete an existing binder template from your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-binder-template
+        
+        Parameters:
+        template_name (str): The binder template name__v field value.
+        
+        Returns:
+        response (json): The response from the API call, which indicates the success or failure of the operation.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/templates/{template_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.delete(url, headers=headers).json()
+        
+        return response.json()
+
+
+    #######################################################
+    # Binders
+    ## Binding Rules
+    #######################################################
+
+    def update_binding_rule(self, binder_id, binding_rule__v=None, binding_rule_override__v=None):
+        """
+        Update a binding rule in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-binding-rule
+
+        Parameters:
+        binder_id (str): The binder id field value.
+        binding_rule__v (str): Optional. Indicates which binding rule to apply. Options are: 'default', 'steady-state', or 'current'.
+        binding_rule_override__v (bool): Optional. Indicates if the specified binding rule should override documents or sections which already have binding rules set.
+
+        Returns:
+        response (json): The response from the API call, which indicates the success or failure of the operation.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/binding_rule"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        data = {
+            "binding_rule__v": binding_rule__v,
+            "binding_rule_override__v": binding_rule_override__v
+        }
+        
+        response = requests.put(url, headers=headers, data=data).json()
+        
+        return response.json()
+
+
+    def update_binder_section_binding_rule(self, binder_id, node_id, binding_rule__v=None, binding_rule_override__v=None):
+        """
+        Update a binding rule for a specific section in a binder in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-section-binding-rule
+
+        Parameters:
+        binder_id (str): The binder id field value.
+        node_id (str): The binder node id field value.
+        binding_rule__v (str): Optional. Indicates which binding rule to apply. Options are: 'default', 'steady-state', or 'current'.
+        binding_rule_override__v (bool): Optional. Indicates if the specified binding rule should override documents or sections which already have binding rules set.
+
+        Returns:
+        response (json): The response from the API call, which indicates the success or failure of the operation, along with the Node ID of the updated section.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/sections/{node_id}/binding_rule"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        data = {
+            "binding_rule__v": binding_rule__v,
+            "binding_rule_override__v": binding_rule_override__v
+        }
+        
+        response = requests.put(url, headers=headers, data=data).json()
+        
+        return response.json()
+
+
+    def update_binder_document_binding_rule(self, binder_id, node_id, binding_rule__v=None, major_version_number__v=None, minor_version_number__v=None):
+        """
+        Update the binding rule for a document node within a binder in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-binder-document-binding-rule
+
+        Parameters:
+        binder_id (str): The binder id field value.
+        node_id (str): The binder node id field value.
+        binding_rule__v (str): Optional. Indicates which binding rule to apply. Options are: 'default', 'steady-state', 'current', or 'specific'.
+        major_version_number__v (int): Optional. Required if binding_rule is 'specific'. Indicates the major version of the document to be linked.
+        minor_version_number__v (int): Optional. Required if binding_rule is 'specific'. Indicates the minor version of the document to be linked.
+
+        Returns:
+        response (json): The response from the API call, which indicates the success or failure of the operation, along with the Node ID of the updated document node within the binder.
+        """
+        
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/documents/{node_id}/binding_rule"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        data = {
+            "binding_rule__v": binding_rule__v,
+            "major_version_number__v": major_version_number__v,
+            "minor_version_number__v": minor_version_number__v
+        }
+        
+        response = requests.put(url, headers=headers, data=data).json()
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Vault Objects
+    #######################################################
+
+
+    def retrieve_object_metadata(self, object_name, loc=False):
+        """
+        Retrieve all metadata configured on a standard or custom Vault Object.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-metadata
+        
+        Parameters:
+        object_name (str): The object name__v field value. For example, product__v, country__v, custom_object__c.
+        loc (bool): Set to true to retrieve the localized_data array, which contains the localized (translated) strings 
+                    for the label and label_plural object fields. If omitted, defaults to false and localized Strings are not included.
+                    
+        Returns:
+        dict: Response data containing metadata information.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}"
+        headers = {
+            'Accept': 'application/json',
+            'Authorization': f"{self.sessionId}"
+        }
+        
+        params = {
+            'loc': loc
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+    def retrieve_object_field_metadata(self, object_name, object_field_name, loc=False):
+        """
+        Retrieves metadata for a specified field of a specified object in the vault. 
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-field-metadata
+        
+        Parameters:
+            object_name (str): The object name__v field value (e.g., product__v, country__v, custom_object__c).
+            object_field_name (str): The object field name value (e.g., id, name__v, external_id__v).
+            loc (bool): Set to true to retrieve the localized_data array. Defaults to false.
+            
+        Returns:
+            dict: A dictionary containing the metadata of the specified object field.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}/fields/{object_field_name}"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {
+            "loc": loc
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            response.raise_for_status()
+
+
+    def retrieve_object_collection(self, loc=False):
+        """
+        Retrieve all Vault objects in the authenticated Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-collection
+        
+        Parameters:
+            loc (bool): Set to true to retrieve localized (translated) strings for the label and label_plural object fields. Defaults to false.
+        
+        Returns:
+            dict: A dictionary containing a summary of key information for all standard and custom Vault Objects configured in your Vault.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects"
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {
+            "loc": loc
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        if response.status_code == 200:
+            return response.json()
+        else:
+            response.raise_for_status()
+
+
+    def retrieve_object_record_collection(self, object_name, fields=None, limit=None, offset=None, sort=None):
+        """
+        Retrieves all records for a specific Vault Object.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-collection
+        
+        Args:
+            object_name (str): The object name__v field value. For example, product__v, country__v, custom_object__c.
+            fields (str, optional): To specify fields to retrieve, include the parameter fields={FIELD_NAMES}. Defaults to None.
+            limit (int, optional): The number of records to return per page, maximum 200. Defaults to None.
+            offset (int, optional): The starting point for the return of the records. Defaults to None.
+            sort (str, optional): The sorting parameter in the format "field_name order". For example, "name__v desc". Defaults to None.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}"
+        
+        params = {}
+        if fields:
+            params['fields'] = fields
+        if limit:
+            params['limit'] = limit
+        if offset:
+            params['offset'] = offset
+        if sort:
+            params['sort'] = sort
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_object_record(self, object_name, object_record_id):
+        """
+        Retrieves metadata configured on a specific object record in your Vault.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record
+        
+        Args:
+            object_name (str): The object name__v field value (product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def create_object_records(self, object_name, data, content_type='text/csv', accept='text/csv', additional_headers=None):
+        """
+        Create Vault object records in bulk using the specified endpoint. For detailed documentation refer to:
+        https://developer.veevavault.com/api/23.2/#create-object-records
+        
+        Args:
+            object_name (str): The name of the object (e.g., product__v).
+            data (str): The data to be sent in the request body (file path or JSON).
+            content_type (str, optional): The content type of the request. Defaults to 'text/csv'.
+            accept (str, optional): The accept header specifying the response format. Defaults to 'text/csv'.
+            additional_headers (dict, optional): Additional headers to be included in the request. Defaults to None.
+        
+        Returns:
+            dict: The response data in dictionary format.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": content_type,
+            "Accept": accept,
+        }
+        
+        if additional_headers:
+            headers.update(additional_headers)
+        
+        with open(data, 'rb') as f:
+            response = requests.post(url, headers=headers, data=f)
+        
+        return response.json()
+
+
+    def update_object_records(self, object_name, data, id_param=None, migration_mode=None):
+        """
+        Updates object records in bulk. You can use this method to update user records (user__sys).
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-object-records
+
+        Args:
+            object_name (str): The name of the object, for example, product__v.
+            data (dict): The data to update in either JSON or CSV format.
+            id_param (str, optional): To identify objects in your input by a unique field, add idParam={field_name} to the request endpoint. Defaults to None.
+            migration_mode (bool, optional): If set to true, Vault bypasses entry criteria, entry actions, validation rules, and reference constraints when updating object records. Defaults to None.
+
+        Returns:
+            dict: The response from the API.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        if migration_mode is not None:
+            headers["X-VaultAPI-MigrationMode"] = str(migration_mode)
+        
+        response = requests.put(url, headers=headers, json=data)
+        if id_param:
+            url += f"?idParam={id_param}"
+            response = requests.put(url, headers=headers, json=data)
+        
+        return response.json()
+
+
+    def delete_object_records(self, object_name, data, id_param=None):
+        """
+        Deletes object records in bulk. This method cannot be used to delete user__sys records. 
+        Use the update_object_records method to set the status__v field to inactive for user__sys records.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-object-records
+
+        Args:
+            object_name (str): The name of the object, e.g., product__v.
+            data (dict): The data to delete in either JSON or CSV format, containing ids or external_ids.
+            id_param (str, optional): If you’re identifying objects in your input by a unique field, add this parameter. Defaults to None.
+
+        Returns:
+            dict: The response from the API.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        if id_param:
+            url += f"?idParam={id_param}"
+        
+        response = requests.delete(url, headers=headers, json=data)
+        
+        return response.json()
+
+    def cascade_delete_object_record(self, object_name, object_record_id):
+        """
+        This asynchronous method deletes a single parent object record and all related children and grandchildren.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#cascade-delete-object-record
+
+        Args:
+            object_name (str): The name of the object to delete.
+            object_record_id (str): The ID of the specific object record to delete.
+
+        Returns:
+            dict: The response from the API, including job ID and URL to track the status of the deletion.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions/cascadedelete"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_cascade_delete_results(self, object_name, job_status, job_id):
+        """
+        This method retrieves the results of a cascade delete job. Before submitting this request:
+        - You must have previously requested a cascade delete job (via the API) which is no longer active.
+        - You must have a valid job_id value, retrieved from the response of the cascade delete request.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-results-of-cascade-delete-job
+
+        Args:
+            object_name (str): The name of the object which was deleted.
+            job_status (str): Possible values are 'success' or 'failure'. It is used to determine the job status.
+            job_id (str): The ID of the job, retrieved from the response of the job request.
+
+        Returns:
+            Response: The response from the API with the details of the deleted records.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/cascadedelete/results/{object_name}/{job_status}/{job_id}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "text/csv"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.text
+
+
+
+    #######################################################
+    # Vault Objects
+    ## Object Types
+    #######################################################
+
+    def retrieve_details_from_all_object_types(self):
+        """
+        This method retrieves details from all object types. It lists all object types and all fields configured on each object type.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-details-from-all-object-types
+
+        Returns:
+            Response: The response from the API with the details of all object types and fields configured on each type.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/Objecttype"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_details_from_specific_object(self, object_name_and_object_type):
+        """
+        This method retrieves details from a specific object. It lists all object types and all fields configured on each object type for the specified object.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-details-from-a-specific-object
+
+        Args:
+            object_name_and_object_type (str): The object name followed by the object type in the format Objecttype.{object_name}.{object_type}. 
+
+        Returns:
+            Response: The response from the API listing all object types and fields configured on the specific object.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/{object_name_and_object_type}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+    def change_object_type(self, object_name, payload):
+        """
+        This method is used to change the object types assigned to object records. Field values which exist on both the original and new object type will carry over to the new type. All other field values will be removed as only fields on the new type are valid. You can set field values on the new object type in the payload input.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#change-object-type
+
+        Args:
+            object_name (str): The name of the object.
+            payload (dict): A dictionary containing at least the "id" and "object_type__v" keys. The "id" key should map to the ID of the object record and the "object_type__v" key should map to the ID of the new object type.
+
+        Returns:
+            Response: The response from the API after attempting to change the object type.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/actions/changetype"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers, json=payload)
+        
+        return response.json()
+
+
+
+
+
+    #######################################################
+    # Vault Objects
+    ## Object Roles
+    #######################################################
+
+
+
+
+    def retrieve_object_record_roles(self, object_name, record_id, role_name=None):
+        """
+        This method is used to retrieve manually assigned roles on an object record along with the users and groups assigned to those roles.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-roles
+
+        Args:
+            object_name (str): The name of the object.
+            record_id (str): The ID of the document, binder, or object record.
+            role_name (str, optional): Role name to filter for a specific role, e.g., owner__v. Defaults to None.
+
+        Returns:
+            Response: The response from the API containing the roles and their details.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        role_name_path = f"/{role_name}" if role_name else ""
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{record_id}/roles{role_name_path}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def assign_users_groups_to_roles_on_object_records(self, object_name, request_body):
+        """
+        This method allows to assign users and groups to roles on an object record in bulk.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#assign-users-amp-groups-to-roles-on-object-records
+
+        Args:
+            object_name (str): The name of the object where you want to update records.
+            request_body (str or dict): JSON or CSV input file as string or dictionary. User and group assignments are 
+                                        ignored if they are invalid, inactive, or already exist.
+        
+        Returns:
+            Response: The response from the API, which includes the object record ID on success.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/roles"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers, data=json.dumps(request_body))
+        
+        return response.json()
+
+
+    def remove_users_groups_from_roles_on_object_records(self, object_name, request_body):
+        """
+        This method allows to remove users and groups from roles on an object record in bulk.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#remove-users-amp-groups-from-roles-on-object-records
+
+        Args:
+            object_name (str): The name of the object where you want to remove roles.
+            request_body (str or dict): JSON or CSV input file as string or dictionary. Users and groups are ignored if they are 
+                                        invalid or inactive.
+        
+        Returns:
+            Response: The response from the API, which includes the object record ID on success.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/roles"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        response = requests.delete(url, headers=headers, data=json.dumps(request_body))
+        
+        return response.json()
+
+
+
+
+
+    #######################################################
+    # Vault Objects
+    ## Object Record Attachments
+    #######################################################
+
+    def determine_if_attachments_are_enabled_on_an_object(self, object_name):
+        """
+        This method helps to determine if attachments are enabled on a specific object.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#determine-if-attachments-are-enabled-on-an-object
+
+        Args:
+            object_name (str): The value of object name__v field (like product__v, country__v, custom_object__c, etc.).
+        
+        Returns:
+            Response: API response which includes details such as if "allow_attachments" is set to true and other object metadata.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_object_record_attachments(self, object_name, object_record_id):
+        """
+        Retrieve a list of all attachments on a specific object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-attachments
+
+        Args:
+            object_name (str): The value of object name__v field (like product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+
+        Returns:
+            Response: API response which includes details such as a list of attachments along with their respective details and versions.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_object_record_attachment_metadata(self, object_name, object_record_id, attachment_id):
+        """
+        Retrieve the metadata of a specific attachment on a specific object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-attachment-metadata
+
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+
+        Returns:
+            Response: API response which includes metadata details of the specified attachment.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_object_record_attachment_versions(self, object_name, object_record_id, attachment_id):
+        """
+        Retrieve all versions of a specific attachment on a specific object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-attachment-versions
+
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+
+        Returns:
+            Response: API response which includes version details of the specified attachment.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_object_record_attachment_version_metadata(self, object_name, object_record_id, attachment_id, attachment_version):
+        """
+        Retrieve the metadata of a specific version of an attachment on a specific object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-attachment-version-metadata
+
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+            attachment_version (str): The attachment version__v field value.
+
+        Returns:
+            Response: API response which includes metadata of the specified attachment version.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+    def download_object_record_attachment_file(self, object_name, object_record_id, attachment_id):
+        """
+        Download the file of a specific attachment on a specific object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#download-object-record-attachment-file
+
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+
+        Returns:
+            Response: The API response containing the attachment file.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/file"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers, stream=True)
+        
+        with open('downloaded_attachment_file', 'wb') as file:
+            for chunk in response.iter_content(chunk_size=8192):
+                file.write(chunk)
+        
+        return "File downloaded successfully"
+
+
+    def download_object_record_attachment_version_file(self, object_name, object_record_id, attachment_id, attachment_version):
+        """
+        Downloads a specific version of an attachment file from a specific object record.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#download-object-record-attachment-version-file
+        
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+            attachment_version (str): The attachment version__v field value.
+
+        Returns:
+            str: Message indicating the success of the file download.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}/file"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers, stream=True)
+        
+        with open('downloaded_attachment_version_file', 'wb') as file:
+            for chunk in response.iter_content(chunk_size=8192):
+                file.write(chunk)
+        
+        return "File downloaded successfully"
+
+
+    def download_all_object_record_attachment_files(self, object_name, object_record_id):
+        """
+        Downloads the latest version of all attachment files from a specific object record, packaged in a ZIP file.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#download-all-object-record-attachment-files
+        
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+
+        Returns:
+            str: Message indicating the success of the file download.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/file"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers, stream=True)
+        
+        with open('downloaded_all_attachment_files.zip', 'wb') as file:
+            for chunk in response.iter_content(chunk_size=8192):
+                file.write(chunk)
+        
+        return "File downloaded successfully"
+
+
+    def create_object_record_attachment(self, object_name, object_record_id, file_path):
+        """
+        Creates a single object record attachment. If the attachment already exists, Vault uploads the attachment 
+        as a new version of the existing attachment. The maximum allowed file size is 4GB.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-object-record-attachment
+        
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+            file_path (str): The path to the file to be uploaded.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        files = {'file': open(file_path, 'rb')}
+        
+        response = requests.post(url, headers=headers, files=files)
+        
+        return response.json()
+
+
+
+    def create_multiple_object_record_attachments(self, object_name, input_file_path, content_type='text/csv', accept='application/json'):
+        """
+        Creates multiple object record attachments in bulk using a JSON or CSV input file. The attachments are first 
+        loaded to the file staging server. The maximum input file size is 1GB, and the maximum batch size is 500.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-multiple-object-record-attachments
+
+        Args:
+            object_name (str): The value of the object name__v field (like veterinary_patient__c, product__v, etc.).
+            input_file_path (str): The path to the input file (CSV or JSON) containing details of attachments to be created.
+            content_type (str): The content type of the input file, either 'application/json' or 'text/csv'. Defaults to 'text/csv'.
+            accept (str): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/attachments/batch"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": content_type,
+            "Accept": accept
+        }
+        
+        with open(input_file_path, 'rb') as input_file:
+            data = input_file.read()
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+    def restore_object_record_attachment_version(self, object_name, object_record_id, attachment_id, attachment_version):
+        """
+        Restores a specific version of an attachment on an object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#restore-object-record-attachment-version
+
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+            attachment_version (str): The attachment version__v field value.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}?restore=true"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers)
+        
+        return response.json()
+
+    def update_object_record_attachment_description(self, object_name, object_record_id, attachment_id, description):
+        """
+        Updates the description of a specific attachment on an object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-object-record-attachment-description
+
+        Args:
+            object_name (str): The value of the object name__v field (like product__v, country__v, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+            description (str): The new description for the attachment. The maximum length is 1000 characters.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        data = {
+            "description__v": description
+        }
+        
+        response = requests.put(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+
+    def update_multiple_object_record_attachment_descriptions(self, object_name, input_file_path, content_type='text/csv', accept='application/json'):
+        """
+        Update multiple object record attachment descriptions in bulk using a JSON or CSV input file.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-multiple-object-record-attachment-descriptions
+
+        Args:
+            object_name (str): The object name__v field value (e.g., veterinary_patient__c).
+            input_file_path (str): The path to the input CSV or JSON file.
+            content_type (str, optional): The content type of the input file, either 'application/json' or 'text/csv'. Defaults to 'text/csv'.
+            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/attachments/batch"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": content_type,
+            "Accept": accept
+        }
+
+        with open(input_file_path, 'rb') as f:
+            response = requests.put(url, headers=headers, data=f)
+
+        return response.json()
+
+
+    def delete_object_record_attachment(self, object_name, object_record_id, attachment_id, accept='application/json'):
+        """
+        Deletes a single object record attachment.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-object-record-attachment
+
+        Args:
+            object_name (str): The object name__v field value (e.g., product__v, country__v, custom_object__c, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": accept
+        }
+
+        response = requests.delete(url, headers=headers)
+        
+        return response.json()
+
+
+    def delete_multiple_object_record_attachments(self, object_name, attachments_data, content_type='application/json', accept='application/json', id_param=None):
+        """
+        Deletes multiple object record attachments in bulk with a JSON or CSV input file. 
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-multiple-object-record-attachments
+
+        Args:
+            object_name (str): The object name__v field value (e.g., veterinary_patient__c, product__v, etc.).
+            attachments_data (str): JSON or CSV formatted string containing details of the attachments to be deleted.
+            content_type (str, optional): The format of the input data, either 'application/json' or 'text/csv'. Defaults to 'application/json'.
+            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
+            id_param (str, optional): If identifying attachments by external id, add idParam=external_id__v to the request endpoint. Defaults to None.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/attachments/batch"
+        if id_param:
+            url += f"?idParam={id_param}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": accept,
+            "Content-Type": content_type
+        }
+
+        response = requests.delete(url, headers=headers, data=attachments_data)
+        
+        return response.json()
+
+
+    def delete_object_record_attachment_version(self, object_name, object_record_id, attachment_id, attachment_version, accept='application/json'):
+        """
+        Deletes a specific version of an object record attachment.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-object-record-attachment-version
+
+        Args:
+            object_name (str): The object name__v field value (e.g., product__v, country__v, etc.).
+            object_record_id (str): The object record id field value.
+            attachment_id (str): The attachment id field value.
+            attachment_version (str): The attachment version__v field value.
+            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": accept
+        }
+
+        response = requests.delete(url, headers=headers)
+        
+        return response.json()
+
+
+
+
+
+
+    #######################################################
+    # Vault Objects
+    ## Object Page Layouts
+    #######################################################
+
+    def retrieve_page_layouts(self, object_name, accept='application/json'):
+        """
+        Retrieves all page layouts associated with the specified object.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-page-layouts
+
+        Args:
+            object_name (str): The name of the object from which to retrieve page layouts.
+            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}/page_layouts"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": accept
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_page_layout_metadata(self, object_name, layout_name, accept='application/json'):
+        """
+        Retrieves the metadata for the specified page layout.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-page-layout-metadata
+
+        Args:
+            object_name (str): The name of the object from which to retrieve page layout metadata.
+            layout_name (str): The name of the page layout from which to retrieve metadata.
+            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/vobjects/{object_name}/page_layouts/{layout_name}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": accept
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+    async def retrieve_all_page_layout_metadata_for_object(self, object_name):
+        """
+        Asynchronously retrieves all page layout metadata for a specified object.
+
+        This function performs the following steps:
+        1. Retrieves all page layouts for the specified object.
+        2. Converts the retrieved page layouts data to a pandas DataFrame.
+        3. Retrieves the metadata for each page layout asynchronously.
+        4. Converts the retrieved page layout metadata to a pandas DataFrame.
+        
+        Args:
+            object_name (str): The name of the object for which to retrieve the page layout metadata.
+
+        Returns:
+            pd.DataFrame: A DataFrame containing the page layout metadata for the specified object.
+
+        Usage:
+            >>> page_layouts_df = asyncio.run(retrieve_all_page_layout_metadata_for_object('my_object_name'))
+        """
+        page_layouts = self.retrieve_page_layouts(object_name)['data']
+        page_layouts_df = pd.DataFrame(page_layouts)
+        
+        async_retrieve_page_layout_metadata = async_wrap(self.retrieve_page_layout_metadata)
+        
+        page_layout_names = page_layouts_df['name'].tolist()
+        
+        page_layout_metadata = await asyncio.gather(*[async_retrieve_page_layout_metadata(object_name, page_layout_name) for page_layout_name in page_layout_names])
+        page_layout_metadata = [x['data'] for x in page_layout_metadata]
+        
+        page_layouts_df = pd.DataFrame(page_layout_metadata)
+        
+        return page_layouts_df
+
+
+
+    #######################################################
+    # Vault Objects
+    ## Deep Copy Object Record
+    #######################################################
+
+    def deep_copy_object_record(self, object_name, object_record_ID, override_fields=None, content_type='application/json', accept='application/json'):
+        """
+        Performs a deep copy of an object record, including all of its related child and grandchild records.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#deep-copy-object-record
+
+        Args:
+            object_name (str): The name of the parent object to copy (e.g., product__v).
+            object_record_ID (str): The ID of the specific object record to copy.
+            override_fields (dict, optional): A dictionary with field names to override field values in the source record. Defaults to None.
+            content_type (str, optional): The content type of the request, either 'application/json' or 'text/csv'. Defaults to 'application/json'.
+            accept (str, optional): The response format, either 'application/json' or 'application/xml'. Defaults to 'application/json'.
+
+        Returns:
+            dict: The API response as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_ID}/actions/deepcopy"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": content_type,
+            "Accept": accept
+        }
+
+        response = requests.post(url, headers=headers, json=override_fields)
+        
+        return response.json()
+
+    def retrieve_deep_copy_job_results(self, object_name, job_id, job_status, accept='text/csv'):
+        """
+        Retrieves the results of a deep copy job request. The function can query Vault to determine 
+        the results of a deep copy request.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-results-of-deep-copy-job
+
+        Args:
+            object_name (str): The name of the deep copied object.
+            job_id (str): The ID of the job, retrieved from the response of the job request.
+            job_status (str): The status of the job, possible values are 'success' or 'failure'.
+            accept (str, optional): The response format, defaults to 'text/csv'.
+
+        Returns:
+            Response: The API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/deepcopy/results/{object_name}/{job_status}/{job_id}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": accept
+        }
+
+        response = requests.post(url, headers=headers)
+        
+        return response.json()
+
+
+
+
+
+    #######################################################
+    # Vault Objects
+    ## Retrieve
+    #######################################################
+
+    def retrieve_deleted_object_record_id(self, object_name, start_date=None, end_date=None, limit=1000, offset=0):
+        """
+        Retrieves the IDs of object records that have been deleted from the Vault within the past 30 days. The IDs remain 
+        retrievable for 30 days post-deletion. The results can be narrowed down to a specific date and time range 
+        within the past 30 days using optional parameters.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-deleted-object-record-id
+
+        Args:
+            object_name (str): The object name__v field value (e.g., product__v, country__v, custom_object__c, etc.).
+            start_date (str, optional): A date (within the past 30 days) post which the API looks for deleted records. 
+                Dates must be formatted as YYYY-MM-DDTHH:MM:SSZ. Defaults to None.
+            end_date (str, optional): A date (within the past 30 days) before which the API looks for deleted records. 
+                Dates must be formatted as YYYY-MM-DDTHH:MM:SSZ. Defaults to None.
+            limit (int, optional): The maximum number of records per page in the response (between 1 and 1000). 
+                Defaults to 1000.
+            offset (int, optional): The offset for pagination, determining the starting point of the records 
+                in the response. Defaults to 0.
+
+        Returns:
+            Response: The API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/deletions/vobjects/{object_name}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        params = {
+            "start_date": start_date,
+            "end_date": end_date,
+            "limit": limit,
+            "offset": offset
+        }
+
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_limits_on_objects(self):
+        """
+        Retrieves the limitations imposed on the number of object records that can be created for each object 
+        (product__v, study__v, custom_object__c, etc.) in the Vault. Additionally, it retrieves the limit on the 
+        number of custom objects that can be created in the Vault and the remaining number available for creation.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-limits-on-objects
+
+        Returns:
+            Response: The API response containing details about the limits on objects.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/limits"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # Vault Objects
+    ## Update Corporate Currency Fields
+    #######################################################
+
+
+    def update_corporate_currency_fields(self, object_name, record_id=None):
+        """
+        Updates the corporate currency fields of an object record based on the rate of the currency denoted by
+        the local_currency__sys field of the specified record. It handles scenarios like when admins change 
+        the Corporate Currency setting for the vault or update the Rate setting for the local currency used by a record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-corporate-currency-fields
+
+        Args:
+            object_name (str): The object name__v field value (for example, product__v).
+            record_id (str, optional): The object record id field value. If not provided, Vault updates corporate fields of 
+                                    all records for the object.
+
+        Returns:
+            Response: The API response containing details about the job initiated for updating the corporate currency fields.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/actions/updatecorporatecurrency"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        payload = {}
+        if record_id:
+            payload['id'] = record_id
+
+        response = requests.put(url, headers=headers, json=payload)
+        
+        return response.json()
+
+
+    #######################################################
+    # Document Roles
+    #######################################################
+
+
+    def retrieve_roles(self, doc_or_binder, id, role_name=None):
+        """
+        Retrieve all available roles on a document or binder along with the users and groups assigned to them.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-roles
+
+        Args:
+            doc_or_binder (str): Specify whether to retrieve values for "documents" or "binders".
+            id (int): The id of the document, binder, or object record.
+            role_name (str, optional): Include a role name to filter for a specific role, e.g., "owner__v".
+
+        Returns:
+            Response: The API response containing the details of the roles assigned to the specified document or binder.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        role_name_endpoint = f"/{role_name}" if role_name else ""
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{doc_or_binder}/{id}/roles{role_name_endpoint}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def assign_users_and_groups_to_roles(self, document_id, roles_data):
+        """
+        Assign users and groups to roles on a single document or binder.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#assign-users-amp-groups-to-roles-on-a-single-document
+
+        Args:
+            document_id (int): The document or binder id field value.
+            roles_data (dict): A dictionary with name-value pairs of all users or groups with their corresponding roles 
+                            in the form {Role_name}.{USERS or GROUPS}: "ID1,ID2,ID3". 
+                            For example, {'reviewer__v.users': "3003,4005"}.
+
+        Returns:
+            Response: The API response containing details of users and groups successfully assigned to roles on the document or binder.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{document_id}/roles"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers, data=roles_data)
+        
+        return response.json()
+
+
+    def assign_users_and_groups_to_roles_bulk(self, csv_file_path):
+        """
+        Assign users and groups to roles on multiple documents or binders in bulk.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#assign-users-amp-groups-to-roles-on-multiple-documents
+
+        Args:
+            csv_file_path (str): The path to the CSV file containing the assignment data.
+
+        Returns:
+            Response: The API response containing details of users and groups successfully assigned to roles on multiple documents or binders.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/roles/batch"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "text/csv",
+            "Accept": "text/csv"
+        }
+
+        with open(csv_file_path, 'rb') as f:
+            response = requests.post(url, headers=headers, data=f)
+
+        return response.json()
+
+
+    def remove_users_and_groups_from_role(self, doc_id, role_name_and_user_or_group, user_or_group_id):
+        """
+        Remove users and groups from roles on a single document or binder.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#remove-users-amp-groups-from-roles-on-a-single-document
+
+        Args:
+            doc_id (str): The ID value of the document or binder from which to remove roles.
+            role_name_and_user_or_group (str): The name of the role and user or group from which to remove. The format is {role_name}.{user_or_group}.
+            user_or_group_id (str): The ID value of the user or group to remove from the role.
+
+        Returns:
+            Response: The API response containing the status and details of the removal process.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/roles/{role_name_and_user_or_group}/{user_or_group_id}"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+        
+        return response.json()
+
+
+    def remove_users_and_groups_from_roles_on_multiple_documents(self, csv_file_path):
+        """
+        Remove users and groups from roles on a document or binder in bulk.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#remove-users-and-groups-from-roles-on-multiple-documents
+
+        Args:
+            csv_file_path (str): The path to the CSV file containing the details of the users and groups to be removed.
+
+        Returns:
+            Response: The API response containing the status and details of the removal process.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/roles/batch"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "text/csv",
+            "Accept": "text/csv"
+        }
+
+        with open(csv_file_path, 'rb') as f:
+            response = requests.delete(url, headers=headers, data=f)
+        
+        return response.json()
+
+
+
+
+
+
+    #######################################################
+    # Workflows
+    #######################################################
+
+
+    def retrieve_workflows(self, object_v=None, record_id_v=None, participant=None, status_v=None, offset=None, page_size=None, loc=None):
+        """
+        Retrieve all workflow instances for a specific object and object record or from a specific workflow participant.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflows
+
+        Args:
+            object_v (str, optional): To retrieve all workflows configured on an object, include the Vault object name__v. Required when the participant parameter is not used.
+            record_id_v (str, optional): To retrieve all workflows configured on an object, include the object record id field value. Required when the participant parameter is not used.
+            participant (str, optional): To retrieve all workflows available to a particular user, include the user id field value. Required when the object__v and record_id__v parameters are not used.
+            status_v (str, optional): To retrieve all workflows with specific statuses, include one or more status name__v field values.
+            offset (int, optional): Used to paginate the results, specifying the amount of offset from the first record returned.
+            page_size (int, optional): Used to paginate the results, specifying the number of records to display per page.
+            loc (bool, optional): When localized strings are available, set to true to retrieve them.
+
+        Returns:
+            Response: The API response containing details of the workflows matching the query parameters.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        params = {
+            "object__v": object_v,
+            "record_id__v": record_id_v,
+            "participant": participant,
+            "status__v": status_v,
+            "offset": offset,
+            "page_size": page_size,
+            "loc": loc
+        }
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+
+    def retrieve_workflow_details(self, workflow_id, loc=None):
+        """
+        Retrieve the details for a specific workflow.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-details
+
+        Args:
+            workflow_id (int): The ID of the workflow to retrieve details for.
+            loc (bool, optional): When localized (translated) strings are available, set to true to retrieve them.
+
+        Returns:
+            Response: The API response containing details of the specified workflow.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/{workflow_id}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        params = {
+            "loc": loc
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_workflow_actions(self, workflow_id, loc=None):
+        """
+        Retrieve all available workflow actions that can be initiated on a specific workflow.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-actions
+
+        Args:
+            workflow_id (int): The ID of the workflow to retrieve actions for.
+            loc (bool, optional): When localized (translated) strings are available, set to true to retrieve them.
+
+        Returns:
+            Response: The API response containing a list of available actions for the specified workflow.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/{workflow_id}/actions"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        params = {
+            "loc": loc
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_workflow_action_details(self, workflow_id, workflow_action):
+        """
+        Retrieve details about a specific workflow action, including any prompts necessary to complete the action.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-action-details
+
+        Args:
+            workflow_id (int): The ID of the workflow.
+            workflow_action (str): The name of the workflow action.
+
+        Returns:
+            Response: The API response containing details about the specified workflow action.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/{workflow_id}/actions/{workflow_action}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def initiate_workflow_action(self, workflow_id, workflow_action, body_parameters):
+        """
+        Initiate a specific action on a particular workflow. The necessary parameters should be specified in the body_parameters dictionary.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-workflow-action
+
+        Args:
+            workflow_id (int): The ID of the workflow.
+            workflow_action (str): The name of the workflow action.
+            body_parameters (dict): A dictionary containing the necessary parameters to initiate the workflow action.
+
+        Returns:
+            Response: The API response indicating the status of the action initiation.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/{workflow_id}/actions/{workflow_action}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers, json=body_parameters)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # Workflows
+    ## Workflow Tasks
+    #######################################################
+
+
+    def retrieve_workflow_tasks(self, query_parameters):
+        """
+        Retrieve all available workflow tasks based on the specified query parameters.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-tasks
+
+        Args:
+            query_parameters (dict): A dictionary containing the query parameters to filter the tasks.
+
+        Returns:
+            Response: The API response containing the list of available workflow tasks.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers, params=query_parameters)
+        
+        return response.json()
+
+
+    def retrieve_workflow_task_details(self, task_id, loc=None):
+        """
+        Retrieve the details of a specific workflow task.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-task-details
+
+        Args:
+            task_id (int): The ID of the workflow task to retrieve details for.
+            loc (bool, optional): Set to true to retrieve localized strings if available. Defaults to None.
+
+        Returns:
+            Response: The API response containing the details of the specified workflow task.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks/{task_id}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        params = {}
+        if loc is not None:
+            params['loc'] = loc
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_workflow_task_actions(self, task_id):
+        """
+        Retrieve all available actions that can be initiated on a given workflow task.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-task-actions
+
+        Args:
+            task_id (int): The ID of the workflow task to retrieve actions for.
+
+        Returns:
+            Response: The API response containing the available actions for the specified workflow task.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks/{task_id}/actions"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_workflow_task_action_details(self, task_id, task_action):
+        """
+        Retrieve the details of a specific workflow task action. The response lists the details of the task action, including all fields required to initiate the action.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-workflow-task-action-details
+
+        Args:
+            task_id (int): The task ID field value.
+            task_action (str): The name of the task action retrieved from Retrieve Workflow Task Actions.
+
+        Returns:
+            Response: The API response containing the details of the specified workflow task action.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks/{task_id}/actions/{task_action}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def initiate_workflow_task_action(self, task_id, task_action, data):
+        """
+        Initiate a workflow task action. Note that the API does not support initiating task actions requiring eSignatures.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-workflow-task-action
+
+        Args:
+            task_id (int): The task ID field value.
+            task_action (str): The name of the task action retrieved from Retrieve Workflow Task Actions.
+            data (dict): A dictionary containing the required parameters depending on the action being initiated.
+                        The keys should represent parameter names such as "verdict", "reason", "capacity", etc., 
+                        and the values should be the respective values for those parameters.
+
+        Returns:
+            Response: The API response indicating the status of the initiated action.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/tasks/{task_id}/actions/{task_action}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # Workflows
+    ## Bulk Active Workflow Actions
+    #######################################################
+
+    def retrieve_bulk_workflow_actions(self):
+        """
+        Retrieve all available workflow actions that can be initiated on a workflow which the authenticated user has permissions to view or initiate and can be initiated through the API.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-bulk-workflow-actions
+
+        Returns:
+            Response: The API response containing a list of available workflow actions for a Vault.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/object/workflow/actions"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_bulk_workflow_action_details(self, action_name):
+        """
+        Once you’ve retrieved the available workflow actions, use this method to retrieve the details for a specific workflow action.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-bulk-workflow-action-details
+
+        Args:
+            action_name (str): The name of the workflow action retrieved from Retrieve Bulk Workflow Actions.
+
+        Returns:
+            Response: The API response containing the details for the specified workflow action.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/object/workflow/actions/{action_name}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def initiate_workflow_actions_on_multiple_workflows(self, action, workflow_ids, cancellation_comment=None, current_task_assignee=None, new_task_assignee=None, user_ids=None, task_ids=None, new_workflow_owner=None, current_workflow_owner=None):
+        """
+        Use this method to initiate a workflow action on multiple workflows. This starts an asynchronous job whose status you can check with the Retrieve Job Status endpoint.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-workflow-actions-on-multiple-workflows
+
+        Args:
+            action (str): The name of the workflow action. Retrieved from Retrieve Bulk Workflow Actions.
+            workflow_ids (str): A comma-separated list of workflow_id__v field values (Maximum 500 workflows). Required for cancelworkflows action.
+            cancellation_comment (str, optional): Comment for cancellation. Only applicable for cancelworkflows action.
+            current_task_assignee (str, optional): The user ID of the user whose tasks you wish to reassign. Required for reassigntasks action.
+            new_task_assignee (str, optional): The user ID of the user who will receive the newly assigned tasks. Required for reassigntasks action.
+            user_ids (str, optional): A comma-separated list of user IDs to cancel tasks by user ID. Applicable for canceltasks action.
+            task_ids (str, optional): A comma-separated list of task IDs to cancel tasks by task ID. Applicable for canceltasks action.
+            new_workflow_owner (str, optional): The ID of the user who will become the new workflow owner. Required for replaceworkflowowner action.
+            current_workflow_owner (str, optional): The ID of the current workflow owner. Required for replaceworkflowowner action.
+
+        Returns:
+            Response: The API response containing the job_id for the initiated action.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/object/workflow/actions/{action}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        data = {
+            "workflow_ids": workflow_ids,
+            "cancellation_comment": cancellation_comment,
+            "current_task_assignee": current_task_assignee,
+            "new_task_assignee": new_task_assignee,
+            "user_ids": user_ids,
+            "task_ids": task_ids,
+            "new_workflow_owner": new_workflow_owner,
+            "current_workflow_owner": current_workflow_owner
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Document Lifecycle & Workflows
+    #######################################################
+
+    #######################################################
+    # Document Lifecycle & Workflows
+    ## Document & Binder User Actions
+    #######################################################
+
+    def retrieve_user_actions(self, documents_or_binders, id, major_version, minor_version):
+        """
+        Retrieve all available user actions on a specific version of a document or binder based on the conditions mentioned in the API documentation. The method returns the available user actions that the authenticated user has permissions to view or initiate, can be initiated through the API, and are not currently in an active workflow.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-user-actions
+
+        Args:
+            documents_or_binders (str): Specify whether to retrieve values for "documents" or "binders".
+            id (int): The ID of the document or binder.
+            major_version (int): The major version number of the document or binder.
+            minor_version (int): The minor version number of the document or binder.
+
+        Returns:
+            Response: The API response containing the list of available user actions (lifecycle_actions__v) that can be initiated on the specified version of the document or binder.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{documents_or_binders}/{id}/versions/{major_version}/{minor_version}/lifecycle_actions"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_user_actions_multiple_documents_or_binders(self, documents_or_binders, doc_ids):
+        """
+        Retrieve all available user actions on specific versions of multiple documents or binders based on the criteria mentioned in the API documentation. The method returns the list of available lifecycle actions that can be initiated on the specified versions of multiple documents or binders, except those that are currently in an active workflow.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-user-actions-on-multiple-documents-or-binders
+
+        Args:
+            documents_or_binders (str): Specify whether to retrieve values for "documents" or "binders".
+            doc_ids (str): A comma-separated list of document or binder IDs and their major and minor version numbers in the format {doc_id:major_version:minor_version}. For example, "22:0:1,21:1:0,20:1:0".
+
+        Returns:
+            Response: The API response containing the list of available lifecycle actions (lifecycle_actions__v) that can be initiated on the specified versions of multiple documents or binders.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{documents_or_binders}/lifecycle_actions"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+
+        data = {
+            "docIds": doc_ids
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+
+        return response.json()
+
+
+    def retrieve_entry_criteria(self, documents_or_binders, id, major_version, minor_version, name_v):
+        """
+        Retrieves the entry criteria for a specific user action on documents or binders. 
+        Entry criteria are the conditions that must be met before initiating a certain action.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-entry-criteria
+
+        Parameters:
+        documents_or_binders (str): Choose to retrieve values for documents or binders.
+        id (int): The ID of the document or binder to retrieve user actions from.
+        major_version (int): The major version number of the document or binder.
+        minor_version (int): The minor version number of the document or binder.
+        name_v (str): The lifecycle name__v field value to retrieve entry criteria from.
+
+        Returns:
+        dict: A dictionary containing the response details of the API call.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{documents_or_binders}/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name_v}/entry_requirements"
+        headers = {"Authorization": f"{self.sessionId}", "Accept": "application/json"}
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+
+    def initiate_user_action(self, documents_or_binders, id, major_version, minor_version, name_v, data=None):
+        """
+        Initiates a user action on documents or binders in the vault. Before initiating, 
+        the applicable entry criteria for the action should be retrieved.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-user-action
+
+        Parameters:
+        documents_or_binders (str): Choose to initiate an action on documents or binders.
+        id (int): The ID of the document or binder to initiate the user action on.
+        major_version (int): The major version number of the document or binder.
+        minor_version (int): The minor version number of the document or binder.
+        name_v (str): The name__v field value representing the action to initiate.
+        data (dict, optional): Additional parameters to add to the request as name-value pairs, default is None.
+
+        Returns:
+        dict: A dictionary containing the response details of the API call.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/{documents_or_binders}/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name_v}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        response = requests.put(url, headers=headers, data=data)
+        return response.json()
+
+
+    def download_controlled_copy_job_results(self, lifecycle_and_state_and_action, job_id):
+        """
+        Downloads the results of a controlled copy job as a file stream. This endpoint is intended 
+        for use by integrations requesting and routing controlled copies of content as a system 
+        integrations account on behalf of users.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#download-controlled-copy-job-results
+        
+        Parameters:
+        lifecycle_and_state_and_action (str): The name__v values for the lifecycle, state, 
+        and action in the format {lifecycle_name}.{state_name}.{action_name}. Retrieve this value 
+        from the job status using the href under "rel": "artifacts".
+        
+        job_id (str): The ID of the job, returned from the original job request. Find this ID in 
+        the Initiate User Action response.
+        
+        Returns:
+        file: A file stream of the controlled copy job results.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/actions/{lifecycle_and_state_and_action}/{job_id}/results"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.get(url, headers=headers, stream=True)
+        with open(f"Download Issued Batch Record - {datetime.utcnow().strftime('%Y-%m-%dT%H-%M-%S.%fZ')}.zip", "wb") as file:
+            for chunk in response.iter_content(chunk_size=8192):
+                file.write(chunk)
+        return "File downloaded successfully"
+
+
+    def initiate_bulk_user_actions(self, docIds, lifecycle, state, user_action_name):
+        """
+        Initiates bulk user actions on multiple documents or binders. Only a single workflow will start 
+        for all selected and valid documents.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-bulk-user-actions
+        
+        Parameters:
+        docIds (str): A comma-separated list of document or binder IDs along with major and minor version 
+                    numbers (e.g., "222:0:1,223:0:1,224:0:1").
+        lifecycle (str): The name of the document or binder lifecycle.
+        state (str): The current state of the documents or binders.
+        user_action_name (str): The name__v field value of the user action. This can be found using the 
+                            Retrieve User Actions on Multiple Documents or Binders endpoint.
+        
+        Returns:
+        json: The response from the API in JSON format.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/lifecycle_actions/{user_action_name}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        data = {
+            "docIds": docIds,
+            "lifecycle": lifecycle,
+            "state": state
+        }
+        response = requests.put(url, headers=headers, data=data)
+        return response.json()
+
+
+
+
+
+
+    #######################################################
+    # Document Lifecycle & Workflows
+    ## Lifecycle Role Assignment Rules
+    #######################################################
+
+
+    def retrieve_lifecycle_role_assignment_rules(self, lifecycle_v=None, role_v=None, product_v=None, country_v=None, study_v=None, study_country_v=None):
+        """
+        Retrieve lifecycle role assignment rules (default and override) from the specified parameters. If no parameters are
+        specified, it retrieves a list of all lifecycle role assignment rules from all roles in all lifecycles in your Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-lifecycle-role-assignment-rules-default-amp-override
+
+        Parameters:
+        lifecycle_v (str, optional): Name of the lifecycle to retrieve information from. Example: "general_lifecycle__c".
+        role_v (str, optional): Name of the role to retrieve information from. Example: "editor__c".
+        product_v (str, optional): ID/name of a specific product to see product-based override rules. Example: "0PR0011001" or "CholeCap".
+        country_v (str, optional): ID/name of a specific country to see country-based override rules. Example: "0CR0022002" or "United States".
+        study_v (str, optional): ID/name of a specific study to see study-based override rules (eTMF Vaults only). Example: "0ST0021J01" or "CholeCap Study".
+        study_country_v (str, optional): ID/name of a specific study country to see study country-based override rules (eTMF Vaults only). Example: "0SC0001001" or "Germany".
+
+        Returns:
+        json: The response from the API in JSON format.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/role_assignment_rule"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        params = {
+            "lifecycle__v": lifecycle_v,
+            "role__v": role_v,
+            "product__v": product_v,
+            "country__v": country_v,
+            "study__v": study_v,
+            "study_country__v": study_country_v
+        }
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+    def create_lifecycle_role_assignment_override_rules(self, input_file_path):
+        """
+        Creates lifecycle role assignment override rules in the Vault.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-lifecycle-role-assignment-override-rules
+        
+        :param input_file_path: The path to the JSON or CSV file containing the override rules data.
+        :type input_file_path: str
+        :return: A dictionary containing the API response.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/role_assignment_rule"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        with open(input_file_path, 'rb') as file:
+            data = file.read()
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+    def update_lifecycle_role_assignment_rules(self, input_file_path, content_type='text/csv', accept='application/json'):
+        """
+        Updates lifecycle role assignment rules (default & override) in the Vault.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-lifecycle-role-assignment-rules-default-amp-override
+        
+        :param input_file_path: The path to the JSON or CSV file containing the rules data to be updated.
+        :type input_file_path: str
+        :param content_type: The content type of the input file, either 'application/json' or 'text/csv'. Default is 'text/csv'.
+        :type content_type: str
+        :param accept: The format of the response, can be 'application/json' (default), 'application/xml' or 'text/csv'.
+        :type accept: str
+        :return: A dictionary containing the API response.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/role_assignment_rule"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": content_type,
+            "Accept": accept
+        }
+        
+        with open(input_file_path, 'rb') as file:
+            data = file.read()
+        
+        response = requests.put(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+
+
+    def delete_lifecycle_role_assignment_override_rules(self, lifecycle_v, role_v, object_name=None, object_name_value=None):
+        """
+        Deletes lifecycle role assignment override rules in the Vault.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-lifecycle-role-assignment-override-rules
+
+        :param lifecycle_v: The name of the lifecycle from which to delete override rules.
+        :type lifecycle_v: str
+        :param role_v: The name of the role from which to delete override rules.
+        :type role_v: str
+        :param object_name: Optional: The name of the object by ID to specify the override to delete.
+        :type object_name: str, optional
+        :param object_name_value: Optional: The name value of the object to specify the override to delete.
+        :type object_name_value: str, optional
+        :return: A dictionary containing the API response.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/configuration/role_assignment_rule"
+        params = {
+            "lifecycle__v": lifecycle_v,
+            "role__v": role_v
+        }
+        if object_name:
+            params[object_name] = object_name_value
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.delete(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+
+
+
+
+    #######################################################
+    # Document Lifecycle & Workflows
+    ## Document Workflows
+    #######################################################
+
+
+
+    def retrieve_all_document_workflows(self, loc=None):
+        """
+        Retrieves all available document workflows that the authenticated user has permissions to view or initiate 
+        and that can be initiated through the API.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-document-workflows
+
+        :param loc: Optional: When localized (translated) strings are available, retrieve them by setting loc to true.
+        :type loc: bool, optional
+        :return: A dictionary containing the API response with details of available workflows.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/actions"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        params = {}
+        if loc is not None:
+            params['loc'] = loc
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_document_workflow_details(self, workflow_name, loc=None):
+        """
+        Retrieves the details for a specific document workflow.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-document-workflow-details
+
+        :param workflow_name: The name of the document workflow to retrieve details for.
+        :type workflow_name: str
+        :param loc: Optional: When localized (translated) strings are available, retrieve them by setting loc to true.
+        :type loc: bool, optional
+        :return: A dictionary containing the API response with details of the specified document workflow.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/actions/{workflow_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        params = {}
+        if loc is not None:
+            params['loc'] = loc
+
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def initiate_document_workflow(self, workflow_name, contents_sys, description_sys):
+        """
+        Initiates a document workflow on a set of documents.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-document-workflow
+
+        :param workflow_name: The name of the document workflow to initiate.
+        :type workflow_name: str
+        :param contents_sys: A comma-separated list of document id field values (maximum 100 documents).
+        :type contents_sys: str
+        :param description_sys: Description of the workflow (maximum 128 characters).
+        :type description_sys: str
+        :return: A dictionary containing the API response which includes details of the initiated workflow or error messages.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/actions/{workflow_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        data = {
+            "contents__sys": contents_sys,
+            "description__sys": description_sys
+        }
+        
+        response = requests.post(url, headers=headers, json=data)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # Object Lifecycle & Workflows
+    #######################################################
+
+    #######################################################
+    # Object Lifecycle & Workflows
+    ## Retrieve Object Record User Actions
+    #######################################################
+
+
+    def retrieve_object_record_user_actions(self, object_name, object_record_id, loc=None):
+        """
+        Retrieve all available user actions that can be initiated on a specific object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-record-user-actions
+
+        :param object_name: The name of the object (name__v field value).
+        :type object_name: str
+        :param object_record_id: The id of the object record.
+        :type object_record_id: str
+        :param loc: Optional parameter to retrieve localized (translated) strings for the label, default is None.
+        :type loc: bool, optional
+        :return: A dictionary containing the API response which includes a list of available user actions or error messages.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        params = {}
+        if loc is not None:
+            params["loc"] = loc
+
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_object_user_action_details(self, object_name, object_record_id, action_name):
+        """
+        Retrieves the details for a specific user action.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-object-user-action-details
+
+        :param object_name: The object name__v field value.
+        :type object_name: str
+        :param object_record_id: The object record id value from which to retrieve user action details.
+        :type object_record_id: str
+        :param action_name: Either the name of the Objectaction or Objectlifecyclestateuseraction to initiate. This is obtained from the Retrieve User Actions request.
+        :type action_name: str
+        :return: A dictionary containing the API response which includes metadata for the specified object action or error messages.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions/{action_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def initiate_object_action_single_record(self, object_name, object_record_id, action_name, body_params):
+        """
+        Initiates an action on a specific object record.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-object-action-on-a-single-record
+
+        :param object_name: The object name__v field value.
+        :type object_name: str
+        :param object_record_id: The object record id field value from which to retrieve user actions.
+        :type object_record_id: str
+        :param action_name: The name of the Objectaction or Objectlifecyclestateuseraction to initiate.
+        :type action_name: str
+        :param body_params: A dictionary containing name-value pairs of any parameters required to initiate the action.
+        :type body_params: dict
+        :return: A dictionary containing the API response which includes the status of the action initiation or error messages.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions/{action_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers, data=body_params)
+        
+        return response.json()
+
+
+    def initiate_object_action_multiple_records(self, object_name, action_name, ids_list, body_params=None):
+        """
+        Initiates an object user action on multiple records, with a maximum of 500 records per batch.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-object-action-on-multiple-records
+
+        :param object_name: The object name__v field value.
+        :type object_name: str
+        :param action_name: Either the name of the Objectaction or Objectlifecyclestateuseraction to initiate.
+        :type action_name: str
+        :param ids_list: A list of object record IDs on which to initiate the action.
+        :type ids_list: list of str
+        :param body_params: (Optional) A dictionary containing name-value pairs of any other parameters required to initiate the action.
+        :type body_params: dict, optional
+        :return: A dictionary containing the API response which includes the status of the action initiation or error messages for each record ID.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/actions/{action_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        body_params = body_params or {}
+        body_params['ids'] = ', '.join(ids_list)
+        
+        response = requests.post(url, headers=headers, data=body_params)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # Object Lifecycle & Workflows
+    ## Multi-Record Workflows
+    #######################################################
+
+    def retrieve_all_multi_record_workflows(self):
+        """
+        Retrieves all available multi-record workflows which the authenticated user has permissions to view or initiate and can be initiated through the API.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-multi-record-workflows
+
+        :return: A dictionary containing the API response which includes details of all available multi-record workflows.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/actions"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_multi_record_workflow_details(self, workflow_name):
+        """
+        Retrieves the fields required to initiate a specific multi-record workflow. It provides details about the necessary controls and configurations required for initiating the workflow.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-multi-record-workflow-details
+
+        :param workflow_name: The name of the multi-record workflow to retrieve details for.
+        :type workflow_name: str
+        :return: A dictionary containing the API response which includes details of the specified multi-record workflow.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/actions/{workflow_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def initiate_multi_record_workflow(self, workflow_name, contents_sys, description_sys, additional_parameters=None):
+        """
+        Initiate a multi-record workflow on a set of records. This API call initiates the specified workflow with the necessary parameters.
+
+        API Documentation: https://developer.veevavault.com/api/23.2/#initiate-multi-record-workflow
+
+        :param workflow_name: The name of the workflow to initiate.
+        :type workflow_name: str
+        :param contents_sys: A comma-separated list of records in the format Object:{objectname}.{record_ID}.
+        :type contents_sys: str
+        :param description_sys: Description of the workflow, maximum of 128 characters.
+        :type description_sys: str
+        :param additional_parameters: Additional parameters as required by the Admin to start the workflow, if any.
+        :type additional_parameters: dict, optional
+        :return: A dictionary containing the API response which includes details like record_id and workflow_id of the initiated workflow.
+        :rtype: dict
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/objectworkflows/actions/{workflow_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        
+        body = {
+            "contents__sys": contents_sys,
+            "description__sys": description_sys
+        }
+        
+        if additional_parameters:
+            body.update(additional_parameters)
+        
+        response = requests.post(url, headers=headers, data=body)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # Users
+    #######################################################
+
+
+    def retrieve_user_metadata(self):
+        """
+        Retrieves user metadata from the Veeva Vault API.
+        
+        API documentation URL: https://developer.veevavault.com/api/23.2/#retrieve-user-metadata
+        
+        Returns:
+            pd.DataFrame: A DataFrame containing the retrieved user metadata.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/users"
+        r = requests.get(url, headers={"Authorization": f"{self.sessionId}"}).json()['properties']
+        return pd.DataFrame(r)
+
+
+
+    def retrieve_all_users(self, vaults=None, exclude_vault_membership=None, exclude_app_licensing=None, limit=None, start=None, sort=None):
+        """
+        This method retrieves user records at the domain level. Beginning in v18.1, Admins create and manage users with 
+        user__sys object records. We strongly recommend using the Retrieve Object Record Collection endpoint to retrieve 
+        user__sys records. More information can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-users
+        
+        Parameters:
+        vaults (str): Optional parameter to specify the vaults to retrieve users from. It accepts values like 'all', '-1', 
+                    or a comma-separated list of Vault IDs e.g., '3003,4004,5005'.
+        exclude_vault_membership (bool): Optional parameter to include or exclude vault_membership fields in the response.
+        exclude_app_licensing (bool): Optional parameter to include or exclude app_licensing fields in the response.
+        limit (int): Optional parameter to specify the size of the result set in the page. Default is 200.
+        start (int): Optional parameter to specify the starting record number. Default is 0.
+        sort (str): Optional parameter to specify the sort order for the result set (e.g., 'id asc').
+        
+        Returns:
+        response: A JSON response containing the user records data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users"
+        
+        params = {
+            "vaults": vaults,
+            "exclude_vault_membership": exclude_vault_membership,
+            "exclude_app_licensing": exclude_app_licensing,
+            "limit": limit,
+            "start": start,
+            "sort": sort
+        }
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+    def retrieve_user(self, user_id, exclude_vault_membership=None, exclude_app_licensing=None):
+        """
+        This method retrieves information for one user at the domain level. Beginning in v18.1, Admins create and manage 
+        users with user__sys object records. It is strongly recommended to use the Retrieve Object Record endpoint to 
+        retrieve a user__sys record. More details can be found at: https://developer.veevavault.com/api/23.2/#retrieve-user
+
+        Parameters:
+        user_id (int): The ID of the user to be retrieved.
+        exclude_vault_membership (bool): Optional parameter to include or exclude vault_membership fields in the response. 
+                                        Including these fields may decrease performance.
+        exclude_app_licensing (bool): Optional parameter to include or exclude app_licensing fields in the response. 
+                                    Including these fields may decrease performance.
+
+        Returns:
+        response: A JSON response containing the information of the specified user.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}"
+        
+        params = {
+            "exclude_vault_membership": exclude_vault_membership,
+            "exclude_app_licensing": exclude_app_licensing
+        }
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+    def create_single_user(self, user_details, domain=None, file_path=None):
+        """
+        This method creates a single user in the Veeva Vault. Admins create and manage users with user__sys object records 
+        from version v18.1. It is strongly recommended to use the Create Object Records endpoint to create new users, 
+        unless creating cross-domain users or adding users to a domain without assigning Vault membership.
+        Detailed documentation about this endpoint can be found at: https://developer.veevavault.com/api/23.2/#create-single-user
+        
+        Parameters:
+        user_details (dict): A dictionary containing the details of the user to be created. It must include the following keys:
+                            - user_name__v (required): The user's Vault username (login credential).
+                            - user_first_name__v (required): The user's first name.
+                            - user_last_name__v (required): The user's last name.
+                            - user_email__v (required): The user's email address.
+                            - user_timezone__v (required): The user's time zone.
+                            - user_locale__v (required): The user's locale.
+                            - security_policy_id__v (required): The user's security policy ID.
+                            - user_language__v (required): The user's preferred language.
+                            It can optionally include:
+                            - security_profile__v: The user's security profile. Default is 'document_user__v' if omitted.
+                            - license_type__v: The user's license type. Default is 'full__v' if omitted.
+        domain (bool): When set to true, the user will not be assigned to a Vault.
+        file_path (str): The file path to upload a profile picture (JPG, PNG, or GIF, less than 10MB).
+        
+        Returns:
+        response: A JSON response indicating the status of the user creation.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users"
+
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "multipart/form-data",
+            "Accept": "application/json"
+        }
+
+        data = user_details
+        if domain is not None:
+            data["domain"] = domain
+
+        files = {}
+        if file_path:
+            files['file'] = open(file_path, 'rb')
+
+        response = requests.post(url, headers=headers, data=data, files=files)
+        return response.json()
+
+
+    def create_multiple_users(self, user_data, file_path=None, operation=None, idParam=None):
+        """
+        Creates multiple users in the vault. You can also add multiple existing users as cross-domain users.
+        API documentation: https://developer.veevavault.com/api/23.2/#create-multiple-users
+        
+        Args:
+        user_data (list of dict): List containing dictionaries where each dictionary contains details for a user.
+        file_path (str, optional): Path to the CSV file containing user data. The values in the file must be UTF-8 encoded and follow RFC 4180 format.
+        operation (str, optional): Operation type for upsert functionality. It can be "upsert".
+        idParam (str, optional): Parameter for upsert functionality. It can be either "id" or "user_name__v".
+        
+        Returns:
+        dict: Response from the API.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users"
+        
+        if file_path:
+            with open(file_path, 'r') as f:
+                data = f.read()
+        else:
+            data = user_data
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        params = {}
+        if operation:
+            params["operation"] = operation
+        if idParam:
+            params["idParam"] = idParam
+        
+        response = requests.post(url, headers=headers, json=data, params=params)
+        
+        return response.json()
+
+
+    def update_single_user(self, user_id, payload):
+        """
+        Updates the information of a single user in the vault. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#update-single-user
+        
+        Args:
+            user_id (str): The ID of the user to be updated.
+            payload (dict): A dictionary containing the fields and values to be updated.
+            
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}"
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.put(url, headers=headers, data=payload)
+        
+        return response.json()
+
+
+    def update_my_user(self, payload):
+        """
+        Updates the information of the currently authenticated user in the vault. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#update-my-user
+        
+        Args:
+            payload (dict): A dictionary containing the fields and values to be updated.
+            
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/me"
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.put(url, headers=headers, data=payload)
+        
+        return response.json()
+
+
+
+    def update_multiple_users(self, file_path, content_type="text/csv", accept="text/csv"):
+        """
+        Updates the information of multiple users in the vault. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#update-multiple-users
+        
+        Args:
+            file_path (str): The path to the input file (CSV or JSON) containing the user data to be updated.
+            content_type (str, optional): The content type of the input file. Defaults to "text/csv".
+            accept (str, optional): The format in which to receive the response. Defaults to "text/csv".
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users"
+        headers = {
+            "Content-Type": content_type,
+            "Accept": accept,
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        with open(file_path, 'rb') as f:
+            response = requests.put(url, headers=headers, data=f)
+        
+        return response.json()
+
+
+    def disable_user(self, user_id, domain=False):
+        """
+        Disables a user in a specific vault or in all vaults in the domain. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#disable-user
+
+        Args:
+            user_id (int): The ID of the user to disable.
+            domain (bool, optional): When set to True, disables the user account in all vaults in the domain. Defaults to False.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}"
+        if domain:
+            url += "?domain=true"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.delete(url, headers=headers)
+        
+        return response.json()
+
+
+    def change_my_password(self, current_password, new_password):
+        """
+        Changes the password for the currently authenticated user. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#change-my-password
+        
+        Args:
+            current_password (str): The current password of the authenticated user.
+            new_password (str): The new password to set for the authenticated user. It must be different from the current password and meet the minimum requirements configured by the Vault Admin.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/me/password"
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        body = {
+            "password__v": current_password,
+            "new_password__v": new_password
+        }
+        
+        response = requests.post(url, headers=headers, data=body)
+        
+        return response.json()
+
+
+
+    def update_vault_membership(self, user_id, vault_id, active=None, security_profile=None, license_type=None):
+        """
+        Updates the vault membership details of a specific user in a particular vault. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#update-vault-membership
+        
+        Args:
+            user_id (str): The ID of the user to update.
+            vault_id (str): The ID of the vault where the update will take place.
+            active (bool, optional): Sets the user status to active (true) or inactive (false). Defaults to None.
+            security_profile (str, optional): Assigns the user a specific security profile in the vault. Defaults to None.
+            license_type (str, optional): Assigns the user a specific license type in the vault. Defaults to None.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}/vault_membership/{vault_id}"
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        body = {}
+        if active is not None:
+            body["active__v"] = str(active).lower()
+        if security_profile:
+            body["security_profile__v"] = security_profile
+        if license_type:
+            body["license_type__v"] = license_type
+        
+        response = requests.put(url, headers=headers, data=body)
+        
+        return response.json()
+
+
+    def retrieve_user_permissions(self, user_id, permission_name=None):
+        """
+        Retrieves the permissions assigned to a specific user. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-user-permissions
+
+        Args:
+            user_id (str): The ID of the user. Use 'me' to retrieve permissions for the currently authenticated user.
+            permission_name (str, optional): The name of the permission to filter the results. Should be in the format object.{object name}.{object or field}_actions. Defaults to None.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/{user_id}/permissions"
+        
+        if permission_name:
+            url += f"?filter=name__v::{permission_name}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_my_user_permissions(self, permission_name=None):
+        """
+        Retrieves all object and object field permissions (Read, Edit, Create, Delete) assigned to the currently authenticated user. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-my-user-permissions
+
+        Args:
+            permission_name (str, optional): The name of the permission to filter the results. Should be in the format object.{object name}.{object or field}_actions. Defaults to None.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/users/me/permissions"
+        
+        if permission_name:
+            url += f"?filter=name__v::{permission_name}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # SCIM
+    #######################################################
+
+    #######################################################
+    # SCIM
+    ## Discovery Endpoints
+    #######################################################
+
+
+    def retrieve_scim_provider(self):
+        """
+        Retrieves a JSON that describes the SCIM specification features available on the currently authenticated Vault. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-scim-provider
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/ServiceProviderConfig"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_all_scim_schema_information(self):
+        """
+        Retrieves information about all SCIM schema specifications supported by a Vault SCIM service provider. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-all-scim-schema-information
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Schemas"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_single_scim_schema_information(self, schema_id):
+        """
+        Retrieves information about a single SCIM schema specification supported by a Vault SCIM service provider. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-single-scim-schema-information
+        
+        Args:
+            schema_id (str): The ID of a specific schema. For example, urn:ietf:params:scim:schemas:extension:veevavault:2.0:User.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Schemas/{schema_id}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_all_scim_resource_types(self):
+        """
+        Retrieves the types of SCIM resources available. Each resource type defines the endpoints, the core schema URI that defines the resource, and any supported schema extensions. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-all-scim-resource-types
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/ResourceTypes"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_single_scim_resource_type(self, type):
+        """
+        Retrieves a single SCIM resource type. Defines the endpoints, the core schema URI which defines this resource, and any supported schema extensions. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-single-scim-resource-type
+
+        Args:
+            type (str): A specific resource type. You can retrieve all available types from the Retrieve All SCIM Resource Types endpoint, where the value for this parameter is the id value.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/ResourceTypes/{type}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # SCIM
+    ## Users
+    #######################################################
+
+
+    def retrieve_all_users_with_scim(self, filter=None, attributes=None, excludedAttributes=None, sortBy=None, sortOrder=None, count=None, startIndex=None):
+        """
+        Retrieve all users with SCIM. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-all-users-with-scim
+
+        Args:
+            filter (str, optional): Filter for a specific attribute value, in the format {attribute} eq "{value}".
+            attributes (str, optional): Include specified attributes only in a comma separated list.
+            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma separated list.
+            sortBy (str, optional): Specify an attribute or sub-attribute to order the response.
+            sortOrder (str, optional): Specify the order in which the sortBy parameter is applied. Allowed values are "ascending" or "descending".
+            count (int, optional): Specify the number of query results per page.
+            startIndex (int, optional): Specify the index of the first result.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Users"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {
+            "filter": filter,
+            "attributes": attributes,
+            "excludedAttributes": excludedAttributes,
+            "sortBy": sortBy,
+            "sortOrder": sortOrder,
+            "count": count,
+            "startIndex": startIndex
+        }
+
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_single_user_with_scim(self, user_id, filter=None, attributes=None, excludedAttributes=None):
+        """
+        Retrieve a specific user with SCIM. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-single-user-with-scim
+
+        Args:
+            user_id (str): The ID of a specific user.
+            filter (str, optional): Filter for a specific attribute value, in the format {attribute} eq "{value}".
+            attributes (str, optional): Include specified attributes only in a comma separated list.
+            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma separated list.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Users/{user_id}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {
+            "filter": filter,
+            "attributes": attributes,
+            "excludedAttributes": excludedAttributes
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+
+    def retrieve_current_user_with_scim(self, attributes=None, excludedAttributes=None):
+        """
+        Retrieve the currently authenticated user with SCIM. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#retrieve-current-user-with-scim
+
+        Args:
+            attributes (str, optional): Include specified attributes only in a comma separated list.
+            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma separated list.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Me"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {
+            "attributes": attributes,
+            "excludedAttributes": excludedAttributes
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def update_current_user_with_scim(self, body_data, attributes=None, excludedAttributes=None):
+        """
+        Update the currently authenticated user with SCIM. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#update-current-user-with-scim
+
+        Args:
+            body_data (dict): A dictionary containing the data to update.
+            attributes (str, optional): Include specified attributes only in a comma separated list.
+            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma separated list.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Me"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {
+            "attributes": attributes,
+            "excludedAttributes": excludedAttributes
+        }
+        
+        response = requests.put(url, headers=headers, params=params, json=body_data)
+        
+        return response.json()
+
+
+    def create_user_with_scim(self, user_data):
+        """
+        Create a user with SCIM. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#create-user-with-scim
+
+        Args:
+            user_data (dict): A dictionary containing the required information to create a new user.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Users"
+        
+        headers = {
+            "Accept": "application/json",
+            "Content-Type": "application/scim+json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.post(url, headers=headers, json=user_data)
+        
+        return response.json()
+
+
+
+    def update_user_with_scim(self, user_id, user_data):
+        """
+        Update fields values on a single user with SCIM. You can find the API documentation here:
+        https://developer.veevavault.com/api/23.2/#update-user-with-scim
+
+        Args:
+            user_id (str): The ID of the user you wish to update.
+            user_data (dict): A dictionary containing the information to update for the user.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/Users/{user_id}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Content-Type": "application/scim+json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.put(url, headers=headers, json=user_data)
+        
+        return response.json()
+
+
+    def retrieve_scim_resources(self, resource_type, filter=None, attributes=None, excludedAttributes=None, sortBy=None, sortOrder=None, count=None, startIndex=None):
+        """
+        Retrieve a single SCIM resource type. The function defines the endpoints, the core schema URI which defines this resource, and any supported schema extensions.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-scim-resources
+
+        Args:
+            resource_type (str): The resource type to retrieve. 
+            filter (str, optional): Filter for a specific attribute value. Defaults to None.
+            attributes (str, optional): Include specified attributes only. Defaults to None.
+            excludedAttributes (str, optional): Exclude specific attributes from the response. Defaults to None.
+            sortBy (str, optional): Specify an attribute or sub-attribute to order the response. Defaults to None.
+            sortOrder (str, optional): Specify the order in which the sortBy parameter is applied. Defaults to None.
+            count (int, optional): Specify the number of query results per page. Defaults to None.
+            startIndex (int, optional): Specify the index of the first result. Defaults to None.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/{resource_type}"
+
+        params = {
+            "filter": filter,
+            "attributes": attributes,
+            "excludedAttributes": excludedAttributes,
+            "sortBy": sortBy,
+            "sortOrder": sortOrder,
+            "count": count,
+            "startIndex": startIndex
+        }
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_single_scim_resource(self, resource_type, resource_id, attributes=None, excludedAttributes=None):
+        """
+        Retrieve a single SCIM resource from the Veeva Vault. 
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-single-scim-resource
+
+        Args:
+            resource_type (str): The type of the resource to retrieve.
+            resource_id (str): The ID of the resource to retrieve.
+            attributes (str, optional): Include specified attributes only in a comma-separated list. Defaults to None.
+            excludedAttributes (str, optional): Exclude specific attributes from the response in a comma-separated list. Defaults to None.
+
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/scim/v2/{resource_type}/{resource_id}"
+        
+        params = {
+            "attributes": attributes,
+            "excludedAttributes": excludedAttributes
+        }
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+
+
+
+    #######################################################
+    # Groups
+    #######################################################
+
+
+    def retrieve_group_metadata(self):
+        """
+        Retrieve metadata of groups in the Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-group-metadata
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/groups"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_all_groups(self, include_implied=None):
+        """
+        Retrieve all groups except Auto Managed groups in the Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-groups
+        
+        Args:
+            include_implied (bool, optional): When true, the response includes the implied_members__v field.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {}
+        if include_implied is not None:
+            params['includeImplied'] = include_implied
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_auto_managed_groups(self, limit=1000, offset=0):
+        """
+        Retrieve all Auto Managed groups from the Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-auto-managed-groups
+        
+        Args:
+            limit (int, optional): The maximum number of records per page in the response. Defaults to 1000.
+            offset (int, optional): The offset from the entry returned to paginate the results displayed per page. Defaults to 0.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups/auto"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {
+            'limit': limit,
+            'offset': offset
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def retrieve_group(self, group_id, include_implied=None):
+        """
+        Retrieve details of a specific group using the group id from the Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-group
+        
+        Args:
+            group_id (int): The ID of the group to retrieve.
+            include_implied (bool, optional): When true, includes the implied_members__v field in the response. Defaults to None.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups/{group_id}"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        params = {}
+        if include_implied is not None:
+            params['includeImplied'] = include_implied
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def create_group(self, label, members=None, security_profiles=None, active=True, group_description=None, allow_delegation_among_members=False):
+        """
+        Create a new group in the Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#create-group
+        
+        Args:
+            label (str): The label for the new group. This is used to create the group name__v value.
+            members (str, optional): A comma-separated list of user IDs to assign to the group. Defaults to None.
+            security_profiles (str, optional): A comma-separated list of security profiles to assign to the group. Defaults to None.
+            active (bool, optional): Set to false to create the group as inactive. Defaults to True.
+            group_description (str, optional): A description of the group. Defaults to None.
+            allow_delegation_among_members (bool, optional): Set to true to allow members to delegate access to other members of the same group. Defaults to False.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups"
+
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        data = {
+            "label__v": label,
+            "active__v": active,
+            "allow_delegation_among_members__v": allow_delegation_among_members
+        }
+
+        if members:
+            data["members__v"] = members
+        if security_profiles:
+            data["security_profiles__v"] = security_profiles
+        if group_description:
+            data["group_description__v"] = group_description
+
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+
+    def update_group(self, group_id, label=None, members=None, security_profiles=None, active=None, group_description=None, allow_delegation_among_members=None):
+        """
+        Update group field values or add/remove members and security profiles in the Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#update-group
+        
+        Args:
+            group_id (str): The ID of the group to be updated.
+            label (str, optional): The new label for the group. Defaults to None.
+            members (str, optional): A comma-separated list of user IDs or a command to add/remove users (e.g., "add (userID1, userID2)" or "delete (userID1, userID2)"). Defaults to None.
+            security_profiles (str, optional): A comma-separated list of security profiles. Defaults to None.
+            active (bool, optional): Set to false to make the group inactive. Defaults to None.
+            group_description (str, optional): The new description of the group. Defaults to None.
+            allow_delegation_among_members (bool, optional): Set to true to allow members to delegate access only to other members of the same group. Defaults to None.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups/{group_id}"
+
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        data = {}
+        
+        if label is not None:
+            data["label__v"] = label
+        if members is not None:
+            data["members__v"] = members
+        if security_profiles is not None:
+            data["security_profiles__v"] = security_profiles
+        if active is not None:
+            data["active__v"] = active
+        if group_description is not None:
+            data["group_description__v"] = group_description
+        if allow_delegation_among_members is not None:
+            data["allow_delegation_among_members__v"] = allow_delegation_among_members
+
+        response = requests.put(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+    def delete_group(self, group_id):
+        """
+        Delete a user-defined group in the Veeva Vault. Note that system-managed groups cannot be deleted.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#delete-group
+        
+        Args:
+            group_id (str): The ID of the group to be deleted.
+        
+        Returns:
+            dict: A dictionary containing the response data.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/groups/{group_id}"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.delete(url, headers=headers)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Picklists
+    #######################################################
+
+
+    def retrieve_all_picklists(self):
+        """
+        Retrieve all picklists available in the Veeva Vault. This method provides metadata about each picklist including its name, label, kind, and where it is used.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-picklists
+        
+        Returns:
+            dict: A dictionary containing the response data including details about each picklist.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_picklist_values(self, picklist_name):
+        """
+        Retrieve all the values configured for a specified picklist in Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-picklist-values
+
+        Args:
+            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
+
+        Returns:
+            dict: A dictionary containing the response data with details about each picklist value.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}"
+
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+
+        return response.json()
+
+
+
+    def create_picklist_values(self, picklist_name, values_dict):
+        """
+        Create new values in a specified picklist in Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#create-picklist-values
+
+        Args:
+            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
+            values_dict (dict): A dictionary with keys as "value_1", "value_2", etc. and values as the new picklist value labels.
+
+        Returns:
+            dict: A dictionary containing the response data with details about the created picklist values.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}"
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.post(url, headers=headers, data=values_dict)
+
+        return response.json()
+
+
+
+    def update_picklist_value_label(self, picklist_name, label_updates_dict):
+        """
+        Update the label of existing picklist values in Veeva Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#update-picklist-value-label
+
+        Args:
+            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
+            label_updates_dict (dict): A dictionary where keys are existing picklist value names and values are the new labels.
+
+        Returns:
+            dict: A dictionary containing the response data with details about the updated picklist values.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}"
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.put(url, headers=headers, data=label_updates_dict)
+
+        return response.json()
+
+
+    def update_picklist_value(self, picklist_name, picklist_value_name, new_name=None, status=None):
+        """
+        Update the name or status of a picklist value in Veeva Vault. Be cautious as it may affect existing documents and objects.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#update-picklist-value
+
+        Args:
+            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
+            picklist_value_name (str): The current name of the picklist value to be updated.
+            new_name (str, optional): The new name for the picklist value. Defaults to None.
+            status (str, optional): The new status for the picklist value, either "active" or "inactive". Defaults to None.
+
+        Returns:
+            dict: A dictionary containing the response data with status of the update operation.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}/{picklist_value_name}"
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        data = {}
+        if new_name:
+            data['name'] = new_name
+        if status:
+            data['status'] = status
+
+        response = requests.put(url, headers=headers, data=data)
+
+        return response.json()
+
+
+    def inactivate_picklist_value(self, picklist_name, picklist_value_name):
+        """
+        Inactivates a picklist value in Veeva Vault. It does not affect picklist values that are already in use.
+        Best practice is to use the update_picklist_value method to inactivate a picklist value.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#inactivate-picklist-value
+
+        Args:
+            picklist_name (str): The name of the picklist (e.g., "license_type__v", "product_family__c", "region__c").
+            picklist_value_name (str): The name of the picklist value to be inactivated.
+
+        Returns:
+            dict: A dictionary containing the response data with the status of the inactivation operation.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/picklists/{picklist_name}/{picklist_value_name}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.delete(url, headers=headers)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # Expected Document Lists
+    #######################################################
+
+
+
+    def create_placeholder_from_edl_item(self, edl_item_ids):
+        """
+        Creates a placeholder from an EDL item. Learn more about working with Content Placeholders in Vault Help.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#create-a-placeholder-from-an-edl-item
+
+        Args:
+            edl_item_ids (str): A comma-separated string of EDL Item IDs on which to initiate the action.
+
+        Returns:
+            dict: A dictionary containing the response data, including job_id and URL to check the job status.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/edl_item__v/actions/createplaceholder"
+
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        data = {
+            "edlItemIds": edl_item_ids
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+    def retrieve_all_root_nodes(self, edl_hierarchy_or_template):
+        """
+        Retrieves all root EDL nodes and node metadata. Learn more about EDL hierarchies in Vault Help.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-root-nodes
+
+        Args:
+            edl_hierarchy_or_template (str): Specifies whether to retrieve nodes for either edl_hierarchy__v or edl_template__v.
+
+        Returns:
+            dict: A dictionary containing the response data with details of all root nodes.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/composites/trees/{edl_hierarchy_or_template}"
+
+        headers = {
+            "Content-Type": "application/json",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_specific_root_nodes(self, edl_hierarchy_or_template, ref_ids):
+        """
+        Retrieves the root node ID for the given EDL record IDs.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-specific-root-nodes
+
+        Args:
+            edl_hierarchy_or_template (str): Specifies whether to retrieve nodes for either edl_hierarchy__v or edl_template__v.
+            ref_ids (list): A list of dictionaries where each dictionary contains a key 'ref_id__v' and the corresponding EDL record ID as value.
+
+        Returns:
+            dict: A dictionary containing the response data with the root node ID for the specified EDL record IDs.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/composites/trees/{edl_hierarchy_or_template}/actions/listnodes"
+        
+        headers = {
+            "Content-Type": "application/json",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.post(url, headers=headers, json=ref_ids)
+        
+        return response.json()
+
+
+
+    def retrieve_node_children(self, edl_hierarchy_or_template, parent_node_id):
+        """
+        Given an EDL node ID, retrieves immediate children (not grandchildren) of that node.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-a-node-39-s-children
+        
+        Args:
+            edl_hierarchy_or_template (str): Specifies whether to retrieve node children for either edl_hierarchy__v or edl_template__v.
+            parent_node_id (str): The ID of a parent node in the hierarchy.
+
+        Returns:
+            dict: A dictionary containing the response data with the immediate children of the specified parent node ID.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/composites/trees/{edl_hierarchy_or_template}/{parent_node_id}/children"
+        
+        headers = {
+            "Content-Type": "application/json",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def update_node_order(self, edl_hierarchy_or_template, parent_node_id, node_id, new_order):
+        """
+        Given an EDL parent node, updates the order of its children.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#update-node-order
+        
+        Args:
+            edl_hierarchy_or_template (str): Specifies whether to update node order for either edl_hierarchy__v or edl_template__v.
+            parent_node_id (str): The ID of a parent node in the hierarchy.
+            node_id (str): The ID of the child node to update.
+            new_order (str): The new order for the node in the hierarchy, such as “1”, “2”, etc.
+
+        Returns:
+            dict: A dictionary containing the response data after updating the node order.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/composites/trees/{edl_hierarchy_or_template}/{parent_node_id}/children"
+
+        headers = {
+            "Content-Type": "application/json",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        payload = {
+            "id": node_id,
+            "order__v": new_order
+        }
+
+        response = requests.put(url, headers=headers, json=payload)
+        
+        return response.json()
+
+
+    def add_edl_matched_documents(self, matched_documents):
+        """
+        Adds matched documents to EDL Items. You must have a security profile that grants the Application: EDL Matching: Edit Document Matches permission, and EDL Matched Document APIs must be enabled in your Vault. To enable this feature, contact Veeva Support.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#add-edl-matched-documents
+
+        Args:
+            matched_documents (list of dict): List of dictionaries where each dictionary contains the details of an EDL item-document match with keys - id, document_id, major_version_number__v (optional), minor_version_number__v (optional), lock (optional).
+
+        Returns:
+            dict: A dictionary containing the response data after adding the EDL matched documents.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/edl_matched_documents/batch/actions/add"
+
+        headers = {
+            "Content-Type": "application/json",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.post(url, headers=headers, json=matched_documents)
+        
+        return response.json()
+
+
+    def remove_edl_matched_documents(self, matched_documents):
+        """
+        Removes manually matched documents from EDL Items. You must have a security profile that grants the Application: EDL Matching: Edit Document Matches permission, and EDL Matched Document APIs must be enabled in your Vault. To enable this feature, contact Veeva Support.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#remove-edl-matched-documents
+
+        Args:
+            matched_documents (list of dict): List of dictionaries where each dictionary contains the details of an EDL item-document match to remove with keys - id, document_id, major_version_number__v (optional), minor_version_number__v (optional), remove_locked (optional).
+
+        Returns:
+            dict: A dictionary containing the response data after removing the EDL matched documents.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/edl_matched_documents/batch/actions/remove"
+
+        headers = {
+            "Content-Type": "application/json",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.post(url, headers=headers, json=matched_documents)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Security Policies
+    #######################################################
+
+
+    def retrieve_security_policy_metadata(self):
+        """
+        Retrieve the metadata associated with the security policy object. 
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-security-policy-metadata
+        
+        Returns:
+            dict: A dictionary containing the metadata associated with the security policy object.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/objects/securitypolicies"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_all_security_policies(self):
+        """
+        Retrieve a list of all security policies in the Vault. 
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-all-security-policies
+        
+        Returns:
+            dict: A dictionary containing a list of all security policies in the Vault.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/securitypolicies"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_security_policy(self, security_policy_name):
+        """
+        Retrieve the details of a specific security policy in the Vault.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-security-policy
+        
+        Args:
+            security_policy_name (str): The name__v field value of the security policy to retrieve. This is typically a numeric value.
+            
+        Returns:
+            dict: A dictionary containing the details of the specified security policy.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/securitypolicies/{security_policy_name}"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Configuration Migration
+    #######################################################
+
+
+    def export_package(self, package_name):
+        """
+        Export a package from the Vault. The API will initiate an export job and respond with the details of the job including a job ID which can be used to check the status of the export job.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#export-package
+        
+        Args:
+            package_name (str): The name of the Outbound Package you would like to export.
+            
+        Returns:
+            dict: A dictionary containing the URL to check the job status and the job ID.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/package"
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        data = {
+            "packageName": package_name
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+
+    def import_package(self, file_path):
+        """
+        Import and validate a VPK package in the Vault. The API initiates an asynchronous import job and responds with the job details including a job ID which can be used to check the status of the import job.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#import-package
+        
+        Args:
+            file_path (str): The path to the .vpk file that you want to import.
+            
+        Returns:
+            dict: A dictionary containing the URL to check the job status and the job ID.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/package"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        files = {
+            'file': open(file_path, 'rb')
+        }
+        
+        response = requests.put(url, headers=headers, files=files)
+        
+        return response.json()
+
+
+
+
+    def deploy_package(self, package_id):
+        """
+        Deploy a package in the Vault. This method initiates a deployment job and responds with the job details including a job ID which can be used to retrieve the status and results of the request.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#deploy-package
+        
+        Args:
+            package_id (str): The ID of the vault_package__v object record that you want to deploy.
+            
+        Returns:
+            dict: A dictionary containing the URL to check the job status and the job ID.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobject/vault_package__v/{package_id}/actions/deploy"
+        
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.post(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_package_deploy_results(self, package_id):
+        """
+        Retrieve the results of a completed package deployment in the Vault. After Vault completes the deploy job, use this method to get detailed information about the deployment results.
+        API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-package-deploy-results
+        
+        Args:
+            package_id (str): The ID of the vault_package__v object record used for deployment.
+            
+        Returns:
+            dict: A dictionary containing the results and details of the package deployment.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobject/vault_package__v/{package_id}/actions/deploy/results"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def retrieve_outbound_package_dependencies(self, package_id):
+        """
+        Retrieve the dependencies of an outbound package in the Vault. This API method allows you to identify all outstanding component dependencies for an outbound package and gives you the ability to add these missing dependencies to the package through another API call.
+        The API documentation can be found at: https://developer.veevavault.com/api/23.2/#retrieve-outbound-package-dependencies
+
+        Args:
+            package_id (str): The ID of the outbound_package__v record for which to retrieve dependencies.
+
+        Returns:
+            dict: A dictionary containing details about the package dependencies, including total number of dependencies, target vault ID, package name, package ID, description, and URL for adding missing dependencies.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/outbound_package__v/{package_id}/dependencies"
+        
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+
+
+    def vault_compare(self, vault_id, results_type="differences", details_type="simple", include_doc_binder_templates=True, include_vault_settings=True, component_types=None, generate_outbound_packages=False):
+        """
+        Compare the configuration of two different Vaults. The Vault where the request is made serves as the source Vault, and the target Vault for the comparison is specified in the request body. This function allows you to initiate a comparison between configurations and view the differences or complete configurations depending on the parameters specified.
+        The API documentation can be found at: https://developer.veevavault.com/api/23.2/#vault-compare
+
+        Args:
+            vault_id (str): The target Vault ID for the comparison.
+            results_type (str, optional): Specify 'complete' to include all configuration values or 'differences' to only see the differences between Vaults. Defaults to 'differences'.
+            details_type (str, optional): Specify the level of details in the comparison. Can be 'none' for component level details only, 'simple' for simple attribute-level details, or 'complex' for all attribute-level details. Defaults to 'simple'.
+            include_doc_binder_templates (bool, optional): Include or exclude Document and Binder Templates for comparison. Defaults to True.
+            include_vault_settings (bool, optional): Include or exclude Vault Settings for comparison. Defaults to True.
+            component_types (str, optional): A comma-separated list of component types to include or 'none' to exclude all component types. Defaults to None (includes all components).
+            generate_outbound_packages (bool, optional): If True, Vault automatically generates an Outbound Package based on the differences between the source and target Vault. Defaults to False.
+
+        Returns:
+            dict: A dictionary containing the response status, URL, and job ID for the comparison report job initiated. Use the URL and job ID to track the status and retrieve the comparison report once generated.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/vault/actions/compare"
+
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        data = {
+            "vault_id": vault_id,
+            "results_type": results_type,
+            "details_type": details_type,
+            "include_doc_binder_templates": include_doc_binder_templates,
+            "include_vault_settings": include_vault_settings,
+            "component_types": component_types,
+            "generate_outbound_packages": generate_outbound_packages
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+
+        return response.json()
+
+
+
+    def vault_configuration_report(self, include_vault_settings=True, include_inactive_components=False, include_components_modified_since=None, include_doc_binder_templates=True, suppress_empty_results=False, component_types=None, output_format="Excel_Macro_Enabled"):
+        """
+        Generates an Excel™ report containing configuration information for a Vault. Users need to have the Vault Configuration Report permission to use this API. The detailed API documentation can be accessed at: https://developer.veevavault.com/api/23.2/#vault-configuration-report
+
+        Args:
+            include_vault_settings (bool, optional): Determines whether to include Vault Settings in the report. Defaults to True.
+            include_inactive_components (bool, optional): Decides whether to include inactive components and subcomponents in the report. Defaults to False.
+            include_components_modified_since (str, optional): To include components modified since the specified date. The date should be in the format 'yyyy-mm-dd'. Defaults to None.
+            include_doc_binder_templates (bool, optional): Determines whether to include document and binder templates in the report. Defaults to True.
+            suppress_empty_results (bool, optional): If True, Vault will exclude tabs with only header rows from the report. Defaults to False.
+            component_types (str, optional): A comma-separated list of component types to include in the report. Defaults to None, which includes all components.
+            output_format (str, optional): Specifies the output format for the report, either 'XSLX' or 'XLSM'. Defaults to 'Excel_Macro_Enabled'.
+
+        Returns:
+            dict: The response dictionary containing the status of the request, the URL, and the job ID for the new Configuration Report job. You can use the URL and job ID to track the status and retrieve the report once generated.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/vault/actions/configreport"
+
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        data = {
+            "include_vault_settings": include_vault_settings,
+            "include_inactive_components": include_inactive_components,
+            "include_components_modified_since": include_components_modified_since,
+            "include_doc_binder_templates": include_doc_binder_templates,
+            "suppress_empty_results": suppress_empty_results,
+            "component_types": component_types,
+            "output_format": output_format
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+
+        return response.json()
+
+
+    def validate_package(self, file_path):
+        """
+        Validates a VPK package attached to this request. The validation response includes information on dependent components, similar to the validation logs generated through the UI. This method does not import your package. For detailed information, refer to the API documentation: https://developer.veevavault.com/api/23.2/#validate-package
+
+        Args:
+            file_path (str): The path to the VPK file to be validated.
+
+        Returns:
+            dict: The response dictionary containing the status of the validation and details of the package validation response.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/package/actions/validate"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        with open(file_path, 'rb') as f:
+            files = {'file': f}
+            response = requests.post(url, headers=headers, files=files)
+
+        return response.json()
+
+
+
+    def validate_inbound_package(self, package_id):
+        """
+        Validates an imported VPK package before deploying it to your Vault. The validation response includes information on dependent components and whether they exist in the package or in your Vault. You can add missing dependencies to the package in the source Vault before re-importing and deploying it to your target Vault. For more details, refer to the API documentation: https://developer.veevavault.com/api/23.2/#validate-inbound-package
+
+        Args:
+            package_id (str): The id field value of the vault_package__v object record to validate.
+
+        Returns:
+            dict: The response dictionary containing the status of the validation and details of the package validation response.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/vobject/vault_package__v/{package_id}/actions/validate"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.post(url, headers=headers)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Sandbox Vaults
+    #######################################################
+
+    def retrieve_sandboxes(self):
+        """
+        Retrieve information about the sandbox Vaults for the authenticated Vault.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-sandboxes
+        
+        Usage:
+            vv_instance = Vv()
+            sandboxes_info = vv_instance.retrieve_sandboxes()
+
+        Returns:
+            dict: A dictionary containing the details of the sandboxes.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def retrieve_sandbox_details_by_id(self, vault_id):
+        """
+        Retrieve information about the sandbox for the given Vault ID.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-sandbox-details-by-id
+        
+        Usage:
+            vv_instance = Vv()
+            sandbox_details = vv_instance.retrieve_sandbox_details_by_id(vault_id='56219')
+
+        Args:
+            vault_id (str): The Vault ID of the sandbox.
+
+        Returns:
+            dict: A dictionary containing the details of the sandbox specified by the Vault ID.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/{vault_id}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def recheck_sandbox_usage_limit(self):
+        """
+        Recalculate the usage values of the sandbox Vaults for the authenticated Vault. This action can be initiated up to three times in a 24-hour period.
+        API Documentation: https://developer.veevavault.com/api/23.2/#recheck-sandbox-usage-limit
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.recheck_sandbox_usage_limit()
+
+        Returns:
+            dict: A dictionary containing the response status of the action.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/actions/recheckusage"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json",
+            "Content-Type": "application/x-www-form-urlencoded"
+        }
+        
+        response = requests.post(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def change_sandbox_size(self, sandbox_details):
+        """
+        Change the size of a sandbox Vault for the authenticated Vault. You can initiate this action if there are sufficient allowances and the current sandbox meets the data and user limits of the requested size.
+        API Documentation: https://developer.veevavault.com/api/23.2/#change-sandbox-size
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.change_sandbox_size(sandbox_details=[{"name": "SandboxA", "size": "Full"}])
+
+        Args:
+            sandbox_details (list of dict): A list of dictionaries containing details of the sandboxes to change the size. Each dictionary should have "name" and "size" keys.
+
+        Returns:
+            dict: A dictionary containing the response status of the action.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/batch/changesize"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json",
+            "Content-Type": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers, json=sandbox_details)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def set_sandbox_entitlements(self, name, size, allowance, grant, temporary_allowance=None):
+        """
+        Set new sandbox entitlements, including granting and revoking allowances, for the given sandbox name.
+        API Documentation: https://developer.veevavault.com/api/23.2/#set-sandbox-entitlements
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.set_sandbox_entitlements(name="Sandbox0", size="Large", allowance=1, grant=True, temporary_allowance=None)
+
+        Args:
+            name (str): The name of the sandbox Vault.
+            size (str): The size of the sandbox: Small, Large, or Full.
+            allowance (int): The number of entitlements to grant or revoke.
+            grant (bool): True grants allowances and false revokes them.
+            temporary_allowance (int, optional): The number of temporary sandbox allowances to grant or revoke.
+
+        Returns:
+            dict: A dictionary containing the response status and the updated entitlement details.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/entitlements/set"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json",
+            "Content-Type": "application/x-www-form-urlencoded"
+        }
+        data = {
+            "name": name,
+            "size": size,
+            "allowance": allowance,
+            "grant": grant,
+            "temporary_allowance": temporary_allowance
+        }
+        response = requests.post(url, headers=headers, data=data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def create_or_refresh_sandbox(self, size, domain, name, source=None, source_snapshot=None, type=None, add_requester=None, release=None):
+        """
+        Create a new sandbox or refresh an existing sandbox for the currently authenticated Vault.
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-or-refresh-sandbox
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.create_or_refresh_sandbox(size="Small", domain="veepharm.com", name="Sandbox", source=None, source_snapshot=None, type=None, add_requester=None, release=None)
+        
+        Args:
+            size (str): The size of the sandbox: Small, Large, or Full.
+            domain (str): The domain to use for the new sandbox.
+            name (str): The name of the sandbox Vault.
+            source (str, optional): The source to refresh the sandbox from: vault or snapshot.
+            source_snapshot (str, optional): The api_name of the snapshot to create the sandbox from, if the source is a snapshot.
+            type (str, optional): The type of sandbox, such as config.
+            add_requester (bool, optional): Adds the currently authenticated user as a Vault Owner in the new sandbox, defaults to True.
+            release (str, optional): The type of release: general, limited, or prerelease, defaults to the release level of the source Vault.
+
+        Returns:
+            dict: A dictionary containing the response status and the job ID and URL to check the status of the sandbox creation request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json",
+            "Content-Type": "application/x-www-form-urlencoded"
+        }
+        data = {
+            "size": size,
+            "domain": domain,
+            "name": name,
+            "source": source,
+            "source_snapshot": source_snapshot,
+            "type": type,
+            "add_requester": add_requester,
+            "release": release
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def refresh_sandbox_from_snapshot(self, vault_id, source_snapshot):
+        """
+        Refresh a sandbox Vault in the currently authenticated Vault from an existing snapshot.
+        API Documentation: https://developer.veevavault.com/api/23.2/#refresh-sandbox-from-snapshot
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.refresh_sandbox_from_snapshot(vault_id=1001055, source_snapshot="Sandbox1 Snapshot")
+        
+        Args:
+            vault_id (int): The Vault ID of the sandbox to be refreshed.
+            source_snapshot (str): The api_name of the snapshot to refresh the sandbox from.
+
+        Returns:
+            dict: A dictionary containing the response status and the job ID and URL to check the status of the sandbox refresh request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/{vault_id}/actions/refresh"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json",
+            "Content-Type": "application/x-www-form-urlencoded"
+        }
+        data = {
+            "source_snapshot": source_snapshot
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def delete_sandbox(self, sandbox_name):
+        """
+        Delete a sandbox Vault. How often you can delete a Vault depends on its size.
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-sandbox
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.delete_sandbox(sandbox_name="My Configuration Sandbox")
+
+        Args:
+            sandbox_name (str): The name of the sandbox Vault to delete. This is the name which appears on the My Vaults page.
+
+        Returns:
+            dict: A dictionary containing the response status and a message about the deletion process.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/{sandbox_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.delete(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+
+
+
+    #######################################################
+    # Sandbox Vaults
+    ## Sandbox Snapshots
+    #######################################################
+
+    def create_sandbox_snapshot(self, source_sandbox, snapshot_name, description=None, include_data=False):
+        """
+        Create a new sandbox snapshot for the indicated sandbox Vault.
+        API Documentation: https://developer.veevavault.com/api/23.2/#create-sandbox-snapshot
+
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.create_sandbox_snapshot(source_sandbox="Sandbox1", snapshot_name="Snapshot1", description="First snapshot of a sandbox.", include_data=False)
+
+        Args:
+            source_sandbox (str): The name of the sandbox Vault to take a snapshot of.
+            snapshot_name (str): The name of the new snapshot.
+            description (str, optional): The description of the new snapshot. Defaults to None.
+            include_data (bool, optional): Set to true to include data as part of the snapshot. Set to false to include only configuration. Defaults to False.
+
+        Returns:
+            dict: A dictionary containing the job ID and URL to retrieve the current status of the snapshot creation request.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot"
+        headers = {
+            "Authorization": self.sessionId,
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        data = {
+            "source_sandbox": source_sandbox,
+            "name": snapshot_name,
+            "description": description,
+            "include_data": str(include_data).lower()
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def retrieve_sandbox_snapshots(self):
+        """
+        Retrieve information about sandbox snapshots managed by the authenticated Vault.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-sandbox-snapshots
+
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.retrieve_sandbox_snapshots()
+
+        Returns:
+            dict: A dictionary containing the details of the sandbox snapshots managed by the authenticated Vault.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def delete_sandbox_snapshot(self, api_name):
+        """
+        Delete a sandbox snapshot managed by the authenticated Vault. Deleted snapshots cannot be recovered.
+        API Documentation: https://developer.veevavault.com/api/23.2/#delete-sandbox-snapshot
+
+        Parameters:
+            api_name (str): The API name of the snapshot to delete.
+
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.delete_sandbox_snapshot(api_name="sandbox_a_snapshot__c")
+
+        Returns:
+            dict: A dictionary containing the response status of the delete request.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot/{api_name}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+
+    def update_sandbox_snapshot(self, api_name):
+        """
+        Recreate a sandbox snapshot for the same source sandbox Vault. This request replaces the existing snapshot with the newly created one.
+        API Documentation: https://developer.veevavault.com/api/23.2/#update-sandbox-snapshot
+
+        Parameters:
+            api_name (str): The API name of the snapshot to update.
+
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.update_sandbox_snapshot(api_name="veepharm_snapshot__c")
+
+        Returns:
+            dict: A dictionary containing the response status and job details of the update request.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot/{api_name}/actions/update"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.post(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def upgrade_sandbox_snapshot(self, api_name):
+        """
+        Upgrade a sandbox snapshot to match the release version of the source sandbox Vault. The request to upgrade a snapshot is only valid if the upgrade_status is "Upgrade Available" or "Upgrade Required".
+        API Documentation: https://developer.veevavault.com/api/23.2/#upgrade-sandbox-snapshot
+
+        Parameters:
+            api_name (str): The API name of the snapshot obtained from the Retrieve Sandbox Snapshots request.
+
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.upgrade_sandbox_snapshot(api_name="veepharm_snapshot__c")
+
+        Returns:
+            dict: A dictionary containing the response status and job details of the upgrade request.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/snapshot/{api_name}/actions/upgrade"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+
+        response = requests.post(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def build_production_vault(self, source):
+        """
+        Given a pre-production Vault, this method allows you to build a production Vault. This is analogous to the Build action in the Vault UI. It is possible to build or rebuild the source Vault for a given pre-production Vault no more than three times in a 24-hour period.
+        API Documentation: https://developer.veevavault.com/api/23.2/#build-production-vault
+        
+        Parameters:
+            source (str): The name of the source Vault to build. This can be the current pre-production Vault or a sandbox Vault. Sandboxes must be active and match the release type (General or Limited) of the pre-production Vault.
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.build_production_vault(source="UAT")
+        
+        Returns:
+            dict: A dictionary containing the response status and job details of the build request.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/actions/buildproduction"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json",
+            "Content-Type": "application/x-www-form-urlencoded"
+        }
+        data = {
+            "source": source
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def promote_to_production(self, name):
+        """
+        Given a built pre-production Vault, this method allows you to promote it to a production Vault. This action is analogous to the Promote action in the Vault UI. Note that you must build your pre-production Vault before you can promote it to production.
+        API Documentation: https://developer.veevavault.com/api/23.2/#promote-to-production
+        
+        Parameters:
+            name (str): The name of the pre-production Vault to promote.
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.promote_to_production(name="VeePharm")
+        
+        Returns:
+            dict: A dictionary containing the response status of the promotion request.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/sandbox/actions/promoteproduction"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json",
+            "Content-Type": "application/x-www-form-urlencoded"
+        }
+        data = {
+            "name": name
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+
+
+
+
+    #######################################################
+    # Logs
+    #######################################################
+
+
+    def retrieve_audit_types(self):
+        """
+        This method retrieves all available audit types that the user has permission to access.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-audit-types
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.retrieve_audit_types()
+        
+        Returns:
+            dict: A dictionary containing the response status and a list of available audit types.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/audittrail"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def retrieve_audit_metadata(self, audit_trail_type):
+        """
+        This method retrieves all fields and their metadata for a specified audit trail or log type.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-audit-metadata
+        
+        Args:
+            audit_trail_type (str): The name of the specified audit type (document_audit_trail, object_audit_trail, etc).
+        
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.retrieve_audit_metadata(audit_trail_type='document_audit_trail')
+        
+        Returns:
+            dict: A dictionary containing the response status and the metadata for the specified audit trail type.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/metadata/audittrail/{audit_trail_type}"
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def retrieve_audit_details(self, audit_trail_type, start_date=None, end_date=None, all_dates=None, format_result=None, limit=None, offset=None, objects=None, events=None):
+        """
+        This method retrieves all audit details for a specific audit type. This request supports optional parameters to narrow the results to a specified date and time within the past 30 days.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-audit-details
+
+        Args:
+            audit_trail_type (str): The name of the specified audit type. Use the Retrieve Audit Types API to retrieve types available in your Vault.
+            start_date (str, optional): The start date in YYYY-MM-DDTHH:MM:SSZ format to retrieve audit information.
+            end_date (str, optional): The end date in YYYY-MM-DDTHH:MM:SSZ format to retrieve audit information.
+            all_dates (bool, optional): Set to true to request audit information for all dates.
+            format_result (str, optional): To request a downloadable CSV file of your audit details, use 'csv'.
+            limit (int, optional): Specifies the maximum number of histories per page in the response.
+            offset (int, optional): Specifies the amount of offset from the entry returned.
+            objects (str, optional): A comma-separated list of one or more object names to retrieve their audit details.
+            events (str, optional): A comma-separated list of one or more audit events to retrieve their audit details.
+
+        Usage:
+            vv_instance = Vv()
+            response = vv_instance.retrieve_audit_details(audit_trail_type='login_audit_trail', start_date='2023-08-01T00:00:00Z', end_date='2023-08-31T00:00:00Z')
+
+        Returns:
+            dict: A dictionary containing the response details and data for the specified audit trail type.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/audittrail/{audit_trail_type}"
+        
+        headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        params = {
+            "start_date": start_date,
+            "end_date": end_date,
+            "all_dates": all_dates,
+            "format_result": format_result,
+            "limit": limit,
+            "offset": offset,
+            "objects": objects,
+            "events": events
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        if response.status_code == 200:
+            return response.json()
+        else:
+            return response.status_code, response.reason
+
+
+    def retrieve_complete_audit_history(self, doc_id, start_date=None, end_date=None, format_result=None, limit=None, offset=None, events=None):
+        """
+        Retrieve complete audit history for a single document.
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-complete-audit-history-for-a-single-document
+
+        Args:
+        doc_id (str): The document ID for which to retrieve audit history.
+        start_date (str): Specify a start date to retrieve audit history in YYYY-MM-DDTHH:MM:SSZ format. Defaults to the Vault’s creation date if omitted.
+        end_date (str): Specify an end date to retrieve audit history in YYYY-MM-DDTHH:MM:SSZ format. Defaults to today’s date if omitted.
+        format_result (str): To request a CSV file of the audit history, use 'csv'. Ignores start_date and end_date if used.
+        limit (int): Paginate the results by specifying the maximum number of histories per page in the response. Can be any value between 1 and 1000. Defaults to 200 if omitted.
+        offset (int): Paginate the results displayed per page by specifying the offset from the entry returned. Defaults to 0 if omitted.
+        events (str): Provide a comma-separated list of one or more audit events to retrieve their audit history. Defaults to all audit events if omitted.
+
+        Returns:
+        response (dict): A dictionary containing the response data from the API call.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/documents/{doc_id}/audittrail"
+        params = {
+            'start_date': start_date,
+            'end_date': end_date,
+            'format_result': format_result,
+            'limit': limit,
+            'offset': offset,
+            'events': events
+        }
+        headers = {
+            'Authorization': self.sessionId,
+            'Accept': 'application/json'
+        }
+        response = requests.get(url, headers=headers, params=params).json()
+        return response.json()
+
+
+    def retrieve_audit_history_single_object_record(self, object_name, object_record_id, start_date=None, end_date=None, format_result=None, limit=None, offset=None, events=None):
+        """
+        Retrieve complete audit history for a single object record.
+        
+        API Documentation: https://developer.veevavault.com/api/23.2/#retrieve-complete-audit-history-for-a-single-object-record
+        
+        Parameters:
+        object_name (str): The name__v of the object for which to retrieve audit history.
+        object_record_id (str): The object record ID for which to retrieve audit history.
+        start_date (str, optional): Specify a start date to retrieve audit history in YYYY-MM-DDTHH:MM:SSZ format. Defaults to Vault’s creation date if omitted.
+        end_date (str, optional): Specify an end date to retrieve audit history in YYYY-MM-DDTHH:MM:SSZ format. Defaults to today’s date if omitted.
+        format_result (str, optional): To request a CSV file of your audit history, use 'csv'. Defaults to None.
+        limit (int, optional): Paginate the results by specifying the maximum number of histories per page in the response, between 1 and 1000. Defaults to 200 if omitted.
+        offset (int, optional): Paginate the results displayed per page by specifying the amount of offset from the entry returned. Defaults to 0 if omitted.
+        events (str, optional): Provide a comma-separated list of one or more audit events to retrieve their audit history. Defaults to all audit events if omitted.
+        
+        Returns:
+        dict: The response data containing the audit history details.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/audittrail"
+        params = {
+            "start_date": start_date,
+            "end_date": end_date,
+            "format_result": format_result,
+            "limit": limit,
+            "offset": offset,
+            "events": events
+        }
+        headers = {
+            "Accept": "application/json",
+            "Authorization": self.sessionId
+        }
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+    def retrieve_email_notification_histories(self, start_date=None, end_date=None, all_dates=None, format_result=None, limit=200, offset=0):
+        """
+        Retrieves details about the email notifications sent by Vault. Details include the notification date, recipient, subject, and delivery status. 
+        Learn more at: https://developer.veevavault.com/api/23.2/#retrieve-email-notification-histories
+
+        Args:
+        start_date (str): Specify a start date to retrieve notification history in YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Defaults to None.
+        end_date (str): Specify an end date to retrieve notification history in YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Defaults to None.
+        all_dates (bool): Set to true to request notification history for all dates. Defaults to None.
+        format_result (str): To request a downloadable CSV file, set this parameter to 'csv'. Defaults to None.
+        limit (int): Specify the maximum number of histories per page in the response, between 1 and 1000. Defaults to 200.
+        offset (int): Specify the amount of offset from the entry returned. Defaults to 0.
+
+        Returns:
+        dict: The response from the API call.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/notifications/histories"
+        
+        params = {
+            'start_date': start_date,
+            'end_date': end_date,
+            'all_dates': all_dates,
+            'format_result': format_result,
+            'limit': limit,
+            'offset': offset
+        }
+        
+        response = requests.get(url, headers=self.APIheaders, params=params)
+        return response.json()
+
+
+    def download_daily_api_usage(self, date, log_format='csv'):
+        """
+        Retrieve the API Usage Log for a single day, up to 30 days in the past. The log contains information such as user name, user ID, remaining burst limit, and the endpoint called. 
+        API documentation: https://developer.veevavault.com/api/23.2/#download-daily-api-usage
+
+        :param date: The day to retrieve the API Usage log in 'YYYY-MM-DD' format. Date cannot be more than 30 days in the past.
+        :param log_format: Optional parameter to specify the format to download. Possible values are 'csv' or 'logfile'. If omitted, defaults to 'csv'.
+        
+        :return: The response containing the log as a .ZIP file.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/logs/api_usage"
+        params = {
+            "date": date,
+            "log_format": log_format
+        }
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        with open('response.zip', 'wb') as file:
+            file.write(response.content)
+        
+        return response.json()
+
+
+    def download_sdk_runtime_log(self, date, log_format='csv'):
+        """
+        Retrieve the Runtime Log for a single day, up to 30 days in the past. Users with the Admin: Logs: Vault Java SDK Logs permission can access these logs.
+        API documentation: https://developer.veevavault.com/api/23.2/#download-sdk-runtime-log
+
+        :param date: The day to retrieve the runtime log in 'YYYY-MM-DD' format. Date cannot be more than 30 days in the past.
+        :param log_format: Optional parameter to specify the format to download. Possible values are 'csv' or 'logfile'. If omitted, defaults to 'csv'.
+        
+        :return: The response containing the log as a .ZIP file.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/logs/code/runtime"
+        params = {
+            "date": date,
+            "log_format": log_format
+        }
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        with open(f'{date}-SdkLog.zip', 'wb') as file:
+            file.write(response.content)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # File Staging
+    #######################################################
+
+
+    def list_items_at_path(self, item, recursive=False, limit=1000, format_result=None):
+        """
+        Return a list of files and folders for the specified path. Paths are different for Admin users (Vault Owners and System Admins) and non-Admin users. 
+        API documentation: https://developer.veevavault.com/api/23.2/#list-items-at-a-path
+
+        :param item: The absolute path to a file or folder. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
+        :param recursive: If true, the response will contain the contents of all subfolders. If not specified, the default value is false.
+        :param limit: The maximum number of items per page in the response. This can be any value between 1 and 1000. If omitted, the default value is 1000.
+        :param format_result: If set to csv, the response includes a job_id. Use the Job ID value to retrieve the status and results of the request.
+
+        :return: The response containing the list of items at the specified path.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items/{item}"
+        params = {
+            "recursive": recursive,
+            "limit": limit,
+            "format_result": format_result
+        }
+        headers = {
+            "Accept": "application/json",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+    def download_item_content(self, item, byte_range=None):
+        """
+        Retrieve the content of a specified file from the file staging server. Use the Range header to create resumable downloads for large files, or to continue downloading a file if your session is interrupted.
+        API documentation: https://developer.veevavault.com/api/23.2/#download-item-content
+
+        :param item: The absolute path to a file. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
+        :param byte_range: Optional: Specifies a partial range of bytes to include in the download.
+
+        :return: The content of the specified file.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items/content/{item}"
+        headers = {
+            "Authorization": f"{self.sessionId}"
+        }
+        if byte_range:
+            headers["Range"] = f"bytes={byte_range}"
+
+        response = requests.get(url, headers=headers)
+        return response.content
+
+    def create_folder_or_file(self, kind, path, overwrite=None, file_content=None):
+        """
+        Upload files or folders up to 50MB to the File Staging Server. You can only create one file or folder per request.
+        API documentation: https://developer.veevavault.com/api/23.2/#create-folder-or-file
+        
+        :param kind: The kind of item to create. This can be either file or folder.
+        :param path: The absolute path, including file or folder name, to place the item in the file staging server. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
+        :param overwrite: Optional: If set to true, Vault will overwrite any existing files with the same name at the specified destination. For folders, this is always false.
+        :param file_content: To upload a file, use the multi-part attachment with the file component. The maximum allowed file size is 50MB.
+        
+        :return: Response from the API as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json",
+            "Content-Type": "multipart/form-data"
+        }
+        data = {
+            "kind": kind,
+            "path": path
+        }
+        if overwrite is not None:
+            data["overwrite"] = overwrite
+        if file_content:
+            data["file"] = file_content
+
+        response = requests.post(url, headers=headers, data=data)
+        return response.json()
+
+
+    def update_folder_or_file(self, item, parent=None, name=None):
+        """
+        Move or rename a folder or file on the file staging server. You can move and rename an item in the same request.
+        API documentation: https://developer.veevavault.com/api/23.2/#update-folder-or-file
+        
+        :param item: The absolute path to a file or folder. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
+        :param parent: Conditional: When moving a file or folder, specifies the absolute path to the parent directory in which to place the file.
+        :param name: Conditional: When renaming a file or folder, specifies the new name.
+        
+        :return: Response from the API as a dictionary containing job ID and URL to check the job status.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items/{item}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        data = {}
+        if parent:
+            data["parent"] = parent
+        if name:
+            data["name"] = name
+
+        response = requests.put(url, headers=headers, data=data)
+        return response.json()
+
+
+
+    def delete_file_or_folder(self, item, recursive=False):
+        """
+        Delete an individual file or folder from the file staging server.
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-file-or-folder
+        
+        :param item: The absolute path to the file or folder to delete. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
+        :param recursive: Applicable to deleting folders only. If true, the request will delete the contents of a folder and all subfolders. The default is false.
+        
+        :return: Response from the API as a dictionary containing job ID and URL to check the job status.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/items/{item}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        params = {
+            "recursive": recursive
+        }
+        
+        response = requests.delete(url, headers=headers, params=params)
+        return response.json()
+
+
+
+    #######################################################
+    # File Staging
+    ## Resumable Upload Sessions
+    #######################################################
+
+    def create_resumable_upload_session(self, path, size, overwrite=False):
+        """
+        Initiate a multipart upload session and return an upload session ID.
+        API documentation: https://developer.veevavault.com/api/23.2/#create-resumable-upload-session
+        
+        :param path: The absolute path, including file name, to place the file in the staging server. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
+        :param size: The size of the file in bytes. The maximum file size is 500GB.
+        :param overwrite: If set to true, Vault will overwrite any existing files with the same name at the specified destination. Default is False.
+        
+        :return: Response from the API as a dictionary containing details about the created upload session.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json",
+            "Content-Type": "application/x-www-form-urlencoded"
+        }
+        data = {
+            'path': path,
+            'size': size,
+            'overwrite': overwrite
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        return response.json()
+
+
+    def upload_to_session(self, upload_session_id, file_part, part_number, content_length, content_md5=None):
+        """
+        The session owner can upload parts of a file to an active upload session.
+        API documentation: https://developer.veevavault.com/api/23.2/#upload-to-a-session
+        
+        :param upload_session_id: The upload session ID.
+        :param file_part: The file part to be uploaded as binary data.
+        :param part_number: The part number, which uniquely identifies a file part and defines its position within the file as a whole.
+        :param content_length: The size of the file part in bytes. Parts must be at least 5MB in size, except for the last part uploaded in a session.
+        :param content_md5: Optional: The MD5 checksum of the file part being uploaded.
+        
+        :return: Response from the API as a dictionary containing details about the uploaded file part.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json",
+            "Content-Type": "application/octet-stream",
+            "Content-Length": str(content_length),
+            "X-VaultAPI-FilePartNumber": str(part_number)
+        }
+        if content_md5:
+            headers["Content-MD5"] = content_md5
+        
+        response = requests.put(url, headers=headers, data=file_part)
+        return response.json()
+
+
+
+    def commit_upload_session(self, upload_session_id):
+        """
+        Mark an upload session as complete and assemble all previously uploaded parts to create a file.
+        API documentation: https://developer.veevavault.com/api/23.2/#commit-upload-session
+        
+        :param upload_session_id: The upload session ID.
+        
+        :return: Response from the API as a dictionary containing job_id for the commit.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json",
+            "Content-Type": "application/json"
+        }
+        
+        response = requests.post(url, headers=headers)
+        return response.json()
+
+
+    def list_upload_sessions(self):
+        """
+        Return a list of active upload sessions.
+        API documentation: https://developer.veevavault.com/api/23.2/#list-upload-sessions
+        
+        :return: Response from the API as a dictionary containing details of all active upload sessions.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+
+    def get_upload_session_details(self, upload_session_id):
+        """
+        Retrieve the details of an active upload session. Admin users can get details for all sessions, while non-Admin users can only get details for sessions if they are the owner.
+        API documentation: https://developer.veevavault.com/api/23.2/#get-upload-session-details
+        
+        :param upload_session_id: The ID of the upload session to retrieve details for.
+        :return: Response from the API as a dictionary containing the details of the specified upload session.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def list_file_parts_uploaded_to_session(self, upload_session_id, limit=1000):
+        """
+        Return a list of parts uploaded in a session. You must be an Admin user or the session owner.
+        API documentation: https://developer.veevavault.com/api/23.2/#list-file-parts-uploaded-to-session
+        
+        :param upload_session_id: The ID of the upload session to retrieve the uploaded file parts for.
+        :param limit: Optional parameter to specify the maximum number of items per page in the response, default is 1000.
+        :return: Response from the API as a dictionary containing the list of uploaded file parts and pagination details.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}/parts"
+        params = {"limit": limit}
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+    def abort_upload_session(self, upload_session_id):
+        """
+        Abort an active upload session and purge all uploaded file parts. Admin users can see and abort all upload sessions, while non-Admin users can only see and abort sessions where they are the owner.
+        API documentation: https://developer.veevavault.com/api/23.2/#abort-upload-session
+        
+        :param upload_session_id: The ID of the upload session to be aborted.
+        :return: Response from the API as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/upload/{upload_session_id}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.delete(url, headers=headers)
+        return response.json()
+
+
+
+
+    #######################################################
+    # Vault Loader
+    #######################################################
+
+    #######################################################
+    # Vault Loader
+    ## Multi-File Extract
+    #######################################################
+
+
+    def extract_data_files(self, data_objects, sendNotification=False):
+        """
+        Create a Loader job to extract one or more data files.
+        API documentation: https://developer.veevavault.com/api/23.2/#extract-data-files
+        
+        :param data_objects: List of dictionaries representing the data objects to extract.
+        :param sendNotification: Whether to send a Vault notification when the job completes. Defaults to False.
+        :return: Response from the API as a dictionary.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/extract"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        params = {
+            "sendNotification": sendNotification
+        }
+        
+        response = requests.post(url, headers=headers, params=params, json=data_objects)
+        return response.json()
+
+
+    def retrieve_loader_extract_results(self, job_id, task_id):
+        """
+        Retrieve the results of a specified job task after submitting a request to extract object types from your Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-loader-extract-results
+
+        :param job_id: The ID value of the requested extract job.
+        :param task_id: The ID value of the requested extract task.
+        :return: Response from the API as a string (CSV format).
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/{job_id}/tasks/{task_id}/results"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "text/csv"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.text
+
+
+    def retrieve_loader_extract_renditions_results(self, job_id, task_id):
+        """
+        Retrieve the results of a specified job task that includes renditions requested with documents from your Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-loader-extract-renditions-results
+
+        :param job_id: The ID value of the requested extract job.
+        :param task_id: The ID value of the requested extract task.
+        :return: Response from the API as a string (CSV format).
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/{job_id}/tasks/{task_id}/results/renditions"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "text/csv"
+        }
+        
+        response = requests.get(url, headers=headers)
+        return response.text
+
+
+
+
+
+
+
+    #######################################################
+    # Vault Loader
+    ## Multi-File Load
+    #######################################################
+
+    def load_data_objects(self, data_objects, send_notification=False):
+        """
+        Create a loader job and load a set of data files in the Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#load-data-objects
+
+        :param data_objects: A list of dictionaries representing data objects to load. 
+        :param send_notification: Boolean indicating whether to send a Vault notification when the job completes.
+        :return: Response from the API in JSON format.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/load"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        params = {
+            "sendNotification": send_notification
+        }
+        response = requests.post(url, headers=headers, json=data_objects, params=params)
+        return response.json()
+
+
+    def retrieve_load_success_log_results(self, job_id, task_id):
+        """
+        Retrieve success logs of the loader results from the Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-load-success-log-results
+
+        :param job_id: The ID value of the requested extract job.
+        :param task_id: The ID value of the requested extract task.
+        :return: CSV file that includes the success log of the loader results.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/{job_id}/tasks/{task_id}/successlog"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "text/csv"
+        }
+        response = requests.get(url, headers=headers)
+        return response.content
+
+
+    def retrieve_load_failure_log_results(self, job_id, task_id):
+        """
+        Retrieve failure logs of the loader results from the Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-load-failure-log-results
+
+        :param job_id: The ID value of the requested extract job.
+        :param task_id: The ID value of the requested extract task.
+        :return: CSV file that includes the failure log of the loader results.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/loader/{job_id}/tasks/{task_id}/failurelog"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "text/csv"
+        }
+        response = requests.get(url, headers=headers)
+        return response.content
+
+
+
+
+    #######################################################
+    # Jobs
+    #######################################################
+
+
+    def retrieve_job_status(self, job_id):
+        """
+        Retrieve the status of a job previously requested through the API from the Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-job-status
+
+        :param job_id: The ID of the job, returned from the original job request.
+        :return: JSON object containing details about the job status.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/{job_id}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_job_tasks(self, job_id):
+        """
+        Retrieve the tasks associated with an SDK job in the Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-job-tasks
+
+        :param job_id: The ID of the job, returned from the original job request.
+        :return: JSON object containing details about the job tasks.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/{job_id}/tasks"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+    def retrieve_job_histories(self, start_date=None, end_date=None, status=None, limit=None, offset=None):
+        """
+        Retrieve a history of all completed jobs in the authenticated Vault. 
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-job-histories
+
+        :param start_date: Sets the date to start retrieving completed jobs, in the format YYYY-MM-DDTHH:MM:SSZ. Optional.
+        :param end_date: Sets the date to end retrieving completed jobs, in the format YYYY-MM-DDTHH:MM:SSZ. Optional.
+        :param status: Filter to only retrieve jobs in a certain status. Optional.
+        :param limit: Paginate the results by specifying the maximum number of histories per page in the response. Optional.
+        :param offset: Paginate the results displayed per page by specifying the amount of offset from the first job history returned. Optional.
+        :return: JSON object containing details about the job histories.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/histories"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        params = {
+            "start_date": start_date,
+            "end_date": end_date,
+            "status": status,
+            "limit": limit,
+            "offset": offset
+        }
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+    def retrieve_job_monitors(self, start_date=None, end_date=None, status=None, limit=None, offset=None):
+        """
+        Retrieve monitors for jobs which have not yet completed in the authenticated Vault. 
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-job-monitors
+
+        :param start_date: Sets the date to start retrieving uncompleted jobs, based on the date and time the job instance was created. Optional.
+        :param end_date: Sets the date to end retrieving uncompleted jobs, based on the date and time the job instance was created. Optional.
+        :param status: Filter to only retrieve jobs in a certain status. Optional.
+        :param limit: Paginate the results by specifying the maximum number of jobs per page in the response. Optional.
+        :param offset: Paginate the results displayed per page by specifying the amount of offset from the first job instance returned. Optional.
+        :return: JSON object containing details about the job monitors.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/monitors"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        params = {
+            "start_date": start_date,
+            "end_date": end_date,
+            "status": status,
+            "limit": limit,
+            "offset": offset
+        }
+        response = requests.get(url, headers=headers, params=params)
+        return response.json()
+
+
+
+    def start_job(self, job_id):
+        """
+        Moves up a scheduled job instance to start immediately. Each time a user calls this API, Vault cancels the next scheduled instance of the specified job. 
+        API documentation: https://developer.veevavault.com/api/23.2/#start-job
+
+        :param job_id: The ID of the scheduled job instance to start.
+        :return: JSON object containing the response details.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/jobs/start_now/{job_id}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.post(url, headers=headers)
+        return response.json()
+
+
+
+    #######################################################
+    # Managing Vault Java SDK
+    #######################################################
+
+
+    def retrieve_single_source_code_file(self, class_name):
+        """
+        Retrieve a single source code file from the currently authenticated Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-single-source-code-file
+        
+        :param class_name: The fully qualified class name of your file.
+        :return: The source code file content.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/code/{class_name}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.get(url, headers=headers)
+        return response.text
+
+
+    def enable_or_disable_vault_extension(self, class_name, action):
+        """
+        Enable or disable a deployed Vault extension in the currently authenticated Vault. 
+        Only available on entry-point classes, such as triggers and actions.
+        API documentation: https://developer.veevavault.com/api/23.2/#enable-or-disable-vault-extension
+
+        :param class_name: The fully qualified class name of your file.
+        :param action: The action to be performed - either 'enable' or 'disable'.
+        :return: API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/code/{class_name}/{action}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json",
+            "Content-Type": "multipart/form-data"
+        }
+        response = requests.put(url, headers=headers)
+        return response.json()
+
+
+    def add_or_replace_single_source_code_file(self, file_path):
+        """
+        Add or replace a single .java file in the currently authenticated Vault. If the given file does not already exist in the Vault, it is added. If the file already exists in the Vault, the file is updated. It is not recommended to use this endpoint to deploy code as it may introduce code that breaks existing deployed code. For best practices, use the VPK Deploy method.
+        API documentation: https://developer.veevavault.com/api/23.2/#add-or-replace-single-source-code-file
+
+        :param file_path: The path to the .java file you wish to add or replace.
+        :return: API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/code"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json",
+            "Content-Type": "multipart/form-data"
+        }
+        with open(file_path, 'rb') as file:
+            response = requests.put(url, headers=headers, files={'file': file})
+        return response.json()
+
+
+    def delete_single_source_code_file(self, class_name):
+        """
+        Delete a single source code file from the currently authenticated Vault. This endpoint is not recommended for use as it may delete code that breaks existing deployed code. For best practices, use the VPK Deploy method. Note that you cannot delete a code component currently in use.
+        API documentation: https://developer.veevavault.com/api/23.2/#delete-single-source-code-file
+
+        :param class_name: The fully qualified class name of the file to be deleted.
+        :return: API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/code/{class_name}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.delete(url, headers=headers)
+        return response.json()
+
+
+    def validate_imported_package(self, package_id):
+        """
+        Validate a previously imported VPK package with Vault Java SDK code. Note that this endpoint does not validate component dependencies for Configuration Migration packages.
+        API documentation: https://developer.veevavault.com/api/23.2/#validate-imported-package
+
+        :param package_id: The ID of the package to validate, which can be found in the API response of a package import or in the URL of the package in the Vault UI.
+        :return: API response.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/vobject/vault_package__v/{package_id}/actions/validate"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.post(url, headers=headers)
+        return response.json()
+
+
+    def retrieve_signing_certificate(self, cert_id):
+        """
+        Allows you to retrieve a signing certificate included in a Spark message header to verify that the received message came from Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-signing-certificate
+
+        :param cert_id: The cert_id is provided in each Spark message in the X-VaultAPISignature-CertificateId header.
+        :return: The public key certificate (.pem) file used for message verification.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/certificate/{cert_id}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.get(url, headers=headers)
+        return response.text
+
+
+    def retrieve_all_queues(self):
+        """
+        Retrieve all queues in a Vault.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-all-queues
+        
+        :return: A list of all available queues and their operational statuses.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+
+    def retrieve_queue_status(self, queue_name):
+        """
+        Retrieve the status of a specific queue.
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-queue-status
+        
+        :param queue_name: The name of a specific queue. For example, queue__c.
+        :return: The status of the specified queue including delivery status, number of messages in the queue, and details of the last message delivered.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues/{queue_name}"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.get(url, headers=headers)
+        return response.json()
+
+
+    def disable_delivery(self, queue_name):
+        """
+        Disable the delivery of messages in an outbound Spark messaging queue or an SDK job queue.
+        API documentation: https://developer.veevavault.com/api/23.2/#disable-delivery
+        
+        :param queue_name: The name of a specific queue.
+        :return: Response status of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues/{queue_name}/actions/disable_delivery"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.put(url, headers=headers)
+        return response.json()
+
+
+    def enable_delivery(self, queue_name):
+        """
+        Enable the delivery of messages in an outbound Spark messaging queue or an SDK job queue.
+        API documentation: https://developer.veevavault.com/api/23.2/#enable-delivery
+        
+        :param queue_name: The name of a specific queue.
+        :return: Response status of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues/{queue_name}/actions/enable_delivery"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.put(url, headers=headers)
+        return response.json()
+
+    def reset_queue(self, queue_name):
+        """
+        Delete all messages in a specific queue. This action is final and cannot be undone.
+        API documentation: https://developer.veevavault.com/api/23.2/#reset-queue
+        
+        :param queue_name: The name of a specific queue.
+        :return: Response status and message of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/queues/{queue_name}/actions/reset"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        response = requests.put(url, headers=headers)
+        return response.json()
+
+
+
+
+
+
+    #######################################################
+    # Clinical Operations
+    #######################################################
+
+    def create_edls(self, study_id, file_content, content_type='text/csv', accept='text/csv', apply_where_edl_items_exist=None):
+        """
+        Create a new Expected Document List.
+        API documentation: https://developer.veevavault.com/api/23.2/#create-edls
+        
+        :param study_id: The ID of the study.
+        :param file_content: The content of the file to be uploaded in text/csv format.
+        :param content_type: The content type of the request, defaults to 'text/csv'.
+        :param accept: The format in which to receive the response, defaults to 'text/csv'.
+        :param apply_where_edl_items_exist: Optional parameter to apply the Create EDL job to existing EDLs.
+        :return: Response status and job details of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/study__v/{study_id}/actions/etmfcreateedl"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": content_type,
+            "Accept": accept
+        }
+        params = {
+            "applyWhereEdlItemsExist": apply_where_edl_items_exist
+        }
+        response = requests.post(url, headers=headers, data=file_content, params=params)
+        return response.json()
+
+
+    def recalculate_milestone_document_field(self, file_content):
+        """
+        Recalculate the milestone__v field on a specified set of documents.
+        API documentation: https://developer.veevavault.com/api/23.2/#recalculate-milestone-document-field
+        
+        :param file_content: The content of the CSV file to be uploaded, which contains document id values in an id column.
+        :return: Response status and message of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/recalculatemilestones/batch"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+        response = requests.post(url, headers=headers, data=file_content)
+        return response.json()
+
+
+    def apply_edl_template_to_milestone(self, milestone_id, edl_id):
+        """
+        Apply an EDL template to a Milestone object record.
+        API documentation: https://developer.veevavault.com/api/23.2/#apply-edl-template-to-a-milestone
+
+        :param milestone_id: The ID of the milestone.
+        :param edl_id: The ID of the EDL template to apply to this milestone.
+        :return: Response status and job details of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/milestone__v/{milestone_id}/actions/etmfcreateedl"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        data = {
+            "edl_id": edl_id
+        }
+        response = requests.post(url, headers=headers, data=data)
+        return response.json()
+
+
+    def create_milestones_from_template(self, object_name, object_record_id):
+        """
+        Use this request to initiate the Create Milestones from Template user action on a study, study country, or site.
+        API documentation: https://developer.veevavault.com/api/23.2/#create-milestones-from-template
+
+        :param object_name: The object name__v field value. This endpoint only works with the study__v, study_country__v, or site__v objects.
+        :param object_record_id: The object record ID field value.
+        :return: Response status and job details of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/{object_name}/{object_record_id}/actions/createmilestones"
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+        response = requests.post(url, headers=headers)
+        return response.json()
+
+
+
+    def execute_milestone_story_events(self, object_name, csv_file_path, id_param=None):
+        """
+        Use this request to create Milestones based on specific Story Events for multiple studies, study countries, or sites.
+        API documentation: https://developer.veevavault.com/api/23.2/#execute-milestone-story-events
+
+        :param object_name: The object name__v field value. This endpoint only works with the study__v, study_country__v, or site__v objects.
+        :param csv_file_path: Path to the CSV input file containing details to create milestones.
+        :param id_param: (Optional) Unique field name to identify objects in the CSV input, if not using id.
+        :return: Response details containing job IDs or errors.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/clinical/milestone/{object_name}/actions/applytemplate"
+        if id_param:
+            url += f"?idParam={id_param}"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+
+        with open(csv_file_path, 'rb') as f:
+            response = requests.post(url, headers=headers, data=f)
+        
+        return response.json()
+
+
+
+    def veeva_site_connect_distribute_to_sites(self, distribution_id):
+        """
+        This API allows sponsors and CROs to send Safety reports and letters to Sites. 
+        API documentation: https://developer.veevavault.com/api/23.2/#veeva-site-connect-distribute-to-sites
+
+        :param distribution_id: The record ID of the Safety Distribution record to send. Must be in a Ready or Distributed state.
+        :return: Response details containing job ID and message.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/clinical/safety_distributions/{distribution_id}/actions/send"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+
+        response = requests.post(url, headers=headers)
+        
+        return response.json()
+
+
+
+    def populate_site_fee_definitions(self, target_study, source_study=None, source_template=None):
+        """
+        Given an existing study with Site Fee Definitions or an eligible Site Fee Template, 
+        automatically generate Site Fee Definitions for a new target study. 
+        This endpoint is only available in CTMS Vaults with the Vault Payments add-on.
+        API documentation: https://developer.veevavault.com/api/23.2/#populate-site-fee-definitions
+
+        :param target_study: The new study to populate with Site Fee Definitions.
+        :param source_study: (Optional) To copy the Site Fee Definitions from studies, include an array with the study IDs.
+        :param source_template: (Optional) To copy the Site Fee Definitions from Site Fee Templates, include an array with the template IDs.
+        :return: Response details containing status and other information.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/clinical/payments/populate-site-fee-definitions"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+
+        data = {
+            "target_study": target_study,
+        }
+        if source_study:
+            data["source_study"] = source_study
+        if source_template:
+            data["source_template"] = source_template
+
+        response = requests.post(url, headers=headers, json=data)
+        
+        return response.json()
+
+
+
+
+    #######################################################
+    # PromoMats
+    #######################################################
+
+    def create_document_update_job(self):
+        """
+        Vault owners can update documents with a Global Content Type of 'Not Specified' to a mapped value. 
+        Learn more about Configuring PromoMats Standard Metrics in Vault Help.
+        API documentation: https://developer.veevavault.com/api/23.2/#standard-metrics-create-document-update-job
+
+        :return: Response details containing jobInstanceId and any errors encountered.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/standardMetrics/createDocumentUpdateJob"
+
+        headers = {
+            "Authorization": f"{self.sessionId}"
+        }
+
+        response = requests.post(url, headers=headers)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # QualityDocs
+    #######################################################
+
+    def document_role_check_for_document_change_control(self, object_record_id, application_role):
+        """
+        Check if any document added to a Document Change Control (DCC) record has one or more users in a specified 
+        Application Role. This API only checks documents added to the standard Documents to be Released and Documents 
+        to be Made Obsolete sections.
+        API documentation: https://developer.veevavault.com/api/23.2/#document-role-check-for-document-change-control
+
+        :param object_record_id: The ID field value of the document_change_control__v object record.
+        :param application_role: The name of the application_role__v.
+        :return: Response details including the Boolean check_result field.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/document_change_control__v/{object_record_id}/actions/documentrolecheck"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+
+        data = {
+            "application_role": application_role
+        }
+
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # QMS
+    #######################################################
+
+
+    def update_quality_team_members(self, object_name, csv_file_path):
+        """
+        Manage Quality Team members on existing records. This endpoint does not support initial Quality Team record 
+        migrations or the creation of new Quality Teams on existing process records. Vault performs updates to Quality 
+        Team assignments asynchronously on behalf of the user.
+        API documentation: https://developer.veevavault.com/api/23.2/#update-quality-team-members
+
+        :param object_name: The object name__v field value for the team-enabled object. 
+                            For example, risk_event__v, investigation__qdm, quality_event__qdm.
+        :param csv_file_path: The path to the CSV file containing the necessary parameters.
+        :return: Response details including the job_id for the action.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/quality/qms/teams/vobjects/{object_name}/actions/manageassignments"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "text/csv"
+        }
+
+        with open(csv_file_path, 'rb') as f:
+            response = requests.post(url, headers=headers, data=f)
+        
+        return response.json()
+
+
+
+
+
+    #######################################################
+    # RIM Submissions Archive
+    #######################################################
+
+    def import_submission(self, submission_id, file_path):
+        """
+        Import a submission into your Vault. Before executing this request, ensure you have the necessary permissions, 
+        created the required object records in your Vault, and uploaded a valid submission import file or folder to your 
+        file staging server following the proper structure.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#import-submission
+
+        :param submission_id: The id field value of the submission__v object record.
+        :param file_path: The path to the submission folder or ZIP file relative to the file staging server root 
+                        or to the path to your user file staging folder.
+        :return: Response details including the job_id and the URL to check the current status of the import request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/import"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Accept": "application/json"
+        }
+
+        data = {
+            "file": file_path
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+    def retrieve_submission_import_results(self, submission_id, job_id):
+        """
+        Retrieve the results of a completed submission import job. Before executing this request, ensure 
+        you have the necessary permissions and that the submission import job is completed (no longer active).
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-submission-import-results
+
+        :param submission_id: The id field value of the submission__v object record.
+        :param job_id: The jobId field value returned from the Import Submission request.
+        :return: Response details including the id, major_version_number__v, and minor_version_number__v of the created submission binder.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/import/{job_id}/results"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+
+    def retrieve_submission_metadata_mapping(self, submission_id):
+        """
+        Retrieve the metadata mapping values of an eCTD submission package. Before executing this request, 
+        make sure you have the necessary permissions.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-submission-metadata-mapping
+
+        :param submission_id: The id field value of the submission__v object record.
+        :return: Response details including metadata mapping records and relevant details such as name__v, 
+                external_id__v, xml_id and possible mappings like clinical_site__v, clinical_study__v, etc.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/ectdmapping"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.get(url, headers=headers)
+
+        return response.json()
+
+
+
+    def update_submission_metadata_mapping(self, submission_id, mapping_values):
+        """
+        Update the mapping values of a submission. Note that XML identifiers are read-only and cannot be updated via the API. 
+
+        API documentation: https://developer.veevavault.com/api/23.2/#update-submission-metadata-mapping
+
+        :param submission_id: The id field value of the submission__v object record.
+        :param mapping_values: A list of dictionaries containing mapping values to be updated.
+        :return: Response details including success status and details of updated mapping values.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/ectdmapping"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+
+        response = requests.put(url, headers=headers, json=mapping_values)
+
+        return response.json()
+
+
+
+    def remove_submission(self, submission_id):
+        """
+        Delete a previously imported submission from your Vault. By removing a submission, you delete any sections created in the archive binder as part of the submission import. This action also removes any documents in the submission from the archive binder but does not delete the documents from Vault.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#remove-submission
+
+        :param submission_id: The id field value of the submission__v object record.
+        :return: Response details including job ID and URL to check the job status.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/import"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        response = requests.delete(url, headers=headers)
+
+        return response.json()
+
+
+
+    def cancel_submission(self, submission_id):
+        """
+        Cancel an ongoing submission import or removal process. Depending on the current archive status of the submission, this action will have different outcomes as described in the API documentation. To proceed with a new import, the submission must be removed first if it was in the import or removal process.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#cancel-submission
+
+        :param submission_id: The id field value of the submission__v object record.
+        :return: Response details including the status of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/vobjects/submission__v/{submission_id}/actions/import"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        params = {
+            "cancel": "true"
+        }
+
+        response = requests.post(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+
+    def export_submission(self, binder_id, submission_id, major_version=None, minor_version=None):
+        """
+        Export a submission, allowing to either export the most recent version or a specific version of a Submissions Archive binder. The function supports two types of requests based on whether the major_version and minor_version are provided or not.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#export-submission
+
+        :param binder_id: The id field value of the binder.
+        :param submission_id: The id field value of the submission__v object record.
+        :param major_version: (Optional) The major_version_number__v field value of the binder.
+        :param minor_version: (Optional) The minor_version_number__v field value of the binder.
+        :return: Response details including the URL to check the status of the export job and the job_id.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        if major_version is not None and minor_version is not None:
+            url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export"
+        else:
+            url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/actions/export"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+
+        params = {
+            "submission": submission_id
+        }
+
+        response = requests.post(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+    def export_partial_submission(self, binder_id, submission_id, major_version, minor_version, file_path):
+        """
+        Exports specific sections and documents from a submissions binder in Vault. Depending on the major_version and minor_version parameters, it can either export from the latest version or a specific version of the submissions binder.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#export-partial-submission
+
+        :param binder_id: The id field value of the binder.
+        :param submission_id: The id field value of the submission__v object record.
+        :param major_version: The major_version_number__v field value of the binder.
+        :param minor_version: The minor_version_number__v field value of the binder.
+        :param file_path: The path to the CSV or JSON file containing the id values of the binder sections and/or documents to be exported.
+        :return: Response details including the URL to check the status of the export job and the job_id.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export"
+
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "text/csv",
+            "Accept": "application/json"
+        }
+
+        params = {
+            "submission": submission_id
+        }
+
+        with open(file_path, 'rb') as f:
+            response = requests.post(url, headers=headers, params=params, data=f)
+        
+        return response.json()
+
+
+    def download_exported_submission_files(self, job_id):
+        """
+        Downloads the files of a successfully completed submission export job from the file staging server. The files are packaged in a ZIP file on the file staging server.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#download-exported-submission-files-via-file-staging-server
+
+        :param job_id: The job ID of the successfully completed submission export job.
+        :return: A message indicating the status of the download operation.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/services/file_staging/jobs/{job_id}/files"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        response = requests.get(url, headers=headers)
+        
+        return response.json()
+
+    def copy_into_content_plan(self, source_id, target_id, order, copy_documents):
+        """
+        Copies a content plan section or item to reuse existing content and prevent duplicate work. This operation can be used to copy a clinical study or quality section and its matched documents for a similar submission to a different application.
+
+        API documentation: https://developer.veevavault.com/api/23.2/#copy-into-content-plan
+
+        :param source_id: The ID of the content plan or content plan item to copy.
+        :param target_id: The ID of the parent content plan where the source content plan will be copied under. The target content plan cannot be inactive.
+        :param order: An integer indicating the position in the target content plan where the source content plan will be copied. A value of 1 indicates the first position in the target content plan.
+        :param copy_documents: A boolean value indicating whether matched documents are included in the copy. If false, matched documents are not included in the copy. This parameter cannot be omitted.
+        :return: A JSON response containing the job ID of the asynchronous copy operation or the record ID of the newly copied content plan item.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/rim/content_plans/actions/copyinto"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "application/json",
+            "Accept": "application/json"
+        }
+        
+        body = {
+            "source_id": source_id,
+            "target_id": target_id,
+            "order": order,
+            "copy_documents": copy_documents
+        }
+        
+        response = requests.post(url, headers=headers, json=body)
+        
+        return response.json()
+
+
+
+    #######################################################
+    # Safety
+    #######################################################
+
+    #######################################################
+    # Safety
+    ## Intake
+    #######################################################
+
+
+
+    def intake_inbox_item(self, file_path, origin_organization, format, organization, transmission_profile=None):
+        """
+        Imports an Inbox Item from an E2B (R2) or E2B (R3) file containing one or more Individual Case Safety Reports (ICSRs).
+
+        API documentation: https://developer.veevavault.com/api/23.2/#intake-inbox-item
+
+        :param file_path: The file path of the E2B file to be imported.
+        :param origin_organization: (Optional) The Vault API Name for the organization sending the E2B file. If not provided, the Origin Organization is left blank.
+        :param format: The format of the file being imported, which must match the Vault API Name of the Inbound Transmission Format picklist value. It should be an E2B format.
+        :param organization: (Optional) To specify which organization to send the Case to, enter the Vault API Name for the Organization record. If not provided, the Organization is set to vault_customer__v. Note that the Organization record type must be Sponsor.
+        :param transmission_profile: (Optional) The Vault API Name of the Transmission Profile to be used for E2B Intake. This parameter is necessary for Narrative Template Override and Inbox Item Auto-Promotion. If not provided, Vault uses parameters on the general_api_profile__v.
+        
+        :return: A JSON response containing the URL to retrieve the current status of the import request and the intake ID of the E2B import.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/intake/inbox-item"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data"
+        }
+        
+        data = {
+            'file': ('file', open(file_path, 'rb')),
+            'origin-organization': origin_organization,
+            'format': format,
+            'organization': organization
+        }
+        
+        if transmission_profile:
+            data['transmission-profile'] = transmission_profile
+        
+        response = requests.post(url, headers=headers, files=data)
+        
+        return response.json()
+
+
+    def intake_imported_case(self, file_path, format, organization, origin_organization=None):
+        """
+        Imports an Imported Case from an E2B (R2) or E2B (R3) file containing one or more Individual Case Safety Reports (ICSRs).
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#intake-imported-case
+
+        :param file_path: The file path of the E2B file to be imported.
+        :param format: The format of the file being imported, which must match the Vault API Name of the Inbound Transmission Format picklist value. Must be an E2B format or other__v.
+        :param organization: (Optional) To specify which organization to send the Case to, enter the Vault API Name for the Organization record. If not provided, the Organization is set to vault_customer__v.
+        :param origin_organization: (Optional) The Vault API Name for the organization sending the E2B file. If not provided, the Origin Organization is left blank.
+        
+        :return: A JSON response containing the URL to retrieve the current status of the import request and the intake ID of the E2B import.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/intake/imported-case"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Content-Type": "multipart/form-data"
+        }
+        
+        data = {
+            'file': ('file', open(file_path, 'rb')),
+            'format': format,
+            'organization': organization
+        }
+        
+        if origin_organization:
+            data['origin-organization'] = origin_organization
+        
+        response = requests.post(url, headers=headers, files=data)
+        
+        return response.json()
+
+
+
+
+    def retrieve_intake_status(self, inbound_id):
+        """
+        Retrieve the status of an intake API call using the inbound transmission ID for the ICSR intake job.
+        
+        API documentation: https://developer.veevavault.com/api/23.2/#retrieve-intake-status
+
+        :param inbound_id: The Inbound Transmission ID for the ICSR intake job.
+        
+        :return: A JSON response containing details about the status of the intake job including processing status, ACK retrieval URL, inbound transmission and document IDs, number of cases and their statuses.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/intake/status"
+        
+        headers = {
+            "Authorization": f"{self.sessionId}",
+            "Accept": "application/json"
+        }
+        
+        params = {
+            'inbound_id': inbound_id
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        return response.json()
+
+
+
+    def retrieve_ack(self, inbound_id):
+        """
+        Retrieve the E2B acknowledgement message (ACK) after sending an intake call.
+        API Documentation URL: https://developer.veevavault.com/api/23.2/#retrieve-ack
+        
+        Args:
+            inbound_id (str): The Inbound Transmission ID for the ICSR intake job.
+            
+        Returns:
+            str: The response containing the ACK XML or a failure message.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/intake/ack"
+        params = {'inbound_id': inbound_id}
+        headers = {
+            'Authorization': f"{self.sessionId}",
+            'Accept': 'application/json'
+        }
+        
+        response = requests.get(url, headers=headers, params=params)
+        
+        if response.status_code == 200:
+            return response.text
+        else:
+            return response.json()
+
+
+
+
+
+
+    #######################################################
+    # Safety
+    ## Intake JSON
+    #######################################################
+
+    def intake_json(self, api_name, intake_json, intake_form=None):
+        """
+        Use this endpoint to send JSON to Vault Safety, which will be imported to a single Inbox Item.
+        API Documentation URL: https://developer.veevavault.com/api/23.2/#intake-json
+        
+        Args:
+            api_name (str): The Vault API Name for the Organization record.
+            intake_json (str): The filepath for the JSON intake file, or the raw JSON text.
+            intake_form (str, optional): The filepath for a source intake document.
+            
+        Returns:
+            dict: The response containing job details or a failure message.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/ai/intake?API_Name={api_name}"
+        
+        headers = {
+            'Authorization': f"{self.sessionId}",
+            'Content-Type': 'application/json' if intake_form is None else 'multipart/form-data'
+        }
+        
+        data = {
+            'intake_json': intake_json,
+            'intake_form': intake_form
+        }
+        
+        response = requests.post(url, headers=headers, data=data)
+        
+        return response.json()
+
+
+    #######################################################
+    # Safety
+    ## Import Narrative
+    #######################################################
+
+    def import_narrative(self, case_id, narrative_type, narrative_language, narrative_text, link_translation_to_primary=False):
+        """
+        Use this endpoint to import narrative text into a Case narrative.
+        API Documentation URL: https://developer.veevavault.com/api/23.2/#import-narrative
+
+        Args:
+            case_id (str): Destination Case or Adverse Event Report ID.
+            narrative_type (str): Type of narrative - 'primary' or 'translation'.
+            narrative_language (str): Three-letter ISO 639-2 language code.
+            narrative_text (str): Narrative text to be imported, limited to 100000 characters.
+            link_translation_to_primary (bool): Set to true to add the localized narrative document as a supporting document to the global (English) narrative document. Defaults to False.
+
+        Returns:
+            dict: The response containing status of the request.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/import-narrative"
+
+        headers = {
+            'Authorization': f"{self.sessionId}",
+            'caseId': case_id,
+            'narrativeType': narrative_type,
+            'narrativeLanguage': narrative_language,
+            'Content-Type': 'text/plain',
+            'link_translation_to_primary': str(link_translation_to_primary).lower()
+        }
+
+        response = requests.post(url, headers=headers, data=narrative_text)
+
+        return response.json()
+
+
+    def bulk_import_narrative(self, narratives_file_path, integrity_check=False, migration_mode=False, archive_document=None):
+        """
+        Use this endpoint to bulk import case narratives into Vault Safety.
+        API Documentation URL: https://developer.veevavault.com/api/23.2/#bulk-import-narrative
+
+        Args:
+            narratives_file_path (str): The file path of the CSV containing the narratives to be imported.
+            integrity_check (bool): Optional: Set to true to perform additional integrity checks on the CSV file. Defaults to false.
+            migration_mode (bool): Optional: Set to true to perform additional verifications on the localizedCaseId. Defaults to false.
+            archive_document (bool): Optional: Set to true to send the imported narrative documents directly to the document archive, or false to create the imported documents as active narratives. Defaults to None.
+
+        Returns:
+            dict: The response containing the status of the request and details of the import operation.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/import-narrative/batch/"
+
+        headers = {
+            'Content-Type': 'multipart/form-data',
+            'Accept': 'text/csv',
+            'Authorization': f"{self.sessionId}",
+            'X-VaultAPI-IntegrityCheck': str(integrity_check).lower(),
+            'X-VaultAPI-MigrationMode': str(migration_mode).lower()
+        }
+
+        if archive_document is not None:
+            headers['X-VaultAPI-ArchiveDocument'] = str(archive_document).lower()
+
+        with open(narratives_file_path, 'rb') as f:
+            files = {'narratives': f}
+            response = requests.post(url, headers=headers, files=files)
+
+        return response.json()
+
+
+    def retrieve_bulk_import_status(self, import_id):
+        """
+        Use this endpoint to retrieve the status of a bulk narrative import.
+        API Documentation URL: https://developer.veevavault.com/api/23.2/#retrieve-bulk-import-status
+
+        Args:
+            import_id (str): The import_id of the bulk narrative import job, retrieved from the job request response details.
+
+        Returns:
+            dict: The response containing the status and details of the bulk narrative import job.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/safety/import-narrative/batch/{import_id}"
+
+        headers = {
+            'Authorization': f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+
+        return response.json()
+
+
+
+    #######################################################
+    # SiteVault
+    #######################################################
+
+    def retrieve_documents_and_signatories(self, participant_id):
+        """
+        Retrieve the valid blank ICFs and signatories for a participant.
+        API Documentation URL: https://developer.veevavault.com/api/23.2/#retrieve-documents-and-signatories
+
+        Args:
+            participant_id (str): The SiteVault ID of the participant. Use the /query REST interface to query the Participant (subject__v) object for the participant ID.
+
+        Returns:
+            list: The response listing the valid blank ICFs and signatories for the participant.
+        """
+        self.LatestAPIversion = 'v23.2'
+
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/sitevault/econsent/participant/{participant_id}"
+
+        headers = {
+            'Authorization': f"{self.sessionId}"
+        }
+
+        response = requests.get(url, headers=headers)
+
+        return response.json()
+
+    def send_documents_to_signatories(self, documents_version_id, signatory_id, signatory_role, subject_id):
+        """
+        Send documents to signatories for signature.
+        API Documentation URL: https://developer.veevavault.com/api/23.2/#send-documents-to-signatories
+
+        Args:
+            documents_version_id (str): The ID of the blank ICF.
+            signatory_id (str): The ID of the signatory.
+            signatory_role (str): The role of the signatory.
+            subject_id (str): The ID of the participant.
+
+        Returns:
+            dict: The response listing the participant, the blank ICF, any signatories, and a job ID.
+        """
+        self.LatestAPIversion = 'v23.2'
+        
+        url = f"{self.vaultURL}/api/{self.LatestAPIversion}/app/sitevault/econsent/send"
+        
+        headers = {
+            'Authorization': f"{self.sessionId}",
+            'Content-Type': 'application/json'
+        }
+        
+        payload = {
+            "documents.version_id__v": documents_version_id,
+            "signatory__v.id": signatory_id,
+            "signatory__v.role__v": signatory_role,
+            "subject__v.id": subject_id
+        }
+        
+        response = requests.post(url, headers=headers, json=payload)
+        
+        return response.json()
+
+
+    #######################################################
+    ## Custom Functions
+    #######################################################
+    
+    
+    def call_url(self, url, method='GET', data=None, headers=None, params=None):
+        
+        default_headers = {
+            "Authorization": self.sessionId,
+            "Accept": "application/json"
+        }
+        
+        headers = default_headers if headers is None else headers
+        url = self.vaultURL + url
+        
+        if method == 'GET':
+            response = requests.get(url, headers=headers, params=params)
+        elif method == 'POST':
+            response = requests.post(url, headers=headers, data=data)
+        elif method == 'PUT':
+            response = requests.put(url, headers=headers, data=data)
+        elif method == 'DELETE':
+            response = requests.delete(url, headers=headers)
+        else:
+            raise Exception(f"Invalid method: {method}")
+        
+        return response.json()
+    
+
+    async def retrieve_and_download_config_report(self):
+        """
+        Kicks off a config report job, monitors its status, and downloads the report file once the job is successful.
+
+        Args:
+            self: The Veeva Vault client instance.
+
+        Returns:
+            None
+        """
+        # Step 1: Kick off the config report job
+        result = self.vault_configuration_report()
+        job_id = result.get('job_id')
+        
+        if not job_id:
+            print("Failed to initiate the job.")
+            return
+
+        # Step 2: Check the job status every 10 seconds
+        while True:
+            time.sleep(10)
+            status_result = self.retrieve_job_status(str(job_id))
+            job_status = status_result.get('data', {}).get('status')
+            
+            if job_status == 'SUCCESS':
+                print("Job completed successfully.")
+                break
+            else:
+                print("Job still executing... Checking again in 10 seconds.")
+
+        # Step 3: Download the file if the job was successful
+        artifact_url = status_result.get('data', {}).get('links', [])[1].get('href')
+        headers = {
+            "Content-Type": "application/x-www-form-urlencoded",
+            "Authorization": f"{self.sessionId}"
+        }
+
+        vaultId = self.vaultId
+        iso_datetime = datetime.now().isoformat(timespec='seconds').replace(':', '-')
+        response = requests.get(artifact_url, headers=headers)
+        if response.status_code == 200:
+            with open(f'{iso_datetime}_vault_{vaultId}_config_report.zip', 'wb') as file:
+                file.write(response.content)
+            print("File downloaded successfully")
+        else:
+            print(f"Failed to download the file. HTTP Status Code: {response.status_code}")
```

