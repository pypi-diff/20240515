# Comparing `tmp/pysui-0.59.0-py3-none-any.whl.zip` & `tmp/pysui-0.60.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,72 +1,72 @@
-Zip file size: 233703 bytes, number of entries: 95
+Zip file size: 234496 bytes, number of entries: 95
 -rw-r--r--  2.0 unx      633 b- defN 24-Feb-05 10:35 env/bin/rst2html.py
 -rw-r--r--  2.0 unx      755 b- defN 24-Feb-05 10:35 env/bin/rst2html4.py
 -rw-r--r--  2.0 unx     1090 b- defN 24-Feb-05 10:35 env/bin/rst2html5.py
 -rw-r--r--  2.0 unx      832 b- defN 24-Feb-05 10:35 env/bin/rst2latex.py
 -rw-r--r--  2.0 unx      655 b- defN 24-Feb-05 10:35 env/bin/rst2man.py
 -rw-r--r--  2.0 unx      821 b- defN 24-Feb-05 10:35 env/bin/rst2odt.py
 -rw-r--r--  2.0 unx      627 b- defN 24-Feb-05 10:35 env/bin/rst2odt_prepstyles.py
 -rw-r--r--  2.0 unx      640 b- defN 24-Feb-05 10:35 env/bin/rst2pseudoxml.py
 -rw-r--r--  2.0 unx      676 b- defN 24-Feb-05 10:35 env/bin/rst2s5.py
 -rw-r--r--  2.0 unx      912 b- defN 24-Feb-05 10:35 env/bin/rst2xetex.py
 -rw-r--r--  2.0 unx      641 b- defN 24-Feb-05 10:35 env/bin/rst2xml.py
 -rw-r--r--  2.0 unx      709 b- defN 24-Feb-05 10:35 env/bin/rstpep2html.py
 -rw-r--r--  2.0 unx     1472 b- defN 23-Jul-27 10:38 pysui/__init__.py
--rw-r--r--  2.0 unx      716 b- defN 24-Apr-23 02:03 pysui/version.py
+-rw-r--r--  2.0 unx      716 b- defN 24-May-02 10:19 pysui/version.py
 -rw-r--r--  2.0 unx     1028 b- defN 23-Dec-12 10:57 pysui/abstracts/__init__.py
 -rw-r--r--  2.0 unx    12823 b- defN 24-Mar-14 10:16 pysui/abstracts/client_config.py
 -rw-r--r--  2.0 unx     4537 b- defN 24-Apr-06 09:25 pysui/abstracts/client_keypair.py
 -rw-r--r--  2.0 unx     3215 b- defN 23-Feb-21 10:38 pysui/abstracts/client_rpc.py
 -rw-r--r--  2.0 unx     2333 b- defN 23-Mar-30 17:41 pysui/abstracts/client_types.py
 -rw-r--r--  2.0 unx      951 b- defN 23-Aug-01 09:48 pysui/sui/__init__.py
--rw-r--r--  2.0 unx     7305 b- defN 24-May-01 08:47 pysui/sui/sui_apidesc.py
+-rw-r--r--  2.0 unx     7305 b- defN 24-May-14 08:26 pysui/sui/sui_apidesc.py
 -rw-r--r--  2.0 unx     3388 b- defN 23-Mar-30 17:41 pysui/sui/sui_bcs.py
 -rw-r--r--  2.0 unx    29644 b- defN 24-Apr-12 09:29 pysui/sui/sui_config.py
 -rw-r--r--  2.0 unx     5706 b- defN 24-Apr-06 09:01 pysui/sui/sui_constants.py
 -rw-r--r--  2.0 unx    28721 b- defN 24-Apr-06 09:27 pysui/sui/sui_crypto.py
 -rw-r--r--  2.0 unx     2778 b- defN 23-Mar-30 17:41 pysui/sui/sui_excepts.py
 -rw-r--r--  2.0 unx     4881 b- defN 24-May-02 09:05 pysui/sui/sui_txn_validator.py
 -rw-r--r--  2.0 unx    23961 b- defN 24-Feb-29 10:16 pysui/sui/sui_utils.py
 -rw-r--r--  2.0 unx      657 b- defN 23-Feb-21 10:42 pysui/sui/sui_builders/__init__.py
 -rw-r--r--  2.0 unx    14665 b- defN 24-May-02 09:12 pysui/sui/sui_builders/base_builder.py
 -rw-r--r--  2.0 unx     6005 b- defN 24-Jan-24 09:03 pysui/sui/sui_builders/exec_builders.py
 -rw-r--r--  2.0 unx    33767 b- defN 24-May-02 09:39 pysui/sui/sui_builders/get_builders.py
 -rw-r--r--  2.0 unx     3544 b- defN 23-May-03 08:36 pysui/sui/sui_builders/subscription_builders.py
 -rw-r--r--  2.0 unx      710 b- defN 23-Feb-21 10:41 pysui/sui/sui_clients/__init__.py
 -rw-r--r--  2.0 unx    23088 b- defN 24-Feb-15 09:47 pysui/sui/sui_clients/async_client.py
--rw-r--r--  2.0 unx    13557 b- defN 24-Apr-26 08:46 pysui/sui/sui_clients/common.py
+-rw-r--r--  2.0 unx    13557 b- defN 24-May-15 08:26 pysui/sui/sui_clients/common.py
 -rw-r--r--  2.0 unx    17397 b- defN 24-Apr-11 08:52 pysui/sui/sui_clients/subscribe.py
 -rw-r--r--  2.0 unx    22556 b- defN 24-May-01 20:47 pysui/sui/sui_clients/sync_client.py
 -rw-r--r--  2.0 unx      140 b- defN 24-Mar-23 09:39 pysui/sui/sui_pgql/__init__.py
--rw-r--r--  2.0 unx    22909 b- defN 24-Apr-14 08:46 pysui/sui/sui_pgql/pgql_clients.py
--rw-r--r--  2.0 unx     2654 b- defN 24-Apr-14 09:28 pysui/sui/sui_pgql/pgql_configs.py
--rw-r--r--  2.0 unx    23621 b- defN 24-May-01 09:23 pysui/sui/sui_pgql/pgql_fragments.py
--rw-r--r--  2.0 unx    55757 b- defN 24-May-01 09:29 pysui/sui/sui_pgql/pgql_query.py
--rw-r--r--  2.0 unx    28272 b- defN 24-Apr-28 10:17 pysui/sui/sui_pgql/pgql_sync_txn.py
--rw-r--r--  2.0 unx     5835 b- defN 24-Mar-23 09:40 pysui/sui/sui_pgql/pgql_txb_gas.py
+-rw-r--r--  2.0 unx    20001 b- defN 24-May-15 08:22 pysui/sui/sui_pgql/pgql_clients.py
+-rw-r--r--  2.0 unx     2654 b- defN 24-May-11 08:34 pysui/sui/sui_pgql/pgql_configs.py
+-rw-r--r--  2.0 unx    24015 b- defN 24-May-10 09:37 pysui/sui/sui_pgql/pgql_fragments.py
+-rw-r--r--  2.0 unx    57677 b- defN 24-May-05 10:51 pysui/sui/sui_pgql/pgql_query.py
+-rw-r--r--  2.0 unx    28365 b- defN 24-May-14 08:48 pysui/sui/sui_pgql/pgql_sync_txn.py
+-rw-r--r--  2.0 unx     5890 b- defN 24-May-14 08:51 pysui/sui/sui_pgql/pgql_txb_gas.py
 -rw-r--r--  2.0 unx     4655 b- defN 24-Apr-22 09:53 pysui/sui/sui_pgql/pgql_txb_signing.py
--rw-r--r--  2.0 unx     9663 b- defN 24-Apr-28 10:11 pysui/sui/sui_pgql/pgql_txn_argb.py
--rw-r--r--  2.0 unx    39669 b- defN 24-Apr-23 01:32 pysui/sui/sui_pgql/pgql_types.py
+-rw-r--r--  2.0 unx    11482 b- defN 24-May-14 09:27 pysui/sui/sui_pgql/pgql_txn_argb.py
+-rw-r--r--  2.0 unx    41225 b- defN 24-May-14 09:20 pysui/sui/sui_pgql/pgql_types.py
 -rw-r--r--  2.0 unx     3722 b- defN 24-Mar-23 09:41 pysui/sui/sui_pgql/pgql_validators.py
 -rw-r--r--  2.0 unx      933 b- defN 23-Aug-10 21:16 pysui/sui/sui_txn/__init__.py
 -rw-r--r--  2.0 unx    51464 b- defN 24-Mar-18 09:19 pysui/sui/sui_txn/async_transaction.py
 -rw-r--r--  2.0 unx    13421 b- defN 24-Feb-19 10:27 pysui/sui/sui_txn/signing_ms.py
 -rw-r--r--  2.0 unx    51915 b- defN 24-Mar-18 09:19 pysui/sui/sui_txn/sync_transaction.py
 -rw-r--r--  2.0 unx    20923 b- defN 24-Mar-18 09:20 pysui/sui/sui_txn/transaction.py
--rw-r--r--  2.0 unx    24256 b- defN 24-Mar-17 11:35 pysui/sui/sui_txn/transaction_builder.py
+-rw-r--r--  2.0 unx    24607 b- defN 24-May-13 21:22 pysui/sui/sui_txn/transaction_builder.py
 -rw-r--r--  2.0 unx     8062 b- defN 23-Nov-05 10:00 pysui/sui/sui_txn/txn_deser.py
 -rw-r--r--  2.0 unx      867 b- defN 23-Feb-21 10:43 pysui/sui/sui_txresults/__init__.py
 -rw-r--r--  2.0 unx     2114 b- defN 23-Apr-11 10:06 pysui/sui/sui_txresults/common.py
 -rw-r--r--  2.0 unx    19637 b- defN 24-Jan-18 09:12 pysui/sui/sui_txresults/complex_tx.py
 -rw-r--r--  2.0 unx     9592 b- defN 23-Apr-20 08:19 pysui/sui/sui_txresults/package_meta.py
 -rw-r--r--  2.0 unx    34404 b- defN 24-Jan-30 09:44 pysui/sui/sui_txresults/single_tx.py
 -rw-r--r--  2.0 unx      785 b- defN 23-Feb-21 10:39 pysui/sui/sui_types/__init__.py
 -rw-r--r--  2.0 unx     4206 b- defN 23-Jul-23 20:01 pysui/sui/sui_types/address.py
--rw-r--r--  2.0 unx    26146 b- defN 24-Mar-17 10:02 pysui/sui/sui_types/bcs.py
+-rw-r--r--  2.0 unx    27567 b- defN 24-May-13 20:43 pysui/sui/sui_types/bcs.py
 -rw-r--r--  2.0 unx     5226 b- defN 24-Jan-24 08:49 pysui/sui/sui_types/collections.py
 -rw-r--r--  2.0 unx     9550 b- defN 24-Apr-11 08:52 pysui/sui/sui_types/event_filter.py
 -rw-r--r--  2.0 unx    12959 b- defN 24-Jan-24 09:01 pysui/sui/sui_types/scalars.py
 -rw-r--r--  2.0 unx     6523 b- defN 23-Jul-27 11:00 pysui/sui/sui_types/transaction_filter.py
 -rw-r--r--  2.0 unx      647 b- defN 23-Feb-21 10:46 pysui/sui_move/__init__.py
 -rw-r--r--  2.0 unx      653 b- defN 23-Feb-21 10:45 pysui/sui_move/bin_reader/__init__.py
 -rw-r--r--  2.0 unx     6811 b- defN 23-Feb-21 10:45 pysui/sui_move/bin_reader/module_reader.py
@@ -84,14 +84,14 @@
 -rw-r--r--  2.0 unx     4235 b- defN 24-Apr-03 09:31 samples/cmd_arg_validators.py
 -rw-r--r--  2.0 unx    26970 b- defN 24-Apr-07 10:06 samples/cmd_args.py
 -rw-r--r--  2.0 unx    21465 b- defN 24-Apr-07 10:09 samples/cmd_argsg.py
 -rw-r--r--  2.0 unx    23598 b- defN 23-Dec-27 09:51 samples/cmds.py
 -rw-r--r--  2.0 unx    19264 b- defN 24-Apr-07 10:35 samples/cmdsg.py
 -rw-r--r--  2.0 unx     2061 b- defN 24-Apr-01 10:04 samples/wallet.py
 -rw-r--r--  2.0 unx     1572 b- defN 24-Apr-02 11:41 samples/walletg.py
--rw-r--r--  2.0 unx    11357 b- defN 24-May-02 09:48 pysui-0.59.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     5651 b- defN 24-May-02 09:48 pysui-0.59.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-May-02 09:48 pysui-0.59.0.dist-info/WHEEL
--rw-r--r--  2.0 unx      191 b- defN 24-May-02 09:48 pysui-0.59.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       27 b- defN 24-May-02 09:48 pysui-0.59.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     8163 b- defN 24-May-02 09:48 pysui-0.59.0.dist-info/RECORD
-95 files, 967449 bytes uncompressed, 220861 bytes compressed:  77.2%
+-rw-r--r--  2.0 unx    11357 b- defN 24-May-15 08:27 pysui-0.60.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     5658 b- defN 24-May-15 08:27 pysui-0.60.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-15 08:27 pysui-0.60.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx      191 b- defN 24-May-15 08:27 pysui-0.60.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       27 b- defN 24-May-15 08:27 pysui-0.60.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     8164 b- defN 24-May-15 08:27 pysui-0.60.0.dist-info/RECORD
+95 files, 972158 bytes uncompressed, 221654 bytes compressed:  77.2%
```

## zipnote {}

```diff
@@ -261,26 +261,26 @@
 
 Filename: samples/wallet.py
 Comment: 
 
 Filename: samples/walletg.py
 Comment: 
 
-Filename: pysui-0.59.0.dist-info/LICENSE
+Filename: pysui-0.60.0.dist-info/LICENSE
 Comment: 
 
-Filename: pysui-0.59.0.dist-info/METADATA
+Filename: pysui-0.60.0.dist-info/METADATA
 Comment: 
 
-Filename: pysui-0.59.0.dist-info/WHEEL
+Filename: pysui-0.60.0.dist-info/WHEEL
 Comment: 
 
-Filename: pysui-0.59.0.dist-info/entry_points.txt
+Filename: pysui-0.60.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: pysui-0.59.0.dist-info/top_level.txt
+Filename: pysui-0.60.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pysui-0.59.0.dist-info/RECORD
+Filename: pysui-0.60.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pysui/version.py

```diff
@@ -8,9 +8,9 @@
 #    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #    See the License for the specific language governing permissions and
 #    limitations under the License.
 
 # -*- coding: utf-8 -*-
 
 # Read in command line and posting to PyPi
-__version__ = "0.59.0"
+__version__ = "0.60.0"
 """Pysui Version."""
```

## pysui/sui/sui_clients/common.py

```diff
@@ -143,15 +143,15 @@
     """Abstract Mix-in.
 
     Inherited by both Synch and Async clients to ensure
     constructor consistency as well as utility functions
     """
 
     _RPC_MINIMAL_VERSION: str = "1.18.0"
-    _RPC_REQUIRED_VERSION: str = "1.25.0"
+    _RPC_REQUIRED_VERSION: str = "1.24.0"
 
     @versionchanged(
         version="0.26.1",
         reason="Added bool flag indicating state of underlying transport",
     )
     @versionchanged(
         version="0.28.0",
```

## pysui/sui/sui_pgql/pgql_clients.py

```diff
@@ -19,14 +19,15 @@
 from gql.transport import exceptions as texc
 from gql.dsl import (
     DSLSchema,
 )
 from graphql import DocumentNode, print_ast, GraphQLSchema
 from graphql.error.syntax_error import GraphQLSyntaxError
 from graphql.utilities.print_schema import print_schema
+from graphql.language.printer import print_ast
 
 
 from pysui import SuiConfig, SuiRpcResult
 from pysui.sui.sui_pgql.pgql_validators import TypeValidator
 import pysui.sui.sui_pgql.pgql_types as pgql_type
 from pysui.sui.sui_pgql.pgql_configs import pgql_config, SuiConfigGQL
 import pysui.sui.sui_constants as cnst
@@ -98,15 +99,15 @@
 
 class BaseSuiGQLClient:
     """Base GraphQL client."""
 
     # TODO: Move these to constants
     _SUI_GRAPHQL_MAINNET: str = "https://sui-mainnet.mystenlabs.com/graphql"
     _SUI_GRAPHQL_TESTNET: str = "https://sui-testnet.mystenlabs.com/graphql"
-    _SUI_GRAPHQL_DEVNET: str = "https://sui-devnet.mystenlabs.com/graphql"
+    _SUI_GRAPHQL_DEVNET: str = "https://sui-devnet.mystenlabs.com/graphql/stable"
     _SCHEMA_HEADER_KEY: str = "X-Sui-RPC-Version"
 
     @classmethod
     def _resolve_url(
         cls, sui_config: SuiConfig, schema_version: Optional[str] = None
     ) -> list[str, str]:
         """Resolve the GraphQL RPC Url."""
@@ -218,36 +219,53 @@
         """schema Return the DSLSchema for configuration
 
         :return: DSLSchema for Sui Schema version associated with connection.
         :rtype: DSLSchema
         """
         return self._schema
 
+    def _qnode_owner(self, qnode: PGQL_QueryNode):
+        """."""
+        if hasattr(qnode, "owner"):
+            resolved_owner = TypeValidator.check_owner(
+                getattr(qnode, "owner"), self.config
+            )
+            setattr(qnode, "owner", resolved_owner)
+
     def _qnode_pre_run(
         self, qnode: PGQL_QueryNode, schema_constraint: Union[str, None] = None
     ) -> Union[DocumentNode, ValueError]:
         """."""
         if issubclass(type(qnode), PGQL_QueryNode):
-            if hasattr(qnode, "owner"):
-                resolved_owner = TypeValidator.check_owner(
-                    getattr(qnode, "owner"), self.config
-                )
-                setattr(qnode, "owner", resolved_owner)
+            self._qnode_owner(qnode)
+            # if hasattr(qnode, "owner"):
+            #     resolved_owner = TypeValidator.check_owner(
+            #         getattr(qnode, "owner"), self.config
+            #     )
+            #     setattr(qnode, "owner", resolved_owner)
             # TODO If schema constrained than pass the correct schema
             # to the document builder
             if qnode.schema_constraint:
                 pass
             dnode = qnode.as_document_node(self.schema)
             if isinstance(dnode, DocumentNode):
                 return dnode, qnode.schema_constraint
             else:
                 raise ValueError("QueryNode did not produce a gql DocumentNode")
         else:
             raise ValueError("Not a valid PGQL_QueryNode")
 
+    @versionadded(version="0.60.0", reason="Support query inspection")
+    def query_node_to_string(
+        self, qnode: PGQL_QueryNode, schema_constraint: Union[str, None] = None
+    ) -> str:
+        """."""
+        self._qnode_owner(qnode)
+        return print_ast(qnode.as_document_node(self.schema))
+
 
 class SuiGQLClient(BaseSuiGQLClient):
     """Synchronous pysui GraphQL client."""
 
     def __init__(
         self,
         *,
@@ -286,15 +304,16 @@
 
     @versionadded(
         version="0.56.0", reason="Common node execution with exception handling"
     )
     def _execute(
         self,
         node: DocumentNode,
-        schema_constraint: Optional[Union[str, None]],
+        schema_constraint: Optional[str] = None,
+        with_headers: Optional[dict] = None,
         encode_fn: Optional[Callable[[dict], Any]] = None,
     ) -> SuiRpcResult:
         """_execute Execute a GQL Document Node
 
         :param node: GQL DocumentNode
         :type node: DocumentNode
         :param schema_constraint: Should run against specific schema
@@ -306,15 +325,17 @@
         """
         try:
             sres = self.client.execute(node)
             return SuiRpcResult(True, None, sres if not encode_fn else encode_fn(sres))
 
         except texc.TransportQueryError as gte:
             return SuiRpcResult(
-                False, "TransportQueryError", pgql_type.ErrorGQL.from_query(gte.errors)
+                False,
+                f"TransportQueryError {gte.errors}",
+                pgql_type.ErrorGQL.from_query(gte.errors),
             )
         except (
             httpx.HTTPError,
             httpx.InvalidURL,
             httpx.CookieConflict,
         ) as hexc:
             return SuiRpcResult(
@@ -322,120 +343,82 @@
             )
         except GraphQLSyntaxError as gqe:
             return SuiRpcResult(
                 False,
                 "GraphQLSyntaxError",
                 pgql_type.ErrorGQL.from_query(gqe.formatted),
             )
+        except TypeError as te:
+            return SuiRpcResult(
+                False, "TypeError", pgql_type.ErrorGQL.from_query(te.args)
+            )
         except ValueError as ve:
             return SuiRpcResult(
                 False, "ValueError", pgql_type.ErrorGQL.from_query(ve.args)
             )
 
     @versionadded(version="0.56.0", reason="Unique function for string processing")
     def execute_query_string(
         self,
         *,
         string: str,
-        schema_constraint: Optional[Union[str, None]] = None,
+        schema_constraint: Optional[str] = None,
+        with_headers: Optional[dict] = None,
         encode_fn: Optional[Callable[[dict], Any]] = None,
     ) -> SuiRpcResult:
         """."""
         if isinstance(string, str):
-            return self._execute(gql(string), schema_constraint, encode_fn)
+            return self._execute(
+                gql(string), schema_constraint, with_headers, encode_fn
+            )
         else:
             return SuiRpcResult(False, "ValueError:Expected string", string)
 
     @versionadded(
         version="0.56.0", reason="Unique function for DocumentNode processing"
     )
     def execute_document_node(
         self,
         *,
         with_node: DocumentNode,
-        schema_constraint: Optional[Union[str, None]] = None,
+        schema_constraint: Optional[str] = None,
+        with_headers: Optional[dict] = None,
         encode_fn: Optional[Callable[[dict], Any]] = None,
     ) -> SuiRpcResult:
         """."""
         if isinstance(with_node, DocumentNode):
-            return self._execute(with_node, schema_constraint, encode_fn)
+            return self._execute(with_node, schema_constraint, with_headers, encode_fn)
         else:
             return SuiRpcResult(False, "Not a valid gql DocumentNode", with_node)
 
     @versionadded(
         version="0.56.0", reason="Unique function for PGQL_QueryNode processing"
     )
     def execute_query_node(
         self,
         *,
         with_node: PGQL_QueryNode,
-        schema_constraint: Optional[Union[str, None]] = None,
+        schema_constraint: Optional[str] = None,
+        with_headers: Optional[dict] = None,
         encode_fn: Optional[Callable[[dict], Any]] = None,
     ) -> SuiRpcResult:
         """."""
         try:
             qdoc_node, _sc_constraint = self._qnode_pre_run(
                 with_node, schema_constraint
             )
             if isinstance(qdoc_node, PGQL_NoOp):
                 return SuiRpcResult(True, None, pgql_type.NoopGQL.from_query())
             encode_fn = encode_fn or with_node.encode_fn()
-            return self._execute(qdoc_node, schema_constraint, encode_fn)
+            return self._execute(qdoc_node, schema_constraint, with_headers, encode_fn)
         except ValueError as ve:
             return SuiRpcResult(
                 False, "ValueError", pgql_type.ErrorGQL.from_query(ve.args)
             )
 
-    @deprecated(
-        version="0.56.0",
-        reason="Use explicit execute for type (str,DocumentNode,PGQL_QueryNode. This will be deleted in version 0.60.0)",
-    )
-    def execute_query(
-        self,
-        *,
-        with_string: Optional[str] = None,
-        with_document_node: Optional[DocumentNode] = None,
-        with_query_node: Optional[PGQL_QueryNode] = None,
-        encode_fn: Optional[Callable[[dict], Any]] = None,
-    ) -> SuiRpcResult:
-        """Executes a GraphQL query and returns raw result.
-
-        with_string and with_document_node and with_query_node are mutually exclusive.
-        with_string takes precedence, then with_document_node then with_query_node. If none is
-        specific an error is returned.
-
-        :param with_string: A python string query, defaults to None
-        :type with_string: Optional[str], optional
-        :param with_document_node: A gql DocumentNode query, defaults to None
-        :type with_document_node: Optional[DocumentNode], optional
-        :param with_query_node: A pysui GraphQL QueryNode, defaults to None
-        :type with_query_node: Optional[PGQL_QueryNode], optional
-        :param encode_fn: Encoding function taking dict as arg and returning Any, defaults to None
-            This can be used on any 'with_' option. If used in addition to with_query_node it
-            will override the builder property of same name if defined
-        :type encode_fn: Optional[Callable[[dict], Any]], optional
-        :return: SuiRpcResult cointaining status and raw result (dict) or that defined by serialization function
-        :rtype: SuiRpcResult
-        """
-
-        if with_string:
-            return self.execute_query_string(string=with_string, encode_fn=encode_fn)
-        elif with_document_node:
-            return self.execute_document_node(
-                with_node=with_document_node, encode_fn=encode_fn
-            )
-        elif with_query_node:
-            return self.execute_query_node(
-                with_node=with_query_node, encode_fn=encode_fn
-            )
-        return SuiRpcResult(
-            False,
-            "Call requires python str, gql.DocumentNode, or PGQL_QueryNode types",
-        )
-
 
 class AsyncSuiGQLClient(BaseSuiGQLClient):
     """Asynchronous pysui GraphQL client."""
 
     def __init__(
         self,
         *,
@@ -481,15 +464,16 @@
 
     @versionadded(
         version="0.56.0", reason="Common node execution with exception handling"
     )
     async def _execute(
         self,
         node: DocumentNode,
-        schema_constraint: Optional[Union[str, None]],
+        schema_constraint: Optional[str] = None,
+        with_headers: Optional[dict] = None,
         encode_fn: Optional[Callable[[dict], Any]] = None,
     ) -> SuiRpcResult:
         """_execute Execute a GQL Document Node
 
         :param node: GQL DocumentNode
         :type node: DocumentNode
         :param schema_constraint: Should run against specific schema
@@ -520,113 +504,78 @@
             )
         except GraphQLSyntaxError as gqe:
             return SuiRpcResult(
                 False,
                 "GraphQLSyntaxError",
                 pgql_type.ErrorGQL.from_query(gqe.formatted),
             )
+        except TypeError as te:
+            return SuiRpcResult(
+                False, "TypeError", pgql_type.ErrorGQL.from_query(te.args)
+            )
         except ValueError as ve:
             return SuiRpcResult(
                 False, "ValueError", pgql_type.ErrorGQL.from_query(ve.args)
             )
 
     @versionadded(version="0.56.0", reason="Unique function for string processing")
     async def execute_query_string(
         self,
         *,
         string: str,
-        schema_constraint: Optional[Union[str, None]] = None,
+        schema_constraint: Optional[str] = None,
+        with_headers: Optional[dict] = None,
         encode_fn: Optional[Callable[[dict], Any]] = None,
     ) -> SuiRpcResult:
         """."""
         if isinstance(string, str):
-            return await self._execute(gql(string), schema_constraint, encode_fn)
+            return await self._execute(
+                gql(string), schema_constraint, with_headers, encode_fn
+            )
         else:
             return SuiRpcResult(False, "ValueError:Expected string", string)
 
     @versionadded(
         version="0.56.0", reason="Unique function for DocumentNode processing"
     )
     async def execute_document_node(
         self,
         *,
         with_node: DocumentNode,
-        schema_constraint: Optional[Union[str, None]] = None,
+        schema_constraint: Optional[str] = None,
+        with_headers: Optional[dict] = None,
         encode_fn: Optional[Callable[[dict], Any]] = None,
     ) -> SuiRpcResult:
         """."""
         if isinstance(with_node, DocumentNode):
-            return await self._execute(with_node, schema_constraint, encode_fn)
+            return await self._execute(
+                with_node, schema_constraint, with_headers, encode_fn
+            )
         else:
             return SuiRpcResult(False, "Not a valid gql DocumentNode", with_node)
 
     @versionadded(
         version="0.56.0", reason="Unique function for PGQL_QueryNode processing"
     )
     async def execute_query_node(
         self,
         *,
         with_node: PGQL_QueryNode,
-        schema_constraint: Optional[Union[str, None]] = None,
+        schema_constraint: Optional[str] = None,
+        with_headers: Optional[dict] = None,
         encode_fn: Optional[Callable[[dict], Any]] = None,
     ) -> SuiRpcResult:
         """."""
         try:
             qdoc_node, _sc_constraint = self._qnode_pre_run(
                 with_node, schema_constraint
             )
             if isinstance(qdoc_node, PGQL_NoOp):
                 return SuiRpcResult(True, None, pgql_type.NoopGQL.from_query())
             encode_fn = encode_fn or with_node.encode_fn()
-            return await self._execute(qdoc_node, schema_constraint, encode_fn)
+            return await self._execute(
+                qdoc_node, schema_constraint, with_headers, encode_fn
+            )
         except ValueError as ve:
             return SuiRpcResult(
                 False, "ValueError", pgql_type.ErrorGQL.from_query(ve.args)
             )
-
-    @deprecated(
-        version="0.56.0",
-        reason="Use explicit execute for type (str,DocumentNode,PGQL_QueryNode. This will be deleted in version 0.60.0)",
-    )
-    async def execute_query(
-        self,
-        *,
-        with_string: Optional[str] = None,
-        with_document_node: Optional[DocumentNode] = None,
-        with_query_node: Optional[PGQL_QueryNode] = None,
-        encode_fn: Optional[Callable[[dict], Any]] = None,
-    ) -> SuiRpcResult:
-        """Executes a GraphQL query and returns raw result.
-
-        with_string and with_document_node and with_query_node are mutually exclusive.
-        with_string takes precedence, then with_document_node then with_query_node. If none is
-        specific an error is returned.
-
-        :param with_string: A python string query, defaults to None
-        :type with_string: Optional[str], optional
-        :param with_document_node: A gql DocumentNode query, defaults to None
-        :type with_document_node: Optional[DocumentNode], optional
-        :param with_query_node: A pysui GraphQL QueryNode, defaults to None
-        :type with_query_node: Optional[PGQL_QueryNode], optional
-        :param encode_fn: Encode function taking dict as arg and returning Any, defaults to None
-            This can be used on any 'with_' option. If used in addition to with_query_node it
-            will override the builder property of same name if defined
-        :type encode_fn: Optional[Callable[[dict], Any]], optional
-        :return: Raw result (dict) or type returned defined by serialization function
-        :rtype: Any
-        """
-        if with_string:
-            return await self.execute_query_string(
-                schema_constraint=with_string, encode_fn=encode_fn
-            )
-        elif with_document_node:
-            return await self.execute_document_node(
-                with_node=with_document_node, encode_fn=encode_fn
-            )
-        elif with_query_node:
-            return await self.execute_query_node(
-                with_node=with_query_node, encode_fn=encode_fn
-            )
-        return SuiRpcResult(
-            False,
-            "Call requires python str, gql.DocumentNode, or PGQL_QueryNode types",
-        )
```

## pysui/sui/sui_pgql/pgql_configs.py

```diff
@@ -33,15 +33,15 @@
             maxOutputNodes
             maxDbQueryCost
             defaultPageSize
             maxPageSize
             requestTimeoutMs
             maxQueryPayloadSize
         }
-      protocolConfig(protocolVersion:39) {
+      protocolConfig(protocolVersion:44) {
           protocolVersion
           configs {
             key
             value
           }
           featureFlags {
             key
```

## pysui/sui/sui_pgql/pgql_fragments.py

```diff
@@ -173,14 +173,17 @@
                     as_object=schema.MoveObject.contents.select(
                         content=schema.MoveValue.json,
                         object_type_repr=schema.MoveValue.type.select(
                             object_type=schema.MoveType.repr
                         ),
                     ),
                 ),
+                as_move_package=schema.Object.asMovePackage.select(
+                    bcs=schema.MovePackage.bcs
+                ),
             )
         )
 
 
 class StandardEvent(PGQL_Fragment):
     """StandardEvent reusable fragment."""
 
@@ -490,26 +493,33 @@
 
     Contains structs and functions
     """
 
     @cache
     def fragment(self, schema: DSLSchema) -> DSLFragment:
         """."""
+        pg_cursor = PageCursor().fragment(schema)
         struc = MoveStructure().fragment(schema)
         func = MoveFunction().fragment(schema)
         return (
             DSLFragment("MoveModule")
             .on(schema.MoveModule)
             .select(
                 schema.MoveModule.name.alias("module_name"),
                 schema.MoveModule.structs.alias("structure_list").select(
-                    module_structures=schema.MoveStructConnection.nodes.select(struc)
+                    schema.MoveStructConnection.pageInfo.select(pg_cursor).alias(
+                        "cursor"
+                    ),
+                    module_structures=schema.MoveStructConnection.nodes.select(struc),
                 ),
                 schema.MoveModule.functions.alias("function_list").select(
-                    module_functions=schema.MoveFunctionConnection.nodes.select(func)
+                    schema.MoveFunctionConnection.pageInfo.select(pg_cursor).alias(
+                        "cursor"
+                    ),
+                    module_functions=schema.MoveFunctionConnection.nodes.select(func),
                 ),
             )
         )
 
 
 class Validator(PGQL_Fragment):
     """Validator reusable fragment."""
@@ -529,20 +539,18 @@
                 schema.Validator.imageUrl,
                 schema.Validator.projectUrl,
                 schema.Validator.operationCap.select(
                     schema.MoveObject.address.alias("operating_cap_address")
                 ),
                 schema.Validator.stakingPoolSuiBalance,
                 schema.Validator.stakingPoolActivationEpoch,
-                schema.Validator.stakingPool.select(
-                    schema.MoveObject.address.alias("staking_pool_address")
-                ),
+                schema.Validator.stakingPoolId.alias("staking_pool_address"),
                 schema.Validator.exchangeRatesSize,
-                schema.Validator.exchangeRates.select(
-                    schema.MoveObject.address.alias("exchange_rates_address")
+                schema.Validator.exchangeRatesTable.select(
+                    schema.Owner.address.alias("exchange_rates_address")
                 ),
                 schema.Validator.rewardsPool,
                 schema.Validator.poolTokenBalance,
                 schema.Validator.pendingStake,
                 schema.Validator.pendingTotalSuiWithdraw,
                 schema.Validator.pendingPoolTokenWithdraw,
                 schema.Validator.votingPower,
```

## pysui/sui/sui_pgql/pgql_query.py

```diff
@@ -968,37 +968,42 @@
                         )
                     ),
                 )
             )
         )
 
 
-# TODO: Handle Cursor
 class GetValidatorsApy(PGQL_QueryNode):
     """Return the validator APY."""
 
     def __init__(self, next_page: Optional[pgql_type.PagingCursor] = None):
         """QueryNode initializer."""
         self.next_page = next_page
 
     def as_document_node(self, schema: DSLSchema) -> DocumentNode:
         """."""
         if self.next_page and not self.next_page.hasNextPage:
             return PGQL_NoOp
+        elif self.next_page:
+            avals_q = schema.ValidatorSet.activeValidators(
+                after=self.next_page.endCursor
+            )
+        else:
+            avals_q = schema.ValidatorSet.activeValidators
 
-        pg_cursor = frag.PageCursor()
+        pg_cursor = frag.PageCursor().fragment(schema)
         return dsl_gql(
-            pg_cursor.fragment(schema),
+            pg_cursor,
             DSLQuery(
                 schema.Query.checkpoint.select(
                     schema.Checkpoint.epoch.select(
                         schema.Epoch.validatorSet.select(
-                            schema.ValidatorSet.activeValidators.select(
+                            avals_q.select(
                                 cursor=schema.ValidatorConnection.pageInfo.select(
-                                    pg_cursor.fragment(schema)
+                                    pg_cursor
                                 ),
                                 validators_apy=schema.ValidatorConnection.nodes.select(
                                     schema.Validator.name,
                                     schema.Validator.apy,
                                 ),
                             ),
                         )
@@ -1021,14 +1026,15 @@
         """QueryNode initializer."""
         self.next_page = next_page
 
     def as_document_node(self, schema: DSLSchema) -> DocumentNode:
         """."""
         if self.next_page and not self.next_page.hasNextPage:
             return PGQL_NoOp
+
         pg_cursor = frag.PageCursor().fragment(schema)
         val = frag.Validator().fragment(schema)
         valset = frag.ValidatorSet().fragment(schema)
         return dsl_gql(
             valset,
             pg_cursor,
             val,
@@ -1043,15 +1049,14 @@
 
     @staticmethod
     def encode_fn() -> Union[Callable[[dict], pgql_type.ValidatorSetsGQL], None]:
         """Return the serialization function for ValidatorSetsGQL."""
         return pgql_type.ValidatorSetsGQL.from_query
 
 
-# TODO: Need object lower level properties rep
 class GetStructure(PGQL_QueryNode):
     """GetStructure When executed, returns a module's structure representation."""
 
     def __init__(
         self,
         *,
         package: str,
@@ -1096,47 +1101,59 @@
     """GetStructures When executed, returns all of a module's structures."""
 
     def __init__(
         self,
         *,
         package: str,
         module_name: str,
+        next_page: Optional[pgql_type.PagingCursor] = None,
     ) -> None:
         """QueryNode initializer.
 
         :param package: object_id of package to query
         :type package: str
         :param module_name: Name of module from package containing structures to fetch
         :type module_name: str
         """
         self.package = package
         self.module = module_name
+        self.next_page = next_page
 
     def as_document_node(self, schema: DSLSchema) -> DocumentNode:
         """."""
-        struc = frag.MoveStructure()
+        if self.next_page and not self.next_page.hasNextPage:
+            return PGQL_NoOp
+        elif self.next_page:
+            struct_q = schema.MoveModule.structs(after=self.next_page.endCursor)
+        else:
+            struct_q = schema.MoveModule.structs
+
+        struc = frag.MoveStructure().fragment(schema)
+        pg_cursor = frag.PageCursor().fragment(schema)
 
         qres = schema.Query.object(address=self.package).select(
             schema.Object.asMovePackage.select(
                 schema.MovePackage.module(name=self.module).select(
-                    schema.MoveModule.structs.select(
-                        schema.MoveStructConnection.nodes.select(struc.fragment(schema))
+                    struct_q.select(
+                        schema.MoveStructConnection.pageInfo.select(pg_cursor).alias(
+                            "cursor"
+                        ),
+                        schema.MoveStructConnection.nodes.select(struc),
                     )
                 )
             )
         )
-        return dsl_gql(struc.fragment(schema), DSLQuery(qres))
+        return dsl_gql(struc, pg_cursor, DSLQuery(qres))
 
     @staticmethod
     def encode_fn() -> Union[Callable[[dict], pgql_type.MoveStructuresGQL], None]:
         """Return the serialization function for ReferenceGasPrice."""
         return pgql_type.MoveStructuresGQL.from_query
 
 
-# TODO: Need object lower parameters and type parameters properties rep
 class GetFunction(PGQL_QueryNode):
     """GetFunction When executed, returns a module's function information."""
 
     def __init__(self, *, package: str, module_name: str, function_name: str) -> None:
         """QueryNode initializer.
 
         :param package: object_id of package to query
@@ -1170,41 +1187,56 @@
         """Return the serialization function for ReferenceGasPrice."""
         return pgql_type.MoveFunctionGQL.from_query
 
 
 class GetFunctions(PGQL_QueryNode):
     """GetFunctions When executed, returns all module's functions information."""
 
-    def __init__(self, *, package: str, module_name: str) -> None:
+    def __init__(
+        self,
+        *,
+        package: str,
+        module_name: str,
+        next_page: Optional[pgql_type.PagingCursor] = None,
+    ) -> None:
         """QueryNode initializer.
 
         :param package: object_id of package to query
         :type package: str
         :param module_name: Name of module from package containing the function to fetch
         :type module_name: str
         """
         self.package = package
         self.module = module_name
+        self.next_page = next_page
 
     def as_document_node(self, schema: DSLSchema) -> DocumentNode:
         """."""
-        func = frag.MoveFunction()
+        if self.next_page and not self.next_page.hasNextPage:
+            return PGQL_NoOp
+        elif self.next_page:
+            func_q = schema.MoveModule.functions(after=self.next_page.endCursor)
+        else:
+            func_q = schema.MoveModule.functions
 
+        func = frag.MoveFunction().fragment(schema)
+        pg_cursor = frag.PageCursor().fragment(schema)
         qres = schema.Query.object(address=self.package).select(
             schema.Object.asMovePackage.select(
                 schema.MovePackage.module(name=self.module).select(
-                    schema.MoveModule.functions.select(
-                        schema.MoveFunctionConnection.nodes.select(
-                            func.fragment(schema)
-                        )
+                    func_q.select(
+                        schema.MoveFunctionConnection.pageInfo.select(pg_cursor).alias(
+                            "cursor"
+                        ),
+                        schema.MoveFunctionConnection.nodes.select(func),
                     )
                 )
             )
         )
-        return dsl_gql(func.fragment(schema), DSLQuery(qres))
+        return dsl_gql(func, pg_cursor, DSLQuery(qres))
 
     @staticmethod
     def encode_fn() -> Union[Callable[[dict], pgql_type.MoveFunctionsGQL], None]:
         """Return the serialization function for ReferenceGasPrice."""
         return pgql_type.MoveFunctionsGQL.from_query
 
 
@@ -1223,58 +1255,75 @@
         :type module_name: SuiString
         """
         self.package = package
         self.module = module_name
 
     def as_document_node(self, schema: DSLSchema) -> DocumentNode:
         """."""
-        func = frag.MoveFunction()
-        struc = frag.MoveStructure()
-        mod = frag.MoveModule()
+        func = frag.MoveFunction().fragment(schema)
+        struc = frag.MoveStructure().fragment(schema)
+        mod = frag.MoveModule().fragment(schema)
+        pg_cursor = frag.PageCursor().fragment(schema)
 
         qres = schema.Query.object(address=self.package).select(
             schema.Object.asMovePackage.select(
-                schema.MovePackage.module(name=self.module).select(mod.fragment(schema))
+                schema.MovePackage.module(name=self.module).select(mod)
             )
         )
         return dsl_gql(
-            func.fragment(schema),
-            struc.fragment(schema),
-            mod.fragment(schema),
+            pg_cursor,
+            func,
+            struc,
+            mod,
             DSLQuery(qres),
         )
 
     @staticmethod
     def encode_fn() -> Union[Callable[[dict], pgql_type.MoveModuleGQL], None]:
         """Return the serialization MoveModule."""
         return pgql_type.MoveModuleGQL.from_query
 
 
 class GetPackage(PGQL_QueryNode):
     """GetPackage When executed, return structured representations of the package."""
 
-    def __init__(self, *, package: str) -> None:
+    def __init__(
+        self, *, package: str, next_page: Optional[pgql_type.PagingCursor] = None
+    ) -> None:
         """__init__ Initialize GetPackage object."""
         self.package = package
+        self.next_page = next_page
 
     def as_document_node(self, schema: DSLSchema) -> DocumentNode:
         """."""
+        if self.next_page and not self.next_page.hasNextPage:
+            return PGQL_NoOp
+        elif self.next_page:
+            mod_q = schema.MovePackage.modules(after=self.next_page.endCursor)
+        else:
+            mod_q = schema.MovePackage.modules
+        pg_cursor = frag.PageCursor().fragment(schema)
         func = frag.MoveFunction().fragment(schema)
         struc = frag.MoveStructure().fragment(schema)
         mod = frag.MoveModule().fragment(schema)
+
         qres = schema.Query.object(address=self.package).select(
             schema.Object.asMovePackage.select(
                 schema.MovePackage.address.alias("package_id"),
                 schema.MovePackage.version.alias("package_version"),
-                schema.MovePackage.modules.select(
-                    schema.MoveModuleConnection.nodes.select(mod)
+                mod_q.select(
+                    schema.MoveModuleConnection.pageInfo.select(pg_cursor).alias(
+                        "cursor"
+                    ),
+                    schema.MoveModuleConnection.nodes.select(mod),
                 ),
             )
         )
         return dsl_gql(
+            pg_cursor,
             func,
             struc,
             mod,
             DSLQuery(qres),
         )
 
     @staticmethod
@@ -1313,14 +1362,15 @@
         self.tx_meta = tx_meta if tx_meta else {}
         self.tx_skipchecks = skip_checks
 
     def as_document_node(self, schema: DSLSchema) -> DocumentNode:
         """."""
         std_txn = frag.StandardTransaction().fragment(schema)
         base_obj = frag.BaseObject().fragment(schema)
+        standard_obj = frag.StandardObject().fragment(schema)
         gas_cost = frag.GasCost().fragment(schema)
         tx_effects = frag.StandardTxEffects().fragment(schema)
 
         qres = (
             schema.Query.dryRunTransactionBlock(
                 txBytes=self.tx_data,
                 txMeta=self.tx_meta,
@@ -1333,15 +1383,17 @@
                     schema.DryRunEffect.returnValues.select(
                         schema.DryRunReturn.type.select(schema.MoveType.repr)
                     )
                 ),
                 transactionBlock=schema.DryRunResult.transaction.select(std_txn),
             )
         )
-        return dsl_gql(base_obj, gas_cost, std_txn, tx_effects, DSLQuery(qres))
+        return dsl_gql(
+            base_obj, standard_obj, gas_cost, std_txn, tx_effects, DSLQuery(qres)
+        )
 
     @staticmethod
     def encode_fn() -> Union[Callable[[dict], pgql_type.DryRunResultGQL], None]:
         """Return the serialization MovePackage."""
         return pgql_type.DryRunResultGQL.from_query
 
 
@@ -1352,14 +1404,15 @@
         """__init__ Initialize DryRunTransaction object."""
         self.tx_data = tx_bytestr
 
     def as_document_node(self, schema: DSLSchema) -> DocumentNode:
         """."""
         std_txn = frag.StandardTransaction().fragment(schema)
         base_obj = frag.BaseObject().fragment(schema)
+        standard_obj = frag.StandardObject().fragment(schema)
         gas_cost = frag.GasCost().fragment(schema)
         tx_effects = frag.StandardTxEffects().fragment(schema)
 
         qres = (
             schema.Query.dryRunTransactionBlock(txBytes=self.tx_data)
             .alias("dryRun")
             .select(
@@ -1368,15 +1421,17 @@
                     schema.DryRunEffect.returnValues.select(
                         schema.DryRunReturn.type.select(schema.MoveType.repr)
                     )
                 ),
                 transactionBlock=schema.DryRunResult.transaction.select(std_txn),
             )
         )
-        return dsl_gql(base_obj, gas_cost, std_txn, tx_effects, DSLQuery(qres))
+        return dsl_gql(
+            base_obj, standard_obj, gas_cost, std_txn, tx_effects, DSLQuery(qres)
+        )
 
     @staticmethod
     def encode_fn() -> Union[Callable[[dict], pgql_type.DryRunResultGQL], None]:
         """Return the serialization MovePackage."""
         return pgql_type.DryRunResultGQL.from_query
```

## pysui/sui/sui_pgql/pgql_sync_txn.py

```diff
@@ -168,16 +168,16 @@
         :type target: str
         :return: The meta function argument summary
         :rtype: pgql_type.MoveArgSummary
         """
         package, package_module, package_function = (
             tv.TypeValidator.check_target_triplet(target)
         )
-        result = self.client.execute_query(
-            with_query_node=qn.GetFunction(
+        result = self.client.execute_query_node(
+            with_node=qn.GetFunction(
                 package=package,
                 module_name=package_module,
                 function_name=package_function,
             )
         )
         if result.is_ok() and not isinstance(result.result_data, pgql_type.NoopGQL):
             mfunc: pgql_type.MoveFunctionGQL = result.result_data
@@ -241,27 +241,27 @@
 
     def build(
         self,
         *,
         gas_budget: Optional[str] = None,
         use_gas_objects: Optional[list[Union[str, pgql_type.SuiCoinObjectGQL]]] = None,
     ) -> str:
-        """build After creating the BCS TransactionKind, serialize to base64 string and return.
+        """build After creating the BCS TransactionData, serialize to base64 string and return.
 
         :param gas_budget: Specify the amount of gas for the transaction budget, defaults to None
         :type gas_budget: Optional[str], optional
         :param use_gas_objects: Specify gas object(s) (by ID or SuiCoinObjectGQL), defaults to None
         :type use_gas_objects: Optional[list[Union[str, pgql_type.SuiCoinObjectGQL]]], optional
         :return: Base64 encoded transaction bytes
         :rtype: str
         """
-        txn_kind = self.transaction_data(
+        txn_data = self.transaction_data(
             gas_budget=gas_budget, use_gas_objects=use_gas_objects
         )
-        return base64.b64encode(txn_kind.serialize()).decode()
+        return base64.b64encode(txn_data.serialize()).decode()
 
     def build_and_sign(
         self,
         *,
         gas_budget: Optional[str] = None,
         use_gas_objects: Optional[list[Union[str, pgql_type.SuiCoinObjectGQL]]] = None,
     ) -> tuple[str, list[str]]:
@@ -481,14 +481,15 @@
         :type arguments: list[Any]
         :param type_arguments: Optional list of type arguments for move function generics, defaults to None
         :type type_arguments: Optional[list], optional
         :return: The result which may or may not be used in subequent commands depending on the
             move method being called.
         :rtype: Union[bcs.Argument, list[bcs.Argument]]
         """
+        type_arguments = type_arguments if type_arguments else []
         # Validate and get target meta arguments
         package, package_module, package_function, retcount, ars = (
             self._function_meta_args(target)
         )
         type_arguments = [bcs.TypeTag.type_tag_from(x) for x in type_arguments]
         parms = ab.build_args(self.client, arguments, ars)
         return self.builder.move_call(
@@ -499,22 +500,22 @@
             function=package_function,
             res_count=retcount,
         )
 
     def stake_coin(
         self,
         *,
-        coins: list[Union[str, pgql_type.ObjectReadGQL]],
+        coins: list[Union[str, pgql_type.ObjectReadGQL, bcs.Argument]],
         validator_address: str,
         amount: Optional[int] = None,
     ) -> bcs.Argument:
         """stake_coin Stakes one or more coins to a specific validator.
 
         :param coins: One or more coins to stake.
-        :type coins: list[str, pgql_type.ObjectReadGQL]
+        :type coins: list[str, pgql_type.ObjectReadGQL, bcs.Argument]
         :param validator_address: The validator to stake coins to
         :type validator_address: str
         :param amount: Amount from coins to stake. If not stated, all coin will be staked, defaults to None
         :type amount: Optional[int], optional
         :return: The command result.
         :rtype: bcs.Argument
         """
```

## pysui/sui/sui_pgql/pgql_txb_gas.py

```diff
@@ -12,55 +12,55 @@
 from pysui.sui.sui_types import bcs
 
 
 def _get_gas_objects(
     client: BaseSuiGQLClient, gas_ids: list[str]
 ) -> list[pgql_type.SuiCoinObjectGQL]:
     """Retreive specific Gas Objects."""
-    result = client.execute_query(
-        with_query_node=qn.GetMultipleGasObjects(coin_object_ids=gas_ids)
+    result = client.execute_query_node(
+        with_node=qn.GetMultipleGasObjects(coin_object_ids=gas_ids)
     )
     if result.is_ok():
         return result.result_data.data
     else:
         raise ValueError(f"Error retrieving coins by id {result.result_string}")
 
 
 def _get_all_gas_objects(
     signing: SignerBlock, client: BaseSuiGQLClient
 ) -> list[pgql_type.SuiCoinObjectGQL]:
     """Retreive all Gas Objects."""
     payer = signing.payer_address
     coin_list: list[pgql_type.SuiCoinObjectGQL] = []
-    result = client.execute_query(with_query_node=qn.GetCoins(owner=payer))
+    result = client.execute_query_node(with_node=qn.GetCoins(owner=payer))
     while True:
         if result.is_ok():
             coin_list.extend(result.result_data.data)
             if result.result_data.next_cursor.hasNextPage:
-                result = client.execute_query(
-                    with_query_node=qn.GetCoins(
+                result = client.execute_query_node(
+                    with_node=qn.GetCoins(
                         owner=payer, next_page=result.result_data.next_cursor
                     )
                 )
             else:
                 break
         else:
-            break
+            raise ValueError(f"Execute query error: {result.result_string}")
     return coin_list
 
 
 def _dry_run_for_budget(
     signing: SignerBlock,
     client: BaseSuiGQLClient,
     tx_bytes: str,
     active_gas_price: int,
 ) -> int:
     """Perform a dry run when no budget specified."""
-    result = client.execute_query(
-        with_query_node=qn.DryRunTransactionKind(
+    result = client.execute_query_node(
+        with_node=qn.DryRunTransactionKind(
             tx_bytestr=tx_bytes,
             tx_meta={
                 "sender": signing.sender_str,
                 "gasPrice": active_gas_price,
                 "gasSponsor": signing.sponsor_str,
             },
             skip_checks=False,
```

## pysui/sui/sui_pgql/pgql_txn_argb.py

```diff
@@ -1,19 +1,19 @@
 #    Copyright Frank V. Castellucci
 #    SPDX-License-Identifier: Apache-2.0
 # -*- coding: utf-8 -*-
 
 """Pysui Transaction argument builder that works with GraphQL connection."""
 
 from typing import Any, Optional, Union
+from functools import partial
 from dataclasses import dataclass, field
 from pysui.sui.sui_pgql.pgql_clients import SuiGQLClient
 import pysui.sui.sui_pgql.pgql_query as qn
 import pysui.sui.sui_pgql.pgql_types as pgql_type
-from pysui import SuiConfig
 
 import pysui.sui.sui_types as suit
 from pysui.sui.sui_types import bcs
 import pysui.sui.sui_txn.transaction_builder as tx_builder
 
 _SCALARS = {
     "u8": suit.SuiU8,
@@ -59,14 +59,19 @@
                 client=client,
                 arg=arg,
                 expected_type=expected_type.type_params[0],
             )
         else:
             inner_type = outer_fn(inner_fn(arg))
         etr = bcs.OptionalTypeFactory.as_optional(inner_type)
+    elif isinstance(construct, list):
+        for index, vconstruct in enumerate(construct):
+            convert, encode = vconstruct
+            inner_type = encode(convert(arg))
+            etr = bcs.OptionalTypeFactory.as_optional(inner_type)
     elif construct:
         inner_type = construct(arg)
         etr = bcs.OptionalTypeFactory.as_optional(inner_type)
     etr.value = inner_type
     return etr
 
 
@@ -125,74 +130,114 @@
 ) -> bcs.ObjectArg:
     """Process an object reference."""
     if arg:
         return _fetch_or_transpose_object(client, arg, expected_type)
     raise ValueError("Missing argument")
 
 
+def pass_through(arg: Any) -> Any:
+    """Emulate 'identity'."""
+    return arg
+
+
 def _scalar_argument(
-    expected_type,
-    arg,
+    expected_type, arg, in_optional: bool = False, in_vector: bool = False
 ) -> tuple[Any, Any]:
     """Prepares a scalar argument for the transaction."""
 
-    match expected_type.scalar_type:
-        case "address" | "signature":
-            # print(f"{expected_type.scalar_type} = {arg}")
-            return bcs.Address.from_str, tx_builder.PureInput.as_input
-        case "digest":
-            # print(f"{expected_type.scalar_type} = {arg}")
-            return bcs.Digest.from_str, tx_builder.PureInput.as_input
-        case _:
-            # if not isinstance(arg, (str, int)):
-            #     raise ValueError("ObjectRef...Oops")
-            return (
-                _SCALARS.get(expected_type.scalar_type),
-                tx_builder.PureInput.as_input,
-            )
+    # Validate arg matches expectation
+    if arg:
+        if _SCALARS.get(expected_type.scalar_type):
+            if not isinstance(arg, int):
+                raise ValueError(f"Expected int and found {arg.__class__}")
+        elif not isinstance(arg, str):
+            raise ValueError(f"Expected str found {arg.__class__}")
+
+    if in_optional:
+        match expected_type.scalar_type:
+            case "address" | "signature" | "ID":
+                return (bcs.Address.from_str, bcs.Address)
+            case "digest":
+                return (bcs.Digest.from_str, bcs.Digest)
+            case "String":
+                return (
+                    tx_builder.PureInput.pure,
+                    partial(bcs.Variable.bcs_var_length_field, bcs.U8),
+                )
+                # return (tx_builder.PureInput.pure, bcs.VariableArrayU8)
+    else:
+        match expected_type.scalar_type:
+            case "address" | "signature" | "ID":
+                # print(f"{expected_type.scalar_type} = {arg}")
+                return bcs.Address.from_str, tx_builder.PureInput.as_input
+            case "digest":
+                # print(f"{expected_type.scalar_type} = {arg}")
+                return bcs.Digest.from_str, tx_builder.PureInput.as_input
+            case "String":
+                # return (tx_builder.PureInput.pure, bcs.VariableArrayU8)
+                return (
+                    tx_builder.PureInput.pure,
+                    partial(bcs.Variable.bcs_var_length_field, bcs.U8),
+                )
+            case _:
+                # if not isinstance(arg, (str, int)):
+                #     raise ValueError("ObjectRef...Oops")
+                return (
+                    _SCALARS.get(expected_type.scalar_type),
+                    tx_builder.PureInput.as_input,
+                )
 
 
-def _object_argument(expected_type: pgql_type.MoveObjectRefArg, arg) -> tuple[Any, Any]:
+def _object_argument(
+    expected_type: pgql_type.MoveObjectRefArg,
+    arg,
+    in_optional: bool = False,
+    in_vector: bool = False,
+) -> tuple[Any, Any]:
     """Prepares an object argument for the transaction."""
     # If optional then get the inner type and validate
     if expected_type.is_optional:
         return _optional_processor, _argument_validate(
-            expected_type.type_params[0], arg
+            expected_type.type_params[0], arg, True, in_vector
         )
     return _object_processor, None
 
 
-def _argument_validate(expected_type: Any, arg: Any) -> Union[None, tuple[Any, Any]]:
+def _argument_validate(
+    expected_type: Any, arg: Any, in_optional: bool = False, in_vector: bool = False
+) -> Union[None, tuple[Any, Any]]:
     """Argument validation and process dispatching function."""
     if isinstance(arg, bcs.Argument):
         return None
     if isinstance(expected_type, pgql_type.MoveScalarArg):
         # print("Scalar")
-        return _scalar_argument(expected_type, arg)
+        return _scalar_argument(expected_type, arg, in_optional, in_vector)
     if isinstance(expected_type, pgql_type.MoveWitnessArg):
         # print("WitnessArg")
-        return _object_argument(expected_type, arg)
+        return _object_argument(expected_type, arg, in_optional)
     elif isinstance(expected_type, pgql_type.MoveObjectRefArg):
         # print("ObjectRef")
-        return _object_argument(expected_type, arg)
+        return _object_argument(expected_type, arg, in_optional)
     if isinstance(expected_type, (pgql_type.MoveVectorArg, pgql_type.MoveListArg)):
         # print("Vector or List")
         if not isinstance(arg, list):
-            raise ValueError("Vector or List...Oops")
+            raise ValueError("Expected list type argument...")
         some_list = []
         inner_type = (
             expected_type.list_arg
             if isinstance(expected_type, pgql_type.MoveListArg)
             else expected_type.vec_arg
         )
         for inner_arg in arg:
             if isinstance(inner_arg, bcs.Argument):
                 some_list.append(inner_arg)
             else:
-                some_list.append(_argument_validate(inner_type, inner_arg))
+                some_list.append(
+                    _argument_validate(inner_type, inner_arg, in_optional, True)
+                )
         return some_list
 
     raise ValueError(f"Unhhandled type {type(expected_type)}")
 
 
 def _argument_builder(
     client: SuiGQLClient, arg, arg_meta, processor_fn, constructor_fn=None
```

## pysui/sui/sui_pgql/pgql_types.py

```diff
@@ -317,14 +317,17 @@
             owner = in_data.pop("owner")
             if owner:
                 owner_kind = owner["obj_owner_kind"]
                 if in_data.get("as_move_content"):
                     contents = in_data["as_move_content"]["as_object"].pop("content")
                 else:
                     contents = None
+                    if in_data.get("as_move_package"):
+                        in_data.pop("as_move_package")
+                        in_data["object_type"] = "Package"
                 # Flatten
                 _fast_flat(in_data, res_dict)
                 # Reassign
                 res_dict["content"] = contents
                 match owner_kind:
                     case "AddressOwner":
                         res_dict["object_owner"] = SuiObjectOwnedAddress(
@@ -836,24 +839,36 @@
 
 @dataclasses_json.dataclass_json(letter_case=dataclasses_json.LetterCase.CAMEL)
 @dataclasses.dataclass
 class MoveStructuresGQL:
     """Sui collection of MoveStuctures."""
 
     structures: list[MoveStructureGQL]
+    next_cursor: Optional[PagingCursor]
 
     @classmethod
     def from_query(clz, in_data: dict) -> "MoveStructuresGQL":
         if in_data:
             in_data = in_data.get("object", in_data)
             fdict: dict = {}
             _fast_flat(in_data, fdict)
-            return MoveStructuresGQL.from_dict(
-                {"structures": [MoveStructureGQL.from_query(x) for x in fdict["nodes"]]}
-            )
+            _fast_flat(in_data, fdict)
+            if "hasNextPage" in fdict:
+                fdict["next_cursor"] = PagingCursor(
+                    fdict.pop("hasNextPage"), fdict.pop("endCursor")
+                )
+            else:
+                fdict["next_cursor"] = None
+            fdict["structures"] = [
+                MoveStructureGQL.from_query(x) for x in fdict["nodes"]
+            ]
+            return MoveStructuresGQL.from_dict(fdict)
+            # return MoveStructuresGQL.from_dict(
+            #     {"structures": [MoveStructureGQL.from_query(x) for x in fdict["nodes"]]}
+            # )
         return NoopGQL.from_query()
 
 
 class RefType(IntEnum):
     """."""
 
     NO_REF = 0
@@ -913,28 +928,40 @@
 
     @classmethod
     def from_body(cls, in_ref: str, in_type: dict) -> "MoveObjectRefArg":
         """ "."""
         ref_type: RefType = (
             in_ref if isinstance(in_ref, RefType) else RefType.from_ref(in_ref)
         )
+        if in_type["type"] == "String" or in_type["type"] == "ID":
+            return MoveScalarArg.from_str(in_ref, in_type["type"])
+        ref_type: RefType = (
+            in_ref if isinstance(in_ref, RefType) else RefType.from_ref(in_ref)
+        )
         inner_type = in_type.get("typeParameters")
         has_type = bool(inner_type)
         inner_list = []
 
         if has_type:
             inner_list = []
             for inner_t in inner_type:
                 if isinstance(inner_t, dict):
                     if "typeParameter" in inner_t:
                         inner_list.append(inner_t["typeParameter"])
                     else:
-                        inner_list.append(
-                            MoveObjectRefArg.from_body(ref_type, inner_t["datatype"])
-                        )
+                        if "vector" in inner_t:
+                            inner_list.append(
+                                MoveVectorArg.from_body(ref_type, inner_t)
+                            )
+                        else:
+                            inner_list.append(
+                                MoveObjectRefArg.from_body(
+                                    ref_type, inner_t["datatype"]
+                                )
+                            )
                 else:
                     inner_list.append(MoveScalarArg.from_str("", inner_t))
 
         return cls(
             ref_type,
             in_type["package"],
             in_type["module"],
@@ -954,20 +981,14 @@
     ref: RefType
     vec_arg: Union[MoveScalarArg, MoveObjectRefArg]
 
     @classmethod
     def from_body(cls, in_ref: str, in_type: dict) -> "MoveVectorArg":
         """ "."""
         from_vec = in_type["vector"]
-        # if isinstance(from_vec, str):
-        #     vtype = MoveScalarArg.from_str("", from_vec)
-        # elif isinstance(from_vec, dict):
-        #     ivtype = from_vec["vector"]
-        # if "datatype" in ivtype:
-        #     vtype = MoveObjectRefArg.from_body("", from_vec["datatype"])
         return cls(
             RefType.from_ref(in_ref),
             (
                 MoveScalarArg.from_str("", from_vec)
                 if isinstance(from_vec, str)
                 else MoveObjectRefArg.from_body("", from_vec["datatype"])
             ),
@@ -1022,17 +1043,19 @@
     visibility: str
     type_parameters: list
     parameters: list[dict]
     returns: Optional[list] = dataclasses.field(default_factory=list)
 
     @classmethod
     def from_query(clz, in_data: dict) -> "MoveFunctionGQL":
-        fdict: dict = {}
-        _fast_flat(in_data, fdict)
-        return MoveFunctionGQL.from_dict(fdict)
+        if in_data.get("object"):
+            fdict: dict = {}
+            _fast_flat(in_data, fdict)
+            return MoveFunctionGQL.from_dict(fdict)
+        return NoopGQL.from_query()
 
     def arg_summary(self) -> MoveArgSummary:
         """Summarize the function's arguments."""
         a_list: list = []
         for parm in self.parameters:
             sig = parm.get("signature")
             ref = sig.get("ref")
@@ -1059,70 +1082,86 @@
 
 @dataclasses_json.dataclass_json(letter_case=dataclasses_json.LetterCase.CAMEL)
 @dataclasses.dataclass
 class MoveFunctionsGQL:
     """Sui MoveFunction representation."""
 
     functions: list[MoveFunctionGQL]
+    next_cursor: Optional[PagingCursor]
 
     @classmethod
     def from_query(clz, in_data: dict) -> "MoveFunctionsGQL":
         """."""
         if in_data:
             in_data = in_data.get("object", in_data)
             fdict: dict = {}
             _fast_flat(in_data, fdict)
-            return MoveFunctionsGQL.from_dict(
-                {"functions": [MoveFunctionGQL.from_query(x) for x in fdict["nodes"]]}
-            )
+            if fdict.get("nodes"):
+                if "hasNextPage" in fdict:
+                    fdict["next_cursor"] = PagingCursor(
+                        fdict.pop("hasNextPage"), fdict.pop("endCursor")
+                    )
+                else:
+                    fdict["next_cursor"] = None
+                fdict["functions"] = [
+                    MoveFunctionGQL.from_query(x) for x in fdict["nodes"]
+                ]
+                return MoveFunctionsGQL.from_dict(fdict)
         return NoopGQL.from_query()
 
 
 @dataclasses_json.dataclass_json(letter_case=dataclasses_json.LetterCase.CAMEL)
 @dataclasses.dataclass
 class MoveModuleGQL:
     """Sui MoveModule representation."""
 
     module_name: str
-    module_structures: MoveStructuresGQL
-    module_functions: MoveFunctionsGQL
+    module_structures: Optional[MoveStructuresGQL]
+    module_functions: Optional[MoveFunctionsGQL]
 
     @classmethod
     def from_query(clz, in_data: dict) -> "MoveModuleGQL":
         if in_data:
             in_data = in_data.get("object", in_data)
             fdict: dict = {}
             _fast_flat(in_data, fdict)
             if "structure_list" in fdict:
                 fdict["module_structures"] = []
+            if "function_list" in fdict:
+                fdict["module_functions"] = []
             # fdict["module_structures"] = fdict.get("module_structures", [])
             fdict["module_structures"] = MoveStructuresGQL.from_query(
                 {"nodes": fdict["module_structures"]}
             )
             fdict["module_functions"] = MoveFunctionsGQL.from_query(
                 {"nodes": fdict["module_functions"]}
             )
+
             return MoveModuleGQL.from_dict(fdict)
         return NoopGQL.from_query()
 
 
 @dataclasses_json.dataclass_json(letter_case=dataclasses_json.LetterCase.CAMEL)
 @dataclasses.dataclass
 class MovePackageGQL:
     """Sui MovePackage representation."""
 
     package_id: str
     package_version: int
     modules: list[MoveModuleGQL]
+    next_cursor: PagingCursor
 
     @classmethod
     def from_query(clz, in_data: dict) -> "MovePackageGQL":
         if in_data.get("object"):
             fdict: dict = {}
             _fast_flat(in_data, fdict)
+            fdict["next_cursor"] = PagingCursor(
+                fdict.pop("hasNextPage"), fdict.pop("endCursor")
+            )
             fdict["modules"] = [MoveModuleGQL.from_query(x) for x in fdict["nodes"]]
             fdict.pop("nodes")
             return MovePackageGQL.from_dict(fdict)
         return NoopGQL.from_query()
 
 
 @dataclasses_json.dataclass_json(letter_case=dataclasses_json.LetterCase.CAMEL)
@@ -1158,20 +1197,17 @@
     @classmethod
     def from_query(clz, in_data: dict) -> "ValidatorFullGQL":
         fdict: dict = {}
         _fast_flat(in_data, fdict)
         if "operatingCap" in fdict:
             fdict["operating_cap_address"] = None
             fdict.pop("operatingCap")
-        if "exchangeRate" in fdict:
-            fdict["exchange_rates_address"] = None
-            fdict.pop("exchangeRate")
-        if "stakingPool" in fdict:
-            fdict["staking_pool_address"] = None
-            fdict.pop("stakingPool")
+        # if "exchangeRate" in fdict:
+        #     fdict["exchange_rates_address"] = None
+        #     fdict.pop("exchangeRate")
         return ValidatorFullGQL.from_dict(fdict)
 
 
 @dataclasses_json.dataclass_json(letter_case=dataclasses_json.LetterCase.CAMEL)
 @dataclasses.dataclass
 class ValidatorSetsGQL:
     """Sui ValidatorSet representation."""
@@ -1210,16 +1246,16 @@
 
 
 @dataclasses_json.dataclass_json(letter_case=dataclasses_json.LetterCase.CAMEL)
 @dataclasses.dataclass
 class ValidatorApysGQL:
     """Sui ValidatorApy representation."""
 
-    next_cursor: PagingCursor
     validators_apy: list[ValidatorApyGQL]
+    next_cursor: PagingCursor
 
     @classmethod
     def from_query(clz, in_data: dict) -> "ValidatorApysGQL":
         fdict: dict = {}
         _fast_flat(in_data, fdict)
         fdict["next_cursor"] = PagingCursor(
             fdict.pop("hasNextPage"), fdict.pop("endCursor")
```

## pysui/sui/sui_txn/transaction_builder.py

```diff
@@ -247,14 +247,21 @@
     def _(cls, arg: bcs.Digest) -> list:
         """Convert bcs,Digest to list of bytes."""
         logger.debug(f"bcs.Digest->pure {arg.to_json()}")
         return list(arg.serialize())
 
     @pure.register
     @classmethod
+    def _(cls, arg: bcs.Variable) -> list:
+        """Convert bcs,Variable to list of bytes."""
+        logger.debug(f"bcs.Variable->pure {arg.to_json()}")
+        return list(arg.serialize())
+
+    @pure.register
+    @classmethod
     def _(cls, arg: list) -> list:
         """."""
         logger.debug(f"list->pure {arg}")
         stage_list = [PureInput.pure(x) for x in arg]
         res_list = list(serialize_uint32_as_uleb128(None, len(stage_list)))
         for stage_pure in stage_list:
             res_list.extend(stage_pure)
@@ -459,14 +466,16 @@
                 argrefs.append(self.input_pure(PureInput.as_input(arg)))
             elif isinstance(arg, tuple):
                 argrefs.append(self.input_obj(*arg))
             elif isinstance(arg, (bcs.Argument, bcs.OptionalU64)):
                 argrefs.append(arg)
             elif isinstance(arg, list):
                 argrefs.append(self.input_pure(PureInput.as_input(arg)))
+            elif isinstance(arg, bcs.Variable):
+                argrefs.append(self.input_pure(PureInput.as_input(arg)))
             else:
                 raise ValueError(f"Unknown arg in movecall {arg.__class__.__name__}")
 
         return self.command(
             bcs.Command(
                 "MoveCall",
                 bcs.ProgrammableMoveCall(
```

## pysui/sui/sui_types/bcs.py

```diff
@@ -10,14 +10,15 @@
 #    limitations under the License.
 
 # -*- coding: utf-8 -*-
 
 """Sui BCS Types."""
 
 import binascii
+import copy
 from typing import Any, Union
 import json
 import canoser
 from deprecated.sphinx import deprecated, versionadded, versionchanged
 
 from pysui.abstracts.client_keypair import PublicKey, SignatureScheme
 from pysui.sui.sui_txresults.common import GenericRef
@@ -71,14 +72,68 @@
     @classmethod
     @versionadded(version="0.17.0", reason="Direct from bytes construction")
     def from_bytes(cls, indata: bytes) -> "Digest":
         """Digest from bytes."""
         return cls(list(indata))
 
 
+@versionadded(version="0.60.0", reason="Handle Sting, etc.")
+class VariableArrayU8(canoser.Struct):
+    """Variable length array"""
+
+    _fields = [("Array", [])]
+
+
+class Variable(canoser.Struct):
+    """."""
+
+    _fields = []
+
+    @classmethod
+    def bcs_var_length_field(
+        cls, base_class: canoser.Struct, ready_data: list[int]
+    ) -> "Variable":
+        """."""
+        deep_copy = copy.deepcopy(Variable)
+        deep_copy._fields.append(("Data", [base_class, len(ready_data), False]))
+        return deep_copy(ready_data)
+
+    @classmethod
+    def encode(cls, obj):
+        return bytes(obj.Data)
+
+    @classmethod
+    def decode(cls, cursor):
+        return super().decode(cursor)
+
+
+class ArrayVar(canoser.Struct):
+    """."""
+
+    _fields = []
+
+    @classmethod
+    def bcs_array_for(cls, *, base_class, ready_data: list, depth: int = 0):
+        """."""
+        deep_copy = copy.deepcopy(ArrayVar)
+        field_def: tuple[str, list] = ()
+        type_list = base_class
+        data_list = ready_data
+        if depth:
+            for _ in range(depth):
+                type_list = [copy.deepcopy(type_list)]
+            for _ in range(depth - 1):
+                data_list = [copy.deepcopy(data_list)]
+            field_def = ("Array", type_list)
+        else:
+            field_def = ("Array", [type_list])
+        deep_copy._fields.append(field_def)
+        return deep_copy(data_list)
+
+
 class BuilderArg(canoser.RustEnum):
     """BuilderArg objects are generated in the TransactionBuilder."""
 
     _enums = [
         ("Object", Address),
         ("Pure", [canoser.Uint8]),
         ("ForcedNonUniquePure", None),
```

## Comparing `pysui-0.59.0.dist-info/LICENSE` & `pysui-0.60.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pysui-0.59.0.dist-info/METADATA` & `pysui-0.60.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pysui
-Version: 0.59.0
+Version: 0.60.0
 Summary: SUI client Python SDK
 License: Apache-2.0
 Project-URL: changelog, https://github.com/FrankC01/pysui/blob/main/CHANGELOG.md
 Project-URL: repository, https://github.com/FrankC01/pysui
 Project-URL: issues, https://github.com/FrankC01/pysui/issues
 Project-URL: documentation, https://pysui.readthedocs.io
 Keywords: software development kit,sui,blockchain
@@ -20,15 +20,15 @@
 Classifier: Programming Language :: Python :: 3.12
 Classifier: Programming Language :: Python :: 3 :: Only
 Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: dataclasses-json <0.7.0,>=0.6.3
 Requires-Dist: PyYAML <6.2,>=6.0.1
-Requires-Dist: httpx <0.28,>=0.26.0
+Requires-Dist: httpx <0.28,>=0.27.0
 Requires-Dist: h2 <5.0,>=4.1
 Requires-Dist: websockets <13.0.0,>=10.0.0
 Requires-Dist: typing-utils <0.2.0,>=0.1.0
 Requires-Dist: canoser ==0.8.2
 Requires-Dist: base58 <2.2.0,>=2.1.1
 Requires-Dist: Deprecated <1.3.0,>=1.2.14
 Requires-Dist: pysui-fastcrypto >=0.5.0
@@ -49,26 +49,26 @@
 - Rust (stable) for installation of Sui Binaries (optional) and building `pysui-fastcrypto` Rust wrapper (required)
 - Python version >= 3.10
 
 **Note**: If moving from 0.51.0 or earlier it is recommended to start a new virtual environment and installing from PyPi!
 
 ## pysui SDK current (github)
 
-**Release-0.59.0**
+**Release-0.60.0**
 
-- Supports _SUI 1.25.x RPC API_
+- Supports _SUI 1.26.x RPC API_
 - Backwards compatable to _Sui 1.18.x RPC API_
 
 See [CHANGELOG](https://github.com/FrankC01/pysui/blob/main/CHANGELOG.md)
 
 ## PyPi current
 
-**Release-0.59.0 - Released 2024-05-02**
+**Release-0.59.0 - Released 2024-05-15**
 
-- Supports _SUI 1.24.x RPC API_
+- Supports _SUI 1.26.x RPC API_
 - Backwards compatable to _Sui 1.18.x RPC API_
 
 - [Latest PyPi Version](https://pypi.org/project/pysui/)
 
 ## Sui GraphQL RPC beta
 
 MystenLabs announcement can be found [Here](https://github.com/mystenLabs/sui/issues/13700). This change transitions
@@ -78,27 +78,27 @@
 
 ### Sui GraphQL IDEs
 
   [Mainnet](https://sui-mainnet.mystenlabs.com/graphql)
 
   [Testnet](https://sui-testnet.mystenlabs.com/graphql)
 
-  [Devnet](https://sui-devnet.mystenlabs.com/graphql)
+  [Devnet](https://sui-devnet.mystenlabs.com/graphql/stable)
 
 ### pysui GraphQL support
 
 With pysui 0.50.0 we released beta `pysui`'s initial alignment with MystenLabs strategy. The timeline of changes will keep up with the Timeline as noted in the Sui GraphQL annoucement. We are not more stable and have Client and TransactionBuilder running against Sui GraphQL.
 
 We continue to monitor and support changes as they evolve.
 
 #### Examples
 
-  - [Synchronous Client](https://github.com/FrankC01/pysui/blob/v0.57.0/pgql_s_example.py) - Examples for all supported QueryNode queries and mutations
-  - [Asynchronous Client](https://github.com/FrankC01/pysui/blob/v0.57.0/pgql_a_example.py) - Examples for all supported QueryNode queries and mutations
-  - [Synchronous TransactionBuilder](https://github.com/FrankC01/pysui/blob/v0.57.0/pgql_s_ptb.py) - Example of new pysui Transaction Builder leveraging Sui GraphQL
+  - [Synchronous Client](https://github.com/FrankC01/pysui/blob/v0.59.0/pgql_s_example.py) - Examples for all supported QueryNode queries and mutations
+  - [Asynchronous Client](https://github.com/FrankC01/pysui/blob/v0.59.0/pgql_a_example.py) - Examples for all supported QueryNode queries and mutations
+  - [Synchronous TransactionBuilder](https://github.com/FrankC01/pysui/blob/v0.59.0/pgql_s_ptb.py) - Example of new pysui Transaction Builder leveraging Sui GraphQL
 
 You can read pysui documentation on graphql beta [here](https://pysui.readthedocs.io/en/latest/graphql.html)
 
 #### Known Issues
 - Sui GraphQL fails fetching ProtocolConfiguration versions greater than 39
 - No subscription support at this time
```

## Comparing `pysui-0.59.0.dist-info/RECORD` & `pysui-0.60.0.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 env/bin/rst2odt_prepstyles.py,sha256=mMCFvseAGsdkIODEEZvbCytJeecv0FGec-317CrM0Ys,627
 env/bin/rst2pseudoxml.py,sha256=9KxJUnDneykYwIC8Dc2wb5Lm7BYlMU1tV-L_-KbYEn8,640
 env/bin/rst2s5.py,sha256=fs3GoqAuCV2W1GpOsQBuej7GFt493w9N0fySF4cQaSQ,676
 env/bin/rst2xetex.py,sha256=qjgCb0yRbDuihoPEXXuws5vKIIcmoqNRFeveugbAawU,912
 env/bin/rst2xml.py,sha256=pxeb0VfHETw1i_Jk71wwF3iZx3QRcTzndDfL30Uqs_0,641
 env/bin/rstpep2html.py,sha256=EVVfxzk8lG4u-GvTB46oIar4uZCVMnnGX9uEQwEEA5k,709
 pysui/__init__.py,sha256=GcTU4Clv2K5TmrgztJDOuUPSRbxknY-IWZNk1UXW81k,1472
-pysui/version.py,sha256=1GmwVWGeyF2bGldjTVta0OaTO-6qTiuwam8Z1cL4Uuc,716
+pysui/version.py,sha256=pPYjtgZYcDMcvAUDETeSMQFDfYY2oibc7eidLUilUVg,716
 pysui/abstracts/__init__.py,sha256=0IwhbXqnQ0meCUKUP-BMjwUHw1Eis--19Q23tA-LD9o,1028
 pysui/abstracts/client_config.py,sha256=OXbK6Y7W4FgJ7xnlds-O7-e2iqNnI9GkYc8tvnQ2MoU,12823
 pysui/abstracts/client_keypair.py,sha256=_sbDiw9Is8Ubr_mF2p-Adt9y9mQ7C9zU4jBWTrqI0bU,4537
 pysui/abstracts/client_rpc.py,sha256=__yFMyr6Qif6tigR9qjupSaUc007doRGJtBl2W_Q3aM,3215
 pysui/abstracts/client_types.py,sha256=et1AwV6XAYhqxmIt0g38Qmulgpo5JCrdR32YdszC4Wo,2333
 pysui/sui/__init__.py,sha256=BptkRx4PJaoUCK1TRLAhQHIjvlvt0tDe2XjgiCOeTnQ,951
 pysui/sui/sui_apidesc.py,sha256=RqeiP0C5YRENHtTTm-X0LZW7JGB5UyiYudwBDv_XEaM,7305
@@ -29,43 +29,43 @@
 pysui/sui/sui_builders/__init__.py,sha256=8G-WxIkItb4IgfT_A9Pf6m2LhiB3em3F9vJ26nLHyXM,657
 pysui/sui/sui_builders/base_builder.py,sha256=kPSbQU0sm0-XrHG577T4ezMBp5CynEwrWwLNGTqdDAQ,14665
 pysui/sui/sui_builders/exec_builders.py,sha256=L3RtN0j4Vtwq4Nrav05hhbChLmB2yQ3wTgOK1zyW2T0,6005
 pysui/sui/sui_builders/get_builders.py,sha256=_uUwS197Uq2dXLZzz03vFCt-wuG2EZIZLDuOT63jS6Q,33767
 pysui/sui/sui_builders/subscription_builders.py,sha256=iZy-_pWZjbAumGxujZcR7UJsDKuYjq-rCaWBuz5nClI,3544
 pysui/sui/sui_clients/__init__.py,sha256=nmtwkY4INLwckBS0BUD06TAIGd8fho6HJHQCBNMkpqs,710
 pysui/sui/sui_clients/async_client.py,sha256=X6AsMQIxxf1cpkDTK8xYI46qNazhgVha9z-MR_OvsKc,23088
-pysui/sui/sui_clients/common.py,sha256=O6pYoY46fR4jaLj7-8K9vg_X92UWA5kzb_zeAE0A6nI,13557
+pysui/sui/sui_clients/common.py,sha256=eIBCpyVdFsaWYm7sj8_0tF7KCluXluTHbHXulPpSpk8,13557
 pysui/sui/sui_clients/subscribe.py,sha256=-UgyJZ2esPScYUdO4SczqQemXQYtU8j46Bv_c-YSHpM,17397
 pysui/sui/sui_clients/sync_client.py,sha256=M_CzTsmz1D6BSqRz5mbORwaj7XNxoemUq6azlIbWK90,22556
 pysui/sui/sui_pgql/__init__.py,sha256=iuY6tP_cUcfumvHmChObIRHbp6g7la3np2YLoFnJfeY,140
-pysui/sui/sui_pgql/pgql_clients.py,sha256=cLCuE7S01Y2NMwOSWe4Hs4UzatUmZp9Q4-6XpQNl7mw,22909
-pysui/sui/sui_pgql/pgql_configs.py,sha256=NHg1dRZIFht4FtBOvmTA2BcvWrZodYl2vsw1wzaCXh8,2654
-pysui/sui/sui_pgql/pgql_fragments.py,sha256=uR0H_mbnoUwL9FQfoKMdsvb6l2zfHmcQc2CgwNj35wM,23621
-pysui/sui/sui_pgql/pgql_query.py,sha256=3OC69FivE8PQQ-RJ_wNh3ELYUycH1HTvA8S_Ag1y-ZA,55757
-pysui/sui/sui_pgql/pgql_sync_txn.py,sha256=wHbJwUSGOTVuxCkirH8nly2rfNwNBoGJpGBo6HBK6-E,28272
-pysui/sui/sui_pgql/pgql_txb_gas.py,sha256=PRtcc-6x6GKv7LtmkwHXDuP-IBWyP13gu5pWB5D-azs,5835
+pysui/sui/sui_pgql/pgql_clients.py,sha256=r-wha6WYx9ZkEpNhZikOicTfPCKZoZTpxel3Si1U5FI,20001
+pysui/sui/sui_pgql/pgql_configs.py,sha256=FSlWqraw4-TVIpIV3g6jGNcPNnbOq1ttfp8fzz_KDD8,2654
+pysui/sui/sui_pgql/pgql_fragments.py,sha256=GzG6Hc_nOy7WttYkILoM8PKJMhjYpt_0ZaPg9zeghw0,24015
+pysui/sui/sui_pgql/pgql_query.py,sha256=vLHB8Ubo7Y7oLn-Cn9IzvJOOtBGVLLyhsyWmjwt-yeI,57677
+pysui/sui/sui_pgql/pgql_sync_txn.py,sha256=Jwz8X59GKU7pmVgOC8fOo9m-QdIcB_FYNWzTA2W7ZPw,28365
+pysui/sui/sui_pgql/pgql_txb_gas.py,sha256=BwM1qC5doinHV3fgBiSq6mXu8leG3EyCh0Gi-9qlOMo,5890
 pysui/sui/sui_pgql/pgql_txb_signing.py,sha256=Glm3mwkRBUZ5qn1Niqm-INqDWlT05YhpzkPv9BCEn64,4655
-pysui/sui/sui_pgql/pgql_txn_argb.py,sha256=HvYYEVLZ6KEBd_fbhvhHLzSNXwdl63Zh_Bj-ObpRacg,9663
-pysui/sui/sui_pgql/pgql_types.py,sha256=EILrZnVx6XNG_oGh-fGfdKz0qGVf_GfxavlGBerfhOI,39669
+pysui/sui/sui_pgql/pgql_txn_argb.py,sha256=3g8iuRK6CeqcOZggAg2_5fa94MsKtPvX2ay3riK8HjA,11482
+pysui/sui/sui_pgql/pgql_types.py,sha256=7Ws3aOqY4LuJCfOEFErcA1sikBo8DQ9acZ3X2cQ7hMk,41225
 pysui/sui/sui_pgql/pgql_validators.py,sha256=4aR5jnnGDww-wzsNLWIJ5AFZoEg1klERu6bRe5TGBMA,3722
 pysui/sui/sui_txn/__init__.py,sha256=0mP9UBHRCsI62rGKK3dMiPc79MGs9EFk9qU0O3hjdhM,933
 pysui/sui/sui_txn/async_transaction.py,sha256=ODoCBfqievi7YaeSHOAcm2oDvoBqFYwsOoiJicE7WsM,51464
 pysui/sui/sui_txn/signing_ms.py,sha256=ANoVuVthGIE8mB_fxgS3-AZU23foM9wMMTwtA2x_czA,13421
 pysui/sui/sui_txn/sync_transaction.py,sha256=fAuqHbtyWN_Li7UVbu1YfXgQpWM56d6AqSl1mP55Zmk,51915
 pysui/sui/sui_txn/transaction.py,sha256=6UL4YBXl8yHYufUiiKK5VSLruIGsEHdHjsQNTeyrnKE,20923
-pysui/sui/sui_txn/transaction_builder.py,sha256=puTz0O8BN4EENve-b1w0VNcHSpOBYbQXQ-ZfViM54P0,24256
+pysui/sui/sui_txn/transaction_builder.py,sha256=UMcyoBZXpXf2LzI2eKe3jsoIb0F-nN3GrLNCgnetHxk,24607
 pysui/sui/sui_txn/txn_deser.py,sha256=6UphwnOlphQpLWPZr_J7myg9M2GTd49DGvHG6JJ62Yg,8062
 pysui/sui/sui_txresults/__init__.py,sha256=wYMkioxWPTznPyxhw1t87db2kQsYrgVSUKb9IXjApZg,867
 pysui/sui/sui_txresults/common.py,sha256=Awz3MfdJjUFyMR2jFeu6h1K8KW4BKB5Js8X4ISD2ASs,2114
 pysui/sui/sui_txresults/complex_tx.py,sha256=uy7dqkqeJa964WrOXGjY57yYifPaP5MehBO2oYckiis,19637
 pysui/sui/sui_txresults/package_meta.py,sha256=zXPCxGOAEH4VCwQAagWDdP7L7evvX7W2G9bSC2eiSwM,9592
 pysui/sui/sui_txresults/single_tx.py,sha256=O_SIGzFRMbOGvJ90Z6Ox_nx09tx5J7rqmWtlhqLQCL8,34404
 pysui/sui/sui_types/__init__.py,sha256=oYD75Ylj7Xp4sO-3RH-xEcr1oCc0Bi2fS9AbM_TZXkk,785
 pysui/sui/sui_types/address.py,sha256=vgmnCiSwrAny0bH90VDBqPFmOmgUbWd-y7TseUpvGL0,4206
-pysui/sui/sui_types/bcs.py,sha256=uly--dhcFcZcGQ1ojmPx7gMAIIJ2gI7Nc1aPsT1K5w0,26146
+pysui/sui/sui_types/bcs.py,sha256=Nm643o-WdwXHCCc_6dl9FpYV7TYt1iuZYYT_S6vqkHM,27567
 pysui/sui/sui_types/collections.py,sha256=lEKFeg9iOq53Y24cEIx1AwmlrI6GB3Sqth8uWCQG0Rs,5226
 pysui/sui/sui_types/event_filter.py,sha256=DgWsbIvBEgMfZgxZXaQF5qHvUNMkkMhYcL-xsKY6zHk,9550
 pysui/sui/sui_types/scalars.py,sha256=dXk3QM97XsTC3dJ0jTz56-QdJa-mloExJknZYvoHjSQ,12959
 pysui/sui/sui_types/transaction_filter.py,sha256=Y2JYg0TsX_zIR-rTZ4rbqO1hgb-K0QRs3WSNP_QXtic,6523
 pysui/sui_move/__init__.py,sha256=QckmTpCGNiYAjz22TaY1ARrdVg5m-59JDv_khgrcY3U,647
 pysui/sui_move/bin_reader/__init__.py,sha256=wQlO02-dCFWsl_7AygJpbNQIzSskJOLKQpmDjjlSM0w,653
 pysui/sui_move/bin_reader/module_reader.py,sha256=wqGDzj1Km-x9SupGB5iMCxb3AacYQdBKlb_DWcfSjAo,6811
@@ -83,13 +83,13 @@
 samples/cmd_arg_validators.py,sha256=NJURJhX04k9z56nd4wqul2GWQBgSmHyki51UjnFAJG8,4235
 samples/cmd_args.py,sha256=tX-irEGHFLnwc7J4I874srW1vc8bJS-PWtfFQf-9N8Q,26970
 samples/cmd_argsg.py,sha256=O-QFVJ6Zk-yUbpKlGibKG2XgjO8bWuYXX6jaAXrDRjI,21465
 samples/cmds.py,sha256=Khq3NYC2LRDythNgiTLbFH0Rc4v8H4BjkAWGFYjUpeg,23598
 samples/cmdsg.py,sha256=BMZ1T_M8i2lk7I0UTdMqbXTB-VLTUsYKL0TvtbVEN7Y,19264
 samples/wallet.py,sha256=4Bb38mmiBB2akVoM-9BPEX-P097I1fSsuxgsEbnMuRk,2061
 samples/walletg.py,sha256=ZO_uDeW_ytCagDElt1W7xK-zhFHtl1JiXngWW70W_4s,1572
-pysui-0.59.0.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-pysui-0.59.0.dist-info/METADATA,sha256=EsRy_30CKPg7f8nz7C4FCdDKvR0XzRb8XFpRJ7AtFgA,5651
-pysui-0.59.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-pysui-0.59.0.dist-info/entry_points.txt,sha256=q0Zn1ui4bYi3xGPZ3i9B2skLWVWqm9H6X3kMRwy0K2M,191
-pysui-0.59.0.dist-info/top_level.txt,sha256=ynrE8s1XHT2oEB-Ac1HRArfNYEjhkzd3x9QaYZUwLR8,27
-pysui-0.59.0.dist-info/RECORD,,
+pysui-0.60.0.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+pysui-0.60.0.dist-info/METADATA,sha256=RSwJIG3DTDLmvkVihKa24AUoPYpcb_cbDJraErA4uNE,5658
+pysui-0.60.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+pysui-0.60.0.dist-info/entry_points.txt,sha256=q0Zn1ui4bYi3xGPZ3i9B2skLWVWqm9H6X3kMRwy0K2M,191
+pysui-0.60.0.dist-info/top_level.txt,sha256=ynrE8s1XHT2oEB-Ac1HRArfNYEjhkzd3x9QaYZUwLR8,27
+pysui-0.60.0.dist-info/RECORD,,
```

