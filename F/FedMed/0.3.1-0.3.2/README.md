# Comparing `tmp/FedMed-0.3.1-py3-none-any.whl.zip` & `tmp/FedMed-0.3.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,30 @@
-Zip file size: 19300 bytes, number of entries: 27
+Zip file size: 21137 bytes, number of entries: 28
 -rw-rw-rw-  2.0 fat       77 b- defN 23-Nov-16 09:58 fedmed/__init__.py
 -rw-rw-rw-  2.0 fat      240 b- defN 24-Jan-25 01:16 fedmed/core/__init__.py
--rw-rw-rw-  2.0 fat     6086 b- defN 24-Jan-24 02:02 fedmed/core/data.py
--rw-rw-rw-  2.0 fat     4475 b- defN 23-Nov-17 15:04 fedmed/core/local.py
--rw-rw-rw-  2.0 fat     2883 b- defN 24-Jan-25 15:57 fedmed/core/remote.py
--rw-rw-rw-  2.0 fat     8486 b- defN 24-Jan-25 15:59 fedmed/core/server.py
--rw-rw-rw-  2.0 fat     4490 b- defN 24-Jan-25 15:57 fedmed/core/simulation.py
+-rw-rw-rw-  2.0 fat     6457 b- defN 24-Apr-03 11:53 fedmed/core/data.py
+-rw-rw-rw-  2.0 fat     4549 b- defN 24-Mar-17 12:15 fedmed/core/local.py
+-rw-rw-rw-  2.0 fat     3044 b- defN 24-Mar-17 12:29 fedmed/core/remote.py
+-rw-rw-rw-  2.0 fat     8540 b- defN 24-Apr-03 12:10 fedmed/core/server.py
+-rw-rw-rw-  2.0 fat     5654 b- defN 24-Mar-17 12:14 fedmed/core/simulation.py
 -rw-rw-rw-  2.0 fat     6260 b- defN 24-Jan-10 12:37 fedmed/core/templates.py
 -rw-rw-rw-  2.0 fat       63 b- defN 23-Nov-16 09:51 fedmed/ops/__init__.py
--rw-rw-rw-  2.0 fat      933 b- defN 24-Jan-25 15:27 fedmed/ops/binary.py
--rw-rw-rw-  2.0 fat     1266 b- defN 24-Jan-25 15:05 fedmed/ops/private.py
--rw-rw-rw-  2.0 fat      877 b- defN 23-Nov-16 09:53 fedmed/ops/public.py
+-rw-rw-rw-  2.0 fat     1105 b- defN 24-Mar-17 12:56 fedmed/ops/binary.py
+-rw-rw-rw-  2.0 fat     1368 b- defN 24-Mar-17 13:12 fedmed/ops/private.py
+-rw-rw-rw-  2.0 fat     1064 b- defN 24-Mar-17 13:11 fedmed/ops/public.py
 -rw-rw-rw-  2.0 fat      347 b- defN 24-Jan-10 13:29 fedmed/privacy/__init__.py
--rw-rw-rw-  2.0 fat     1929 b- defN 24-Jan-25 15:03 fedmed/privacy/anonymity.py
--rw-rw-rw-  2.0 fat     1999 b- defN 24-Jan-10 13:08 fedmed/privacy/coarsening.py
+-rw-rw-rw-  2.0 fat     2048 b- defN 24-Mar-15 11:10 fedmed/privacy/anonymity.py
+-rw-rw-rw-  2.0 fat     2171 b- defN 24-Mar-15 11:10 fedmed/privacy/coarsening.py
 -rw-rw-rw-  2.0 fat     1203 b- defN 24-Jan-10 12:13 fedmed/privacy/combined.py
--rw-rw-rw-  2.0 fat     2803 b- defN 24-Jan-10 13:08 fedmed/privacy/memory.py
--rw-rw-rw-  2.0 fat     1990 b- defN 24-Jan-10 13:07 fedmed/privacy/noise.py
--rw-rw-rw-  2.0 fat     2552 b- defN 24-Jan-10 13:27 fedmed/privacy/saturation.py
+-rw-rw-rw-  2.0 fat     3050 b- defN 24-Mar-15 11:10 fedmed/privacy/memory.py
+-rw-rw-rw-  2.0 fat     2266 b- defN 24-Mar-15 11:10 fedmed/privacy/noise.py
+-rw-rw-rw-  2.0 fat     2724 b- defN 24-Mar-15 11:10 fedmed/privacy/saturation.py
 -rw-rw-rw-  2.0 fat      512 b- defN 24-Jan-10 11:10 fedmed/privacy/trustful.py
--rw-rw-rw-  2.0 fat       62 b- defN 23-Dec-01 09:27 fedmed/stats/__init__.py
--rw-rw-rw-  2.0 fat      506 b- defN 24-Jan-25 15:10 fedmed/stats/base.py
--rw-rw-rw-  2.0 fat     1694 b- defN 23-Dec-13 14:06 fedmed/stats/test.py
--rw-rw-rw-  2.0 fat     4360 b- defN 24-Jan-25 16:02 FedMed-0.3.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Jan-25 16:02 FedMed-0.3.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 24-Jan-25 16:02 FedMed-0.3.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2118 b- defN 24-Jan-25 16:02 FedMed-0.3.1.dist-info/RECORD
-27 files, 58310 bytes uncompressed, 15926 bytes compressed:  72.7%
+-rw-rw-rw-  2.0 fat      100 b- defN 24-Jan-28 13:17 fedmed/stats/__init__.py
+-rw-rw-rw-  2.0 fat     2755 b- defN 24-May-15 21:16 fedmed/stats/base.py
+-rw-rw-rw-  2.0 fat      145 b- defN 24-Mar-15 11:10 fedmed/stats/correlation.py
+-rw-rw-rw-  2.0 fat     1708 b- defN 24-Mar-15 11:10 fedmed/stats/test.py
+-rw-rw-rw-  2.0 fat     5610 b- defN 24-May-15 21:58 FedMed-0.3.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-15 21:58 FedMed-0.3.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 24-May-15 21:58 FedMed-0.3.2.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2205 b- defN 24-May-15 21:58 FedMed-0.3.2.dist-info/RECORD
+28 files, 65364 bytes uncompressed, 17633 bytes compressed:  73.0%
```

## zipnote {}

```diff
@@ -60,23 +60,26 @@
 
 Filename: fedmed/stats/__init__.py
 Comment: 
 
 Filename: fedmed/stats/base.py
 Comment: 
 
+Filename: fedmed/stats/correlation.py
+Comment: 
+
 Filename: fedmed/stats/test.py
 Comment: 
 
-Filename: FedMed-0.3.1.dist-info/METADATA
+Filename: FedMed-0.3.2.dist-info/METADATA
 Comment: 
 
-Filename: FedMed-0.3.1.dist-info/WHEEL
+Filename: FedMed-0.3.2.dist-info/WHEEL
 Comment: 
 
-Filename: FedMed-0.3.1.dist-info/top_level.txt
+Filename: FedMed-0.3.2.dist-info/top_level.txt
 Comment: 
 
-Filename: FedMed-0.3.1.dist-info/RECORD
+Filename: FedMed-0.3.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fedmed/core/data.py

```diff
@@ -10,14 +10,17 @@
                 self.config = yaml.safe_load(file)
         else:
             self.config = config
         self.devices = list()
         if devices is not None:
             self.register(devices)
 
+    def __str__(self):
+        return f"FedData ({len(self.devices)} devices)" + "".join("\n\t"+str(device) for device in self.devices)
+
     def __getitem__(self, item):
         return FedData([device[item] for device in self.devices], self.config)
 
     def __mul__(self, other):
         if isinstance(other, FedData):
             return FedData(
                 [device * o for device, o in zip(self.devices, other.devices)]
@@ -58,24 +61,24 @@
                 [o - device for device, o in zip(self.devices, other.devices)]
             )
         return FedData([other - device for device in self.devices], self.config)
 
     def __pow__(self, other):
         if isinstance(other, FedData):
             return FedData(
-                [device ** o for device, o in zip(self.devices, other.devices)]
+                [device**o for device, o in zip(self.devices, other.devices)]
             )
-        return FedData([device ** other for device in self.devices], self.config)
+        return FedData([device**other for device in self.devices], self.config)
 
     def __rpow__(self, other):
         if isinstance(other, FedData):
             return FedData(
-                [o ** device for device, o in zip(self.devices, other.devices)]
+                [o**device for device, o in zip(self.devices, other.devices)]
             )
-        return FedData([other ** device for device in self.devices], self.config)
+        return FedData([other**device for device in self.devices], self.config)
 
     def __eq__(self, other):
         if isinstance(other, FedData):
             return FedData(
                 [device == o for device, o in zip(self.devices, other.devices)]
             )
         return FedData([device == other for device in self.devices], self.config)
@@ -134,20 +137,26 @@
         self.devices.extend(devices)
         return self
 
     def run(self, request):
         if isinstance(request, str):
             request = (request, {})
         method, kwargs = request
-        method = self.config["methods"][method]["reduce"]
-        package, method = method.rsplit(".", 1)
-        importlib.__import__(package)
-        method = getattr(sys.modules[package], method)
-        results = [device.run(request) for device in self.devices]
-        return method(results)
+        if not isinstance(self.config["methods"][method], str):
+            method = self.config["methods"][method]["reduce"]
+            package, method = method.rsplit(".", 1)
+            importlib.__import__(package)
+            method = getattr(sys.modules[package], method)
+            results = [device.run(request) for device in self.devices]
+            return method(results)
+        else:
+            return FedData(
+                [device.operator(method, None) for device in self.devices], self.config
+            )
+
 
     def __getattr__(self, item):
         if item in ["run", "devices", "config", "register", "operator"]:
             return object.__getattribute__(self, item)
 
         def method(**kwargs):
             return self.run((item, kwargs))
```

## fedmed/core/local.py

```diff
@@ -18,14 +18,17 @@
         if isinstance(config, str):
             with open(config, "r") as file:
                 self.config = yaml.safe_load(file)
         else:
             self.config = config
         self.policy = Trustful()
 
+    def __str__(self):
+        return f"Local fast data: {self.data}"
+
     def __getitem__(self, item):
         return Local(self.data[item], self.config)
 
     def operator(self, name, other):
         data = other.data if isinstance(other, Local) else other
         assert name in self.config["methods"]
         return Local(
```

## fedmed/core/remote.py

```diff
@@ -4,22 +4,27 @@
 
 class Remote:
     def __init__(self, ip, fragment, subpoint=None):
         self.ip = ip
         self.fragment = fragment
         self.subpoint = list() if subpoint is None else subpoint
 
+    def __str__(self):
+        return f"Connection at {self.ip} to data fragment: {'.'.join([self.fragment]+self.subpoint)}"
+
     def __getitem__(self, item):
         return Remote(self.ip, self.fragment, self.subpoint + [item])
 
     def _binoperator(self, name, other):
         method = name
         payload = {
             "subpoint": self.subpoint,
-            "kwargs": {"other": [other.fragment] if isinstance(other, Remote) else other},
+            "kwargs": {
+                "other": [other.fragment] if isinstance(other, Remote) else other
+            },
         }
         response = requests.post(f"{self.ip}/{self.fragment}/{method}", json=payload)
         if response.status_code == 200:
             return str(response.json())
         else:
             return f"Failed to execute {method}. Status code: {response.status_code}"
```

## fedmed/core/server.py

```diff
@@ -13,15 +13,15 @@
 
 class Server:
     def purpose(self, key):
         if "." not in key:
             return [key, '<span class="badge bg-info text-dark">Raw</span>']
         fragment = key.split(".", 1)[0]
         request = key
-        return [fragment, request]#.replace("_", "")]
+        return [fragment, request]  # .replace("_", "")]
 
     def desc(self, value):
         if isinstance(value, list) or isinstance(value, dict):
             return "JSON"
         return value.__class__.__name__
 
     def on_update(self, fragment, value):
@@ -62,16 +62,16 @@
             mem = psutil.virtual_memory()
             ret = render_template_string(
                 templates._index,
                 config=self.path,
                 operations=len(self.config["methods"]),
                 policies=len(self.policy.policies),
                 percmemory=int(100 * mem.used / mem.total),
-                memory=int(mem.used/1024/1024/1024),
-                maxmemory=int(mem.total/1024/1024/1024),
+                memory=int(mem.used / 1024 / 1024 / 1024),
+                maxmemory=int(mem.total / 1024 / 1024 / 1024),
             )
             self.memory_lock.release()
             return ret
 
         @self.app.route("/config", methods=["GET"])
         def config():
             with open(self.path, "r") as file:
@@ -144,17 +144,15 @@
                             return jsonify(f"Item {item} does not exist"), 400
                         fragment2 = fragment2[item]
                     subpoint2_alias = ".".join(kwargs["other"])
                 else:
                     fragment2 = kwargs["other"]
                     subpoint2_alias = fragment2
                 if not subpoint:
-                    new_name = (
-                        f"{fragment}.{method}({subpoint2_alias})"
-                    )
+                    new_name = f"{fragment}.{method}({subpoint2_alias})"
                 else:
                     new_name = (
                         f"{fragment}.{method}({'.'.join(subpoint)}, {subpoint2_alias})"
                     )
                 self.memory_lock.release()
                 method = self.config["methods"][method]
                 assert isinstance(method, str)
@@ -165,19 +163,20 @@
                     output = method(fragment1, fragment2)
                     self.on_update(new_name, output)
                 except Exception as e:
                     print(str(e))
                     return jsonify(str(e)), 400
                 return jsonify(new_name), 200
             self.memory_lock.acquire()
-            new_name = (
-                f"{fragment}.{method}({'.'.join(subpoint)})"
-            )
+            new_name = f"{fragment}.{method}({'.'.join(subpoint)})"
+            #print(self.fragments.keys())
             fragment = self.fragments[fragment]
-            method = self.config["methods"][method]["map"]
+            method = self.config["methods"][method]
+            if not isinstance(method, str):
+                method = method["map"]
             package, method = method.rsplit(".", 1)
             importlib.__import__(package)
             method = getattr(sys.modules[package], method)
             for item in subpoint:
                 if item not in fragment:
                     return jsonify(f"Item {item} does not exist"), 400
                 fragment = fragment[item]
@@ -189,15 +188,15 @@
         def process_fragment_method(fragment, method):
             data = request.json
             return manual_request(fragment, method, data=data, jsonify=jsonify)
 
         self.manual_request = manual_request
 
     def __setitem__(self, key, value):
-        assert key!="self", "Fragment name should not be 'self' '.'."
+        assert key != "self", "Fragment name should not be 'self' '.'."
         assert "." not in key, "Fragment name should not contain '.'."
         assert "(" not in key, "Fragment name should not contain '('."
         assert ")" not in key, "Fragment name should not contain ')'."
         assert "*" not in key, "Fragment name should not contain '*'."
         assert "?" not in key, "Fragment name should not contain '?'."
         assert "/" not in key, "Fragment name should not contain '/'."
         self.memory_lock.acquire()
```

## fedmed/core/simulation.py

```diff
@@ -20,87 +20,169 @@
 
 
 class Simulation:
     def __init__(self, server, fragment, subpoint=None, communication=None):
         self.server = server
         self.fragment = fragment
         self.subpoint = list() if subpoint is None else subpoint
-        self.communication = SimulatedCommunication() if communication is None else communication
+        self.communication = (
+            SimulatedCommunication() if communication is None else communication
+        )
+
+    def __str__(self):
+        return f"Simulated connection to data fragment: {'.'.join([self.fragment]+self.subpoint)}"
 
     def __getitem__(self, item):
-        return Simulation(self.server, self.fragment, self.subpoint + [item], communication=self.communication)
+        return Simulation(
+            self.server,
+            self.fragment,
+            self.subpoint + [item],
+            communication=self.communication,
+        )
 
     def _binoperator(self, name, other):
         method = name
         payload = {
             "subpoint": self.subpoint,
-            "kwargs": {"other": [other.fragment] if isinstance(other, Simulation) else other},
+            "kwargs": {
+                "other": [other.fragment] + other.subpoint
+                if isinstance(other, Simulation)
+                else other
+            },
         }
-        #print(method, self.fragment, payload)
+        # print(method, self.fragment, payload)
         payload = self.communication.send(payload)
-        response, status_code = self.server.manual_request(self.fragment, method, payload)
+        response, status_code = self.server.manual_request(
+            self.fragment, method, payload
+        )
         response, status_code = self.communication.receive((response, status_code))
         response = json.loads(response)
         if status_code == 200:
             return str(response)
         else:
             return f"Failed to execute {method}. Status code: {status_code}"
 
     def operator(self, name, other):
-        return Simulation(self.server, self._binoperator(name, other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator(name, other),
+            communication=self.communication,
+        )
 
     def __mul__(self, other):
-        return Simulation(self.server, self._binoperator("__mul__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__mul__", other),
+            communication=self.communication,
+        )
 
     def __add__(self, other):
-        return Simulation(self.server, self._binoperator("__add__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__add__", other),
+            communication=self.communication,
+        )
 
     def __radd__(self, other):
-        return Simulation(self.server, self._binoperator("__radd__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__radd__", other),
+            communication=self.communication,
+        )
 
     def __sub__(self, other):
-        return Simulation(self.server, self._binoperator("__sub__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__sub__", other),
+            communication=self.communication,
+        )
 
     def __rsub__(self, other):
-        return Simulation(self.server, self._binoperator("__rsub__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__rsub__", other),
+            communication=self.communication,
+        )
 
     def __pow__(self, other):
-        return Simulation(self.server, self._binoperator("__pow__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__pow__", other),
+            communication=self.communication,
+        )
 
     def __rpow__(self, other):
-        return Simulation(self.server, self._binoperator("__rpow__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__rpow__", other),
+            communication=self.communication,
+        )
 
     def __rmul__(self, other):
-        return Simulation(self.server, self._binoperator("__rmul__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__rmul__", other),
+            communication=self.communication,
+        )
 
     def __eq__(self, other):
-        return Simulation(self.server, self._binoperator("__eq__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__eq__", other),
+            communication=self.communication,
+        )
 
     def __ne__(self, other):
-        return Simulation(self.server, self._binoperator("__ne__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__ne__", other),
+            communication=self.communication,
+        )
 
     def __lt__(self, other):
-        return Simulation(self.server, self._binoperator("__lt__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__lt__", other),
+            communication=self.communication,
+        )
 
     def __le__(self, other):
-        return Simulation(self.server, self._binoperator("__le__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__le__", other),
+            communication=self.communication,
+        )
 
     def __gt__(self, other):
-        return Simulation(self.server, self._binoperator("__gt__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__gt__", other),
+            communication=self.communication,
+        )
 
     def __ge__(self, other):
-        return Simulation(self.server, self._binoperator("__ge__", other), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__ge__", other),
+            communication=self.communication,
+        )
 
     def __abs__(self):
-        return Simulation(self.server, self._binoperator("__abs__", ""), communication=self.communication)
+        return Simulation(
+            self.server,
+            self._binoperator("__abs__", ""),
+            communication=self.communication,
+        )
 
     def run(self, request):
         method, kwargs = request
         payload = {"subpoint": self.subpoint, "kwargs": kwargs}
         payload = self.communication.send(payload)
-        response, status_code = self.server.manual_request(self.fragment, method, payload)
+        response, status_code = self.server.manual_request(
+            self.fragment, method, payload
+        )
         response, status_code = self.communication.receive((response, status_code))
         response = json.loads(response)
         if status_code == 200:
             return response
         else:
             return f"Failed to execute {method}. Status code: {status_code}"
```

## fedmed/ops/binary.py

```diff
@@ -9,21 +9,22 @@
         return method(a, b)
 
     return wrapper
 
 
 @operator
 def pow(a, b):
-    return a ** b
+    return a**b
 
 
 @operator
 def add(a, b):
     return a + b
 
+
 @operator
 def mul(a, b):
     return a * b
 
 
 @operator
 def sub(a, b):
@@ -58,7 +59,14 @@
 @operator
 def ge(a, b):
     return a >= b
 
 
 def abs(a, _):
     return [ae if ae > 0 else -ae for ae in a]
+
+
+def round(a, precision):
+    if precision is None:
+        return [int(ae+0.5) for ae in a]
+    else:
+        return [int(ae/precision+0.5)*precision for ae in a]
```

## fedmed/ops/private.py

```diff
@@ -23,14 +23,17 @@
 def unique(entries, policy):
     counts = Counter(entries)
     return [value for value, _ in policy.bins(counts.items())]
 
 
 @privatize
 def distribution(entries, policy):
+    #numbins = 10
+    #width = (max(entries, None)-min(entries, None)) / numbins
+    #entries = []
     pass
 
 
 @privatize
 def max(entries):
     if not entries:
         return None
@@ -43,15 +46,15 @@
 
 @privatize
 def min(entries):
     if not entries:
         return None
     ret = entries[0]
     for val in entries:
-        if val > ret:
+        if val < ret:
             ret = val
     return ret
 
 
 @privatize
 def sum(entries):
     ret = 0
```

## fedmed/ops/public.py

```diff
@@ -24,23 +24,32 @@
     if len(entries) <= 0:
         return None
     ret = entries[0]
     for val in entries:
         if val > ret:
             ret = val
     return ret
+@reductor
+def max(entries):
+    if len(entries) <= 0:
+        return None
+    ret = entries[0]
+    for val in entries:
+        if val > ret:
+            ret = val
+    return ret
 
 
 @reductor
 def min(entries):
     if len(entries) <= 0:
         return None
     ret = entries[0]
     for val in entries:
-        if val > ret:
+        if val < ret:
             ret = val
     return ret
 
 
 @reductor
 def sum(entries):
     ret = 0
```

## fedmed/privacy/anonymity.py

```diff
@@ -14,22 +14,34 @@
                 return None
         for condition in self.condition:
             if fnmatch.fnmatch(fragment, condition):
                 return self
         return None
 
     def name(self):
-        if '\n'.join(self.condition) == '*':
+        if "\n".join(self.condition) == "*":
             cond = ""
         else:
-            cond = " on:<br>&emsp;<i>"+"<br>&emsp;".join(self.condition).replace("*", '<span style="color: blue;">&lowast;</span>')+'</i>'
+            cond = (
+                " on:<br>&emsp;<i>"
+                + "<br>&emsp;".join(self.condition).replace(
+                    "*", '<span style="color: blue;">&lowast;</span>'
+                )
+                + "</i>"
+            )
         for reject in self.reject:
-            cond += "<br>&emsp;<b style=\"color:red\";>ignore</b>&nbsp;&nbsp;<i>" + reject.replace("*",
-                                                                                                   '<span style="color: blue;">&lowast;</span>') + '</i>'
-        return f'<span class="badge bg-success text-light" style="width:30px">{self.k}</span> Anonymity'+cond
+            cond += (
+                '<br>&emsp;<b style="color:red";>ignore</b>&nbsp;&nbsp;<i>'
+                + reject.replace("*", '<span style="color: blue;">&lowast;</span>')
+                + "</i>"
+            )
+        return (
+            f'<span class="badge bg-success text-light" style="width:30px">{self.k}</span> Anonymity'
+            + cond
+        )
 
     def description(self):
         return (
             f"Any Map operation (e.g., num, sum) outcome is computed across at least {self.k} samples."
             f" For example, arrays with fewer elements are returned as empty,"
             f" and quantiles or unique computations should have at least that"
             f" many samples in each bin."
```

## fedmed/privacy/coarsening.py

```diff
@@ -6,22 +6,34 @@
         self.value = value
         self.type = type
         self.applied = 0
         self.condition = kwargs.get("filter", ["*"])
         self.reject = kwargs.get("reject", [])
 
     def name(self):
-        if '\n'.join(self.condition) == '*':
+        if "\n".join(self.condition) == "*":
             cond = ""
         else:
-            cond = " on:<br>&emsp;<i>"+"<br>&emsp;".join(self.condition).replace("*", '<span style="color: blue;">&lowast;</span>')+'</i>'
+            cond = (
+                " on:<br>&emsp;<i>"
+                + "<br>&emsp;".join(self.condition).replace(
+                    "*", '<span style="color: blue;">&lowast;</span>'
+                )
+                + "</i>"
+            )
         for reject in self.reject:
-            cond += "<br>&emsp;<b style=\"color:red\";>ignore</b>&nbsp;&nbsp;<i>" + reject.replace("*",
-                                                                                                   '<span style="color: blue;">&lowast;</span>') + '</i>'
-        return f'<span class="badge bg-secondary text-light">{self.value}</span> Precision for {self.type}s' + cond
+            cond += (
+                '<br>&emsp;<b style="color:red";>ignore</b>&nbsp;&nbsp;<i>'
+                + reject.replace("*", '<span style="color: blue;">&lowast;</span>')
+                + "</i>"
+            )
+        return (
+            f'<span class="badge bg-secondary text-light">{self.value}</span> Precision for {self.type}s'
+            + cond
+        )
 
     def description(self):
         return (
             f"Any Map operation (e.g., num, sum) outcome of type {self.type}"
             f" is coarsened to numerical precision {self.value}. This"
             f" includes quantile calculations. Other data types require"
             f" different versions of this rule."
@@ -33,15 +45,18 @@
                 return None
         for condition in self.condition:
             if fnmatch.fnmatch(fragment, condition):
                 return self
         return None
 
     def bins(self, results):
-        return [(value, self.postprocess(count)) for value, count in results]
+        return [
+            (self.postprocess(value), self.postprocess(count))
+            for value, count in results
+        ]
 
     def preprocess(self, entries):
         return entries
 
     def postprocess(self, result):
         if self.type == result.__class__.__name__:
             self.applied += 1
```

## fedmed/privacy/memory.py

```diff
@@ -7,16 +7,18 @@
         self.applied = 0
         self.condition = ["*"]
 
     def name(self):
         return f'<span class="badge bg-primary text-light" style="width:30px">{self.limit}</span> Cache limit'
 
     def description(self):
-        return f"Stores up to {self.limit} cached computations." \
-               f" This protects your server by limiting total memory size."
+        return (
+            f"Stores up to {self.limit} cached computations."
+            f" This protects your server by limiting total memory size."
+        )
 
     def on(self, fragment):
         return self
 
     def bins(self, results):
         return results
 
@@ -37,28 +39,42 @@
     def __init__(self, cap, **kwargs):
         self.cap = cap
         self.applied = 0
         self.condition = kwargs.get("filter", ["*"])
         self.reject = kwargs.get("reject", [])
 
     def name(self):
-        if '\n'.join(self.condition) == '*':
+        if "\n".join(self.condition) == "*":
             cond = ""
         else:
-            cond = " on:<br>&emsp;<i>"+"<br>&emsp;".join(self.condition).replace("*", '<span style="color: blue;">&lowast;</span>')+'</i>'
+            cond = (
+                " on:<br>&emsp;<i>"
+                + "<br>&emsp;".join(self.condition).replace(
+                    "*", '<span style="color: blue;">&lowast;</span>'
+                )
+                + "</i>"
+            )
         for reject in self.reject:
-            cond += "<br>&emsp;<b style=\"color:red\";>ignore</b>&nbsp;&nbsp;<i>" + reject.replace("*", '<span style="color: blue;">&lowast;</span>') + '</i>'
-        return f'<span class="badge bg-primary text-light" style="width:30px">{self.cap}</span> Complexity cap' + cond
-
+            cond += (
+                '<br>&emsp;<b style="color:red";>ignore</b>&nbsp;&nbsp;<i>'
+                + reject.replace("*", '<span style="color: blue;">&lowast;</span>')
+                + "</i>"
+            )
+        return (
+            f'<span class="badge bg-primary text-light" style="width:30px">{self.cap}</span> Complexity cap'
+            + cond
+        )
 
     def description(self):
-        return f"Prevents computations that involve more than this number of dependent operations." \
-               f" For example, this at worst allows multiplication of up to {self.cap}" \
-               f" data columns; if you have more than these columns then specific combinations" \
-               f" can never be explored by clients. A limit of 0 would prevents non-Map operations."
+        return (
+            f"Prevents computations that involve more than this number of dependent operations."
+            f" For example, this at worst allows multiplication of up to {self.cap}"
+            f" data columns; if you have more than these columns then specific combinations"
+            f" can never be explored by clients. A limit of 0 would prevents non-Map operations."
+        )
 
     def on(self, fragment):
         for condition in self.reject:
             if fnmatch.fnmatch(fragment, condition):
                 return None
         for condition in self.condition:
             if fnmatch.fnmatch(fragment, condition):
```

## fedmed/privacy/noise.py

```diff
@@ -7,21 +7,34 @@
         self.value = value
         self.type = type
         self.applied = 0
         self.condition = kwargs.get("filter", ["*"])
         self.reject = kwargs.get("reject", [])
 
     def name(self):
-        if '\n'.join(self.condition) == '*':
+        if "\n".join(self.condition) == "*":
             cond = ""
         else:
-            cond = " on:<br>&emsp;<i>"+"<br>&emsp;".join(self.condition).replace("*", '<span style="color: blue;">&lowast;</span>')+'</i>'
+            cond = (
+                " on:<br>&emsp;<i>"
+                + "<br>&emsp;".join(self.condition).replace(
+                    "*", '<span style="color: blue;">&lowast;</span>'
+                )
+                + "</i>"
+            )
         for reject in self.reject:
-            cond += "<br>&emsp;<b style=\"color:red\";>ignore</b>&nbsp;&nbsp;<i>"+reject.replace("*", '<span style="color: blue;">&lowast;</span>')+'</i>'
-        return f'<span class="badge bg-secondary text-light">{self.value}</span> Variance for {self.type}s' + cond
+            cond += (
+                '<br>&emsp;<b style="color:red";>ignore</b>&nbsp;&nbsp;<i>'
+                + reject.replace("*", '<span style="color: blue;">&lowast;</span>')
+                + "</i>"
+            )
+        return (
+            f'<span class="badge bg-secondary text-light">{self.value}</span> Variance for {self.type}s'
+            + cond
+        )
 
     def description(self):
         return (
             f"Any Map operation (e.g., num, sum) outcome of type {self.type}"
             f" is distorted though noise of variance {self.value}. This"
             f" includes quantile calculations. Other data types require"
             f" different versions of this rule."
@@ -33,15 +46,18 @@
                 return None
         for condition in self.condition:
             if fnmatch.fnmatch(fragment, condition):
                 return self
         return None
 
     def bins(self, results):
-        return [(value, self.postprocess(count)) for value, count in results]
+        return [
+            (self.postprocess(value), self.postprocess(count))
+            for value, count in results
+        ]
 
     def preprocess(self, entries):
         return entries
 
     def postprocess(self, result):
         if self.type == result.__class__.__name__:
             self.applied += 1
```

## fedmed/privacy/saturation.py

```diff
@@ -7,22 +7,34 @@
         self.max = kwargs.get("max", None)
         self.type = kwargs.get("type", None)
         self.applied = 0
         self.condition = kwargs.get("filter", ["*"])
         self.reject = kwargs.get("reject", [])
 
     def name(self):
-        if '\n'.join(self.condition) == '*':
+        if "\n".join(self.condition) == "*":
             cond = ""
         else:
-            cond = " on:<br>&emsp;<i>"+"<br>&emsp;".join(self.condition).replace("*", '<span style="color: blue;">&lowast;</span>')+'</i>'
+            cond = (
+                " on:<br>&emsp;<i>"
+                + "<br>&emsp;".join(self.condition).replace(
+                    "*", '<span style="color: blue;">&lowast;</span>'
+                )
+                + "</i>"
+            )
         for reject in self.reject:
-            cond += "<br>&emsp;<b style=\"color:red\";>ignore</b>&nbsp;&nbsp;<i>" + reject.replace("*",
-                                                                                                   '<span style="color: blue;">&lowast;</span>') + '</i>'
-        return f'<span class="badge bg-secondary text-light">[{"-&infin;"if self.min is None else self.min}, {"&infin;" if self.max is None else self.max}]</span> Saturation for {"number" if self.type is None else self.type}s' + cond
+            cond += (
+                '<br>&emsp;<b style="color:red";>ignore</b>&nbsp;&nbsp;<i>'
+                + reject.replace("*", '<span style="color: blue;">&lowast;</span>')
+                + "</i>"
+            )
+        return (
+            f'<span class="badge bg-secondary text-light">[{"-&infin;"if self.min is None else self.min}, {"&infin;" if self.max is None else self.max}]</span> Saturation for {"number" if self.type is None else self.type}s'
+            + cond
+        )
 
     def description(self):
         return (
             f"Any Map operation (e.g., num, sum) outcome{' of type '+self.type if self.type is not None else ''}"
             f" whose outcome lies outside the interval [{'-&infin;'if self.min is None else self.min}, {'&infin;' if self.max is None else self.max}]  "
             f" has that value snapped to the interval's edges. This"
             f" includes quantile calculations. Other data types require"
@@ -35,15 +47,18 @@
                 return None
         for condition in self.condition:
             if fnmatch.fnmatch(fragment, condition):
                 return self
         return None
 
     def bins(self, results):
-        return [(value, self.postprocess(count)) for value, count in results]
+        return [
+            (self.postprocess(value), self.postprocess(count))
+            for value, count in results
+        ]
 
     def preprocess(self, entries):
         return entries
 
     def postprocess(self, result):
         if self.type is None or self.type == result.__class__.__name__:
             self.applied += 1
```

## fedmed/stats/__init__.py

```diff
@@ -1,2 +1,3 @@
 from fedmed.stats import base
+from fedmed.stats import correlation
 from fedmed.stats import test
```

## fedmed/stats/base.py

```diff
@@ -1,24 +1,95 @@
 from fedmed.core import FedData, RemoteRunnable
+from typing import Optional
+import scipy
+from random import random
+import numpy as np
 
 
+_min = min
+_max = max
+_set = set
+_sum = sum
 sum = RemoteRunnable("sum")
 len = RemoteRunnable("len")
 max = RemoteRunnable("max")
 min = RemoteRunnable("min")
+set = RemoteRunnable("set")
+round = RemoteRunnable("round")
 
 
 def mean(data: FedData):
     return sum(data) / len(data)
 
 
 def var(data: FedData, df: int = 0):
     # df=1 for sample variance
     n = len(data)
-    r = sum(data ** 2) / (n-df) - sum(data) ** 2 / n / (n-df)
+    r = sum(data**2) / (n - df) - sum(data) ** 2 / n / (n - df)
     if r < 0:
         r = 0
     return r
 
 
 def std(data: FedData, df: int = 0):
-    return var(data, df)**0.5
+    return var(data, df) ** 0.5
+
+
+def pearson(d1: FedData, d2: FedData):
+    return _max(-1, _min(1, mean(d1 * d2) - mean(d1) * mean(d2)) / (std(d1) * std(d2)))
+
+
+def distribution(data: FedData, discrete: Optional[float]):
+    distr = {}
+    rounded = data if discrete is None else round(data, discrete)
+    offset = {}
+    for element in set(rounded):
+        if discrete is not None:
+            element = int(element/discrete+0.5)*discrete
+        filter = rounded == element
+        count = sum(filter)
+        if count > 0:
+            if discrete is not None:
+                key = sum(filter*data) / count  # place histogram on the center
+                offset[key] = element-key
+            else:
+                key = element
+            #assert key not in distr
+            distr[key] = distr.get(key, 0)+count
+    return distr, offset
+
+
+def hist(data: FedData, bins: Optional[int] = 50, _info=False):
+    mx = None if bins is None else max(abs(data))
+    mn = None if bins is None else min(abs(data))
+    discrete = None if bins is None else (mx-mn) / bins
+    if _info:
+        return *distribution(data, discrete), discrete
+    return distribution(data, discrete)[0]
+
+
+def reconstruct(d, bins=50):
+    distr, offset, width = hist(d, bins, _info=True)
+    if width is None:
+        ret = [k for k, v in distr.items() for _ in range(v)]
+    else:
+        width *= 2
+        #ret = [k+width*(i/(v-1)-0.5) for k, v in distr.items() for i in range(v) if v>1]
+        ret = list()
+        for k, v in distr.items():
+            if v % 2 == 1:
+                ret.append(k)
+                v = v-1
+            halfv = v//2
+            for i in range(halfv):
+                wid = width-abs(offset[k])
+                ret.append(k+wid-wid*i/halfv)
+                ret.append(k-wid+wid*i/halfv)
+    return ret
+
+
+def wilcoxon(d1, d2, bins=50, **kwargs):
+    r = reconstruct(d1-d2, bins=bins)
+    #from matplotlib import pyplot as plt
+    #plt.hist(r)
+    #plt.show()
+    return scipy.stats.wilcoxon(r, **kwargs)
```

## fedmed/stats/test.py

```diff
@@ -13,16 +13,16 @@
 
     def reject(self, x1: FedData, x2: FedData):
         t, df = self.t_statistic(x1, x2)
         if self.mode == "two-tailed":
             t = abs(t)
         elif self.mode == "less":
             t = -t
-        p = scipy.stats.t.cdf(-t, df) * (1+int(self.mode == "two-tailed"))
-        return 1-p if self.alpha is None else (1-p > self.alpha)
+        p = scipy.stats.t.cdf(-t, df) * (1 + int(self.mode == "two-tailed"))
+        return 1 - p if self.alpha is None else (1 - p > self.alpha)
 
 
 class Welch:
     def t_statistic(self, x1: FedData, x2: FedData):
         n1 = len(x1)
         n2 = len(x2)
         mean1 = mean(x1)
@@ -30,15 +30,15 @@
         var1 = var(x1, df=1)
         var2 = var(x2, df=1)
         # compute degrees of freedom
         num = (var1 / n1 + var2 / n2) ** 2
         denom = (var1 / n1) ** 2 / (n1 - 1) + (var2 / n2) ** 2 / (n2 - 1)
         df = num / denom
         # compute t
-        t = (mean1 - mean2) / (var1 / n1 + var2 / n2)**0.5
+        t = (mean1 - mean2) / (var1 / n1 + var2 / n2) ** 0.5
         return t, df
 
 
 class Student(Test):
     def t_statistic(self, x1, x2):
         n1 = len(x1)
         n2 = len(x2)
@@ -46,9 +46,9 @@
         mean2 = mean(x2)
         var1 = var(x1, df=1)
         var2 = var(x2, df=1)
         # compute degrees of freedom
         df = n1 + n2 - 2
         # compute t
         pooled_var = ((n1 - 1) * var1 + (n2 - 1) * var2) / df
-        t = (mean1 - mean2) / (pooled_var * (1/n1 + 1/n2))**0.5
+        t = (mean1 - mean2) / (pooled_var * (1 / n1 + 1 / n2)) ** 0.5
         return t, df
```

